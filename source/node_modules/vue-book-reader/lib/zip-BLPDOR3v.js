const Z = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535], Rt = 1440, xn = [96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9, 192, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 160, 0, 8, 0, 0, 8, 128, 0, 8, 64, 0, 9, 224, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 144, 83, 7, 59, 0, 8, 120, 0, 8, 56, 0, 9, 208, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 176, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 240, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 200, 81, 7, 13, 0, 8, 100, 0, 8, 36, 0, 9, 168, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 232, 80, 7, 8, 0, 8, 92, 0, 8, 28, 0, 9, 152, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 216, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 184, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 248, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9, 196, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 164, 0, 8, 2, 0, 8, 130, 0, 8, 66, 0, 9, 228, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 148, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 212, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 180, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 244, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 204, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0, 9, 172, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 236, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 156, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 220, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 188, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 252, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 194, 80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 162, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 226, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 146, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 210, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 178, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 242, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117, 0, 8, 53, 0, 9, 202, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 170, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 234, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 154, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 218, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 186, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9, 250, 80, 7, 3, 0, 8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 198, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 166, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 230, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 150, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 214, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9, 182, 0, 8, 11, 0, 8, 139, 0, 8, 75, 0, 9, 246, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9, 206, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 174, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 238, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 158, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9, 222, 82, 7, 27, 0, 8, 111, 0, 8, 47, 0, 9, 190, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 254, 96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9, 193, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 161, 0, 8, 0, 0, 8, 128, 0, 8, 64, 0, 9, 225, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 145, 83, 7, 59, 0, 8, 120, 0, 8, 56, 0, 9, 209, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 177, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 241, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 201, 81, 7, 13, 0, 8, 100, 0, 8, 36, 0, 9, 169, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 233, 80, 7, 8, 0, 8, 92, 0, 8, 28, 0, 9, 153, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 217, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 185, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 249, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9, 197, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 165, 0, 8, 2, 0, 8, 130, 0, 8, 66, 0, 9, 229, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 149, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 213, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 181, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 245, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 205, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0, 9, 173, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 237, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 157, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 221, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 189, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 253, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 195, 80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 163, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 227, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 147, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 211, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 179, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 243, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117, 0, 8, 53, 0, 9, 203, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 171, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 235, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 155, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 219, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 187, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9, 251, 80, 7, 3, 0, 8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 199, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 167, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 231, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 151, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 215, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9, 183, 0, 8, 11, 0, 8, 139, 0, 8, 75, 0, 9, 247, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9, 207, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 175, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 239, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 159, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9, 223, 82, 7, 27, 0, 8, 111, 0, 8, 47, 0, 9, 191, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 255], kn = [80, 5, 1, 87, 5, 257, 83, 5, 17, 91, 5, 4097, 81, 5, 5, 89, 5, 1025, 85, 5, 65, 93, 5, 16385, 80, 5, 3, 88, 5, 513, 84, 5, 33, 92, 5, 8193, 82, 5, 9, 90, 5, 2049, 86, 5, 129, 192, 5, 24577, 80, 5, 2, 87, 5, 385, 83, 5, 25, 91, 5, 6145, 81, 5, 7, 89, 5, 1537, 85, 5, 97, 93, 5, 24577, 80, 5, 4, 88, 5, 769, 84, 5, 49, 92, 5, 12289, 82, 5, 13, 90, 5, 3073, 86, 5, 193, 192, 5, 24577], vn = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], Sn = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112], zn = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577], An = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], $ = 15;
function Ze() {
  let n, t, e, i, r, l;
  function s(f, _, w, p, S, z, c, m, a, o, u) {
    let y, b, x, g, h, A, E, U, k, v, F, j, M, D, C;
    v = 0, h = w;
    do
      e[f[_ + v]]++, v++, h--;
    while (h !== 0);
    if (e[0] == w)
      return c[0] = -1, m[0] = 0, 0;
    for (U = m[0], A = 1; A <= $ && e[A] === 0; A++)
      ;
    for (E = A, U < A && (U = A), h = $; h !== 0 && e[h] === 0; h--)
      ;
    for (x = h, U > h && (U = h), m[0] = U, D = 1 << A; A < h; A++, D <<= 1)
      if ((D -= e[A]) < 0)
        return -3;
    if ((D -= e[h]) < 0)
      return -3;
    for (e[h] += D, l[1] = A = 0, v = 1, M = 2; --h != 0; )
      l[M] = A += e[v], M++, v++;
    h = 0, v = 0;
    do
      (A = f[_ + v]) !== 0 && (u[l[A]++] = h), v++;
    while (++h < w);
    for (w = l[x], l[0] = h = 0, v = 0, g = -1, j = -U, r[0] = 0, F = 0, C = 0; E <= x; E++)
      for (y = e[E]; y-- != 0; ) {
        for (; E > j + U; ) {
          if (g++, j += U, C = x - j, C = C > U ? U : C, (b = 1 << (A = E - j)) > y + 1 && (b -= y + 1, M = E, A < C))
            for (; ++A < C && !((b <<= 1) <= e[++M]); )
              b -= e[M];
          if (C = 1 << A, o[0] + C > Rt)
            return -3;
          r[g] = F = o[0], o[0] += C, g !== 0 ? (l[g] = h, i[0] = A, i[1] = U, A = h >>> j - U, i[2] = F - r[g - 1] - A, a.set(i, 3 * (r[g - 1] + A))) : c[0] = F;
        }
        for (i[1] = E - j, v >= w ? i[0] = 192 : u[v] < p ? (i[0] = u[v] < 256 ? 0 : 96, i[2] = u[v++]) : (i[0] = z[u[v] - p] + 16 + 64, i[2] = S[u[v++] - p]), b = 1 << E - j, A = h >>> j; A < C; A += b)
          a.set(i, 3 * (F + A));
        for (A = 1 << E - 1; h & A; A >>>= 1)
          h ^= A;
        for (h ^= A, k = (1 << j) - 1; (h & k) != l[g]; )
          g--, j -= U, k = (1 << j) - 1;
      }
    return D !== 0 && x != 1 ? -5 : 0;
  }
  function d(f) {
    let _;
    for (n || (n = [], t = [], e = new Int32Array($ + 1), i = [], r = new Int32Array($), l = new Int32Array($ + 1)), t.length < f && (t = []), _ = 0; _ < f; _++)
      t[_] = 0;
    for (_ = 0; _ < $ + 1; _++)
      e[_] = 0;
    for (_ = 0; _ < 3; _++)
      i[_] = 0;
    r.set(e.subarray(0, $), 0), l.set(e.subarray(0, $ + 1), 0);
  }
  this.inflate_trees_bits = function(f, _, w, p, S) {
    let z;
    return d(19), n[0] = 0, z = s(f, 0, 19, 19, null, null, w, _, p, n, t), z == -3 ? S.msg = "oversubscribed dynamic bit lengths tree" : z != -5 && _[0] !== 0 || (S.msg = "incomplete dynamic bit lengths tree", z = -3), z;
  }, this.inflate_trees_dynamic = function(f, _, w, p, S, z, c, m, a) {
    let o;
    return d(288), n[0] = 0, o = s(w, 0, f, 257, vn, Sn, z, p, m, n, t), o != 0 || p[0] === 0 ? (o == -3 ? a.msg = "oversubscribed literal/length tree" : o != -4 && (a.msg = "incomplete literal/length tree", o = -3), o) : (d(288), o = s(w, f, _, 0, zn, An, c, S, m, n, t), o != 0 || S[0] === 0 && f > 257 ? (o == -3 ? a.msg = "oversubscribed distance tree" : o == -5 ? (a.msg = "incomplete distance tree", o = -3) : o != -4 && (a.msg = "empty distance tree with lengths", o = -3), o) : 0);
  };
}
Ze.inflate_trees_fixed = function(n, t, e, i) {
  return n[0] = 9, t[0] = 5, e[0] = xn, i[0] = kn, 0;
};
const ze = 0, nt = 1, it = 2, at = 3, rt = 4, st = 5, ot = 6, Pe = 7, lt = 8, Ae = 9;
function Un() {
  const n = this;
  let t, e, i, r, l = 0, s = 0, d = 0, f = 0, _ = 0, w = 0, p = 0, S = 0, z = 0, c = 0;
  function m(a, o, u, y, b, x, g, h) {
    let A, E, U, k, v, F, j, M, D, C, K, q, W, P, L, R;
    j = h.next_in_index, M = h.avail_in, v = g.bitb, F = g.bitk, D = g.write, C = D < g.read ? g.read - D - 1 : g.end - D, K = Z[a], q = Z[o];
    do {
      for (; F < 20; )
        M--, v |= (255 & h.read_byte(j++)) << F, F += 8;
      if (A = v & K, E = u, U = y, R = 3 * (U + A), (k = E[R]) !== 0)
        for (; ; ) {
          if (v >>= E[R + 1], F -= E[R + 1], (16 & k) != 0) {
            for (k &= 15, W = E[R + 2] + (v & Z[k]), v >>= k, F -= k; F < 15; )
              M--, v |= (255 & h.read_byte(j++)) << F, F += 8;
            for (A = v & q, E = b, U = x, R = 3 * (U + A), k = E[R]; ; ) {
              if (v >>= E[R + 1], F -= E[R + 1], (16 & k) != 0) {
                for (k &= 15; F < k; )
                  M--, v |= (255 & h.read_byte(j++)) << F, F += 8;
                if (P = E[R + 2] + (v & Z[k]), v >>= k, F -= k, C -= W, D >= P)
                  L = D - P, D - L > 0 && 2 > D - L ? (g.win[D++] = g.win[L++], g.win[D++] = g.win[L++], W -= 2) : (g.win.set(g.win.subarray(L, L + 2), D), D += 2, L += 2, W -= 2);
                else {
                  L = D - P;
                  do
                    L += g.end;
                  while (L < 0);
                  if (k = g.end - L, W > k) {
                    if (W -= k, D - L > 0 && k > D - L)
                      do
                        g.win[D++] = g.win[L++];
                      while (--k != 0);
                    else
                      g.win.set(g.win.subarray(L, L + k), D), D += k, L += k, k = 0;
                    L = 0;
                  }
                }
                if (D - L > 0 && W > D - L)
                  do
                    g.win[D++] = g.win[L++];
                  while (--W != 0);
                else
                  g.win.set(g.win.subarray(L, L + W), D), D += W, L += W, W = 0;
                break;
              }
              if (64 & k)
                return h.msg = "invalid distance code", W = h.avail_in - M, W = F >> 3 < W ? F >> 3 : W, M += W, j -= W, F -= W << 3, g.bitb = v, g.bitk = F, h.avail_in = M, h.total_in += j - h.next_in_index, h.next_in_index = j, g.write = D, -3;
              A += E[R + 2], A += v & Z[k], R = 3 * (U + A), k = E[R];
            }
            break;
          }
          if (64 & k)
            return 32 & k ? (W = h.avail_in - M, W = F >> 3 < W ? F >> 3 : W, M += W, j -= W, F -= W << 3, g.bitb = v, g.bitk = F, h.avail_in = M, h.total_in += j - h.next_in_index, h.next_in_index = j, g.write = D, 1) : (h.msg = "invalid literal/length code", W = h.avail_in - M, W = F >> 3 < W ? F >> 3 : W, M += W, j -= W, F -= W << 3, g.bitb = v, g.bitk = F, h.avail_in = M, h.total_in += j - h.next_in_index, h.next_in_index = j, g.write = D, -3);
          if (A += E[R + 2], A += v & Z[k], R = 3 * (U + A), (k = E[R]) === 0) {
            v >>= E[R + 1], F -= E[R + 1], g.win[D++] = E[R + 2], C--;
            break;
          }
        }
      else
        v >>= E[R + 1], F -= E[R + 1], g.win[D++] = E[R + 2], C--;
    } while (C >= 258 && M >= 10);
    return W = h.avail_in - M, W = F >> 3 < W ? F >> 3 : W, M += W, j -= W, F -= W << 3, g.bitb = v, g.bitk = F, h.avail_in = M, h.total_in += j - h.next_in_index, h.next_in_index = j, g.write = D, 0;
  }
  n.init = function(a, o, u, y, b, x) {
    t = ze, p = a, S = o, i = u, z = y, r = b, c = x, e = null;
  }, n.proc = function(a, o, u) {
    let y, b, x, g, h, A, E, U = 0, k = 0, v = 0;
    for (v = o.next_in_index, g = o.avail_in, U = a.bitb, k = a.bitk, h = a.write, A = h < a.read ? a.read - h - 1 : a.end - h; ; )
      switch (t) {
        case ze:
          if (A >= 258 && g >= 10 && (a.bitb = U, a.bitk = k, o.avail_in = g, o.total_in += v - o.next_in_index, o.next_in_index = v, a.write = h, u = m(p, S, i, z, r, c, a, o), v = o.next_in_index, g = o.avail_in, U = a.bitb, k = a.bitk, h = a.write, A = h < a.read ? a.read - h - 1 : a.end - h, u != 0)) {
            t = u == 1 ? Pe : Ae;
            break;
          }
          d = p, e = i, s = z, t = nt;
        case nt:
          for (y = d; k < y; ) {
            if (g === 0)
              return a.bitb = U, a.bitk = k, o.avail_in = g, o.total_in += v - o.next_in_index, o.next_in_index = v, a.write = h, a.inflate_flush(o, u);
            u = 0, g--, U |= (255 & o.read_byte(v++)) << k, k += 8;
          }
          if (b = 3 * (s + (U & Z[y])), U >>>= e[b + 1], k -= e[b + 1], x = e[b], x === 0) {
            f = e[b + 2], t = ot;
            break;
          }
          if (16 & x) {
            _ = 15 & x, l = e[b + 2], t = it;
            break;
          }
          if (!(64 & x)) {
            d = x, s = b / 3 + e[b + 2];
            break;
          }
          if (32 & x) {
            t = Pe;
            break;
          }
          return t = Ae, o.msg = "invalid literal/length code", u = -3, a.bitb = U, a.bitk = k, o.avail_in = g, o.total_in += v - o.next_in_index, o.next_in_index = v, a.write = h, a.inflate_flush(o, u);
        case it:
          for (y = _; k < y; ) {
            if (g === 0)
              return a.bitb = U, a.bitk = k, o.avail_in = g, o.total_in += v - o.next_in_index, o.next_in_index = v, a.write = h, a.inflate_flush(o, u);
            u = 0, g--, U |= (255 & o.read_byte(v++)) << k, k += 8;
          }
          l += U & Z[y], U >>= y, k -= y, d = S, e = r, s = c, t = at;
        case at:
          for (y = d; k < y; ) {
            if (g === 0)
              return a.bitb = U, a.bitk = k, o.avail_in = g, o.total_in += v - o.next_in_index, o.next_in_index = v, a.write = h, a.inflate_flush(o, u);
            u = 0, g--, U |= (255 & o.read_byte(v++)) << k, k += 8;
          }
          if (b = 3 * (s + (U & Z[y])), U >>= e[b + 1], k -= e[b + 1], x = e[b], (16 & x) != 0) {
            _ = 15 & x, w = e[b + 2], t = rt;
            break;
          }
          if (!(64 & x)) {
            d = x, s = b / 3 + e[b + 2];
            break;
          }
          return t = Ae, o.msg = "invalid distance code", u = -3, a.bitb = U, a.bitk = k, o.avail_in = g, o.total_in += v - o.next_in_index, o.next_in_index = v, a.write = h, a.inflate_flush(o, u);
        case rt:
          for (y = _; k < y; ) {
            if (g === 0)
              return a.bitb = U, a.bitk = k, o.avail_in = g, o.total_in += v - o.next_in_index, o.next_in_index = v, a.write = h, a.inflate_flush(o, u);
            u = 0, g--, U |= (255 & o.read_byte(v++)) << k, k += 8;
          }
          w += U & Z[y], U >>= y, k -= y, t = st;
        case st:
          for (E = h - w; E < 0; )
            E += a.end;
          for (; l !== 0; ) {
            if (A === 0 && (h == a.end && a.read !== 0 && (h = 0, A = h < a.read ? a.read - h - 1 : a.end - h), A === 0 && (a.write = h, u = a.inflate_flush(o, u), h = a.write, A = h < a.read ? a.read - h - 1 : a.end - h, h == a.end && a.read !== 0 && (h = 0, A = h < a.read ? a.read - h - 1 : a.end - h), A === 0)))
              return a.bitb = U, a.bitk = k, o.avail_in = g, o.total_in += v - o.next_in_index, o.next_in_index = v, a.write = h, a.inflate_flush(o, u);
            a.win[h++] = a.win[E++], A--, E == a.end && (E = 0), l--;
          }
          t = ze;
          break;
        case ot:
          if (A === 0 && (h == a.end && a.read !== 0 && (h = 0, A = h < a.read ? a.read - h - 1 : a.end - h), A === 0 && (a.write = h, u = a.inflate_flush(o, u), h = a.write, A = h < a.read ? a.read - h - 1 : a.end - h, h == a.end && a.read !== 0 && (h = 0, A = h < a.read ? a.read - h - 1 : a.end - h), A === 0)))
            return a.bitb = U, a.bitk = k, o.avail_in = g, o.total_in += v - o.next_in_index, o.next_in_index = v, a.write = h, a.inflate_flush(o, u);
          u = 0, a.win[h++] = f, A--, t = ze;
          break;
        case Pe:
          if (k > 7 && (k -= 8, g++, v--), a.write = h, u = a.inflate_flush(o, u), h = a.write, A = h < a.read ? a.read - h - 1 : a.end - h, a.read != a.write)
            return a.bitb = U, a.bitk = k, o.avail_in = g, o.total_in += v - o.next_in_index, o.next_in_index = v, a.write = h, a.inflate_flush(o, u);
          t = lt;
        case lt:
          return u = 1, a.bitb = U, a.bitk = k, o.avail_in = g, o.total_in += v - o.next_in_index, o.next_in_index = v, a.write = h, a.inflate_flush(o, u);
        case Ae:
          return u = -3, a.bitb = U, a.bitk = k, o.avail_in = g, o.total_in += v - o.next_in_index, o.next_in_index = v, a.write = h, a.inflate_flush(o, u);
        default:
          return u = -2, a.bitb = U, a.bitk = k, o.avail_in = g, o.total_in += v - o.next_in_index, o.next_in_index = v, a.write = h, a.inflate_flush(o, u);
      }
  }, n.free = function() {
  };
}
const ct = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], ce = 0, Ie = 1, ft = 2, ut = 3, dt = 4, ht = 5, Ue = 6, De = 7, _t = 8, ie = 9;
function Dn(n, t) {
  const e = this;
  let i, r = ce, l = 0, s = 0, d = 0;
  const f = [0], _ = [0], w = new Un();
  let p = 0, S = new Int32Array(3 * Rt);
  const z = new Ze();
  e.bitk = 0, e.bitb = 0, e.win = new Uint8Array(t), e.end = t, e.read = 0, e.write = 0, e.reset = function(c, m) {
    m && (m[0] = 0), r == Ue && w.free(c), r = ce, e.bitk = 0, e.bitb = 0, e.read = e.write = 0;
  }, e.reset(n, null), e.inflate_flush = function(c, m) {
    let a, o, u;
    return o = c.next_out_index, u = e.read, a = (u <= e.write ? e.write : e.end) - u, a > c.avail_out && (a = c.avail_out), a !== 0 && m == -5 && (m = 0), c.avail_out -= a, c.total_out += a, c.next_out.set(e.win.subarray(u, u + a), o), o += a, u += a, u == e.end && (u = 0, e.write == e.end && (e.write = 0), a = e.write - u, a > c.avail_out && (a = c.avail_out), a !== 0 && m == -5 && (m = 0), c.avail_out -= a, c.total_out += a, c.next_out.set(e.win.subarray(u, u + a), o), o += a, u += a), c.next_out_index = o, e.read = u, m;
  }, e.proc = function(c, m) {
    let a, o, u, y, b, x, g, h;
    for (y = c.next_in_index, b = c.avail_in, o = e.bitb, u = e.bitk, x = e.write, g = x < e.read ? e.read - x - 1 : e.end - x; ; ) {
      let A, E, U, k, v, F, j, M;
      switch (r) {
        case ce:
          for (; u < 3; ) {
            if (b === 0)
              return e.bitb = o, e.bitk = u, c.avail_in = b, c.total_in += y - c.next_in_index, c.next_in_index = y, e.write = x, e.inflate_flush(c, m);
            m = 0, b--, o |= (255 & c.read_byte(y++)) << u, u += 8;
          }
          switch (a = 7 & o, p = 1 & a, a >>> 1) {
            case 0:
              o >>>= 3, u -= 3, a = 7 & u, o >>>= a, u -= a, r = Ie;
              break;
            case 1:
              A = [], E = [], U = [[]], k = [[]], Ze.inflate_trees_fixed(A, E, U, k), w.init(A[0], E[0], U[0], 0, k[0], 0), o >>>= 3, u -= 3, r = Ue;
              break;
            case 2:
              o >>>= 3, u -= 3, r = ut;
              break;
            case 3:
              return o >>>= 3, u -= 3, r = ie, c.msg = "invalid block type", m = -3, e.bitb = o, e.bitk = u, c.avail_in = b, c.total_in += y - c.next_in_index, c.next_in_index = y, e.write = x, e.inflate_flush(c, m);
          }
          break;
        case Ie:
          for (; u < 32; ) {
            if (b === 0)
              return e.bitb = o, e.bitk = u, c.avail_in = b, c.total_in += y - c.next_in_index, c.next_in_index = y, e.write = x, e.inflate_flush(c, m);
            m = 0, b--, o |= (255 & c.read_byte(y++)) << u, u += 8;
          }
          if ((~o >>> 16 & 65535) != (65535 & o))
            return r = ie, c.msg = "invalid stored block lengths", m = -3, e.bitb = o, e.bitk = u, c.avail_in = b, c.total_in += y - c.next_in_index, c.next_in_index = y, e.write = x, e.inflate_flush(c, m);
          l = 65535 & o, o = u = 0, r = l !== 0 ? ft : p !== 0 ? De : ce;
          break;
        case ft:
          if (b === 0 || g === 0 && (x == e.end && e.read !== 0 && (x = 0, g = x < e.read ? e.read - x - 1 : e.end - x), g === 0 && (e.write = x, m = e.inflate_flush(c, m), x = e.write, g = x < e.read ? e.read - x - 1 : e.end - x, x == e.end && e.read !== 0 && (x = 0, g = x < e.read ? e.read - x - 1 : e.end - x), g === 0)))
            return e.bitb = o, e.bitk = u, c.avail_in = b, c.total_in += y - c.next_in_index, c.next_in_index = y, e.write = x, e.inflate_flush(c, m);
          if (m = 0, a = l, a > b && (a = b), a > g && (a = g), e.win.set(c.read_buf(y, a), x), y += a, b -= a, x += a, g -= a, (l -= a) != 0)
            break;
          r = p !== 0 ? De : ce;
          break;
        case ut:
          for (; u < 14; ) {
            if (b === 0)
              return e.bitb = o, e.bitk = u, c.avail_in = b, c.total_in += y - c.next_in_index, c.next_in_index = y, e.write = x, e.inflate_flush(c, m);
            m = 0, b--, o |= (255 & c.read_byte(y++)) << u, u += 8;
          }
          if (s = a = 16383 & o, (31 & a) > 29 || (a >> 5 & 31) > 29)
            return r = ie, c.msg = "too many length or distance symbols", m = -3, e.bitb = o, e.bitk = u, c.avail_in = b, c.total_in += y - c.next_in_index, c.next_in_index = y, e.write = x, e.inflate_flush(c, m);
          if (a = 258 + (31 & a) + (a >> 5 & 31), !i || i.length < a)
            i = [];
          else
            for (h = 0; h < a; h++)
              i[h] = 0;
          o >>>= 14, u -= 14, d = 0, r = dt;
        case dt:
          for (; d < 4 + (s >>> 10); ) {
            for (; u < 3; ) {
              if (b === 0)
                return e.bitb = o, e.bitk = u, c.avail_in = b, c.total_in += y - c.next_in_index, c.next_in_index = y, e.write = x, e.inflate_flush(c, m);
              m = 0, b--, o |= (255 & c.read_byte(y++)) << u, u += 8;
            }
            i[ct[d++]] = 7 & o, o >>>= 3, u -= 3;
          }
          for (; d < 19; )
            i[ct[d++]] = 0;
          if (f[0] = 7, a = z.inflate_trees_bits(i, f, _, S, c), a != 0)
            return (m = a) == -3 && (i = null, r = ie), e.bitb = o, e.bitk = u, c.avail_in = b, c.total_in += y - c.next_in_index, c.next_in_index = y, e.write = x, e.inflate_flush(c, m);
          d = 0, r = ht;
        case ht:
          for (; a = s, !(d >= 258 + (31 & a) + (a >> 5 & 31)); ) {
            let D, C;
            for (a = f[0]; u < a; ) {
              if (b === 0)
                return e.bitb = o, e.bitk = u, c.avail_in = b, c.total_in += y - c.next_in_index, c.next_in_index = y, e.write = x, e.inflate_flush(c, m);
              m = 0, b--, o |= (255 & c.read_byte(y++)) << u, u += 8;
            }
            if (a = S[3 * (_[0] + (o & Z[a])) + 1], C = S[3 * (_[0] + (o & Z[a])) + 2], C < 16)
              o >>>= a, u -= a, i[d++] = C;
            else {
              for (h = C == 18 ? 7 : C - 14, D = C == 18 ? 11 : 3; u < a + h; ) {
                if (b === 0)
                  return e.bitb = o, e.bitk = u, c.avail_in = b, c.total_in += y - c.next_in_index, c.next_in_index = y, e.write = x, e.inflate_flush(c, m);
                m = 0, b--, o |= (255 & c.read_byte(y++)) << u, u += 8;
              }
              if (o >>>= a, u -= a, D += o & Z[h], o >>>= h, u -= h, h = d, a = s, h + D > 258 + (31 & a) + (a >> 5 & 31) || C == 16 && h < 1)
                return i = null, r = ie, c.msg = "invalid bit length repeat", m = -3, e.bitb = o, e.bitk = u, c.avail_in = b, c.total_in += y - c.next_in_index, c.next_in_index = y, e.write = x, e.inflate_flush(c, m);
              C = C == 16 ? i[h - 1] : 0;
              do
                i[h++] = C;
              while (--D != 0);
              d = h;
            }
          }
          if (_[0] = -1, v = [], F = [], j = [], M = [], v[0] = 9, F[0] = 6, a = s, a = z.inflate_trees_dynamic(257 + (31 & a), 1 + (a >> 5 & 31), i, v, F, j, M, S, c), a != 0)
            return a == -3 && (i = null, r = ie), m = a, e.bitb = o, e.bitk = u, c.avail_in = b, c.total_in += y - c.next_in_index, c.next_in_index = y, e.write = x, e.inflate_flush(c, m);
          w.init(v[0], F[0], S, j[0], S, M[0]), r = Ue;
        case Ue:
          if (e.bitb = o, e.bitk = u, c.avail_in = b, c.total_in += y - c.next_in_index, c.next_in_index = y, e.write = x, (m = w.proc(e, c, m)) != 1)
            return e.inflate_flush(c, m);
          if (m = 0, w.free(c), y = c.next_in_index, b = c.avail_in, o = e.bitb, u = e.bitk, x = e.write, g = x < e.read ? e.read - x - 1 : e.end - x, p === 0) {
            r = ce;
            break;
          }
          r = De;
        case De:
          if (e.write = x, m = e.inflate_flush(c, m), x = e.write, g = x < e.read ? e.read - x - 1 : e.end - x, e.read != e.write)
            return e.bitb = o, e.bitk = u, c.avail_in = b, c.total_in += y - c.next_in_index, c.next_in_index = y, e.write = x, e.inflate_flush(c, m);
          r = _t;
        case _t:
          return m = 1, e.bitb = o, e.bitk = u, c.avail_in = b, c.total_in += y - c.next_in_index, c.next_in_index = y, e.write = x, e.inflate_flush(c, m);
        case ie:
          return m = -3, e.bitb = o, e.bitk = u, c.avail_in = b, c.total_in += y - c.next_in_index, c.next_in_index = y, e.write = x, e.inflate_flush(c, m);
        default:
          return m = -2, e.bitb = o, e.bitk = u, c.avail_in = b, c.total_in += y - c.next_in_index, c.next_in_index = y, e.write = x, e.inflate_flush(c, m);
      }
    }
  }, e.free = function(c) {
    e.reset(c, null), e.win = null, S = null;
  }, e.set_dictionary = function(c, m, a) {
    e.win.set(c.subarray(m, m + a), 0), e.read = e.write = a;
  }, e.sync_point = function() {
    return r == Ie ? 1 : 0;
  };
}
const O = 13, En = [0, 0, 255, 255];
function Fn() {
  const n = this;
  function t(e) {
    return e && e.istate ? (e.total_in = e.total_out = 0, e.msg = null, e.istate.mode = 7, e.istate.blocks.reset(e, null), 0) : -2;
  }
  n.mode = 0, n.method = 0, n.was = [0], n.need = 0, n.marker = 0, n.wbits = 0, n.inflateEnd = function(e) {
    return n.blocks && n.blocks.free(e), n.blocks = null, 0;
  }, n.inflateInit = function(e, i) {
    return e.msg = null, n.blocks = null, i < 8 || i > 15 ? (n.inflateEnd(e), -2) : (n.wbits = i, e.istate.blocks = new Dn(e, 1 << i), t(e), 0);
  }, n.inflate = function(e, i) {
    let r, l;
    if (!e || !e.istate || !e.next_in)
      return -2;
    const s = e.istate;
    for (i = i == 4 ? -5 : 0, r = -5; ; )
      switch (s.mode) {
        case 0:
          if (e.avail_in === 0)
            return r;
          if (r = i, e.avail_in--, e.total_in++, (15 & (s.method = e.read_byte(e.next_in_index++))) != 8) {
            s.mode = O, e.msg = "unknown compression method", s.marker = 5;
            break;
          }
          if (8 + (s.method >> 4) > s.wbits) {
            s.mode = O, e.msg = "invalid win size", s.marker = 5;
            break;
          }
          s.mode = 1;
        case 1:
          if (e.avail_in === 0)
            return r;
          if (r = i, e.avail_in--, e.total_in++, l = 255 & e.read_byte(e.next_in_index++), ((s.method << 8) + l) % 31 != 0) {
            s.mode = O, e.msg = "incorrect header check", s.marker = 5;
            break;
          }
          if (!(32 & l)) {
            s.mode = 7;
            break;
          }
          s.mode = 2;
        case 2:
          if (e.avail_in === 0)
            return r;
          r = i, e.avail_in--, e.total_in++, s.need = (255 & e.read_byte(e.next_in_index++)) << 24 & 4278190080, s.mode = 3;
        case 3:
          if (e.avail_in === 0)
            return r;
          r = i, e.avail_in--, e.total_in++, s.need += (255 & e.read_byte(e.next_in_index++)) << 16 & 16711680, s.mode = 4;
        case 4:
          if (e.avail_in === 0)
            return r;
          r = i, e.avail_in--, e.total_in++, s.need += (255 & e.read_byte(e.next_in_index++)) << 8 & 65280, s.mode = 5;
        case 5:
          return e.avail_in === 0 ? r : (r = i, e.avail_in--, e.total_in++, s.need += 255 & e.read_byte(e.next_in_index++), s.mode = 6, 2);
        case 6:
          return s.mode = O, e.msg = "need dictionary", s.marker = 0, -2;
        case 7:
          if (r = s.blocks.proc(e, r), r == -3) {
            s.mode = O, s.marker = 0;
            break;
          }
          if (r == 0 && (r = i), r != 1)
            return r;
          r = i, s.blocks.reset(e, s.was), s.mode = 12;
        case 12:
          return e.avail_in = 0, 1;
        case O:
          return -3;
        default:
          return -2;
      }
  }, n.inflateSetDictionary = function(e, i, r) {
    let l = 0, s = r;
    if (!e || !e.istate || e.istate.mode != 6)
      return -2;
    const d = e.istate;
    return s >= 1 << d.wbits && (s = (1 << d.wbits) - 1, l = r - s), d.blocks.set_dictionary(i, l, s), d.mode = 7, 0;
  }, n.inflateSync = function(e) {
    let i, r, l, s, d;
    if (!e || !e.istate)
      return -2;
    const f = e.istate;
    if (f.mode != O && (f.mode = O, f.marker = 0), (i = e.avail_in) === 0)
      return -5;
    for (r = e.next_in_index, l = f.marker; i !== 0 && l < 4; )
      e.read_byte(r) == En[l] ? l++ : l = e.read_byte(r) !== 0 ? 0 : 4 - l, r++, i--;
    return e.total_in += r - e.next_in_index, e.next_in_index = r, e.avail_in = i, f.marker = l, l != 4 ? -3 : (s = e.total_in, d = e.total_out, t(e), e.total_in = s, e.total_out = d, f.mode = 7, 0);
  }, n.inflateSyncPoint = function(e) {
    return e && e.istate && e.istate.blocks ? e.istate.blocks.sync_point() : -2;
  };
}
function Bt() {
}
Bt.prototype = { inflateInit(n) {
  const t = this;
  return t.istate = new Fn(), n || (n = 15), t.istate.inflateInit(t, n);
}, inflate(n) {
  const t = this;
  return t.istate ? t.istate.inflate(t, n) : -2;
}, inflateEnd() {
  const n = this;
  if (!n.istate)
    return -2;
  const t = n.istate.inflateEnd(n);
  return n.istate = null, t;
}, inflateSync() {
  const n = this;
  return n.istate ? n.istate.inflateSync(n) : -2;
}, inflateSetDictionary(n, t) {
  const e = this;
  return e.istate ? e.istate.inflateSetDictionary(e, n, t) : -2;
}, read_byte(n) {
  return this.next_in[n];
}, read_buf(n, t) {
  return this.next_in.subarray(n, n + t);
} };
const se = 4294967295, re = 65535, wt = 33639248, bt = 101075792, Wn = 1, Q = void 0, Fe = "undefined", Pt = "function";
class pt {
  constructor(t) {
    return class extends TransformStream {
      constructor(e, i) {
        const r = new t(i);
        super({ transform(l, s) {
          s.enqueue(r.append(l));
        }, flush(l) {
          const s = r.flush();
          s && l.enqueue(s);
        } });
      }
    };
  }
}
let It = 2;
try {
  typeof navigator != Fe && navigator.hardwareConcurrency && (It = navigator.hardwareConcurrency);
} catch {
}
const Cn = { chunkSize: 524288, maxWorkers: It, terminateWorkerTimeout: 5e3, useWebWorkers: !0, useCompressionStream: !0, workerScripts: Q, CompressionStreamNative: typeof CompressionStream != Fe && CompressionStream, DecompressionStreamNative: typeof DecompressionStream != Fe && DecompressionStream }, ne = Object.assign({}, Cn);
function jn(n) {
  const { baseURL: t, chunkSize: e, maxWorkers: i, terminateWorkerTimeout: r, useCompressionStream: l, useWebWorkers: s, Deflate: d, Inflate: f, CompressionStream: _, DecompressionStream: w, workerScripts: p } = n;
  if (ee("baseURL", t), ee("chunkSize", e), ee("maxWorkers", i), ee("terminateWorkerTimeout", r), ee("useCompressionStream", l), ee("useWebWorkers", s), d && (ne.CompressionStream = new pt(d)), f && (ne.DecompressionStream = new pt(f)), ee("CompressionStream", _), ee("DecompressionStream", w), p !== Q) {
    const { deflate: S, inflate: z } = p;
    if ((S || z) && (ne.workerScripts || (ne.workerScripts = {})), S) {
      if (!Array.isArray(S))
        throw new Error("workerScripts.deflate must be an array");
      ne.workerScripts.deflate = S;
    }
    if (z) {
      if (!Array.isArray(z))
        throw new Error("workerScripts.inflate must be an array");
      ne.workerScripts.inflate = z;
    }
  }
}
function ee(n, t) {
  t !== Q && (ne[n] = t);
}
const Nt = [];
for (let n = 0; n < 256; n++) {
  let t = n;
  for (let e = 0; e < 8; e++)
    1 & t ? t = t >>> 1 ^ 3988292384 : t >>>= 1;
  Nt[n] = t;
}
class We {
  constructor(t) {
    this.crc = t || -1;
  }
  append(t) {
    let e = 0 | this.crc;
    for (let i = 0, r = 0 | t.length; i < r; i++)
      e = e >>> 8 ^ Nt[255 & (e ^ t[i])];
    this.crc = e;
  }
  get() {
    return ~this.crc;
  }
}
class Tt extends TransformStream {
  constructor() {
    let t;
    const e = new We();
    super({ transform(i, r) {
      e.append(i), r.enqueue(i);
    }, flush() {
      const i = new Uint8Array(4);
      new DataView(i.buffer).setUint32(0, e.get()), t.value = i;
    } }), t = this;
  }
}
const V = { concat(n, t) {
  if (n.length === 0 || t.length === 0)
    return n.concat(t);
  const e = n[n.length - 1], i = V.getPartial(e);
  return i === 32 ? n.concat(t) : V._shiftRight(t, i, 0 | e, n.slice(0, n.length - 1));
}, bitLength(n) {
  const t = n.length;
  if (t === 0)
    return 0;
  const e = n[t - 1];
  return 32 * (t - 1) + V.getPartial(e);
}, clamp(n, t) {
  if (32 * n.length < t)
    return n;
  const e = (n = n.slice(0, Math.ceil(t / 32))).length;
  return t &= 31, e > 0 && t && (n[e - 1] = V.partial(t, n[e - 1] & 2147483648 >> t - 1, 1)), n;
}, partial: (n, t, e) => n === 32 ? t : (e ? 0 | t : t << 32 - n) + 1099511627776 * n, getPartial: (n) => Math.round(n / 1099511627776) || 32, _shiftRight(n, t, e, i) {
  for (i === void 0 && (i = []); t >= 32; t -= 32)
    i.push(e), e = 0;
  if (t === 0)
    return i.concat(n);
  for (let s = 0; s < n.length; s++)
    i.push(e | n[s] >>> t), e = n[s] << 32 - t;
  const r = n.length ? n[n.length - 1] : 0, l = V.getPartial(r);
  return i.push(V.partial(t + l & 31, t + l > 32 ? e : i.pop(), 1)), i;
} }, Ce = { bytes: { fromBits(n) {
  const t = V.bitLength(n) / 8, e = new Uint8Array(t);
  let i;
  for (let r = 0; r < t; r++)
    !(3 & r) && (i = n[r / 4]), e[r] = i >>> 24, i <<= 8;
  return e;
}, toBits(n) {
  const t = [];
  let e, i = 0;
  for (e = 0; e < n.length; e++)
    i = i << 8 | n[e], (3 & e) == 3 && (t.push(i), i = 0);
  return 3 & e && t.push(V.partial(8 * (3 & e), i)), t;
} } }, Mn = { sha1: class {
  constructor(n) {
    const t = this;
    t.blockSize = 512, t._init = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], t._key = [1518500249, 1859775393, 2400959708, 3395469782], n ? (t._h = n._h.slice(0), t._buffer = n._buffer.slice(0), t._length = n._length) : t.reset();
  }
  reset() {
    const n = this;
    return n._h = n._init.slice(0), n._buffer = [], n._length = 0, n;
  }
  update(n) {
    const t = this;
    typeof n == "string" && (n = Ce.utf8String.toBits(n));
    const e = t._buffer = V.concat(t._buffer, n), i = t._length, r = t._length = i + V.bitLength(n);
    if (r > 9007199254740991)
      throw new Error("Cannot hash more than 2^53 - 1 bits");
    const l = new Uint32Array(e);
    let s = 0;
    for (let d = t.blockSize + i - (t.blockSize + i & t.blockSize - 1); d <= r; d += t.blockSize)
      t._block(l.subarray(16 * s, 16 * (s + 1))), s += 1;
    return e.splice(0, 16 * s), t;
  }
  finalize() {
    const n = this;
    let t = n._buffer;
    const e = n._h;
    t = V.concat(t, [V.partial(1, 1)]);
    for (let i = t.length + 2; 15 & i; i++)
      t.push(0);
    for (t.push(Math.floor(n._length / 4294967296)), t.push(0 | n._length); t.length; )
      n._block(t.splice(0, 16));
    return n.reset(), e;
  }
  _f(n, t, e, i) {
    return n <= 19 ? t & e | ~t & i : n <= 39 ? t ^ e ^ i : n <= 59 ? t & e | t & i | e & i : n <= 79 ? t ^ e ^ i : void 0;
  }
  _S(n, t) {
    return t << n | t >>> 32 - n;
  }
  _block(n) {
    const t = this, e = t._h, i = Array(80);
    for (let _ = 0; _ < 16; _++)
      i[_] = n[_];
    let r = e[0], l = e[1], s = e[2], d = e[3], f = e[4];
    for (let _ = 0; _ <= 79; _++) {
      _ >= 16 && (i[_] = t._S(1, i[_ - 3] ^ i[_ - 8] ^ i[_ - 14] ^ i[_ - 16]));
      const w = t._S(5, r) + t._f(_, l, s, d) + f + i[_] + t._key[Math.floor(_ / 20)] | 0;
      f = d, d = s, s = t._S(30, l), l = r, r = w;
    }
    e[0] = e[0] + r | 0, e[1] = e[1] + l | 0, e[2] = e[2] + s | 0, e[3] = e[3] + d | 0, e[4] = e[4] + f | 0;
  }
} }, Ln = { aes: class {
  constructor(n) {
    const t = this;
    t._tables = [[[], [], [], [], []], [[], [], [], [], []]], t._tables[0][0][0] || t._precompute();
    const e = t._tables[0][4], i = t._tables[1], r = n.length;
    let l, s, d, f = 1;
    if (r !== 4 && r !== 6 && r !== 8)
      throw new Error("invalid aes key size");
    for (t._key = [s = n.slice(0), d = []], l = r; l < 4 * r + 28; l++) {
      let _ = s[l - 1];
      (l % r == 0 || r === 8 && l % r == 4) && (_ = e[_ >>> 24] << 24 ^ e[_ >> 16 & 255] << 16 ^ e[_ >> 8 & 255] << 8 ^ e[255 & _], l % r == 0 && (_ = _ << 8 ^ _ >>> 24 ^ f << 24, f = f << 1 ^ 283 * (f >> 7))), s[l] = s[l - r] ^ _;
    }
    for (let _ = 0; l; _++, l--) {
      const w = s[3 & _ ? l : l - 4];
      d[_] = l <= 4 || _ < 4 ? w : i[0][e[w >>> 24]] ^ i[1][e[w >> 16 & 255]] ^ i[2][e[w >> 8 & 255]] ^ i[3][e[255 & w]];
    }
  }
  encrypt(n) {
    return this._crypt(n, 0);
  }
  decrypt(n) {
    return this._crypt(n, 1);
  }
  _precompute() {
    const n = this._tables[0], t = this._tables[1], e = n[4], i = t[4], r = [], l = [];
    let s, d, f, _;
    for (let w = 0; w < 256; w++)
      l[(r[w] = w << 1 ^ 283 * (w >> 7)) ^ w] = w;
    for (let w = s = 0; !e[w]; w ^= d || 1, s = l[s] || 1) {
      let p = s ^ s << 1 ^ s << 2 ^ s << 3 ^ s << 4;
      p = p >> 8 ^ 255 & p ^ 99, e[w] = p, i[p] = w, _ = r[f = r[d = r[w]]];
      let S = 16843009 * _ ^ 65537 * f ^ 257 * d ^ 16843008 * w, z = 257 * r[p] ^ 16843008 * p;
      for (let c = 0; c < 4; c++)
        n[c][w] = z = z << 24 ^ z >>> 8, t[c][p] = S = S << 24 ^ S >>> 8;
    }
    for (let w = 0; w < 5; w++)
      n[w] = n[w].slice(0), t[w] = t[w].slice(0);
  }
  _crypt(n, t) {
    if (n.length !== 4)
      throw new Error("invalid aes block size");
    const e = this._key[t], i = e.length / 4 - 2, r = [0, 0, 0, 0], l = this._tables[t], s = l[0], d = l[1], f = l[2], _ = l[3], w = l[4];
    let p, S, z, c = n[0] ^ e[0], m = n[t ? 3 : 1] ^ e[1], a = n[2] ^ e[2], o = n[t ? 1 : 3] ^ e[3], u = 4;
    for (let y = 0; y < i; y++)
      p = s[c >>> 24] ^ d[m >> 16 & 255] ^ f[a >> 8 & 255] ^ _[255 & o] ^ e[u], S = s[m >>> 24] ^ d[a >> 16 & 255] ^ f[o >> 8 & 255] ^ _[255 & c] ^ e[u + 1], z = s[a >>> 24] ^ d[o >> 16 & 255] ^ f[c >> 8 & 255] ^ _[255 & m] ^ e[u + 2], o = s[o >>> 24] ^ d[c >> 16 & 255] ^ f[m >> 8 & 255] ^ _[255 & a] ^ e[u + 3], u += 4, c = p, m = S, a = z;
    for (let y = 0; y < 4; y++)
      r[t ? 3 & -y : y] = w[c >>> 24] << 24 ^ w[m >> 16 & 255] << 16 ^ w[a >> 8 & 255] << 8 ^ w[255 & o] ^ e[u++], p = c, c = m, m = a, a = o, o = p;
    return r;
  }
} }, Rn = { getRandomValues(n) {
  const t = new Uint32Array(n.buffer), e = (i) => {
    let r = 987654321;
    const l = 4294967295;
    return function() {
      return r = 36969 * (65535 & r) + (r >> 16) & l, (((r << 16) + (i = 18e3 * (65535 & i) + (i >> 16) & l) & l) / 4294967296 + 0.5) * (Math.random() > 0.5 ? 1 : -1);
    };
  };
  for (let i, r = 0; r < n.length; r += 4) {
    const l = e(4294967296 * (i || Math.random()));
    i = 987654071 * l(), t[r / 4] = 4294967296 * l() | 0;
  }
  return n;
} }, Bn = { ctrGladman: class {
  constructor(n, t) {
    this._prf = n, this._initIv = t, this._iv = t;
  }
  reset() {
    this._iv = this._initIv;
  }
  update(n) {
    return this.calculate(this._prf, n, this._iv);
  }
  incWord(n) {
    if ((n >> 24 & 255) == 255) {
      let t = n >> 16 & 255, e = n >> 8 & 255, i = 255 & n;
      t === 255 ? (t = 0, e === 255 ? (e = 0, i === 255 ? i = 0 : ++i) : ++e) : ++t, n = 0, n += t << 16, n += e << 8, n += i;
    } else
      n += 1 << 24;
    return n;
  }
  incCounter(n) {
    (n[0] = this.incWord(n[0])) === 0 && (n[1] = this.incWord(n[1]));
  }
  calculate(n, t, e) {
    let i;
    if (!(i = t.length))
      return [];
    const r = V.bitLength(t);
    for (let l = 0; l < i; l += 4) {
      this.incCounter(e);
      const s = n.encrypt(e);
      t[l] ^= s[0], t[l + 1] ^= s[1], t[l + 2] ^= s[2], t[l + 3] ^= s[3];
    }
    return V.clamp(t, r);
  }
} }, fe = { importKey: (n) => new fe.hmacSha1(Ce.bytes.toBits(n)), pbkdf2(n, t, e, i) {
  if (e = e || 1e4, i < 0 || e < 0)
    throw new Error("invalid params to pbkdf2");
  const r = 1 + (i >> 5) << 2;
  let l, s, d, f, _;
  const w = new ArrayBuffer(r), p = new DataView(w);
  let S = 0;
  const z = V;
  for (t = Ce.bytes.toBits(t), _ = 1; S < (r || 1); _++) {
    for (l = s = n.encrypt(z.concat(t, [_])), d = 1; d < e; d++)
      for (s = n.encrypt(s), f = 0; f < s.length; f++)
        l[f] ^= s[f];
    for (d = 0; S < (r || 1) && d < l.length; d++)
      p.setInt32(S, l[d]), S += 4;
  }
  return w.slice(0, i / 8);
}, hmacSha1: class {
  constructor(n) {
    const t = this, e = t._hash = Mn.sha1, i = [[], []];
    t._baseHash = [new e(), new e()];
    const r = t._baseHash[0].blockSize / 32;
    n.length > r && (n = new e().update(n).finalize());
    for (let l = 0; l < r; l++)
      i[0][l] = 909522486 ^ n[l], i[1][l] = 1549556828 ^ n[l];
    t._baseHash[0].update(i[0]), t._baseHash[1].update(i[1]), t._resultHash = new e(t._baseHash[0]);
  }
  reset() {
    const n = this;
    n._resultHash = new n._hash(n._baseHash[0]), n._updated = !1;
  }
  update(n) {
    this._updated = !0, this._resultHash.update(n);
  }
  digest() {
    const n = this, t = n._resultHash.finalize(), e = new n._hash(n._baseHash[1]).update(t).finalize();
    return n.reset(), e;
  }
  encrypt(n) {
    if (this._updated)
      throw new Error("encrypt on already updated hmac called!");
    return this.update(n), this.digest(n);
  }
} }, Pn = typeof crypto < "u" && typeof crypto.getRandomValues == "function", Vt = "Invalid password", qt = "Invalid signature", Oe = "zipjs-abort-check-password";
function Ht(n) {
  return Pn ? crypto.getRandomValues(n) : Rn.getRandomValues(n);
}
const ue = 16, In = "raw", Kt = { name: "PBKDF2" }, Nn = Object.assign({ hash: { name: "HMAC" } }, Kt), Ne = Object.assign({ iterations: 1e3, hash: { name: "SHA-1" } }, Kt), Tn = ["deriveBits"], be = [8, 12, 16], we = [16, 24, 32], te = 10, Vn = [0, 0, 0, 0], Zt = "undefined", Gt = "function", Le = typeof crypto != Zt, pe = Le && crypto.subtle, Jt = Le && typeof pe != Zt, X = Ce.bytes, qn = Ln.aes, Hn = Bn.ctrGladman, Kn = fe.hmacSha1;
let mt = Le && Jt && typeof pe.importKey == Gt, gt = Le && Jt && typeof pe.deriveBits == Gt;
class Zn extends TransformStream {
  constructor({ password: t, signed: e, encryptionStrength: i, checkPasswordOnly: r }) {
    super({ start() {
      Object.assign(this, { ready: new Promise((l) => this.resolveReady = l), password: t, signed: e, strength: i - 1, pending: new Uint8Array() });
    }, async transform(l, s) {
      const d = this, { password: f, strength: _, resolveReady: w, ready: p } = d;
      f ? (await async function(z, c, m, a) {
        const o = await Xt(z, c, m, J(a, 0, be[c])), u = J(a, be[c]);
        if (o[0] != u[0] || o[1] != u[1])
          throw new Error(Vt);
      }(d, _, f, J(l, 0, be[_] + 2)), l = J(l, be[_] + 2), r ? s.error(new Error(Oe)) : w()) : await p;
      const S = new Uint8Array(l.length - te - (l.length - te) % ue);
      s.enqueue(Qt(d, l, S, 0, te, !0));
    }, async flush(l) {
      const { signed: s, ctr: d, hmac: f, pending: _, ready: w } = this;
      if (f && d) {
        await w;
        const p = J(_, 0, _.length - te), S = J(_, _.length - te);
        let z = new Uint8Array();
        if (p.length) {
          const c = ge(X, p);
          f.update(c);
          const m = d.update(c);
          z = me(X, m);
        }
        if (s) {
          const c = J(me(X, f.digest()), 0, te);
          for (let m = 0; m < te; m++)
            if (c[m] != S[m])
              throw new Error(qt);
        }
        l.enqueue(z);
      }
    } });
  }
}
class Gn extends TransformStream {
  constructor({ password: t, encryptionStrength: e }) {
    let i;
    super({ start() {
      Object.assign(this, { ready: new Promise((r) => this.resolveReady = r), password: t, strength: e - 1, pending: new Uint8Array() });
    }, async transform(r, l) {
      const s = this, { password: d, strength: f, resolveReady: _, ready: w } = s;
      let p = new Uint8Array();
      d ? (p = await async function(z, c, m) {
        const a = Ht(new Uint8Array(be[c])), o = await Xt(z, c, m, a);
        return Ge(a, o);
      }(s, f, d), _()) : await w;
      const S = new Uint8Array(p.length + r.length - r.length % ue);
      S.set(p, 0), l.enqueue(Qt(s, r, S, p.length, 0));
    }, async flush(r) {
      const { ctr: l, hmac: s, pending: d, ready: f } = this;
      if (s && l) {
        await f;
        let _ = new Uint8Array();
        if (d.length) {
          const w = l.update(ge(X, d));
          s.update(w), _ = me(X, w);
        }
        i.signature = me(X, s.digest()).slice(0, te), r.enqueue(Ge(_, i.signature));
      }
    } }), i = this;
  }
}
function Qt(n, t, e, i, r, l) {
  const { ctr: s, hmac: d, pending: f } = n, _ = t.length - r;
  let w;
  for (f.length && (t = Ge(f, t), e = function(p, S) {
    if (S && S > p.length) {
      const z = p;
      (p = new Uint8Array(S)).set(z, 0);
    }
    return p;
  }(e, _ - _ % ue)), w = 0; w <= _ - ue; w += ue) {
    const p = ge(X, J(t, w, w + ue));
    l && d.update(p);
    const S = s.update(p);
    l || d.update(S), e.set(me(X, S), w + i);
  }
  return n.pending = J(t, w), e;
}
async function Xt(n, t, e, i) {
  n.password = null;
  const r = function(p) {
    if (typeof TextEncoder > "u") {
      p = unescape(encodeURIComponent(p));
      const S = new Uint8Array(p.length);
      for (let z = 0; z < S.length; z++)
        S[z] = p.charCodeAt(z);
      return S;
    }
    return new TextEncoder().encode(p);
  }(e), l = await async function(p, S, z, c, m) {
    if (!mt)
      return fe.importKey(S);
    try {
      return await pe.importKey(p, S, z, c, m);
    } catch {
      return mt = !1, fe.importKey(S);
    }
  }(In, r, Nn, !1, Tn), s = await async function(p, S, z) {
    if (!gt)
      return fe.pbkdf2(S, p.salt, Ne.iterations, z);
    try {
      return await pe.deriveBits(p, S, z);
    } catch {
      return gt = !1, fe.pbkdf2(S, p.salt, Ne.iterations, z);
    }
  }(Object.assign({ salt: i }, Ne), l, 8 * (2 * we[t] + 2)), d = new Uint8Array(s), f = ge(X, J(d, 0, we[t])), _ = ge(X, J(d, we[t], 2 * we[t])), w = J(d, 2 * we[t]);
  return Object.assign(n, { keys: { key: f, authentication: _, passwordVerification: w }, ctr: new Hn(new qn(f), Array.from(Vn)), hmac: new Kn(_) }), w;
}
function Ge(n, t) {
  let e = n;
  return n.length + t.length && (e = new Uint8Array(n.length + t.length), e.set(n, 0), e.set(t, n.length)), e;
}
function J(n, t, e) {
  return n.subarray(t, e);
}
function me(n, t) {
  return n.fromBits(t);
}
function ge(n, t) {
  return n.toBits(t);
}
const je = 12;
class Jn extends TransformStream {
  constructor({ password: t, passwordVerification: e, checkPasswordOnly: i }) {
    super({ start() {
      Object.assign(this, { password: t, passwordVerification: e }), Yt(this, t);
    }, transform(r, l) {
      const s = this;
      if (s.password) {
        const d = yt(s, r.subarray(0, je));
        if (s.password = null, d[11] != s.passwordVerification)
          throw new Error(Vt);
        r = r.subarray(je);
      }
      i ? l.error(new Error(Oe)) : l.enqueue(yt(s, r));
    } });
  }
}
class Qn extends TransformStream {
  constructor({ password: t, passwordVerification: e }) {
    super({ start() {
      Object.assign(this, { password: t, passwordVerification: e }), Yt(this, t);
    }, transform(i, r) {
      const l = this;
      let s, d;
      if (l.password) {
        l.password = null;
        const f = Ht(new Uint8Array(je));
        f[11] = l.passwordVerification, s = new Uint8Array(i.length + f.length), s.set(xt(l, f), 0), d = je;
      } else
        s = new Uint8Array(i.length), d = 0;
      s.set(xt(l, i), d), r.enqueue(s);
    } });
  }
}
function yt(n, t) {
  const e = new Uint8Array(t.length);
  for (let i = 0; i < t.length; i++)
    e[i] = $t(n) ^ t[i], et(n, e[i]);
  return e;
}
function xt(n, t) {
  const e = new Uint8Array(t.length);
  for (let i = 0; i < t.length; i++)
    e[i] = $t(n) ^ t[i], et(n, t[i]);
  return e;
}
function Yt(n, t) {
  const e = [305419896, 591751049, 878082192];
  Object.assign(n, { keys: e, crcKey0: new We(e[0]), crcKey2: new We(e[2]) });
  for (let i = 0; i < t.length; i++)
    et(n, t.charCodeAt(i));
}
function et(n, t) {
  let [e, i, r] = n.keys;
  n.crcKey0.append([t]), e = ~n.crcKey0.get(), i = kt(Math.imul(kt(i + Ot(e)), 134775813) + 1), n.crcKey2.append([i >>> 24]), r = ~n.crcKey2.get(), n.keys = [e, i, r];
}
function $t(n) {
  const t = 2 | n.keys[2];
  return Ot(Math.imul(t, 1 ^ t) >>> 8);
}
function Ot(n) {
  return 255 & n;
}
function kt(n) {
  return 4294967295 & n;
}
const vt = "deflate-raw";
class Xn extends TransformStream {
  constructor(t, { chunkSize: e, CompressionStream: i, CompressionStreamNative: r }) {
    super({});
    const { compressed: l, encrypted: s, useCompressionStream: d, zipCrypto: f, signed: _, level: w } = t, p = this;
    let S, z, c = en(super.readable);
    s && !f || !_ || (S = new Tt(), c = Y(c, S)), l && (c = nn(c, d, { level: w, chunkSize: e }, r, i)), s && (f ? c = Y(c, new Qn(t)) : (z = new Gn(t), c = Y(c, z))), tn(p, c, () => {
      let m;
      s && !f && (m = z.signature), s && !f || !_ || (m = new DataView(S.value.buffer).getUint32(0)), p.signature = m;
    });
  }
}
class Yn extends TransformStream {
  constructor(t, { chunkSize: e, DecompressionStream: i, DecompressionStreamNative: r }) {
    super({});
    const { zipCrypto: l, encrypted: s, signed: d, signature: f, compressed: _, useCompressionStream: w } = t;
    let p, S, z = en(super.readable);
    s && (l ? z = Y(z, new Jn(t)) : (S = new Zn(t), z = Y(z, S))), _ && (z = nn(z, w, { chunkSize: e }, r, i)), s && !l || !d || (p = new Tt(), z = Y(z, p)), tn(this, z, () => {
      if ((!s || l) && d) {
        const c = new DataView(p.value.buffer);
        if (f != c.getUint32(0, !1))
          throw new Error(qt);
      }
    });
  }
}
function en(n) {
  return Y(n, new TransformStream({ transform(t, e) {
    t && t.length && e.enqueue(t);
  } }));
}
function tn(n, t, e) {
  t = Y(t, new TransformStream({ flush: e })), Object.defineProperty(n, "readable", { get: () => t });
}
function nn(n, t, e, i, r) {
  try {
    n = Y(n, new (t && i ? i : r)(vt, e));
  } catch (l) {
    if (!t)
      throw l;
    n = Y(n, new r(vt, e));
  }
  return n;
}
function Y(n, t) {
  return n.pipeThrough(t);
}
const $n = "message", On = "start", ei = "pull", St = "data", ti = "ack", ni = "close", an = "inflate";
class ii extends TransformStream {
  constructor(t, e) {
    super({});
    const i = this, { codecType: r } = t;
    let l;
    r.startsWith("deflate") ? l = Xn : r.startsWith(an) && (l = Yn);
    let s = 0;
    const d = new l(t, e), f = super.readable, _ = new TransformStream({ transform(w, p) {
      w && w.length && (s += w.length, p.enqueue(w));
    }, flush() {
      const { signature: w } = d;
      Object.assign(i, { signature: w, size: s });
    } });
    Object.defineProperty(i, "readable", { get: () => f.pipeThrough(d).pipeThrough(_) });
  }
}
const ai = typeof Worker != Fe;
class Te {
  constructor(t, { readable: e, writable: i }, { options: r, config: l, streamOptions: s, useWebWorkers: d, transferStreams: f, scripts: _ }, w) {
    const { signal: p } = s;
    return Object.assign(t, { busy: !0, readable: e.pipeThrough(new ri(e, s, l), { signal: p }), writable: i, options: Object.assign({}, r), scripts: _, transferStreams: f, terminate() {
      const { worker: S, busy: z } = t;
      S && !z && (S.terminate(), t.interface = null);
    }, onTaskFinished() {
      t.busy = !1, w(t);
    } }), (d && ai ? oi : si)(t, l);
  }
}
class ri extends TransformStream {
  constructor(t, { onstart: e, onprogress: i, size: r, onend: l }, { chunkSize: s }) {
    let d = 0;
    super({ start() {
      e && Ve(e, r);
    }, async transform(f, _) {
      d += f.length, i && await Ve(i, d, r), _.enqueue(f);
    }, flush() {
      t.size = d, l && Ve(l, d);
    } }, { highWaterMark: 1, size: () => s });
  }
}
async function Ve(n, ...t) {
  try {
    await n(...t);
  } catch {
  }
}
function si(n, t) {
  return { run: () => async function({ options: e, readable: i, writable: r, onTaskFinished: l }, s) {
    const d = new ii(e, s);
    try {
      await i.pipeThrough(d).pipeTo(r, { preventClose: !0, preventAbort: !0 });
      const { signature: f, size: _ } = d;
      return { signature: f, size: _ };
    } finally {
      l();
    }
  }(n, t) };
}
function oi(n, { baseURL: t, chunkSize: e }) {
  return n.interface || Object.assign(n, { worker: li(n.scripts[0], t, n), interface: { run: () => async function(i, r) {
    let l, s;
    const d = new Promise((m, a) => {
      l = m, s = a;
    });
    Object.assign(i, { reader: null, writer: null, resolveResult: l, rejectResult: s, result: d });
    const { readable: f, options: _, scripts: w } = i, { writable: p, closed: S } = function(m) {
      const a = m.getWriter();
      let o;
      const u = new Promise((b) => o = b);
      return { writable: new WritableStream({ async write(b) {
        await a.ready, await a.write(b);
      }, close() {
        a.releaseLock(), o();
      }, abort: (b) => a.abort(b) }), closed: u };
    }(i.writable);
    Je({ type: On, scripts: w.slice(1), options: _, config: r, readable: f, writable: p }, i) || Object.assign(i, { reader: f.getReader(), writer: p.getWriter() });
    const c = await d;
    try {
      await p.getWriter().close();
    } catch {
    }
    return await S, c;
  }(n, { chunkSize: e }) } }), n.interface;
}
let zt = !0, At = !0;
function li(n, t, e) {
  const i = { type: "module" };
  let r, l;
  typeof n == Pt && (n = n());
  try {
    r = new URL(n, t);
  } catch {
    r = n;
  }
  if (zt)
    try {
      l = new Worker(r);
    } catch {
      zt = !1, l = new Worker(r, i);
    }
  else
    l = new Worker(r, i);
  return l.addEventListener($n, (s) => async function({ data: d }, f) {
    const { type: _, value: w, messageId: p, result: S, error: z } = d, { reader: c, writer: m, resolveResult: a, rejectResult: o, onTaskFinished: u } = f;
    try {
      if (z) {
        const { message: b, stack: x, code: g, name: h } = z, A = new Error(b);
        Object.assign(A, { stack: x, code: g, name: h }), y(A);
      } else {
        if (_ == ei) {
          const { value: b, done: x } = await c.read();
          Je({ type: St, value: b, done: x, messageId: p }, f);
        }
        _ == St && (await m.ready, await m.write(new Uint8Array(w)), Je({ type: ti, messageId: p }, f)), _ == ni && y(null, S);
      }
    } catch (b) {
      y(b);
    }
    function y(b, x) {
      b ? o(b) : a(x), m && m.releaseLock(), u();
    }
  }(s, e)), l;
}
function Je(n, { worker: t, writer: e, onTaskFinished: i, transferStreams: r }) {
  try {
    let { value: l, readable: s, writable: d } = n;
    const f = [];
    if (l && (n.value = l.buffer, f.push(n.value)), r && At ? (s && f.push(s), d && f.push(d)) : n.readable = n.writable = null, f.length)
      try {
        return t.postMessage(n, f), !0;
      } catch {
        At = !1, n.readable = n.writable = null, t.postMessage(n);
      }
    else
      t.postMessage(n);
  } catch (l) {
    throw e && e.releaseLock(), i(), l;
  }
}
let ae = [];
const qe = [];
let Ut = 0;
function Dt(n) {
  const { terminateTimeout: t } = n;
  t && (clearTimeout(t), n.terminateTimeout = null);
}
const ci = 65536, rn = "writable";
class tt {
  constructor() {
    this.size = 0;
  }
  init() {
    this.initialized = !0;
  }
}
class sn extends tt {
  get readable() {
    const t = this, { chunkSize: e = ci } = t, i = new ReadableStream({ start() {
      this.chunkOffset = 0;
    }, async pull(r) {
      const { offset: l = 0, size: s, diskNumberStart: d } = i, { chunkOffset: f } = this;
      r.enqueue(await T(t, l + f, Math.min(e, s - f), d)), f + e > s ? r.close() : this.chunkOffset += e;
    } });
    return i;
  }
}
class fi extends sn {
  constructor(t) {
    super(), Object.assign(this, { blob: t, size: t.size });
  }
  async readUint8Array(t, e) {
    const i = this, r = t + e;
    let s = await (t || r < i.size ? i.blob.slice(t, r) : i.blob).arrayBuffer();
    return s.byteLength > e && (s = s.slice(t, r)), new Uint8Array(s);
  }
}
class ui extends tt {
  constructor(t) {
    super();
    const e = new TransformStream(), i = [];
    t && i.push(["Content-Type", t]), Object.defineProperty(this, rn, { get: () => e.writable }), this.blob = new Response(e.readable, { headers: i }).blob();
  }
  getData() {
    return this.blob;
  }
}
class vi extends ui {
  constructor(t) {
    super(t), Object.assign(this, { encoding: t, utf8: !t || t.toLowerCase() == "utf-8" });
  }
  async getData() {
    const { encoding: t, utf8: e } = this, i = await super.getData();
    if (i.text && e)
      return i.text();
    {
      const r = new FileReader();
      return new Promise((l, s) => {
        Object.assign(r, { onload: ({ target: d }) => l(d.result), onerror: () => s(r.error) }), r.readAsText(i, t);
      });
    }
  }
}
class di extends sn {
  constructor(t) {
    super(), this.readers = t;
  }
  async init() {
    const t = this, { readers: e } = t;
    t.lastDiskNumber = 0, t.lastDiskOffset = 0, await Promise.all(e.map(async (i, r) => {
      await i.init(), r != e.length - 1 && (t.lastDiskOffset += i.size), t.size += i.size;
    })), super.init();
  }
  async readUint8Array(t, e, i = 0) {
    const r = this, { readers: l } = this;
    let s, d = i;
    d == -1 && (d = l.length - 1);
    let f = t;
    for (; f >= l[d].size; )
      f -= l[d].size, d++;
    const _ = l[d], w = _.size;
    if (f + e <= w)
      s = await T(_, f, e);
    else {
      const p = w - f;
      s = new Uint8Array(e), s.set(await T(_, f, p)), s.set(await r.readUint8Array(t + p, e - p, i), p);
    }
    return r.lastDiskNumber = Math.max(d, r.lastDiskNumber), s;
  }
}
class Et extends tt {
  constructor(t, e = 4294967295) {
    super();
    const i = this;
    let r, l, s;
    Object.assign(i, { diskNumber: 0, diskOffset: 0, size: 0, maxSize: e, availableSize: e });
    const d = new WritableStream({ async write(w) {
      const { availableSize: p } = i;
      if (s)
        w.length >= p ? (await f(w.slice(0, p)), await _(), i.diskOffset += r.size, i.diskNumber++, s = null, await this.write(w.slice(p))) : await f(w);
      else {
        const { value: S, done: z } = await t.next();
        if (z && !S)
          throw new Error("Writer iterator completed too soon");
        r = S, r.size = 0, r.maxSize && (i.maxSize = r.maxSize), i.availableSize = i.maxSize, await Me(r), l = S.writable, s = l.getWriter(), await this.write(w);
      }
    }, async close() {
      await s.ready, await _();
    } });
    async function f(w) {
      const p = w.length;
      p && (await s.ready, await s.write(w), r.size += p, i.size += p, i.availableSize -= p);
    }
    async function _() {
      l.size = r.size, await s.close();
    }
    Object.defineProperty(i, rn, { get: () => d });
  }
}
async function Me(n, t) {
  n.init && !n.initialized && await n.init(t);
}
function hi(n) {
  return Array.isArray(n) && (n = new di(n)), n instanceof ReadableStream && (n = { readable: n }), n;
}
function T(n, t, e, i) {
  return n.readUint8Array(t, e, i);
}
const on = "\0 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ ".split(""), _i = on.length == 256;
function Qe(n, t) {
  return t && t.trim().toLowerCase() == "cp437" ? function(e) {
    if (_i) {
      let i = "";
      for (let r = 0; r < e.length; r++)
        i += on[e[r]];
      return i;
    }
    return new TextDecoder().decode(e);
  }(n) : new TextDecoder(t).decode(n);
}
const ln = "filename", cn = "rawFilename", fn = "comment", un = "rawComment", dn = "uncompressedSize", hn = "compressedSize", _n = "offset", Xe = "diskNumberStart", Ye = "lastModDate", $e = "rawLastModDate", wn = "lastAccessDate", wi = "rawLastAccessDate", bn = "creationDate", bi = "rawCreationDate", pi = [ln, cn, hn, dn, Ye, $e, fn, un, wn, bn, _n, Xe, Xe, "internalFileAttribute", "externalFileAttribute", "msDosCompatible", "zip64", "directory", "bitFlag", "encrypted", "signature", "filenameUTF8", "commentUTF8", "compressionMethod", "version", "versionMadeBy", "extraField", "rawExtraField", "extraFieldZip64", "extraFieldUnicodePath", "extraFieldUnicodeComment", "extraFieldAES", "extraFieldNTFS", "extraFieldExtendedTimestamp"];
class Ft {
  constructor(t) {
    pi.forEach((e) => this[e] = t[e]);
  }
}
const He = "File format is not recognized", mi = "Zip64 extra field not found", Wt = "Compression method not supported", Ct = "Split zip file", jt = "utf-8", Mt = "cp437", gi = [[dn, se], [hn, se], [_n, se], [Xe, re]], yi = { [re]: { getValue: B, bytes: 4 }, [se]: { getValue: Ee, bytes: 8 } };
class Si {
  constructor(t, e = {}) {
    Object.assign(this, { reader: hi(t), options: e, config: ne });
  }
  async *getEntriesGenerator(t = {}) {
    const e = this;
    let { reader: i } = e;
    const { config: r } = e;
    if (await Me(i), i.size !== Q && i.readUint8Array || (i = new fi(await new Response(i.readable).blob()), await Me(i)), i.size < 22)
      throw new Error(He);
    i.chunkSize = function(U) {
      return Math.max(U.chunkSize, 64);
    }(r);
    const l = await async function(U, k, v, F, j) {
      const M = new Uint8Array(4);
      (function(K, q, W) {
        K.setUint32(q, W, !0);
      })(I(M), 0, k);
      const D = F + j;
      return await C(F) || await C(Math.min(D, v));
      async function C(K) {
        const q = v - K, W = await T(U, q, K);
        for (let P = W.length - F; P >= 0; P--)
          if (W[P] == M[0] && W[P + 1] == M[1] && W[P + 2] == M[2] && W[P + 3] == M[3])
            return { offset: q + P, buffer: W.slice(P, P + F).buffer };
      }
    }(i, 101010256, i.size, 22, 1048560);
    if (!l)
      throw B(I(await T(i, 0, 4))) == 134695760 ? new Error(Ct) : new Error("End of central directory not found");
    const s = I(l);
    let d = B(s, 12), f = B(s, 16);
    const _ = l.offset, w = N(s, 20), p = _ + 22 + w;
    let S = N(s, 4);
    const z = i.lastDiskNumber || 0;
    let c = N(s, 6), m = N(s, 8), a = 0, o = 0;
    if (f == se || d == se || m == re || c == re) {
      const U = I(await T(i, l.offset - 20, 20));
      if (B(U, 0) != 117853008)
        throw new Error("End of Zip64 central directory not found");
      f = Ee(U, 8);
      let k = await T(i, f, 56, -1), v = I(k);
      const F = l.offset - 20 - 56;
      if (B(v, 0) != bt && f != F) {
        const j = f;
        f = F, a = f - j, k = await T(i, f, 56, -1), v = I(k);
      }
      if (B(v, 0) != bt)
        throw new Error("End of Zip64 central directory locator not found");
      S == re && (S = B(v, 16)), c == re && (c = B(v, 20)), m == re && (m = Ee(v, 32)), d == se && (d = Ee(v, 40)), f -= d;
    }
    if (z != S)
      throw new Error(Ct);
    if (f < 0 || f >= i.size)
      throw new Error(He);
    let u = 0, y = await T(i, f, d, c), b = I(y);
    if (d) {
      const U = l.offset - d;
      if (B(b, u) != wt && f != U) {
        const k = f;
        f = U, a = f - k, y = await T(i, f, d, c), b = I(y);
      }
    }
    const x = l.offset - f - (i.lastDiskOffset || 0);
    if (d != x && x >= 0 && (d = x, y = await T(i, f, d, c), b = I(y)), f < 0 || f >= i.size)
      throw new Error(He);
    const g = G(e, t, "filenameEncoding"), h = G(e, t, "commentEncoding");
    for (let U = 0; U < m; U++) {
      const k = new xi(i, r, e.options);
      if (B(b, u) != wt)
        throw new Error("Central directory header not found");
      pn(k, b, u + 6);
      const v = !!k.bitFlag.languageEncodingFlag, F = u + 46, j = F + k.filenameLength, M = j + k.extraFieldLength, D = N(b, u + 4), C = (0 & D) == 0, K = y.subarray(F, j), q = N(b, u + 32), W = M + q, P = y.subarray(M, W), L = v, R = v, ye = C && (16 & de(b, u + 38)) == 16, xe = B(b, u + 42) + a;
      Object.assign(k, { versionMadeBy: D, msDosCompatible: C, compressedSize: 0, uncompressedSize: 0, commentLength: q, directory: ye, offset: xe, diskNumberStart: N(b, u + 34), internalFileAttribute: N(b, u + 36), externalFileAttribute: B(b, u + 38), rawFilename: K, filenameUTF8: L, commentUTF8: R, rawExtraField: y.subarray(j, M) });
      const [ke, ve] = await Promise.all([Qe(K, L ? jt : g || Mt), Qe(P, R ? jt : h || Mt)]);
      Object.assign(k, { rawComment: P, filename: ke, comment: ve, directory: ye || ke.endsWith("/") }), o = Math.max(xe, o), await mn(k, k, b, u + 6);
      const he = new Ft(k);
      he.getData = (Se, le) => k.getData(Se, he, le), u = W;
      const { onprogress: oe } = t;
      if (oe)
        try {
          await oe(U + 1, m, new Ft(k));
        } catch {
        }
      yield he;
    }
    const A = G(e, t, "extractPrependedData"), E = G(e, t, "extractAppendedData");
    return A && (e.prependedData = o > 0 ? await T(i, 0, o) : new Uint8Array()), e.comment = w ? await T(i, _ + 22, w) : new Uint8Array(), E && (e.appendedData = p < i.size ? await T(i, p, i.size - p) : new Uint8Array()), !0;
  }
  async getEntries(t = {}) {
    const e = [];
    for await (const i of this.getEntriesGenerator(t))
      e.push(i);
    return e;
  }
  async close() {
  }
}
class xi {
  constructor(t, e, i) {
    Object.assign(this, { reader: t, config: e, options: i });
  }
  async getData(t, e, i = {}) {
    const r = this, { reader: l, offset: s, diskNumberStart: d, extraFieldAES: f, compressionMethod: _, config: w, bitFlag: p, signature: S, rawLastModDate: z, uncompressedSize: c, compressedSize: m } = r, a = e.localDirectory = {}, o = I(await T(l, s, 30, d));
    let u = G(r, i, "password");
    if (u = u && u.length && u, f && f.originalCompressionMethod != 99)
      throw new Error(Wt);
    if (_ != 0 && _ != 8)
      throw new Error(Wt);
    if (B(o, 0) != 67324752)
      throw new Error("Local file header not found");
    pn(a, o, 4), a.rawExtraField = a.extraFieldLength ? await T(l, s + 30 + a.filenameLength, a.extraFieldLength, d) : new Uint8Array(), await mn(r, a, o, 4, !0), Object.assign(e, { lastAccessDate: a.lastAccessDate, creationDate: a.creationDate });
    const y = r.encrypted && a.encrypted, b = y && !f;
    if (y) {
      if (!b && f.strength === Q)
        throw new Error("Encryption method not supported");
      if (!u)
        throw new Error("File contains encrypted entry");
    }
    const x = s + 30 + a.filenameLength + a.extraFieldLength, g = m, h = l.readable;
    Object.assign(h, { diskNumberStart: d, offset: x, size: g });
    const A = G(r, i, "signal"), E = G(r, i, "checkPasswordOnly");
    E && (t = new WritableStream()), t = function(D) {
      D.writable === Q && typeof D.next == Pt && (D = new Et(D)), D instanceof WritableStream && (D = { writable: D });
      const { writable: C } = D;
      return C.size === Q && (C.size = 0), D instanceof Et || Object.assign(D, { diskNumber: 0, diskOffset: 0, availableSize: 1 / 0, maxSize: 1 / 0 }), D;
    }(t), await Me(t, c);
    const { writable: U } = t, { onstart: k, onprogress: v, onend: F } = i, j = { options: { codecType: an, password: u, zipCrypto: b, encryptionStrength: f && f.strength, signed: G(r, i, "checkSignature"), passwordVerification: b && (p.dataDescriptor ? z >>> 8 & 255 : S >>> 24 & 255), signature: S, compressed: _ != 0, encrypted: y, useWebWorkers: G(r, i, "useWebWorkers"), useCompressionStream: G(r, i, "useCompressionStream"), transferStreams: G(r, i, "transferStreams"), checkPasswordOnly: E }, config: w, streamOptions: { signal: A, size: g, onstart: k, onprogress: v, onend: F } };
    let M = 0;
    try {
      ({ outputSize: M } = await async function(D, C) {
        const { options: K, config: q } = C, { transferStreams: W, useWebWorkers: P, useCompressionStream: L, codecType: R, compressed: ye, signed: xe, encrypted: ke } = K, { workerScripts: ve, maxWorkers: he, terminateWorkerTimeout: oe } = q;
        C.transferStreams = W || W === Q;
        const Se = !(ye || xe || ke || C.transferStreams);
        let le;
        C.useWebWorkers = !Se && (P || P === Q && q.useWebWorkers), C.scripts = C.useWebWorkers && ve ? ve[R] : [], K.useCompressionStream = L || L === Q && q.useCompressionStream;
        const Re = ae.find((H) => !H.busy);
        if (Re)
          Dt(Re), le = new Te(Re, D, C, Be);
        else if (ae.length < he) {
          const H = { indexWorker: Ut };
          Ut++, ae.push(H), le = new Te(H, D, C, Be);
        } else
          le = await new Promise((H) => qe.push({ resolve: H, stream: D, workerOptions: C }));
        return le.run();
        function Be(H) {
          if (qe.length) {
            const [{ resolve: _e, stream: gn, workerOptions: yn }] = qe.splice(0, 1);
            _e(new Te(H, gn, yn, Be));
          } else
            H.worker ? (Dt(H), Number.isFinite(oe) && oe >= 0 && (H.terminateTimeout = setTimeout(() => {
              ae = ae.filter((_e) => _e != H), H.terminate();
            }, oe))) : ae = ae.filter((_e) => _e != H);
        }
      }({ readable: h, writable: U }, j));
    } catch (D) {
      if (!E || D.message != Oe)
        throw D;
    } finally {
      const D = G(r, i, "preventClose");
      U.size += M, D || U.locked || await U.getWriter().close();
    }
    return E ? void 0 : t.getData ? t.getData() : U;
  }
}
function pn(n, t, e) {
  const i = n.rawBitFlag = N(t, e + 2), r = (1 & i) == 1, l = B(t, e + 6);
  Object.assign(n, { encrypted: r, version: N(t, e), bitFlag: { level: (6 & i) >> 1, dataDescriptor: (8 & i) == 8, languageEncodingFlag: (2048 & i) == 2048 }, rawLastModDate: l, lastModDate: ki(l), filenameLength: N(t, e + 22), extraFieldLength: N(t, e + 24) });
}
async function mn(n, t, e, i, r) {
  const { rawExtraField: l } = t, s = t.extraField = /* @__PURE__ */ new Map(), d = I(new Uint8Array(l));
  let f = 0;
  try {
    for (; f < l.length; ) {
      const o = N(d, f), u = N(d, f + 2);
      s.set(o, { type: o, data: l.slice(f + 4, f + 4 + u) }), f += 4 + u;
    }
  } catch {
  }
  const _ = N(e, i + 4);
  Object.assign(t, { signature: B(e, i + 10), uncompressedSize: B(e, i + 18), compressedSize: B(e, i + 14) });
  const w = s.get(1);
  w && (function(o, u) {
    u.zip64 = !0;
    const y = I(o.data), b = gi.filter(([x, g]) => u[x] == g);
    for (let x = 0, g = 0; x < b.length; x++) {
      const [h, A] = b[x];
      if (u[h] == A) {
        const E = yi[A];
        u[h] = o[h] = E.getValue(y, g), g += E.bytes;
      } else if (o[h])
        throw new Error(mi);
    }
  }(w, t), t.extraFieldZip64 = w);
  const p = s.get(28789);
  p && (await Lt(p, ln, cn, t, n), t.extraFieldUnicodePath = p);
  const S = s.get(25461);
  S && (await Lt(S, fn, un, t, n), t.extraFieldUnicodeComment = S);
  const z = s.get(39169);
  z ? (function(o, u, y) {
    const b = I(o.data), x = de(b, 4);
    Object.assign(o, { vendorVersion: de(b, 0), vendorId: de(b, 2), strength: x, originalCompressionMethod: y, compressionMethod: N(b, 5) }), u.compressionMethod = o.compressionMethod;
  }(z, t, _), t.extraFieldAES = z) : t.compressionMethod = _;
  const c = s.get(10);
  c && (function(o, u) {
    const y = I(o.data);
    let b, x = 4;
    try {
      for (; x < o.data.length && !b; ) {
        const g = N(y, x), h = N(y, x + 2);
        g == Wn && (b = o.data.slice(x + 4, x + 4 + h)), x += 4 + h;
      }
    } catch {
    }
    try {
      if (b && b.length == 24) {
        const g = I(b), h = g.getBigUint64(0, !0), A = g.getBigUint64(8, !0), E = g.getBigUint64(16, !0);
        Object.assign(o, { rawLastModDate: h, rawLastAccessDate: A, rawCreationDate: E });
        const U = Ke(h), k = Ke(A), v = { lastModDate: U, lastAccessDate: k, creationDate: Ke(E) };
        Object.assign(o, v), Object.assign(u, v);
      }
    } catch {
    }
  }(c, t), t.extraFieldNTFS = c);
  const m = s.get(21589);
  m && (function(o, u, y) {
    const b = I(o.data), x = de(b, 0), g = [], h = [];
    y ? ((1 & x) == 1 && (g.push(Ye), h.push($e)), (2 & x) == 2 && (g.push(wn), h.push(wi)), (4 & x) == 4 && (g.push(bn), h.push(bi))) : o.data.length >= 5 && (g.push(Ye), h.push($e));
    let A = 1;
    g.forEach((E, U) => {
      if (o.data.length >= A + 4) {
        const k = B(b, A);
        u[E] = o[E] = new Date(1e3 * k);
        const v = h[U];
        o[v] = k;
      }
      A += 4;
    });
  }(m, t, r), t.extraFieldExtendedTimestamp = m);
  const a = s.get(6534);
  a && (t.extraFieldUSDZ = a);
}
async function Lt(n, t, e, i, r) {
  const l = I(n.data), s = new We();
  s.append(r[e]);
  const d = I(new Uint8Array(4));
  d.setUint32(0, s.get(), !0);
  const f = B(l, 1);
  Object.assign(n, { version: de(l, 0), [t]: Qe(n.data.subarray(5)), valid: !r.bitFlag.languageEncodingFlag && f == B(d, 0) }), n.valid && (i[t] = n[t], i[t + "UTF8"] = !0);
}
function G(n, t, e) {
  return t[e] === Q ? n.options[e] : t[e];
}
function ki(n) {
  const t = (4294901760 & n) >> 16, e = 65535 & n;
  try {
    return new Date(1980 + ((65024 & t) >> 9), ((480 & t) >> 5) - 1, 31 & t, (63488 & e) >> 11, (2016 & e) >> 5, 2 * (31 & e), 0);
  } catch {
  }
}
function Ke(n) {
  return new Date(Number(n / BigInt(1e4) - BigInt(116444736e5)));
}
function de(n, t) {
  return n.getUint8(t);
}
function N(n, t) {
  return n.getUint16(t, !0);
}
function B(n, t) {
  return n.getUint32(t, !0);
}
function Ee(n, t) {
  return Number(n.getBigUint64(t, !0));
}
function I(n) {
  return new DataView(n.buffer);
}
jn({ Inflate: function(n) {
  const t = new Bt(), e = n && n.chunkSize ? Math.floor(2 * n.chunkSize) : 131072, i = new Uint8Array(e);
  let r = !1;
  t.inflateInit(), t.next_out = i, this.append = function(l, s) {
    const d = [];
    let f, _, w = 0, p = 0, S = 0;
    if (l.length !== 0) {
      t.next_in_index = 0, t.next_in = l, t.avail_in = l.length;
      do {
        if (t.next_out_index = 0, t.avail_out = e, t.avail_in !== 0 || r || (t.next_in_index = 0, r = !0), f = t.inflate(0), r && f === -5) {
          if (t.avail_in !== 0)
            throw new Error("inflating: bad input");
        } else if (f !== 0 && f !== 1)
          throw new Error("inflating: " + t.msg);
        if ((r || f === 1) && t.avail_in === l.length)
          throw new Error("inflating: bad input");
        t.next_out_index && (t.next_out_index === e ? d.push(new Uint8Array(i)) : d.push(i.subarray(0, t.next_out_index))), S += t.next_out_index, s && t.next_in_index > 0 && t.next_in_index != w && (s(t.next_in_index), w = t.next_in_index);
      } while (t.avail_in > 0 || t.avail_out === 0);
      return d.length > 1 ? (_ = new Uint8Array(S), d.forEach(function(z) {
        _.set(z, p), p += z.length;
      })) : _ = d[0] ? new Uint8Array(d[0]) : new Uint8Array(), _;
    }
  }, this.flush = function() {
    t.inflateEnd();
  };
} });
export {
  fi as BlobReader,
  ui as BlobWriter,
  vi as TextWriter,
  Si as ZipReader,
  jn as configure
};
