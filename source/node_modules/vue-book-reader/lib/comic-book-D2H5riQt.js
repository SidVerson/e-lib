const h = ({ entries: l, loadBlob: i, getSize: a }, p) => {
  const s = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Map(), d = async (e) => {
    if (s.has(e))
      return s.get(e);
    const t = URL.createObjectURL(await i(e)), r = URL.createObjectURL(
      new Blob([`<img src="${t}">`], { type: "text/html" })
    );
    return c.set(e, [t, r]), s.set(e, r), r;
  }, f = (e) => {
    var t, r;
    (r = (t = c.get(e)) == null ? void 0 : t.forEach) == null || r.call(t, (u) => URL.revokeObjectURL(u)), c.delete(e), s.delete(e);
  }, g = [".jpg", ".jpeg", ".png", ".gif", ".bmp", ".webp", ".svg", ".jxl", ".avif"], n = l.map((e) => e.filename).filter((e) => g.some((t) => e.endsWith(t))).sort();
  if (!n.length)
    throw new Error("No supported image files in archive");
  const o = {};
  return o.getCover = () => i(n[0]), o.metadata = { title: p.name }, o.sections = n.map((e) => ({
    id: e,
    load: () => d(e),
    unload: () => f(e),
    size: a(e)
  })), o.toc = n.map((e) => ({ label: e, href: e })), o.rendition = { layout: "pre-paginated" }, o.resolveHref = (e) => ({ index: o.sections.findIndex((t) => t.id === e) }), o.splitTOCHref = (e) => [e, null], o.getTOCFragment = (e) => e.documentElement, o.destroy = () => {
    for (const e of c.values())
      for (const t of e)
        URL.revokeObjectURL(t);
  }, o;
};
export {
  h as makeComicBook
};
