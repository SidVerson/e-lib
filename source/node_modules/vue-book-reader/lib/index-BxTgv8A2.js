var As = Object.defineProperty;
var Ss = (Re, ge, xe) => ge in Re ? As(Re, ge, { enumerable: !0, configurable: !0, writable: !0, value: xe }) : Re[ge] = xe;
var Ot = (Re, ge, xe) => (Ss(Re, typeof ge != "symbol" ? ge + "" : ge, xe), xe), Pi = (Re, ge, xe) => {
  if (!ge.has(Re))
    throw TypeError("Cannot " + xe);
};
var le = (Re, ge, xe) => (Pi(Re, ge, "read from private field"), xe ? xe.call(Re) : ge.get(Re)), Me = (Re, ge, xe) => {
  if (ge.has(Re))
    throw TypeError("Cannot add the same private member more than once");
  ge instanceof WeakSet ? ge.add(Re) : ge.set(Re, xe);
}, Xe = (Re, ge, xe, de) => (Pi(Re, ge, "write to private field"), de ? de.call(Re, xe) : ge.set(Re, xe), xe);
var xn = (Re, ge, xe, de) => ({
  set _(fe) {
    Xe(Re, ge, fe, xe);
  },
  get _() {
    return le(Re, ge, de);
  }
}), De = (Re, ge, xe) => (Pi(Re, ge, "access private method"), xe);
import { toRefs, ref, watch, onMounted, openBlock, createElementBlock, createElementVNode, withDirectives, vShow, renderSlot, createCommentVNode, defineComponent, getCurrentInstance, h, Transition, reactive, normalizeClass, unref, normalizeStyle, toDisplayString, createVNode, mergeProps, withCtx } from "vue";
(function(ge, xe) {
  typeof exports == "object" && typeof module == "object" ? module.exports = ge.pdfjsWorker = xe() : typeof define == "function" && define.amd ? define("pdfjs-dist/build/pdf.worker", [], () => ge.pdfjsWorker = xe()) : typeof exports == "object" ? exports["pdfjs-dist/build/pdf.worker"] = ge.pdfjsWorker = xe() : ge["pdfjs-dist/build/pdf.worker"] = ge.pdfjsWorker = xe();
})(globalThis, () => (
  /******/
  (() => {
    var Re = [
      ,
      /* 1 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.WorkerTask = w.WorkerMessageHandler = void 0;
        var n = V(2), F = V(3), C = V(4), e = V(6), t = V(10), l = V(68), j = V(73), U = V(104), O = V(105), v = V(72);
        class g {
          constructor(d) {
            this.name = d, this.terminated = !1, this._capability = new n.PromiseCapability();
          }
          get finished() {
            return this._capability.promise;
          }
          finish() {
            this._capability.resolve();
          }
          terminate() {
            this.terminated = !0;
          }
          ensureNotTerminated() {
            if (this.terminated)
              throw new Error("Worker task was terminated");
          }
        }
        w.WorkerTask = g;
        class b {
          static setup(d, A) {
            let I = !1;
            d.on("test", function(E) {
              I || (I = !0, d.send("test", E instanceof Uint8Array));
            }), d.on("configure", function(E) {
              (0, n.setVerbosityLevel)(E.verbosity);
            }), d.on("GetDocRequest", function(E) {
              return b.createDocumentHandler(E, A);
            });
          }
          static createDocumentHandler(d, A) {
            let I, E = !1, k = null;
            const H = /* @__PURE__ */ new Set(), x = (0, n.getVerbosityLevel)(), {
              docId: R,
              apiVersion: f
            } = d, c = "3.11.174";
            if (f !== c)
              throw new Error(`The API version "${f}" does not match the Worker version "${c}".`);
            const N = [];
            for (const o in [])
              N.push(o);
            if (N.length)
              throw new Error("The `Array.prototype` contains unexpected enumerable properties: " + N.join(", ") + "; thus breaking e.g. `for...in` iteration of `Array`s.");
            const u = R + "_worker";
            let p = new U.MessageHandler(u, R, A);
            function S() {
              if (E)
                throw new Error("Worker was terminated");
            }
            function B(o) {
              H.add(o);
            }
            function T(o) {
              o.finish(), H.delete(o);
            }
            async function D(o) {
              await I.ensureDoc("checkHeader"), await I.ensureDoc("parseStartXRef"), await I.ensureDoc("parse", [o]), await I.ensureDoc("checkFirstPage", [o]), await I.ensureDoc("checkLastPage", [o]);
              const m = await I.ensureDoc("isPureXfa");
              if (m) {
                const M = new g("loadXfaFonts");
                B(M), await Promise.all([I.loadXfaFonts(p, M).catch(($) => {
                }).then(() => T(M)), I.loadXfaImages()]);
              }
              const [s, r] = await Promise.all([I.ensureDoc("numPages"), I.ensureDoc("fingerprints")]), y = m ? await I.ensureDoc("htmlForXfa") : null;
              return {
                numPages: s,
                fingerprints: r,
                htmlForXfa: y
              };
            }
            function K({
              data: o,
              password: m,
              disableAutoFetch: s,
              rangeChunkSize: r,
              length: y,
              docBaseUrl: M,
              enableXfa: $,
              evaluatorOptions: G
            }) {
              const ce = {
                source: null,
                disableAutoFetch: s,
                docBaseUrl: M,
                docId: R,
                enableXfa: $,
                evaluatorOptions: G,
                handler: p,
                length: y,
                password: m,
                rangeChunkSize: r
              }, q = new n.PromiseCapability();
              let re;
              if (o) {
                try {
                  ce.source = o, re = new e.LocalPdfManager(ce), q.resolve(re);
                } catch (Y) {
                  q.reject(Y);
                }
                return q.promise;
              }
              let Z, te = [];
              try {
                Z = new O.PDFWorkerStream(p);
              } catch (Y) {
                return q.reject(Y), q.promise;
              }
              const L = Z.getFullReader();
              L.headersReady.then(function() {
                if (L.isRangeSupported) {
                  ce.source = Z, ce.length = L.contentLength, ce.disableAutoFetch || (ce.disableAutoFetch = L.isStreamingSupported), re = new e.NetworkPdfManager(ce);
                  for (const Y of te)
                    re.sendProgressiveData(Y);
                  te = [], q.resolve(re), k = null;
                }
              }).catch(function(Y) {
                q.reject(Y), k = null;
              });
              let X = 0;
              const J = function() {
                const Y = (0, F.arrayBuffersToBytes)(te);
                y && Y.length !== y && (0, n.warn)("reported HTTP length is different from actual");
                try {
                  ce.source = Y, re = new e.LocalPdfManager(ce), q.resolve(re);
                } catch (ae) {
                  q.reject(ae);
                }
                te = [];
              };
              return new Promise(function(Y, ae) {
                const se = function({
                  value: Q,
                  done: z
                }) {
                  try {
                    if (S(), z) {
                      re || J(), k = null;
                      return;
                    }
                    X += Q.byteLength, L.isStreamingSupported || p.send("DocProgress", {
                      loaded: X,
                      total: Math.max(X, L.contentLength || 0)
                    }), re ? re.sendProgressiveData(Q) : te.push(Q), L.read().then(se, ae);
                  } catch (ie) {
                    ae(ie);
                  }
                };
                L.read().then(se, ae);
              }).catch(function(Y) {
                q.reject(Y), k = null;
              }), k = function(Y) {
                Z.cancelAllRequests(Y);
              }, q.promise;
            }
            function _(o) {
              function m(y) {
                S(), p.send("GetDoc", {
                  pdfInfo: y
                });
              }
              function s(y) {
                if (S(), y instanceof n.PasswordException) {
                  const M = new g(`PasswordException: response ${y.code}`);
                  B(M), p.sendWithPromise("PasswordRequest", y).then(function({
                    password: $
                  }) {
                    T(M), I.updatePassword($), r();
                  }).catch(function() {
                    T(M), p.send("DocException", y);
                  });
                } else
                  y instanceof n.InvalidPDFException || y instanceof n.MissingPDFException || y instanceof n.UnexpectedResponseException || y instanceof n.UnknownErrorException ? p.send("DocException", y) : p.send("DocException", new n.UnknownErrorException(y.message, y.toString()));
              }
              function r() {
                S(), D(!1).then(m, function(y) {
                  if (S(), !(y instanceof F.XRefParseException)) {
                    s(y);
                    return;
                  }
                  I.requestLoadedStream().then(function() {
                    S(), D(!0).then(m, s);
                  });
                });
              }
              S(), K(o).then(function(y) {
                if (E)
                  throw y.terminate(new n.AbortException("Worker was terminated.")), new Error("Worker was terminated");
                I = y, I.requestLoadedStream(!0).then((M) => {
                  p.send("DataLoaded", {
                    length: M.bytes.byteLength
                  });
                });
              }).then(r, s);
            }
            return p.on("GetPage", function(o) {
              return I.getPage(o.pageIndex).then(function(m) {
                return Promise.all([I.ensure(m, "rotate"), I.ensure(m, "ref"), I.ensure(m, "userUnit"), I.ensure(m, "view")]).then(function([s, r, y, M]) {
                  return {
                    rotate: s,
                    ref: r,
                    userUnit: y,
                    view: M
                  };
                });
              });
            }), p.on("GetPageIndex", function(o) {
              const m = C.Ref.get(o.num, o.gen);
              return I.ensureCatalog("getPageIndex", [m]);
            }), p.on("GetDestinations", function(o) {
              return I.ensureCatalog("destinations");
            }), p.on("GetDestination", function(o) {
              return I.ensureCatalog("getDestination", [o.id]);
            }), p.on("GetPageLabels", function(o) {
              return I.ensureCatalog("pageLabels");
            }), p.on("GetPageLayout", function(o) {
              return I.ensureCatalog("pageLayout");
            }), p.on("GetPageMode", function(o) {
              return I.ensureCatalog("pageMode");
            }), p.on("GetViewerPreferences", function(o) {
              return I.ensureCatalog("viewerPreferences");
            }), p.on("GetOpenAction", function(o) {
              return I.ensureCatalog("openAction");
            }), p.on("GetAttachments", function(o) {
              return I.ensureCatalog("attachments");
            }), p.on("GetDocJSActions", function(o) {
              return I.ensureCatalog("jsActions");
            }), p.on("GetPageJSActions", function({
              pageIndex: o
            }) {
              return I.getPage(o).then(function(m) {
                return I.ensure(m, "jsActions");
              });
            }), p.on("GetOutline", function(o) {
              return I.ensureCatalog("documentOutline");
            }), p.on("GetOptionalContentConfig", function(o) {
              return I.ensureCatalog("optionalContentConfig");
            }), p.on("GetPermissions", function(o) {
              return I.ensureCatalog("permissions");
            }), p.on("GetMetadata", function(o) {
              return Promise.all([I.ensureDoc("documentInfo"), I.ensureCatalog("metadata")]);
            }), p.on("GetMarkInfo", function(o) {
              return I.ensureCatalog("markInfo");
            }), p.on("GetData", function(o) {
              return I.requestLoadedStream().then(function(m) {
                return m.bytes;
              });
            }), p.on("GetAnnotations", function({
              pageIndex: o,
              intent: m
            }) {
              return I.getPage(o).then(function(s) {
                const r = new g(`GetAnnotations: page ${o}`);
                return B(r), s.getAnnotationsData(p, r, m).then((y) => (T(r), y), (y) => {
                  throw T(r), y;
                });
              });
            }), p.on("GetFieldObjects", function(o) {
              return I.ensureDoc("fieldObjects");
            }), p.on("HasJSActions", function(o) {
              return I.ensureDoc("hasJSActions");
            }), p.on("GetCalculationOrderIds", function(o) {
              return I.ensureDoc("calculationOrderIds");
            }), p.on("SaveDocument", async function({
              isPureXfa: o,
              numPages: m,
              annotationStorage: s,
              filename: r
            }) {
              const y = [I.requestLoadedStream(), I.ensureCatalog("acroForm"), I.ensureCatalog("acroFormRef"), I.ensureDoc("startXRef"), I.ensureDoc("xref"), I.ensureDoc("linearization"), I.ensureCatalog("structTreeRoot")], M = [], $ = o ? null : (0, F.getNewAnnotationsMap)(s), [G, ce, q, re, Z, te, L] = await Promise.all(y), X = Z.trailer.getRaw("Root") || null;
              let J;
              if ($) {
                L ? await L.canUpdateStructTree({
                  pdfManager: I,
                  newAnnotationsByPage: $
                }) && (J = L) : await v.StructTreeRoot.canCreateStructureTree({
                  catalogRef: X,
                  pdfManager: I,
                  newAnnotationsByPage: $
                }) && (J = null);
                const oe = t.AnnotationFactory.generateImages(s.values(), Z, I.evaluatorOptions.isOffscreenCanvasSupported), ue = J === void 0 ? M : [];
                for (const [pe, ve] of $)
                  ue.push(I.getPage(pe).then((Ce) => {
                    const Fe = new g(`Save (editor): page ${pe}`);
                    return Ce.saveNewAnnotations(p, Fe, ve, oe).finally(function() {
                      T(Fe);
                    });
                  }));
                J === null ? M.push(Promise.all(ue).then(async (pe) => (await v.StructTreeRoot.createStructureTree({
                  newAnnotationsByPage: $,
                  xref: Z,
                  catalogRef: X,
                  pdfManager: I,
                  newRefs: pe
                }), pe))) : J && M.push(Promise.all(ue).then(async (pe) => (await J.updateStructureTree({
                  newAnnotationsByPage: $,
                  pdfManager: I,
                  newRefs: pe
                }), pe)));
              }
              if (o)
                M.push(I.serializeXfaData(s));
              else
                for (let oe = 0; oe < m; oe++)
                  M.push(I.getPage(oe).then(function(ue) {
                    const pe = new g(`Save: page ${oe}`);
                    return ue.save(p, pe, s).finally(function() {
                      T(pe);
                    });
                  }));
              const Y = await Promise.all(M);
              let ae = [], se = null;
              if (o) {
                if (se = Y[0], !se)
                  return G.bytes;
              } else if (ae = Y.flat(2), ae.length === 0)
                return G.bytes;
              const Q = q && ce instanceof C.Dict && ae.some((oe) => oe.needAppearances), z = ce instanceof C.Dict && ce.get("XFA") || null;
              let ie = null, ne = !1;
              if (Array.isArray(z)) {
                for (let oe = 0, ue = z.length; oe < ue; oe += 2)
                  z[oe] === "datasets" && (ie = z[oe + 1], ne = !0);
                ie === null && (ie = Z.getNewTemporaryRef());
              } else
                z && (0, n.warn)("Unsupported XFA type.");
              let W = /* @__PURE__ */ Object.create(null);
              if (Z.trailer) {
                const oe = /* @__PURE__ */ Object.create(null), ue = Z.trailer.get("Info") || null;
                ue instanceof C.Dict && ue.forEach((pe, ve) => {
                  typeof ve == "string" && (oe[pe] = (0, n.stringToPDFString)(ve));
                }), W = {
                  rootRef: X,
                  encryptRef: Z.trailer.getRaw("Encrypt") || null,
                  newRef: Z.getNewTemporaryRef(),
                  infoRef: Z.trailer.getRaw("Info") || null,
                  info: oe,
                  fileIds: Z.trailer.get("ID") || null,
                  startXRef: te ? re : Z.lastXRefStreamPos ?? re,
                  filename: r
                };
              }
              return (0, j.incrementalUpdate)({
                originalData: G.bytes,
                xrefInfo: W,
                newRefs: ae,
                xref: Z,
                hasXfa: !!z,
                xfaDatasetsRef: ie,
                hasXfaDatasetsEntry: ne,
                needAppearances: Q,
                acroFormRef: q,
                acroForm: ce,
                xfaData: se
              }).finally(() => {
                Z.resetNewTemporaryRef();
              });
            }), p.on("GetOperatorList", function(o, m) {
              const s = o.pageIndex;
              I.getPage(s).then(function(r) {
                const y = new g(`GetOperatorList: page ${s}`);
                B(y);
                const M = x >= n.VerbosityLevel.INFOS ? Date.now() : 0;
                r.getOperatorList({
                  handler: p,
                  sink: m,
                  task: y,
                  intent: o.intent,
                  cacheKey: o.cacheKey,
                  annotationStorage: o.annotationStorage
                }).then(function($) {
                  T(y), M && (0, n.info)(`page=${s + 1} - getOperatorList: time=${Date.now() - M}ms, len=${$.length}`), m.close();
                }, function($) {
                  T(y), !y.terminated && m.error($);
                });
              });
            }), p.on("GetTextContent", function(o, m) {
              const {
                pageIndex: s,
                includeMarkedContent: r,
                disableNormalization: y
              } = o;
              I.getPage(s).then(function(M) {
                const $ = new g("GetTextContent: page " + s);
                B($);
                const G = x >= n.VerbosityLevel.INFOS ? Date.now() : 0;
                M.extractTextContent({
                  handler: p,
                  task: $,
                  sink: m,
                  includeMarkedContent: r,
                  disableNormalization: y
                }).then(function() {
                  T($), G && (0, n.info)(`page=${s + 1} - getTextContent: time=${Date.now() - G}ms`), m.close();
                }, function(ce) {
                  T($), !$.terminated && m.error(ce);
                });
              });
            }), p.on("GetStructTree", function(o) {
              return I.getPage(o.pageIndex).then(function(m) {
                return I.ensure(m, "getStructTree");
              });
            }), p.on("FontFallback", function(o) {
              return I.fontFallback(o.id, p);
            }), p.on("Cleanup", function(o) {
              return I.cleanup(!0);
            }), p.on("Terminate", function(o) {
              E = !0;
              const m = [];
              if (I) {
                I.terminate(new n.AbortException("Worker was terminated."));
                const s = I.cleanup();
                m.push(s), I = null;
              } else
                (0, l.clearGlobalCaches)();
              k && k(new n.AbortException("Worker was terminated."));
              for (const s of H)
                m.push(s.finished), s.terminate();
              return Promise.all(m).then(function() {
                p.destroy(), p = null;
              });
            }), p.on("Ready", function(o) {
              _(d), d = null;
            }), u;
          }
          static initializeFromPort(d) {
            const A = new U.MessageHandler("worker", "main", d);
            b.setup(A, d), A.send("ready", null);
          }
        }
        w.WorkerMessageHandler = b;
        function i(P) {
          return typeof P.postMessage == "function" && "onmessage" in P;
        }
        typeof window > "u" && !n.isNodeJS && typeof self < "u" && i(self) && b.initializeFromPort(self);
      },
      /* 2 */
      /***/
      (fe, w) => {
        var _e;
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.VerbosityLevel = w.Util = w.UnknownErrorException = w.UnexpectedResponseException = w.TextRenderingMode = w.RenderingIntentFlag = w.PromiseCapability = w.PermissionFlag = w.PasswordResponses = w.PasswordException = w.PageActionEventType = w.OPS = w.MissingPDFException = w.MAX_IMAGE_SIZE_TO_CACHE = w.LINE_FACTOR = w.LINE_DESCENT_FACTOR = w.InvalidPDFException = w.ImageKind = w.IDENTITY_MATRIX = w.FormatError = w.FeatureTest = w.FONT_IDENTITY_MATRIX = w.DocumentActionEventType = w.CMapCompressionType = w.BaseException = w.BASELINE_FACTOR = w.AnnotationType = w.AnnotationReplyType = w.AnnotationPrefix = w.AnnotationMode = w.AnnotationFlag = w.AnnotationFieldFlag = w.AnnotationEditorType = w.AnnotationEditorPrefix = w.AnnotationEditorParamsType = w.AnnotationBorderStyleType = w.AnnotationActionEventType = w.AbortException = void 0, w.assert = _, w.bytesToString = Z, w.createValidAbsoluteUrl = m, w.getModificationDate = ve, w.getUuid = me, w.getVerbosityLevel = B, w.info = T, w.isArrayBuffer = ue, w.isArrayEqual = pe, w.isNodeJS = void 0, w.normalizeUnicode = be, w.objectFromMap = J, w.objectSize = X, w.setVerbosityLevel = S, w.shadow = s, w.string32 = L, w.stringToBytes = te, w.stringToPDFString = ne, w.stringToUTF8String = W, w.unreachable = K, w.utf8StringToString = oe, w.warn = D;
        const V = typeof process == "object" && process + "" == "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
        w.isNodeJS = V;
        const n = [1, 0, 0, 1, 0, 0];
        w.IDENTITY_MATRIX = n;
        const F = [1e-3, 0, 0, 1e-3, 0, 0];
        w.FONT_IDENTITY_MATRIX = F;
        const C = 1e7;
        w.MAX_IMAGE_SIZE_TO_CACHE = C;
        const e = 1.35;
        w.LINE_FACTOR = e;
        const t = 0.35;
        w.LINE_DESCENT_FACTOR = t;
        const l = t / e;
        w.BASELINE_FACTOR = l;
        const j = {
          ANY: 1,
          DISPLAY: 2,
          PRINT: 4,
          SAVE: 8,
          ANNOTATIONS_FORMS: 16,
          ANNOTATIONS_STORAGE: 32,
          ANNOTATIONS_DISABLE: 64,
          OPLIST: 256
        };
        w.RenderingIntentFlag = j;
        const U = {
          DISABLE: 0,
          ENABLE: 1,
          ENABLE_FORMS: 2,
          ENABLE_STORAGE: 3
        };
        w.AnnotationMode = U;
        const O = "pdfjs_internal_editor_";
        w.AnnotationEditorPrefix = O;
        const v = {
          DISABLE: -1,
          NONE: 0,
          FREETEXT: 3,
          STAMP: 13,
          INK: 15
        };
        w.AnnotationEditorType = v;
        const g = {
          RESIZE: 1,
          CREATE: 2,
          FREETEXT_SIZE: 11,
          FREETEXT_COLOR: 12,
          FREETEXT_OPACITY: 13,
          INK_COLOR: 21,
          INK_THICKNESS: 22,
          INK_OPACITY: 23
        };
        w.AnnotationEditorParamsType = g;
        const b = {
          PRINT: 4,
          MODIFY_CONTENTS: 8,
          COPY: 16,
          MODIFY_ANNOTATIONS: 32,
          FILL_INTERACTIVE_FORMS: 256,
          COPY_FOR_ACCESSIBILITY: 512,
          ASSEMBLE: 1024,
          PRINT_HIGH_QUALITY: 2048
        };
        w.PermissionFlag = b;
        const i = {
          FILL: 0,
          STROKE: 1,
          FILL_STROKE: 2,
          INVISIBLE: 3,
          FILL_ADD_TO_PATH: 4,
          STROKE_ADD_TO_PATH: 5,
          FILL_STROKE_ADD_TO_PATH: 6,
          ADD_TO_PATH: 7,
          FILL_STROKE_MASK: 3,
          ADD_TO_PATH_FLAG: 4
        };
        w.TextRenderingMode = i;
        const P = {
          GRAYSCALE_1BPP: 1,
          RGB_24BPP: 2,
          RGBA_32BPP: 3
        };
        w.ImageKind = P;
        const d = {
          TEXT: 1,
          LINK: 2,
          FREETEXT: 3,
          LINE: 4,
          SQUARE: 5,
          CIRCLE: 6,
          POLYGON: 7,
          POLYLINE: 8,
          HIGHLIGHT: 9,
          UNDERLINE: 10,
          SQUIGGLY: 11,
          STRIKEOUT: 12,
          STAMP: 13,
          CARET: 14,
          INK: 15,
          POPUP: 16,
          FILEATTACHMENT: 17,
          SOUND: 18,
          MOVIE: 19,
          WIDGET: 20,
          SCREEN: 21,
          PRINTERMARK: 22,
          TRAPNET: 23,
          WATERMARK: 24,
          THREED: 25,
          REDACT: 26
        };
        w.AnnotationType = d;
        const A = {
          GROUP: "Group",
          REPLY: "R"
        };
        w.AnnotationReplyType = A;
        const I = {
          INVISIBLE: 1,
          HIDDEN: 2,
          PRINT: 4,
          NOZOOM: 8,
          NOROTATE: 16,
          NOVIEW: 32,
          READONLY: 64,
          LOCKED: 128,
          TOGGLENOVIEW: 256,
          LOCKEDCONTENTS: 512
        };
        w.AnnotationFlag = I;
        const E = {
          READONLY: 1,
          REQUIRED: 2,
          NOEXPORT: 4,
          MULTILINE: 4096,
          PASSWORD: 8192,
          NOTOGGLETOOFF: 16384,
          RADIO: 32768,
          PUSHBUTTON: 65536,
          COMBO: 131072,
          EDIT: 262144,
          SORT: 524288,
          FILESELECT: 1048576,
          MULTISELECT: 2097152,
          DONOTSPELLCHECK: 4194304,
          DONOTSCROLL: 8388608,
          COMB: 16777216,
          RICHTEXT: 33554432,
          RADIOSINUNISON: 33554432,
          COMMITONSELCHANGE: 67108864
        };
        w.AnnotationFieldFlag = E;
        const k = {
          SOLID: 1,
          DASHED: 2,
          BEVELED: 3,
          INSET: 4,
          UNDERLINE: 5
        };
        w.AnnotationBorderStyleType = k;
        const H = {
          E: "Mouse Enter",
          X: "Mouse Exit",
          D: "Mouse Down",
          U: "Mouse Up",
          Fo: "Focus",
          Bl: "Blur",
          PO: "PageOpen",
          PC: "PageClose",
          PV: "PageVisible",
          PI: "PageInvisible",
          K: "Keystroke",
          F: "Format",
          V: "Validate",
          C: "Calculate"
        };
        w.AnnotationActionEventType = H;
        const x = {
          WC: "WillClose",
          WS: "WillSave",
          DS: "DidSave",
          WP: "WillPrint",
          DP: "DidPrint"
        };
        w.DocumentActionEventType = x;
        const R = {
          O: "PageOpen",
          C: "PageClose"
        };
        w.PageActionEventType = R;
        const f = {
          ERRORS: 0,
          WARNINGS: 1,
          INFOS: 5
        };
        w.VerbosityLevel = f;
        const c = {
          NONE: 0,
          BINARY: 1
        };
        w.CMapCompressionType = c;
        const N = {
          dependency: 1,
          setLineWidth: 2,
          setLineCap: 3,
          setLineJoin: 4,
          setMiterLimit: 5,
          setDash: 6,
          setRenderingIntent: 7,
          setFlatness: 8,
          setGState: 9,
          save: 10,
          restore: 11,
          transform: 12,
          moveTo: 13,
          lineTo: 14,
          curveTo: 15,
          curveTo2: 16,
          curveTo3: 17,
          closePath: 18,
          rectangle: 19,
          stroke: 20,
          closeStroke: 21,
          fill: 22,
          eoFill: 23,
          fillStroke: 24,
          eoFillStroke: 25,
          closeFillStroke: 26,
          closeEOFillStroke: 27,
          endPath: 28,
          clip: 29,
          eoClip: 30,
          beginText: 31,
          endText: 32,
          setCharSpacing: 33,
          setWordSpacing: 34,
          setHScale: 35,
          setLeading: 36,
          setFont: 37,
          setTextRenderingMode: 38,
          setTextRise: 39,
          moveText: 40,
          setLeadingMoveText: 41,
          setTextMatrix: 42,
          nextLine: 43,
          showText: 44,
          showSpacedText: 45,
          nextLineShowText: 46,
          nextLineSetSpacingShowText: 47,
          setCharWidth: 48,
          setCharWidthAndBounds: 49,
          setStrokeColorSpace: 50,
          setFillColorSpace: 51,
          setStrokeColor: 52,
          setStrokeColorN: 53,
          setFillColor: 54,
          setFillColorN: 55,
          setStrokeGray: 56,
          setFillGray: 57,
          setStrokeRGBColor: 58,
          setFillRGBColor: 59,
          setStrokeCMYKColor: 60,
          setFillCMYKColor: 61,
          shadingFill: 62,
          beginInlineImage: 63,
          beginImageData: 64,
          endInlineImage: 65,
          paintXObject: 66,
          markPoint: 67,
          markPointProps: 68,
          beginMarkedContent: 69,
          beginMarkedContentProps: 70,
          endMarkedContent: 71,
          beginCompat: 72,
          endCompat: 73,
          paintFormXObjectBegin: 74,
          paintFormXObjectEnd: 75,
          beginGroup: 76,
          endGroup: 77,
          beginAnnotation: 80,
          endAnnotation: 81,
          paintImageMaskXObject: 83,
          paintImageMaskXObjectGroup: 84,
          paintImageXObject: 85,
          paintInlineImageXObject: 86,
          paintInlineImageXObjectGroup: 87,
          paintImageXObjectRepeat: 88,
          paintImageMaskXObjectRepeat: 89,
          paintSolidColorImageMask: 90,
          constructPath: 91
        };
        w.OPS = N;
        const u = {
          NEED_PASSWORD: 1,
          INCORRECT_PASSWORD: 2
        };
        w.PasswordResponses = u;
        let p = f.WARNINGS;
        function S(Se) {
          Number.isInteger(Se) && (p = Se);
        }
        function B() {
          return p;
        }
        function T(Se) {
          p >= f.INFOS && console.log(`Info: ${Se}`);
        }
        function D(Se) {
          p >= f.WARNINGS && console.log(`Warning: ${Se}`);
        }
        function K(Se) {
          throw new Error(Se);
        }
        function _(Se, Ae) {
          Se || K(Ae);
        }
        function o(Se) {
          switch (Se == null ? void 0 : Se.protocol) {
            case "http:":
            case "https:":
            case "ftp:":
            case "mailto:":
            case "tel:":
              return !0;
            default:
              return !1;
          }
        }
        function m(Se, Ae = null, Te = null) {
          if (!Se)
            return null;
          try {
            if (Te && typeof Se == "string") {
              if (Te.addDefaultProtocol && Se.startsWith("www.")) {
                const Ee = Se.match(/\./g);
                (Ee == null ? void 0 : Ee.length) >= 2 && (Se = `http://${Se}`);
              }
              if (Te.tryConvertEncoding)
                try {
                  Se = W(Se);
                } catch {
                }
            }
            const ke = Ae ? new URL(Se, Ae) : new URL(Se);
            if (o(ke))
              return ke;
          } catch {
          }
          return null;
        }
        function s(Se, Ae, Te, ke = !1) {
          return Object.defineProperty(Se, Ae, {
            value: Te,
            enumerable: !ke,
            configurable: !0,
            writable: !1
          }), Te;
        }
        const r = function() {
          function Ae(Te, ke) {
            this.constructor === Ae && K("Cannot initialize BaseException."), this.message = Te, this.name = ke;
          }
          return Ae.prototype = new Error(), Ae.constructor = Ae, Ae;
        }();
        w.BaseException = r;
        class y extends r {
          constructor(Ae, Te) {
            super(Ae, "PasswordException"), this.code = Te;
          }
        }
        w.PasswordException = y;
        class M extends r {
          constructor(Ae, Te) {
            super(Ae, "UnknownErrorException"), this.details = Te;
          }
        }
        w.UnknownErrorException = M;
        class $ extends r {
          constructor(Ae) {
            super(Ae, "InvalidPDFException");
          }
        }
        w.InvalidPDFException = $;
        class G extends r {
          constructor(Ae) {
            super(Ae, "MissingPDFException");
          }
        }
        w.MissingPDFException = G;
        class ce extends r {
          constructor(Ae, Te) {
            super(Ae, "UnexpectedResponseException"), this.status = Te;
          }
        }
        w.UnexpectedResponseException = ce;
        class q extends r {
          constructor(Ae) {
            super(Ae, "FormatError");
          }
        }
        w.FormatError = q;
        class re extends r {
          constructor(Ae) {
            super(Ae, "AbortException");
          }
        }
        w.AbortException = re;
        function Z(Se) {
          (typeof Se != "object" || (Se == null ? void 0 : Se.length) === void 0) && K("Invalid argument for bytesToString");
          const Ae = Se.length, Te = 8192;
          if (Ae < Te)
            return String.fromCharCode.apply(null, Se);
          const ke = [];
          for (let Ee = 0; Ee < Ae; Ee += Te) {
            const Ve = Math.min(Ee + Te, Ae), je = Se.subarray(Ee, Ve);
            ke.push(String.fromCharCode.apply(null, je));
          }
          return ke.join("");
        }
        function te(Se) {
          typeof Se != "string" && K("Invalid argument for stringToBytes");
          const Ae = Se.length, Te = new Uint8Array(Ae);
          for (let ke = 0; ke < Ae; ++ke)
            Te[ke] = Se.charCodeAt(ke) & 255;
          return Te;
        }
        function L(Se) {
          return String.fromCharCode(Se >> 24 & 255, Se >> 16 & 255, Se >> 8 & 255, Se & 255);
        }
        function X(Se) {
          return Object.keys(Se).length;
        }
        function J(Se) {
          const Ae = /* @__PURE__ */ Object.create(null);
          for (const [Te, ke] of Se)
            Ae[Te] = ke;
          return Ae;
        }
        function Y() {
          const Se = new Uint8Array(4);
          return Se[0] = 1, new Uint32Array(Se.buffer, 0, 1)[0] === 1;
        }
        function ae() {
          try {
            return new Function(""), !0;
          } catch {
            return !1;
          }
        }
        class se {
          static get isLittleEndian() {
            return s(this, "isLittleEndian", Y());
          }
          static get isEvalSupported() {
            return s(this, "isEvalSupported", ae());
          }
          static get isOffscreenCanvasSupported() {
            return s(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas < "u");
          }
          static get platform() {
            return typeof navigator > "u" ? s(this, "platform", {
              isWin: !1,
              isMac: !1
            }) : s(this, "platform", {
              isWin: navigator.platform.includes("Win"),
              isMac: navigator.platform.includes("Mac")
            });
          }
          static get isCSSRoundSupported() {
            var Ae, Te;
            return s(this, "isCSSRoundSupported", (Te = (Ae = globalThis.CSS) == null ? void 0 : Ae.supports) == null ? void 0 : Te.call(Ae, "width: round(1.5px, 1px)"));
          }
        }
        w.FeatureTest = se;
        const Q = [...Array(256).keys()].map((Se) => Se.toString(16).padStart(2, "0"));
        class z {
          static makeHexColor(Ae, Te, ke) {
            return `#${Q[Ae]}${Q[Te]}${Q[ke]}`;
          }
          static scaleMinMax(Ae, Te) {
            let ke;
            Ae[0] ? (Ae[0] < 0 && (ke = Te[0], Te[0] = Te[1], Te[1] = ke), Te[0] *= Ae[0], Te[1] *= Ae[0], Ae[3] < 0 && (ke = Te[2], Te[2] = Te[3], Te[3] = ke), Te[2] *= Ae[3], Te[3] *= Ae[3]) : (ke = Te[0], Te[0] = Te[2], Te[2] = ke, ke = Te[1], Te[1] = Te[3], Te[3] = ke, Ae[1] < 0 && (ke = Te[2], Te[2] = Te[3], Te[3] = ke), Te[2] *= Ae[1], Te[3] *= Ae[1], Ae[2] < 0 && (ke = Te[0], Te[0] = Te[1], Te[1] = ke), Te[0] *= Ae[2], Te[1] *= Ae[2]), Te[0] += Ae[4], Te[1] += Ae[4], Te[2] += Ae[5], Te[3] += Ae[5];
          }
          static transform(Ae, Te) {
            return [Ae[0] * Te[0] + Ae[2] * Te[1], Ae[1] * Te[0] + Ae[3] * Te[1], Ae[0] * Te[2] + Ae[2] * Te[3], Ae[1] * Te[2] + Ae[3] * Te[3], Ae[0] * Te[4] + Ae[2] * Te[5] + Ae[4], Ae[1] * Te[4] + Ae[3] * Te[5] + Ae[5]];
          }
          static applyTransform(Ae, Te) {
            const ke = Ae[0] * Te[0] + Ae[1] * Te[2] + Te[4], Ee = Ae[0] * Te[1] + Ae[1] * Te[3] + Te[5];
            return [ke, Ee];
          }
          static applyInverseTransform(Ae, Te) {
            const ke = Te[0] * Te[3] - Te[1] * Te[2], Ee = (Ae[0] * Te[3] - Ae[1] * Te[2] + Te[2] * Te[5] - Te[4] * Te[3]) / ke, Ve = (-Ae[0] * Te[1] + Ae[1] * Te[0] + Te[4] * Te[1] - Te[5] * Te[0]) / ke;
            return [Ee, Ve];
          }
          static getAxialAlignedBoundingBox(Ae, Te) {
            const ke = this.applyTransform(Ae, Te), Ee = this.applyTransform(Ae.slice(2, 4), Te), Ve = this.applyTransform([Ae[0], Ae[3]], Te), je = this.applyTransform([Ae[2], Ae[1]], Te);
            return [Math.min(ke[0], Ee[0], Ve[0], je[0]), Math.min(ke[1], Ee[1], Ve[1], je[1]), Math.max(ke[0], Ee[0], Ve[0], je[0]), Math.max(ke[1], Ee[1], Ve[1], je[1])];
          }
          static inverseTransform(Ae) {
            const Te = Ae[0] * Ae[3] - Ae[1] * Ae[2];
            return [Ae[3] / Te, -Ae[1] / Te, -Ae[2] / Te, Ae[0] / Te, (Ae[2] * Ae[5] - Ae[4] * Ae[3]) / Te, (Ae[4] * Ae[1] - Ae[5] * Ae[0]) / Te];
          }
          static singularValueDecompose2dScale(Ae) {
            const Te = [Ae[0], Ae[2], Ae[1], Ae[3]], ke = Ae[0] * Te[0] + Ae[1] * Te[2], Ee = Ae[0] * Te[1] + Ae[1] * Te[3], Ve = Ae[2] * Te[0] + Ae[3] * Te[2], je = Ae[2] * Te[1] + Ae[3] * Te[3], at = (ke + je) / 2, $e = Math.sqrt((ke + je) ** 2 - 4 * (ke * je - Ve * Ee)) / 2, ct = at + $e || 1, ze = at - $e || 1;
            return [Math.sqrt(ct), Math.sqrt(ze)];
          }
          static normalizeRect(Ae) {
            const Te = Ae.slice(0);
            return Ae[0] > Ae[2] && (Te[0] = Ae[2], Te[2] = Ae[0]), Ae[1] > Ae[3] && (Te[1] = Ae[3], Te[3] = Ae[1]), Te;
          }
          static intersect(Ae, Te) {
            const ke = Math.max(Math.min(Ae[0], Ae[2]), Math.min(Te[0], Te[2])), Ee = Math.min(Math.max(Ae[0], Ae[2]), Math.max(Te[0], Te[2]));
            if (ke > Ee)
              return null;
            const Ve = Math.max(Math.min(Ae[1], Ae[3]), Math.min(Te[1], Te[3])), je = Math.min(Math.max(Ae[1], Ae[3]), Math.max(Te[1], Te[3]));
            return Ve > je ? null : [ke, Ve, Ee, je];
          }
          static bezierBoundingBox(Ae, Te, ke, Ee, Ve, je, at, $e) {
            const ct = [], ze = [[], []];
            let Ye, Qe, Oe, he, ye, Ie, Le, Be;
            for (let tt = 0; tt < 2; ++tt) {
              if (tt === 0 ? (Qe = 6 * Ae - 12 * ke + 6 * Ve, Ye = -3 * Ae + 9 * ke - 9 * Ve + 3 * at, Oe = 3 * ke - 3 * Ae) : (Qe = 6 * Te - 12 * Ee + 6 * je, Ye = -3 * Te + 9 * Ee - 9 * je + 3 * $e, Oe = 3 * Ee - 3 * Te), Math.abs(Ye) < 1e-12) {
                if (Math.abs(Qe) < 1e-12)
                  continue;
                he = -Oe / Qe, 0 < he && he < 1 && ct.push(he);
                continue;
              }
              Le = Qe * Qe - 4 * Oe * Ye, Be = Math.sqrt(Le), !(Le < 0) && (ye = (-Qe + Be) / (2 * Ye), 0 < ye && ye < 1 && ct.push(ye), Ie = (-Qe - Be) / (2 * Ye), 0 < Ie && Ie < 1 && ct.push(Ie));
            }
            let Ne = ct.length, Ue;
            const qe = Ne;
            for (; Ne--; )
              he = ct[Ne], Ue = 1 - he, ze[0][Ne] = Ue * Ue * Ue * Ae + 3 * Ue * Ue * he * ke + 3 * Ue * he * he * Ve + he * he * he * at, ze[1][Ne] = Ue * Ue * Ue * Te + 3 * Ue * Ue * he * Ee + 3 * Ue * he * he * je + he * he * he * $e;
            return ze[0][qe] = Ae, ze[1][qe] = Te, ze[0][qe + 1] = at, ze[1][qe + 1] = $e, ze[0].length = ze[1].length = qe + 2, [Math.min(...ze[0]), Math.min(...ze[1]), Math.max(...ze[0]), Math.max(...ze[1])];
          }
        }
        w.Util = z;
        const ie = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
        function ne(Se) {
          if (Se[0] >= "ï") {
            let Te;
            if (Se[0] === "þ" && Se[1] === "ÿ" ? Te = "utf-16be" : Se[0] === "ÿ" && Se[1] === "þ" ? Te = "utf-16le" : Se[0] === "ï" && Se[1] === "»" && Se[2] === "¿" && (Te = "utf-8"), Te)
              try {
                const ke = new TextDecoder(Te, {
                  fatal: !0
                }), Ee = te(Se);
                return ke.decode(Ee);
              } catch (ke) {
                D(`stringToPDFString: "${ke}".`);
              }
          }
          const Ae = [];
          for (let Te = 0, ke = Se.length; Te < ke; Te++) {
            const Ee = ie[Se.charCodeAt(Te)];
            Ae.push(Ee ? String.fromCharCode(Ee) : Se.charAt(Te));
          }
          return Ae.join("");
        }
        function W(Se) {
          return decodeURIComponent(escape(Se));
        }
        function oe(Se) {
          return unescape(encodeURIComponent(Se));
        }
        function ue(Se) {
          return typeof Se == "object" && (Se == null ? void 0 : Se.byteLength) !== void 0;
        }
        function pe(Se, Ae) {
          if (Se.length !== Ae.length)
            return !1;
          for (let Te = 0, ke = Se.length; Te < ke; Te++)
            if (Se[Te] !== Ae[Te])
              return !1;
          return !0;
        }
        function ve(Se = /* @__PURE__ */ new Date()) {
          return [Se.getUTCFullYear().toString(), (Se.getUTCMonth() + 1).toString().padStart(2, "0"), Se.getUTCDate().toString().padStart(2, "0"), Se.getUTCHours().toString().padStart(2, "0"), Se.getUTCMinutes().toString().padStart(2, "0"), Se.getUTCSeconds().toString().padStart(2, "0")].join("");
        }
        class Ce {
          constructor() {
            Me(this, _e, !1);
            this.promise = new Promise((Ae, Te) => {
              this.resolve = (ke) => {
                Xe(this, _e, !0), Ae(ke);
              }, this.reject = (ke) => {
                Xe(this, _e, !0), Te(ke);
              };
            });
          }
          get settled() {
            return le(this, _e);
          }
        }
        _e = new WeakMap(), w.PromiseCapability = Ce;
        let Fe = null, Pe = null;
        function be(Se) {
          return Fe || (Fe = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu, Pe = /* @__PURE__ */ new Map([["ﬅ", "ſt"]])), Se.replaceAll(Fe, (Ae, Te, ke) => Te ? Te.normalize("NFKC") : Pe.get(ke));
        }
        function me() {
          if (typeof crypto < "u" && typeof (crypto == null ? void 0 : crypto.randomUUID) == "function")
            return crypto.randomUUID();
          const Se = new Uint8Array(32);
          if (typeof crypto < "u" && typeof (crypto == null ? void 0 : crypto.getRandomValues) == "function")
            crypto.getRandomValues(Se);
          else
            for (let Ae = 0; Ae < 32; Ae++)
              Se[Ae] = Math.floor(Math.random() * 255);
          return Z(Se);
        }
        const we = "pdfjs_internal_id_";
        w.AnnotationPrefix = we;
      },
      /* 3 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.XRefParseException = w.XRefEntryException = w.ParserEOFException = w.PDF_VERSION_REGEXP = w.MissingDataException = void 0, w.arrayBuffersToBytes = v, w.collectActions = f, w.encodeToXmlString = N, w.escapePDFName = H, w.escapeString = x, w.getInheritableProperty = g, w.getLookupTableFactory = t, w.getNewAnnotationsMap = T, w.getRotationMatrix = o, w.isAscii = D, w.isWhiteSpace = E, w.log2 = P, w.numberToString = B, w.parseXFAPath = k, w.readInt8 = d, w.readUint16 = A, w.readUint32 = I, w.recoverJsURL = S, w.stringToUTF16HexString = K, w.stringToUTF16String = _, w.toRomanNumerals = i, w.validateCSSFont = p, w.validateFontName = u;
        var n = V(2), F = V(4), C = V(5);
        const e = /^[1-9]\.\d$/;
        w.PDF_VERSION_REGEXP = e;
        function t(m) {
          let s;
          return function() {
            return m && (s = /* @__PURE__ */ Object.create(null), m(s), m = null), s;
          };
        }
        class l extends n.BaseException {
          constructor(s, r) {
            super(`Missing data [${s}, ${r})`, "MissingDataException"), this.begin = s, this.end = r;
          }
        }
        w.MissingDataException = l;
        class j extends n.BaseException {
          constructor(s) {
            super(s, "ParserEOFException");
          }
        }
        w.ParserEOFException = j;
        class U extends n.BaseException {
          constructor(s) {
            super(s, "XRefEntryException");
          }
        }
        w.XRefEntryException = U;
        class O extends n.BaseException {
          constructor(s) {
            super(s, "XRefParseException");
          }
        }
        w.XRefParseException = O;
        function v(m) {
          const s = m.length;
          if (s === 0)
            return new Uint8Array(0);
          if (s === 1)
            return new Uint8Array(m[0]);
          let r = 0;
          for (let $ = 0; $ < s; $++)
            r += m[$].byteLength;
          const y = new Uint8Array(r);
          let M = 0;
          for (let $ = 0; $ < s; $++) {
            const G = new Uint8Array(m[$]);
            y.set(G, M), M += G.byteLength;
          }
          return y;
        }
        function g({
          dict: m,
          key: s,
          getArray: r = !1,
          stopWhenFound: y = !0
        }) {
          let M;
          const $ = new F.RefSet();
          for (; m instanceof F.Dict && !(m.objId && $.has(m.objId)); ) {
            m.objId && $.put(m.objId);
            const G = r ? m.getArray(s) : m.get(s);
            if (G !== void 0) {
              if (y)
                return G;
              (M || (M = [])).push(G);
            }
            m = m.get("Parent");
          }
          return M;
        }
        const b = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
        function i(m, s = !1) {
          (0, n.assert)(Number.isInteger(m) && m > 0, "The number should be a positive integer.");
          const r = [];
          let y;
          for (; m >= 1e3; )
            m -= 1e3, r.push("M");
          y = m / 100 | 0, m %= 100, r.push(b[y]), y = m / 10 | 0, m %= 10, r.push(b[10 + y]), r.push(b[20 + m]);
          const M = r.join("");
          return s ? M.toLowerCase() : M;
        }
        function P(m) {
          return m <= 0 ? 0 : Math.ceil(Math.log2(m));
        }
        function d(m, s) {
          return m[s] << 24 >> 24;
        }
        function A(m, s) {
          return m[s] << 8 | m[s + 1];
        }
        function I(m, s) {
          return (m[s] << 24 | m[s + 1] << 16 | m[s + 2] << 8 | m[s + 3]) >>> 0;
        }
        function E(m) {
          return m === 32 || m === 9 || m === 13 || m === 10;
        }
        function k(m) {
          const s = /(.+)\[(\d+)\]$/;
          return m.split(".").map((r) => {
            const y = r.match(s);
            return y ? {
              name: y[1],
              pos: parseInt(y[2], 10)
            } : {
              name: r,
              pos: 0
            };
          });
        }
        function H(m) {
          const s = [];
          let r = 0;
          for (let y = 0, M = m.length; y < M; y++) {
            const $ = m.charCodeAt(y);
            ($ < 33 || $ > 126 || $ === 35 || $ === 40 || $ === 41 || $ === 60 || $ === 62 || $ === 91 || $ === 93 || $ === 123 || $ === 125 || $ === 47 || $ === 37) && (r < y && s.push(m.substring(r, y)), s.push(`#${$.toString(16)}`), r = y + 1);
          }
          return s.length === 0 ? m : (r < m.length && s.push(m.substring(r, m.length)), s.join(""));
        }
        function x(m) {
          return m.replaceAll(/([()\\\n\r])/g, (s) => s === `
` ? "\\n" : s === "\r" ? "\\r" : `\\${s}`);
        }
        function R(m, s, r, y) {
          if (!m)
            return;
          let M = null;
          if (m instanceof F.Ref) {
            if (y.has(m))
              return;
            M = m, y.put(M), m = s.fetch(m);
          }
          if (Array.isArray(m))
            for (const $ of m)
              R($, s, r, y);
          else if (m instanceof F.Dict) {
            if ((0, F.isName)(m.get("S"), "JavaScript")) {
              const $ = m.get("JS");
              let G;
              $ instanceof C.BaseStream ? G = $.getString() : typeof $ == "string" && (G = $), G && (G = (0, n.stringToPDFString)(G).replaceAll("\0", "")), G && r.push(G);
            }
            R(m.getRaw("Next"), s, r, y);
          }
          M && y.remove(M);
        }
        function f(m, s, r) {
          const y = /* @__PURE__ */ Object.create(null), M = g({
            dict: s,
            key: "AA",
            stopWhenFound: !1
          });
          if (M)
            for (let $ = M.length - 1; $ >= 0; $--) {
              const G = M[$];
              if (G instanceof F.Dict)
                for (const ce of G.getKeys()) {
                  const q = r[ce];
                  if (!q)
                    continue;
                  const re = G.getRaw(ce), Z = new F.RefSet(), te = [];
                  R(re, m, te, Z), te.length > 0 && (y[q] = te);
                }
            }
          if (s.has("A")) {
            const $ = s.get("A"), G = new F.RefSet(), ce = [];
            R($, m, ce, G), ce.length > 0 && (y.Action = ce);
          }
          return (0, n.objectSize)(y) > 0 ? y : null;
        }
        const c = {
          60: "&lt;",
          62: "&gt;",
          38: "&amp;",
          34: "&quot;",
          39: "&apos;"
        };
        function N(m) {
          const s = [];
          let r = 0;
          for (let y = 0, M = m.length; y < M; y++) {
            const $ = m.codePointAt(y);
            if (32 <= $ && $ <= 126) {
              const G = c[$];
              G && (r < y && s.push(m.substring(r, y)), s.push(G), r = y + 1);
            } else
              r < y && s.push(m.substring(r, y)), s.push(`&#x${$.toString(16).toUpperCase()};`), $ > 55295 && ($ < 57344 || $ > 65533) && y++, r = y + 1;
          }
          return s.length === 0 ? m : (r < m.length && s.push(m.substring(r, m.length)), s.join(""));
        }
        function u(m, s = !1) {
          const r = /^("|').*("|')$/.exec(m);
          if (r && r[1] === r[2]) {
            if (new RegExp(`[^\\\\]${r[1]}`).test(m.slice(1, -1)))
              return s && (0, n.warn)(`FontFamily contains unescaped ${r[1]}: ${m}.`), !1;
          } else
            for (const y of m.split(/[ \t]+/))
              if (/^(\d|(-(\d|-)))/.test(y) || !/^[\w-\\]+$/.test(y))
                return s && (0, n.warn)(`FontFamily contains invalid <custom-ident>: ${m}.`), !1;
          return !0;
        }
        function p(m) {
          const s = "14", r = "400", y = /* @__PURE__ */ new Set(["100", "200", "300", "400", "500", "600", "700", "800", "900", "1000", "normal", "bold", "bolder", "lighter"]), {
            fontFamily: M,
            fontWeight: $,
            italicAngle: G
          } = m;
          if (!u(M, !0))
            return !1;
          const ce = $ ? $.toString() : "";
          m.fontWeight = y.has(ce) ? ce : r;
          const q = parseFloat(G);
          return m.italicAngle = isNaN(q) || q < -90 || q > 90 ? s : G.toString(), !0;
        }
        function S(m) {
          const s = ["app.launchURL", "window.open", "xfa.host.gotoURL"], y = new RegExp("^\\s*(" + s.join("|").replaceAll(".", "\\.") + `)\\((?:'|")([^'"]*)(?:'|")(?:,\\s*(\\w+)\\)|\\))`, "i").exec(m);
          if (y != null && y[2]) {
            const M = y[2];
            let $ = !1;
            return y[3] === "true" && y[1] === "app.launchURL" && ($ = !0), {
              url: M,
              newWindow: $
            };
          }
          return null;
        }
        function B(m) {
          if (Number.isInteger(m))
            return m.toString();
          const s = Math.round(m * 100);
          return s % 100 === 0 ? (s / 100).toString() : s % 10 === 0 ? m.toFixed(1) : m.toFixed(2);
        }
        function T(m) {
          if (!m)
            return null;
          const s = /* @__PURE__ */ new Map();
          for (const [r, y] of m) {
            if (!r.startsWith(n.AnnotationEditorPrefix))
              continue;
            let M = s.get(y.pageIndex);
            M || (M = [], s.set(y.pageIndex, M)), M.push(y);
          }
          return s.size > 0 ? s : null;
        }
        function D(m) {
          return /^[\x00-\x7F]*$/.test(m);
        }
        function K(m) {
          const s = [];
          for (let r = 0, y = m.length; r < y; r++) {
            const M = m.charCodeAt(r);
            s.push((M >> 8 & 255).toString(16).padStart(2, "0"), (M & 255).toString(16).padStart(2, "0"));
          }
          return s.join("");
        }
        function _(m, s = !1) {
          const r = [];
          s && r.push("þÿ");
          for (let y = 0, M = m.length; y < M; y++) {
            const $ = m.charCodeAt(y);
            r.push(String.fromCharCode($ >> 8 & 255), String.fromCharCode($ & 255));
          }
          return r.join("");
        }
        function o(m, s, r) {
          switch (m) {
            case 90:
              return [0, 1, -1, 0, s, 0];
            case 180:
              return [-1, 0, 0, -1, s, r];
            case 270:
              return [0, -1, 1, 0, 0, r];
            default:
              throw new Error("Invalid rotation");
          }
        }
      },
      /* 4 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.RefSetCache = w.RefSet = w.Ref = w.Name = w.EOF = w.Dict = w.Cmd = w.CIRCULAR_REF = void 0, w.clearPrimitiveCaches = j, w.isCmd = A, w.isDict = I, w.isName = d, w.isRefsEqual = E;
        var n = V(2);
        const F = Symbol("CIRCULAR_REF");
        w.CIRCULAR_REF = F;
        const C = Symbol("EOF");
        w.EOF = C;
        let e = /* @__PURE__ */ Object.create(null), t = /* @__PURE__ */ Object.create(null), l = /* @__PURE__ */ Object.create(null);
        function j() {
          e = /* @__PURE__ */ Object.create(null), t = /* @__PURE__ */ Object.create(null), l = /* @__PURE__ */ Object.create(null);
        }
        class U {
          constructor(H) {
            this.name = H;
          }
          static get(H) {
            return t[H] || (t[H] = new U(H));
          }
        }
        w.Name = U;
        class O {
          constructor(H) {
            this.cmd = H;
          }
          static get(H) {
            return e[H] || (e[H] = new O(H));
          }
        }
        w.Cmd = O;
        const v = function() {
          return v;
        };
        class g {
          constructor(H = null) {
            this._map = /* @__PURE__ */ Object.create(null), this.xref = H, this.objId = null, this.suppressEncryption = !1, this.__nonSerializable__ = v;
          }
          assignXref(H) {
            this.xref = H;
          }
          get size() {
            return Object.keys(this._map).length;
          }
          get(H, x, R) {
            let f = this._map[H];
            return f === void 0 && x !== void 0 && (f = this._map[x], f === void 0 && R !== void 0 && (f = this._map[R])), f instanceof b && this.xref ? this.xref.fetch(f, this.suppressEncryption) : f;
          }
          async getAsync(H, x, R) {
            let f = this._map[H];
            return f === void 0 && x !== void 0 && (f = this._map[x], f === void 0 && R !== void 0 && (f = this._map[R])), f instanceof b && this.xref ? this.xref.fetchAsync(f, this.suppressEncryption) : f;
          }
          getArray(H, x, R) {
            let f = this._map[H];
            if (f === void 0 && x !== void 0 && (f = this._map[x], f === void 0 && R !== void 0 && (f = this._map[R])), f instanceof b && this.xref && (f = this.xref.fetch(f, this.suppressEncryption)), Array.isArray(f)) {
              f = f.slice();
              for (let c = 0, N = f.length; c < N; c++)
                f[c] instanceof b && this.xref && (f[c] = this.xref.fetch(f[c], this.suppressEncryption));
            }
            return f;
          }
          getRaw(H) {
            return this._map[H];
          }
          getKeys() {
            return Object.keys(this._map);
          }
          getRawValues() {
            return Object.values(this._map);
          }
          set(H, x) {
            this._map[H] = x;
          }
          has(H) {
            return this._map[H] !== void 0;
          }
          forEach(H) {
            for (const x in this._map)
              H(x, this.get(x));
          }
          static get empty() {
            const H = new g(null);
            return H.set = (x, R) => {
              (0, n.unreachable)("Should not call `set` on the empty dictionary.");
            }, (0, n.shadow)(this, "empty", H);
          }
          static merge({
            xref: H,
            dictArray: x,
            mergeSubDicts: R = !1
          }) {
            const f = new g(H), c = /* @__PURE__ */ new Map();
            for (const N of x)
              if (N instanceof g)
                for (const [u, p] of Object.entries(N._map)) {
                  let S = c.get(u);
                  if (S === void 0)
                    S = [], c.set(u, S);
                  else if (!R || !(p instanceof g))
                    continue;
                  S.push(p);
                }
            for (const [N, u] of c) {
              if (u.length === 1 || !(u[0] instanceof g)) {
                f._map[N] = u[0];
                continue;
              }
              const p = new g(H);
              for (const S of u)
                for (const [B, T] of Object.entries(S._map))
                  p._map[B] === void 0 && (p._map[B] = T);
              p.size > 0 && (f._map[N] = p);
            }
            return c.clear(), f.size > 0 ? f : g.empty;
          }
          clone() {
            const H = new g(this.xref);
            for (const x of this.getKeys())
              H.set(x, this.getRaw(x));
            return H;
          }
        }
        w.Dict = g;
        class b {
          constructor(H, x) {
            this.num = H, this.gen = x;
          }
          toString() {
            return this.gen === 0 ? `${this.num}R` : `${this.num}R${this.gen}`;
          }
          static fromString(H) {
            const x = l[H];
            if (x)
              return x;
            const R = /^(\d+)R(\d*)$/.exec(H);
            return !R || R[1] === "0" ? null : l[H] = new b(parseInt(R[1]), R[2] ? parseInt(R[2]) : 0);
          }
          static get(H, x) {
            const R = x === 0 ? `${H}R` : `${H}R${x}`;
            return l[R] || (l[R] = new b(H, x));
          }
        }
        w.Ref = b;
        class i {
          constructor(H = null) {
            this._set = new Set(H == null ? void 0 : H._set);
          }
          has(H) {
            return this._set.has(H.toString());
          }
          put(H) {
            this._set.add(H.toString());
          }
          remove(H) {
            this._set.delete(H.toString());
          }
          [Symbol.iterator]() {
            return this._set.values();
          }
          clear() {
            this._set.clear();
          }
        }
        w.RefSet = i;
        class P {
          constructor() {
            this._map = /* @__PURE__ */ new Map();
          }
          get size() {
            return this._map.size;
          }
          get(H) {
            return this._map.get(H.toString());
          }
          has(H) {
            return this._map.has(H.toString());
          }
          put(H, x) {
            this._map.set(H.toString(), x);
          }
          putAlias(H, x) {
            this._map.set(H.toString(), this.get(x));
          }
          [Symbol.iterator]() {
            return this._map.values();
          }
          clear() {
            this._map.clear();
          }
        }
        w.RefSetCache = P;
        function d(k, H) {
          return k instanceof U && (H === void 0 || k.name === H);
        }
        function A(k, H) {
          return k instanceof O && (H === void 0 || k.cmd === H);
        }
        function I(k, H) {
          return k instanceof g && (H === void 0 || d(k.get("Type"), H));
        }
        function E(k, H) {
          return k.num === H.num && k.gen === H.gen;
        }
      },
      /* 5 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.BaseStream = void 0;
        var n = V(2);
        class F {
          constructor() {
            this.constructor === F && (0, n.unreachable)("Cannot initialize BaseStream.");
          }
          get length() {
            (0, n.unreachable)("Abstract getter `length` accessed");
          }
          get isEmpty() {
            (0, n.unreachable)("Abstract getter `isEmpty` accessed");
          }
          get isDataLoaded() {
            return (0, n.shadow)(this, "isDataLoaded", !0);
          }
          getByte() {
            (0, n.unreachable)("Abstract method `getByte` called");
          }
          getBytes(e) {
            (0, n.unreachable)("Abstract method `getBytes` called");
          }
          peekByte() {
            const e = this.getByte();
            return e !== -1 && this.pos--, e;
          }
          peekBytes(e) {
            const t = this.getBytes(e);
            return this.pos -= t.length, t;
          }
          getUint16() {
            const e = this.getByte(), t = this.getByte();
            return e === -1 || t === -1 ? -1 : (e << 8) + t;
          }
          getInt32() {
            const e = this.getByte(), t = this.getByte(), l = this.getByte(), j = this.getByte();
            return (e << 24) + (t << 16) + (l << 8) + j;
          }
          getByteRange(e, t) {
            (0, n.unreachable)("Abstract method `getByteRange` called");
          }
          getString(e) {
            return (0, n.bytesToString)(this.getBytes(e));
          }
          skip(e) {
            this.pos += e || 1;
          }
          reset() {
            (0, n.unreachable)("Abstract method `reset` called");
          }
          moveStart() {
            (0, n.unreachable)("Abstract method `moveStart` called");
          }
          makeSubStream(e, t, l = null) {
            (0, n.unreachable)("Abstract method `makeSubStream` called");
          }
          getBaseStreams() {
            return null;
          }
        }
        w.BaseStream = F;
      },
      /* 6 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.NetworkPdfManager = w.LocalPdfManager = void 0;
        var n = V(2), F = V(7), C = V(3), e = V(9), t = V(8);
        function l(v) {
          if (v) {
            const g = (0, n.createValidAbsoluteUrl)(v);
            if (g)
              return g.href;
            (0, n.warn)(`Invalid absolute docBaseUrl: "${v}".`);
          }
          return null;
        }
        class j {
          constructor(g) {
            var b;
            this.constructor === j && (0, n.unreachable)("Cannot initialize BasePdfManager."), this._docBaseUrl = l(g.docBaseUrl), this._docId = g.docId, this._password = g.password, this.enableXfa = g.enableXfa, (b = g.evaluatorOptions).isOffscreenCanvasSupported && (b.isOffscreenCanvasSupported = n.FeatureTest.isOffscreenCanvasSupported), this.evaluatorOptions = g.evaluatorOptions;
          }
          get docId() {
            return this._docId;
          }
          get password() {
            return this._password;
          }
          get docBaseUrl() {
            return this._docBaseUrl;
          }
          get catalog() {
            return this.pdfDocument.catalog;
          }
          ensureDoc(g, b) {
            return this.ensure(this.pdfDocument, g, b);
          }
          ensureXRef(g, b) {
            return this.ensure(this.pdfDocument.xref, g, b);
          }
          ensureCatalog(g, b) {
            return this.ensure(this.pdfDocument.catalog, g, b);
          }
          getPage(g) {
            return this.pdfDocument.getPage(g);
          }
          fontFallback(g, b) {
            return this.pdfDocument.fontFallback(g, b);
          }
          loadXfaFonts(g, b) {
            return this.pdfDocument.loadXfaFonts(g, b);
          }
          loadXfaImages() {
            return this.pdfDocument.loadXfaImages();
          }
          serializeXfaData(g) {
            return this.pdfDocument.serializeXfaData(g);
          }
          cleanup(g = !1) {
            return this.pdfDocument.cleanup(g);
          }
          async ensure(g, b, i) {
            (0, n.unreachable)("Abstract method `ensure` called");
          }
          requestRange(g, b) {
            (0, n.unreachable)("Abstract method `requestRange` called");
          }
          requestLoadedStream(g = !1) {
            (0, n.unreachable)("Abstract method `requestLoadedStream` called");
          }
          sendProgressiveData(g) {
            (0, n.unreachable)("Abstract method `sendProgressiveData` called");
          }
          updatePassword(g) {
            this._password = g;
          }
          terminate(g) {
            (0, n.unreachable)("Abstract method `terminate` called");
          }
        }
        class U extends j {
          constructor(g) {
            super(g);
            const b = new t.Stream(g.source);
            this.pdfDocument = new e.PDFDocument(this, b), this._loadedStreamPromise = Promise.resolve(b);
          }
          async ensure(g, b, i) {
            const P = g[b];
            return typeof P == "function" ? P.apply(g, i) : P;
          }
          requestRange(g, b) {
            return Promise.resolve();
          }
          requestLoadedStream(g = !1) {
            return this._loadedStreamPromise;
          }
          terminate(g) {
          }
        }
        w.LocalPdfManager = U;
        class O extends j {
          constructor(g) {
            super(g), this.streamManager = new F.ChunkedStreamManager(g.source, {
              msgHandler: g.handler,
              length: g.length,
              disableAutoFetch: g.disableAutoFetch,
              rangeChunkSize: g.rangeChunkSize
            }), this.pdfDocument = new e.PDFDocument(this, this.streamManager.getStream());
          }
          async ensure(g, b, i) {
            try {
              const P = g[b];
              return typeof P == "function" ? P.apply(g, i) : P;
            } catch (P) {
              if (!(P instanceof C.MissingDataException))
                throw P;
              return await this.requestRange(P.begin, P.end), this.ensure(g, b, i);
            }
          }
          requestRange(g, b) {
            return this.streamManager.requestRange(g, b);
          }
          requestLoadedStream(g = !1) {
            return this.streamManager.requestAllChunks(g);
          }
          sendProgressiveData(g) {
            this.streamManager.onReceiveData({
              chunk: g
            });
          }
          terminate(g) {
            this.streamManager.abort(g);
          }
        }
        w.NetworkPdfManager = O;
      },
      /* 7 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.ChunkedStreamManager = w.ChunkedStream = void 0;
        var n = V(3), F = V(2), C = V(8);
        class e extends C.Stream {
          constructor(j, U, O) {
            super(new Uint8Array(j), 0, j, null), this.chunkSize = U, this._loadedChunks = /* @__PURE__ */ new Set(), this.numChunks = Math.ceil(j / U), this.manager = O, this.progressiveDataLength = 0, this.lastSuccessfulEnsureByteChunk = -1;
          }
          getMissingChunks() {
            const j = [];
            for (let U = 0, O = this.numChunks; U < O; ++U)
              this._loadedChunks.has(U) || j.push(U);
            return j;
          }
          get numChunksLoaded() {
            return this._loadedChunks.size;
          }
          get isDataLoaded() {
            return this.numChunksLoaded === this.numChunks;
          }
          onReceiveData(j, U) {
            const O = this.chunkSize;
            if (j % O !== 0)
              throw new Error(`Bad begin offset: ${j}`);
            const v = j + U.byteLength;
            if (v % O !== 0 && v !== this.bytes.length)
              throw new Error(`Bad end offset: ${v}`);
            this.bytes.set(new Uint8Array(U), j);
            const g = Math.floor(j / O), b = Math.floor((v - 1) / O) + 1;
            for (let i = g; i < b; ++i)
              this._loadedChunks.add(i);
          }
          onReceiveProgressiveData(j) {
            let U = this.progressiveDataLength;
            const O = Math.floor(U / this.chunkSize);
            this.bytes.set(new Uint8Array(j), U), U += j.byteLength, this.progressiveDataLength = U;
            const v = U >= this.end ? this.numChunks : Math.floor(U / this.chunkSize);
            for (let g = O; g < v; ++g)
              this._loadedChunks.add(g);
          }
          ensureByte(j) {
            if (j < this.progressiveDataLength)
              return;
            const U = Math.floor(j / this.chunkSize);
            if (!(U > this.numChunks) && U !== this.lastSuccessfulEnsureByteChunk) {
              if (!this._loadedChunks.has(U))
                throw new n.MissingDataException(j, j + 1);
              this.lastSuccessfulEnsureByteChunk = U;
            }
          }
          ensureRange(j, U) {
            if (j >= U || U <= this.progressiveDataLength)
              return;
            const O = Math.floor(j / this.chunkSize);
            if (O > this.numChunks)
              return;
            const v = Math.min(Math.floor((U - 1) / this.chunkSize) + 1, this.numChunks);
            for (let g = O; g < v; ++g)
              if (!this._loadedChunks.has(g))
                throw new n.MissingDataException(j, U);
          }
          nextEmptyChunk(j) {
            const U = this.numChunks;
            for (let O = 0; O < U; ++O) {
              const v = (j + O) % U;
              if (!this._loadedChunks.has(v))
                return v;
            }
            return null;
          }
          hasChunk(j) {
            return this._loadedChunks.has(j);
          }
          getByte() {
            const j = this.pos;
            return j >= this.end ? -1 : (j >= this.progressiveDataLength && this.ensureByte(j), this.bytes[this.pos++]);
          }
          getBytes(j) {
            const U = this.bytes, O = this.pos, v = this.end;
            if (!j)
              return v > this.progressiveDataLength && this.ensureRange(O, v), U.subarray(O, v);
            let g = O + j;
            return g > v && (g = v), g > this.progressiveDataLength && this.ensureRange(O, g), this.pos = g, U.subarray(O, g);
          }
          getByteRange(j, U) {
            return j < 0 && (j = 0), U > this.end && (U = this.end), U > this.progressiveDataLength && this.ensureRange(j, U), this.bytes.subarray(j, U);
          }
          makeSubStream(j, U, O = null) {
            U ? j + U > this.progressiveDataLength && this.ensureRange(j, j + U) : j >= this.progressiveDataLength && this.ensureByte(j);
            function v() {
            }
            v.prototype = Object.create(this), v.prototype.getMissingChunks = function() {
              const b = this.chunkSize, i = Math.floor(this.start / b), P = Math.floor((this.end - 1) / b) + 1, d = [];
              for (let A = i; A < P; ++A)
                this._loadedChunks.has(A) || d.push(A);
              return d;
            }, Object.defineProperty(v.prototype, "isDataLoaded", {
              get() {
                return this.numChunksLoaded === this.numChunks ? !0 : this.getMissingChunks().length === 0;
              },
              configurable: !0
            });
            const g = new v();
            return g.pos = g.start = j, g.end = j + U || this.end, g.dict = O, g;
          }
          getBaseStreams() {
            return [this];
          }
        }
        w.ChunkedStream = e;
        class t {
          constructor(j, U) {
            this.length = U.length, this.chunkSize = U.rangeChunkSize, this.stream = new e(this.length, this.chunkSize, this), this.pdfNetworkStream = j, this.disableAutoFetch = U.disableAutoFetch, this.msgHandler = U.msgHandler, this.currRequestId = 0, this._chunksNeededByRequest = /* @__PURE__ */ new Map(), this._requestsByChunk = /* @__PURE__ */ new Map(), this._promisesByRequest = /* @__PURE__ */ new Map(), this.progressiveDataLength = 0, this.aborted = !1, this._loadedStreamCapability = new F.PromiseCapability();
          }
          sendRequest(j, U) {
            const O = this.pdfNetworkStream.getRangeReader(j, U);
            O.isStreamingSupported || (O.onProgress = this.onProgress.bind(this));
            let v = [], g = 0;
            return new Promise((b, i) => {
              const P = ({
                value: d,
                done: A
              }) => {
                try {
                  if (A) {
                    const I = (0, n.arrayBuffersToBytes)(v);
                    v = null, b(I);
                    return;
                  }
                  g += d.byteLength, O.isStreamingSupported && this.onProgress({
                    loaded: g
                  }), v.push(d), O.read().then(P, i);
                } catch (I) {
                  i(I);
                }
              };
              O.read().then(P, i);
            }).then((b) => {
              this.aborted || this.onReceiveData({
                chunk: b,
                begin: j
              });
            });
          }
          requestAllChunks(j = !1) {
            if (!j) {
              const U = this.stream.getMissingChunks();
              this._requestChunks(U);
            }
            return this._loadedStreamCapability.promise;
          }
          _requestChunks(j) {
            const U = this.currRequestId++, O = /* @__PURE__ */ new Set();
            this._chunksNeededByRequest.set(U, O);
            for (const b of j)
              this.stream.hasChunk(b) || O.add(b);
            if (O.size === 0)
              return Promise.resolve();
            const v = new F.PromiseCapability();
            this._promisesByRequest.set(U, v);
            const g = [];
            for (const b of O) {
              let i = this._requestsByChunk.get(b);
              i || (i = [], this._requestsByChunk.set(b, i), g.push(b)), i.push(U);
            }
            if (g.length > 0) {
              const b = this.groupChunks(g);
              for (const i of b) {
                const P = i.beginChunk * this.chunkSize, d = Math.min(i.endChunk * this.chunkSize, this.length);
                this.sendRequest(P, d).catch(v.reject);
              }
            }
            return v.promise.catch((b) => {
              if (!this.aborted)
                throw b;
            });
          }
          getStream() {
            return this.stream;
          }
          requestRange(j, U) {
            U = Math.min(U, this.length);
            const O = this.getBeginChunk(j), v = this.getEndChunk(U), g = [];
            for (let b = O; b < v; ++b)
              g.push(b);
            return this._requestChunks(g);
          }
          requestRanges(j = []) {
            const U = [];
            for (const O of j) {
              const v = this.getBeginChunk(O.begin), g = this.getEndChunk(O.end);
              for (let b = v; b < g; ++b)
                U.includes(b) || U.push(b);
            }
            return U.sort(function(O, v) {
              return O - v;
            }), this._requestChunks(U);
          }
          groupChunks(j) {
            const U = [];
            let O = -1, v = -1;
            for (let g = 0, b = j.length; g < b; ++g) {
              const i = j[g];
              O < 0 && (O = i), v >= 0 && v + 1 !== i && (U.push({
                beginChunk: O,
                endChunk: v + 1
              }), O = i), g + 1 === j.length && U.push({
                beginChunk: O,
                endChunk: i + 1
              }), v = i;
            }
            return U;
          }
          onProgress(j) {
            this.msgHandler.send("DocProgress", {
              loaded: this.stream.numChunksLoaded * this.chunkSize + j.loaded,
              total: this.length
            });
          }
          onReceiveData(j) {
            const U = j.chunk, O = j.begin === void 0, v = O ? this.progressiveDataLength : j.begin, g = v + U.byteLength, b = Math.floor(v / this.chunkSize), i = g < this.length ? Math.floor(g / this.chunkSize) : Math.ceil(g / this.chunkSize);
            O ? (this.stream.onReceiveProgressiveData(U), this.progressiveDataLength = g) : this.stream.onReceiveData(v, U), this.stream.isDataLoaded && this._loadedStreamCapability.resolve(this.stream);
            const P = [];
            for (let d = b; d < i; ++d) {
              const A = this._requestsByChunk.get(d);
              if (A) {
                this._requestsByChunk.delete(d);
                for (const I of A) {
                  const E = this._chunksNeededByRequest.get(I);
                  E.has(d) && E.delete(d), !(E.size > 0) && P.push(I);
                }
              }
            }
            if (!this.disableAutoFetch && this._requestsByChunk.size === 0) {
              let d;
              if (this.stream.numChunksLoaded === 1) {
                const A = this.stream.numChunks - 1;
                this.stream.hasChunk(A) || (d = A);
              } else
                d = this.stream.nextEmptyChunk(i);
              Number.isInteger(d) && this._requestChunks([d]);
            }
            for (const d of P) {
              const A = this._promisesByRequest.get(d);
              this._promisesByRequest.delete(d), A.resolve();
            }
            this.msgHandler.send("DocProgress", {
              loaded: this.stream.numChunksLoaded * this.chunkSize,
              total: this.length
            });
          }
          onError(j) {
            this._loadedStreamCapability.reject(j);
          }
          getBeginChunk(j) {
            return Math.floor(j / this.chunkSize);
          }
          getEndChunk(j) {
            return Math.floor((j - 1) / this.chunkSize) + 1;
          }
          abort(j) {
            var U;
            this.aborted = !0, (U = this.pdfNetworkStream) == null || U.cancelAllRequests(j);
            for (const O of this._promisesByRequest.values())
              O.reject(j);
          }
        }
        w.ChunkedStreamManager = t;
      },
      /* 8 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.StringStream = w.Stream = w.NullStream = void 0;
        var n = V(5), F = V(2);
        class C extends n.BaseStream {
          constructor(j, U, O, v) {
            super(), this.bytes = j instanceof Uint8Array ? j : new Uint8Array(j), this.start = U || 0, this.pos = this.start, this.end = U + O || this.bytes.length, this.dict = v;
          }
          get length() {
            return this.end - this.start;
          }
          get isEmpty() {
            return this.length === 0;
          }
          getByte() {
            return this.pos >= this.end ? -1 : this.bytes[this.pos++];
          }
          getBytes(j) {
            const U = this.bytes, O = this.pos, v = this.end;
            if (!j)
              return U.subarray(O, v);
            let g = O + j;
            return g > v && (g = v), this.pos = g, U.subarray(O, g);
          }
          getByteRange(j, U) {
            return j < 0 && (j = 0), U > this.end && (U = this.end), this.bytes.subarray(j, U);
          }
          reset() {
            this.pos = this.start;
          }
          moveStart() {
            this.start = this.pos;
          }
          makeSubStream(j, U, O = null) {
            return new C(this.bytes.buffer, j, U, O);
          }
        }
        w.Stream = C;
        class e extends C {
          constructor(j) {
            super((0, F.stringToBytes)(j));
          }
        }
        w.StringStream = e;
        class t extends C {
          constructor() {
            super(new Uint8Array(0));
          }
        }
        w.NullStream = t;
      },
      /* 9 */
      /***/
      (fe, w, V) => {
        var D, Mi, _, _i;
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.Page = w.PDFDocument = void 0;
        var n = V(2), F = V(10), C = V(3), e = V(4), t = V(51), l = V(5), j = V(74), U = V(66), O = V(68), v = V(102), g = V(16), b = V(8), i = V(76), P = V(64), d = V(13), A = V(18), I = V(72), E = V(73), k = V(77), H = V(103);
        const x = 1, R = [0, 0, 612, 792];
        class f {
          constructor({
            pdfManager: s,
            xref: r,
            pageIndex: y,
            pageDict: M,
            ref: $,
            globalIdFactory: G,
            fontCache: ce,
            builtInCMapCache: q,
            standardFontDataCache: re,
            globalImageCache: Z,
            systemFontCache: te,
            nonBlendModesSet: L,
            xfaFactory: X
          }) {
            Me(this, D);
            this.pdfManager = s, this.pageIndex = y, this.pageDict = M, this.xref = r, this.ref = $, this.fontCache = ce, this.builtInCMapCache = q, this.standardFontDataCache = re, this.globalImageCache = Z, this.systemFontCache = te, this.nonBlendModesSet = L, this.evaluatorOptions = s.evaluatorOptions, this.resourcesPromise = null, this.xfaFactory = X;
            const J = {
              obj: 0
            };
            this._localIdFactory = class extends G {
              static createObjId() {
                return `p${y}_${++J.obj}`;
              }
              static getPageObjId() {
                return `p${$.toString()}`;
              }
            };
          }
          _getInheritableProperty(s, r = !1) {
            const y = (0, C.getInheritableProperty)({
              dict: this.pageDict,
              key: s,
              getArray: r,
              stopWhenFound: !1
            });
            return Array.isArray(y) ? y.length === 1 || !(y[0] instanceof e.Dict) ? y[0] : e.Dict.merge({
              xref: this.xref,
              dictArray: y
            }) : y;
          }
          get content() {
            return this.pageDict.getArray("Contents");
          }
          get resources() {
            const s = this._getInheritableProperty("Resources");
            return (0, n.shadow)(this, "resources", s instanceof e.Dict ? s : e.Dict.empty);
          }
          _getBoundingBox(s) {
            if (this.xfaData)
              return this.xfaData.bbox;
            let r = this._getInheritableProperty(s, !0);
            if (Array.isArray(r) && r.length === 4) {
              if (r = n.Util.normalizeRect(r), r[2] - r[0] > 0 && r[3] - r[1] > 0)
                return r;
              (0, n.warn)(`Empty, or invalid, /${s} entry.`);
            }
            return null;
          }
          get mediaBox() {
            return (0, n.shadow)(this, "mediaBox", this._getBoundingBox("MediaBox") || R);
          }
          get cropBox() {
            return (0, n.shadow)(this, "cropBox", this._getBoundingBox("CropBox") || this.mediaBox);
          }
          get userUnit() {
            let s = this.pageDict.get("UserUnit");
            return (typeof s != "number" || s <= 0) && (s = x), (0, n.shadow)(this, "userUnit", s);
          }
          get view() {
            const {
              cropBox: s,
              mediaBox: r
            } = this;
            if (s !== r && !(0, n.isArrayEqual)(s, r)) {
              const y = n.Util.intersect(s, r);
              if (y && y[2] - y[0] > 0 && y[3] - y[1] > 0)
                return (0, n.shadow)(this, "view", y);
              (0, n.warn)("Empty /CropBox and /MediaBox intersection.");
            }
            return (0, n.shadow)(this, "view", r);
          }
          get rotate() {
            let s = this._getInheritableProperty("Rotate") || 0;
            return s % 90 !== 0 ? s = 0 : s >= 360 ? s %= 360 : s < 0 && (s = (s % 360 + 360) % 360), (0, n.shadow)(this, "rotate", s);
          }
          _onSubStreamError(s, r) {
            if (this.evaluatorOptions.ignoreErrors) {
              (0, n.warn)(`getContentStream - ignoring sub-stream (${r}): "${s}".`);
              return;
            }
            throw s;
          }
          getContentStream() {
            return this.pdfManager.ensure(this, "content").then((s) => s instanceof l.BaseStream ? s : Array.isArray(s) ? new A.StreamsSequenceStream(s, this._onSubStreamError.bind(this)) : new b.NullStream());
          }
          get xfaData() {
            return (0, n.shadow)(this, "xfaData", this.xfaFactory ? {
              bbox: this.xfaFactory.getBoundingBox(this.pageIndex)
            } : null);
          }
          async saveNewAnnotations(s, r, y, M) {
            if (this.xfaFactory)
              throw new Error("XFA: Cannot save new annotations.");
            const $ = new d.PartialEvaluator({
              xref: this.xref,
              handler: s,
              pageIndex: this.pageIndex,
              idFactory: this._localIdFactory,
              fontCache: this.fontCache,
              builtInCMapCache: this.builtInCMapCache,
              standardFontDataCache: this.standardFontDataCache,
              globalImageCache: this.globalImageCache,
              systemFontCache: this.systemFontCache,
              options: this.evaluatorOptions
            }), G = new e.RefSet(), ce = new e.RefSet();
            De(this, D, Mi).call(this, y, G, ce);
            const q = this.pageDict, re = this.annotations.filter((J) => !(J instanceof e.Ref && G.has(J))), Z = await F.AnnotationFactory.saveNewAnnotations($, r, y, M);
            for (const {
              ref: J
            } of Z.annotations)
              J instanceof e.Ref && !ce.has(J) && re.push(J);
            const te = q.get("Annots");
            q.set("Annots", re);
            const L = [];
            await (0, E.writeObject)(this.ref, q, L, this.xref), te && q.set("Annots", te);
            const X = Z.dependencies;
            return X.push({
              ref: this.ref,
              data: L.join("")
            }, ...Z.annotations), X;
          }
          save(s, r, y) {
            const M = new d.PartialEvaluator({
              xref: this.xref,
              handler: s,
              pageIndex: this.pageIndex,
              idFactory: this._localIdFactory,
              fontCache: this.fontCache,
              builtInCMapCache: this.builtInCMapCache,
              standardFontDataCache: this.standardFontDataCache,
              globalImageCache: this.globalImageCache,
              systemFontCache: this.systemFontCache,
              options: this.evaluatorOptions
            });
            return this._parsedAnnotations.then(function($) {
              const G = [];
              for (const ce of $)
                ce.mustBePrinted(y) && G.push(ce.save(M, r, y).catch(function(q) {
                  return (0, n.warn)(`save - ignoring annotation data during "${r.name}" task: "${q}".`), null;
                }));
              return Promise.all(G).then(function(ce) {
                return ce.filter((q) => !!q);
              });
            });
          }
          loadResources(s) {
            return this.resourcesPromise || (this.resourcesPromise = this.pdfManager.ensure(this, "resources")), this.resourcesPromise.then(() => new i.ObjectLoader(this.resources, s, this.xref).load());
          }
          getOperatorList({
            handler: s,
            sink: r,
            task: y,
            intent: M,
            cacheKey: $,
            annotationStorage: G = null
          }) {
            const ce = this.getContentStream(), q = this.loadResources(["ColorSpace", "ExtGState", "Font", "Pattern", "Properties", "Shading", "XObject"]), re = new d.PartialEvaluator({
              xref: this.xref,
              handler: s,
              pageIndex: this.pageIndex,
              idFactory: this._localIdFactory,
              fontCache: this.fontCache,
              builtInCMapCache: this.builtInCMapCache,
              standardFontDataCache: this.standardFontDataCache,
              globalImageCache: this.globalImageCache,
              systemFontCache: this.systemFontCache,
              options: this.evaluatorOptions
            }), Z = this.xfaFactory ? null : (0, C.getNewAnnotationsMap)(G);
            let te = null, L = Promise.resolve(null);
            if (Z) {
              const Y = Z.get(this.pageIndex);
              if (Y) {
                const ae = this.pdfManager.ensureDoc("annotationGlobals");
                let se;
                const Q = /* @__PURE__ */ new Set();
                for (const {
                  bitmapId: ie,
                  bitmap: ne
                } of Y)
                  ie && !ne && !Q.has(ie) && Q.add(ie);
                const {
                  isOffscreenCanvasSupported: z
                } = this.evaluatorOptions;
                if (Q.size > 0) {
                  const ie = Y.slice();
                  for (const [ne, W] of G)
                    ne.startsWith(n.AnnotationEditorPrefix) && W.bitmap && Q.has(W.bitmapId) && ie.push(W);
                  se = F.AnnotationFactory.generateImages(ie, this.xref, z);
                } else
                  se = F.AnnotationFactory.generateImages(Y, this.xref, z);
                te = new e.RefSet(), De(this, D, Mi).call(this, Y, te, null), L = ae.then((ie) => ie ? F.AnnotationFactory.printNewAnnotations(ie, re, y, Y, se) : null);
              }
            }
            const J = Promise.all([ce, q]).then(([Y]) => {
              const ae = new P.OperatorList(M, r);
              return s.send("StartRenderPage", {
                transparency: re.hasBlendModes(this.resources, this.nonBlendModesSet),
                pageIndex: this.pageIndex,
                cacheKey: $
              }), re.getOperatorList({
                stream: Y,
                task: y,
                resources: this.resources,
                operatorList: ae
              }).then(function() {
                return ae;
              });
            });
            return Promise.all([J, this._parsedAnnotations, L]).then(function([Y, ae, se]) {
              if (se) {
                ae = ae.filter((oe) => !(oe.ref && te.has(oe.ref)));
                for (let oe = 0, ue = se.length; oe < ue; oe++) {
                  const pe = se[oe];
                  if (pe.refToReplace) {
                    const ve = ae.findIndex((Ce) => Ce.ref && (0, e.isRefsEqual)(Ce.ref, pe.refToReplace));
                    ve >= 0 && (ae.splice(ve, 1, pe), se.splice(oe--, 1), ue--);
                  }
                }
                ae = ae.concat(se);
              }
              if (ae.length === 0 || M & n.RenderingIntentFlag.ANNOTATIONS_DISABLE)
                return Y.flush(!0), {
                  length: Y.totalLength
                };
              const Q = !!(M & n.RenderingIntentFlag.ANNOTATIONS_FORMS), z = !!(M & n.RenderingIntentFlag.ANY), ie = !!(M & n.RenderingIntentFlag.DISPLAY), ne = !!(M & n.RenderingIntentFlag.PRINT), W = [];
              for (const oe of ae)
                (z || ie && oe.mustBeViewed(G, Q) || ne && oe.mustBePrinted(G)) && W.push(oe.getOperatorList(re, y, M, Q, G).catch(function(ue) {
                  return (0, n.warn)(`getOperatorList - ignoring annotation data during "${y.name}" task: "${ue}".`), {
                    opList: null,
                    separateForm: !1,
                    separateCanvas: !1
                  };
                }));
              return Promise.all(W).then(function(oe) {
                let ue = !1, pe = !1;
                for (const {
                  opList: ve,
                  separateForm: Ce,
                  separateCanvas: Fe
                } of oe)
                  Y.addOpList(ve), ue || (ue = Ce), pe || (pe = Fe);
                return Y.flush(!0, {
                  form: ue,
                  canvas: pe
                }), {
                  length: Y.totalLength
                };
              });
            });
          }
          extractTextContent({
            handler: s,
            task: r,
            includeMarkedContent: y,
            disableNormalization: M,
            sink: $
          }) {
            const G = this.getContentStream(), ce = this.loadResources(["ExtGState", "Font", "Properties", "XObject"]);
            return Promise.all([G, ce]).then(([re]) => new d.PartialEvaluator({
              xref: this.xref,
              handler: s,
              pageIndex: this.pageIndex,
              idFactory: this._localIdFactory,
              fontCache: this.fontCache,
              builtInCMapCache: this.builtInCMapCache,
              standardFontDataCache: this.standardFontDataCache,
              globalImageCache: this.globalImageCache,
              systemFontCache: this.systemFontCache,
              options: this.evaluatorOptions
            }).getTextContent({
              stream: re,
              task: r,
              resources: this.resources,
              includeMarkedContent: y,
              disableNormalization: M,
              sink: $,
              viewBox: this.view
            }));
          }
          async getStructTree() {
            const s = await this.pdfManager.ensureCatalog("structTreeRoot");
            return s ? (await this._parsedAnnotations, (await this.pdfManager.ensure(this, "_parseStructTree", [s])).serializable) : null;
          }
          _parseStructTree(s) {
            const r = new I.StructTreePage(s, this.pageDict);
            return r.parse(this.ref), r;
          }
          async getAnnotationsData(s, r, y) {
            const M = await this._parsedAnnotations;
            if (M.length === 0)
              return M;
            const $ = [], G = [];
            let ce;
            const q = !!(y & n.RenderingIntentFlag.ANY), re = !!(y & n.RenderingIntentFlag.DISPLAY), Z = !!(y & n.RenderingIntentFlag.PRINT);
            for (const te of M) {
              const L = q || re && te.viewable;
              (L || Z && te.printable) && $.push(te.data), te.hasTextContent && L && (ce || (ce = new d.PartialEvaluator({
                xref: this.xref,
                handler: s,
                pageIndex: this.pageIndex,
                idFactory: this._localIdFactory,
                fontCache: this.fontCache,
                builtInCMapCache: this.builtInCMapCache,
                standardFontDataCache: this.standardFontDataCache,
                globalImageCache: this.globalImageCache,
                systemFontCache: this.systemFontCache,
                options: this.evaluatorOptions
              })), G.push(te.extractTextContent(ce, r, [-1 / 0, -1 / 0, 1 / 0, 1 / 0]).catch(function(X) {
                (0, n.warn)(`getAnnotationsData - ignoring textContent during "${r.name}" task: "${X}".`);
              })));
            }
            return await Promise.all(G), $;
          }
          get annotations() {
            const s = this._getInheritableProperty("Annots");
            return (0, n.shadow)(this, "annotations", Array.isArray(s) ? s : []);
          }
          get _parsedAnnotations() {
            const s = this.pdfManager.ensure(this, "annotations").then(async (r) => {
              if (r.length === 0)
                return r;
              const y = await this.pdfManager.ensureDoc("annotationGlobals");
              if (!y)
                return [];
              const M = [];
              for (const ce of r)
                M.push(F.AnnotationFactory.create(this.xref, ce, y, this._localIdFactory, !1, this.ref).catch(function(q) {
                  return (0, n.warn)(`_parsedAnnotations: "${q}".`), null;
                }));
              const $ = [];
              let G;
              for (const ce of await Promise.all(M))
                if (ce) {
                  if (ce instanceof F.PopupAnnotation) {
                    (G || (G = [])).push(ce);
                    continue;
                  }
                  $.push(ce);
                }
              return G && $.push(...G), $;
            });
            return (0, n.shadow)(this, "_parsedAnnotations", s);
          }
          get jsActions() {
            const s = (0, C.collectActions)(this.xref, this.pageDict, n.PageActionEventType);
            return (0, n.shadow)(this, "jsActions", s);
          }
        }
        D = new WeakSet(), Mi = function(s, r, y) {
          for (const M of s)
            if (M.id) {
              const $ = e.Ref.fromString(M.id);
              if (!$) {
                (0, n.warn)(`A non-linked annotation cannot be modified: ${M.id}`);
                continue;
              }
              if (M.deleted) {
                r.put($);
                continue;
              }
              y == null || y.put($), M.ref = $, delete M.id;
            }
        }, w.Page = f;
        const c = new Uint8Array([37, 80, 68, 70, 45]), N = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]), u = new Uint8Array([101, 110, 100, 111, 98, 106]), p = 1024, S = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
        function B(m, s, r = 1024, y = !1) {
          const M = s.length, $ = m.peekBytes(r), G = $.length - M;
          if (G <= 0)
            return !1;
          if (y) {
            const ce = M - 1;
            let q = $.length - 1;
            for (; q >= ce; ) {
              let re = 0;
              for (; re < M && $[q - re] === s[ce - re]; )
                re++;
              if (re >= M)
                return m.pos += q - ce, !0;
              q--;
            }
          } else {
            let ce = 0;
            for (; ce <= G; ) {
              let q = 0;
              for (; q < M && $[ce + q] === s[q]; )
                q++;
              if (q >= M)
                return m.pos += ce, !0;
              ce++;
            }
          }
          return !1;
        }
        class T {
          constructor(s, r) {
            Me(this, _);
            if (r.length <= 0)
              throw new n.InvalidPDFException("The PDF file is empty, i.e. its size is zero bytes.");
            this.pdfManager = s, this.stream = r, this.xref = new H.XRef(r, s), this._pagePromises = /* @__PURE__ */ new Map(), this._version = null;
            const y = {
              font: 0
            };
            this._globalIdFactory = class {
              static getDocId() {
                return `g_${s.docId}`;
              }
              static createFontId() {
                return `f${++y.font}`;
              }
              static createObjId() {
                (0, n.unreachable)("Abstract method `createObjId` called.");
              }
              static getPageObjId() {
                (0, n.unreachable)("Abstract method `getPageObjId` called.");
              }
            };
          }
          parse(s) {
            this.xref.parse(s), this.catalog = new U.Catalog(this.pdfManager, this.xref);
          }
          get linearization() {
            let s = null;
            try {
              s = g.Linearization.create(this.stream);
            } catch (r) {
              if (r instanceof C.MissingDataException)
                throw r;
              (0, n.info)(r);
            }
            return (0, n.shadow)(this, "linearization", s);
          }
          get startXRef() {
            const s = this.stream;
            let r = 0;
            if (this.linearization)
              s.reset(), B(s, u) && (r = s.pos + 6 - s.start);
            else {
              const M = N.length;
              let $ = !1, G = s.end;
              for (; !$ && G > 0; )
                G -= 1024 - M, G < 0 && (G = 0), s.pos = G, $ = B(s, N, 1024, !0);
              if ($) {
                s.skip(9);
                let ce;
                do
                  ce = s.getByte();
                while ((0, C.isWhiteSpace)(ce));
                let q = "";
                for (; ce >= 32 && ce <= 57; )
                  q += String.fromCharCode(ce), ce = s.getByte();
                r = parseInt(q, 10), isNaN(r) && (r = 0);
              }
            }
            return (0, n.shadow)(this, "startXRef", r);
          }
          checkHeader() {
            const s = this.stream;
            if (s.reset(), !B(s, c))
              return;
            s.moveStart(), s.skip(c.length);
            let r = "", y;
            for (; (y = s.getByte()) > 32 && r.length < 7; )
              r += String.fromCharCode(y);
            C.PDF_VERSION_REGEXP.test(r) ? this._version = r : (0, n.warn)(`Invalid PDF header version: ${r}`);
          }
          parseStartXRef() {
            this.xref.setStartXRef(this.startXRef);
          }
          get numPages() {
            let s = 0;
            return this.catalog.hasActualNumPages ? s = this.catalog.numPages : this.xfaFactory ? s = this.xfaFactory.getNumPages() : this.linearization ? s = this.linearization.numPages : s = this.catalog.numPages, (0, n.shadow)(this, "numPages", s);
          }
          _hasOnlyDocumentSignatures(s, r = 0) {
            return Array.isArray(s) ? s.every((M) => {
              if (M = this.xref.fetchIfRef(M), !(M instanceof e.Dict))
                return !1;
              if (M.has("Kids"))
                return ++r > 10 ? ((0, n.warn)("_hasOnlyDocumentSignatures: maximum recursion depth reached"), !1) : this._hasOnlyDocumentSignatures(M.get("Kids"), r);
              const $ = (0, e.isName)(M.get("FT"), "Sig"), G = M.get("Rect"), ce = Array.isArray(G) && G.every((q) => q === 0);
              return $ && ce;
            }) : !1;
          }
          get _xfaStreams() {
            const s = this.catalog.acroForm;
            if (!s)
              return null;
            const r = s.get("XFA"), y = {
              "xdp:xdp": "",
              template: "",
              datasets: "",
              config: "",
              connectionSet: "",
              localeSet: "",
              stylesheet: "",
              "/xdp:xdp": ""
            };
            if (r instanceof l.BaseStream && !r.isEmpty)
              return y["xdp:xdp"] = r, y;
            if (!Array.isArray(r) || r.length === 0)
              return null;
            for (let M = 0, $ = r.length; M < $; M += 2) {
              let G;
              if (M === 0 ? G = "xdp:xdp" : M === $ - 2 ? G = "/xdp:xdp" : G = r[M], !y.hasOwnProperty(G))
                continue;
              const ce = this.xref.fetchIfRef(r[M + 1]);
              !(ce instanceof l.BaseStream) || ce.isEmpty || (y[G] = ce);
            }
            return y;
          }
          get xfaDatasets() {
            const s = this._xfaStreams;
            if (!s)
              return (0, n.shadow)(this, "xfaDatasets", null);
            for (const r of ["datasets", "xdp:xdp"]) {
              const y = s[r];
              if (y)
                try {
                  const M = (0, n.stringToUTF8String)(y.getString()), $ = {
                    [r]: M
                  };
                  return (0, n.shadow)(this, "xfaDatasets", new v.DatasetReader($));
                } catch {
                  (0, n.warn)("XFA - Invalid utf-8 string.");
                  break;
                }
            }
            return (0, n.shadow)(this, "xfaDatasets", null);
          }
          get xfaData() {
            const s = this._xfaStreams;
            if (!s)
              return null;
            const r = /* @__PURE__ */ Object.create(null);
            for (const [y, M] of Object.entries(s))
              if (M)
                try {
                  r[y] = (0, n.stringToUTF8String)(M.getString());
                } catch {
                  return (0, n.warn)("XFA - Invalid utf-8 string."), null;
                }
            return r;
          }
          get xfaFactory() {
            let s;
            return this.pdfManager.enableXfa && this.catalog.needsRendering && this.formInfo.hasXfa && !this.formInfo.hasAcroForm && (s = this.xfaData), (0, n.shadow)(this, "xfaFactory", s ? new k.XFAFactory(s) : null);
          }
          get isPureXfa() {
            return this.xfaFactory ? this.xfaFactory.isValid() : !1;
          }
          get htmlForXfa() {
            return this.xfaFactory ? this.xfaFactory.getPages() : null;
          }
          async loadXfaImages() {
            const s = await this.pdfManager.ensureCatalog("xfaImages");
            if (!s)
              return;
            const r = s.getKeys();
            await new i.ObjectLoader(s, r, this.xref).load();
            const M = /* @__PURE__ */ new Map();
            for (const $ of r) {
              const G = s.get($);
              G instanceof l.BaseStream && M.set($, G.getBytes());
            }
            this.xfaFactory.setImages(M);
          }
          async loadXfaFonts(s, r) {
            const y = await this.pdfManager.ensureCatalog("acroForm");
            if (!y)
              return;
            const M = await y.getAsync("DR");
            if (!(M instanceof e.Dict))
              return;
            await new i.ObjectLoader(M, ["Font"], this.xref).load();
            const G = M.get("Font");
            if (!(G instanceof e.Dict))
              return;
            const ce = Object.assign(/* @__PURE__ */ Object.create(null), this.pdfManager.evaluatorOptions);
            ce.useSystemFonts = !1;
            const q = new d.PartialEvaluator({
              xref: this.xref,
              handler: s,
              pageIndex: -1,
              idFactory: this._globalIdFactory,
              fontCache: this.catalog.fontCache,
              builtInCMapCache: this.catalog.builtInCMapCache,
              standardFontDataCache: this.catalog.standardFontDataCache,
              options: ce
            }), re = new P.OperatorList(), Z = [], te = {
              get font() {
                return Z.at(-1);
              },
              set font(ae) {
                Z.push(ae);
              },
              clone() {
                return this;
              }
            }, L = /* @__PURE__ */ new Map();
            G.forEach((ae, se) => {
              L.set(ae, se);
            });
            const X = [];
            for (const [ae, se] of L) {
              const Q = se.get("FontDescriptor");
              if (!(Q instanceof e.Dict))
                continue;
              let z = Q.get("FontFamily");
              z = z.replaceAll(/[ ]+(\d)/g, "$1");
              const ie = Q.get("FontWeight"), ne = -Q.get("ItalicAngle"), W = {
                fontFamily: z,
                fontWeight: ie,
                italicAngle: ne
              };
              (0, C.validateCSSFont)(W) && X.push(q.handleSetFont(M, [e.Name.get(ae), 1], null, re, r, te, null, W).catch(function(oe) {
                return (0, n.warn)(`loadXfaFonts: "${oe}".`), null;
              }));
            }
            await Promise.all(X);
            const J = this.xfaFactory.setFonts(Z);
            if (!J)
              return;
            ce.ignoreErrors = !0, X.length = 0, Z.length = 0;
            const Y = /* @__PURE__ */ new Set();
            for (const ae of J)
              (0, t.getXfaFontName)(`${ae}-Regular`) || Y.add(ae);
            Y.size && J.push("PdfJS-Fallback");
            for (const ae of J)
              if (!Y.has(ae))
                for (const se of [{
                  name: "Regular",
                  fontWeight: 400,
                  italicAngle: 0
                }, {
                  name: "Bold",
                  fontWeight: 700,
                  italicAngle: 0
                }, {
                  name: "Italic",
                  fontWeight: 400,
                  italicAngle: 12
                }, {
                  name: "BoldItalic",
                  fontWeight: 700,
                  italicAngle: 12
                }]) {
                  const Q = `${ae}-${se.name}`, z = (0, t.getXfaFontDict)(Q);
                  X.push(q.handleSetFont(M, [e.Name.get(Q), 1], null, re, r, te, z, {
                    fontFamily: ae,
                    fontWeight: se.fontWeight,
                    italicAngle: se.italicAngle
                  }).catch(function(ie) {
                    return (0, n.warn)(`loadXfaFonts: "${ie}".`), null;
                  }));
                }
            await Promise.all(X), this.xfaFactory.appendFonts(Z, Y);
          }
          async serializeXfaData(s) {
            return this.xfaFactory ? this.xfaFactory.serializeData(s) : null;
          }
          get version() {
            return this.catalog.version || this._version;
          }
          get formInfo() {
            const s = {
              hasFields: !1,
              hasAcroForm: !1,
              hasXfa: !1,
              hasSignatures: !1
            }, r = this.catalog.acroForm;
            if (!r)
              return (0, n.shadow)(this, "formInfo", s);
            try {
              const y = r.get("Fields"), M = Array.isArray(y) && y.length > 0;
              s.hasFields = M;
              const $ = r.get("XFA");
              s.hasXfa = Array.isArray($) && $.length > 0 || $ instanceof l.BaseStream && !$.isEmpty;
              const ce = !!(r.get("SigFlags") & 1), q = ce && this._hasOnlyDocumentSignatures(y);
              s.hasAcroForm = M && !q, s.hasSignatures = ce;
            } catch (y) {
              if (y instanceof C.MissingDataException)
                throw y;
              (0, n.warn)(`Cannot fetch form information: "${y}".`);
            }
            return (0, n.shadow)(this, "formInfo", s);
          }
          get documentInfo() {
            const s = {
              PDFFormatVersion: this.version,
              Language: this.catalog.lang,
              EncryptFilterName: this.xref.encrypt ? this.xref.encrypt.filterName : null,
              IsLinearized: !!this.linearization,
              IsAcroFormPresent: this.formInfo.hasAcroForm,
              IsXFAPresent: this.formInfo.hasXfa,
              IsCollectionPresent: !!this.catalog.collection,
              IsSignaturesPresent: this.formInfo.hasSignatures
            };
            let r;
            try {
              r = this.xref.trailer.get("Info");
            } catch (y) {
              if (y instanceof C.MissingDataException)
                throw y;
              (0, n.info)("The document information dictionary is invalid.");
            }
            if (!(r instanceof e.Dict))
              return (0, n.shadow)(this, "documentInfo", s);
            for (const y of r.getKeys()) {
              const M = r.get(y);
              switch (y) {
                case "Title":
                case "Author":
                case "Subject":
                case "Keywords":
                case "Creator":
                case "Producer":
                case "CreationDate":
                case "ModDate":
                  if (typeof M == "string") {
                    s[y] = (0, n.stringToPDFString)(M);
                    continue;
                  }
                  break;
                case "Trapped":
                  if (M instanceof e.Name) {
                    s[y] = M;
                    continue;
                  }
                  break;
                default:
                  let $;
                  switch (typeof M) {
                    case "string":
                      $ = (0, n.stringToPDFString)(M);
                      break;
                    case "number":
                    case "boolean":
                      $ = M;
                      break;
                    default:
                      M instanceof e.Name && ($ = M);
                      break;
                  }
                  if ($ === void 0) {
                    (0, n.warn)(`Bad value, for custom key "${y}", in Info: ${M}.`);
                    continue;
                  }
                  s.Custom || (s.Custom = /* @__PURE__ */ Object.create(null)), s.Custom[y] = $;
                  continue;
              }
              (0, n.warn)(`Bad value, for key "${y}", in Info: ${M}.`);
            }
            return (0, n.shadow)(this, "documentInfo", s);
          }
          get fingerprints() {
            function s(G) {
              return typeof G == "string" && G.length > 0 && G !== S;
            }
            function r(G) {
              const ce = [];
              for (const q of G) {
                const re = q.toString(16);
                ce.push(re.padStart(2, "0"));
              }
              return ce.join("");
            }
            const y = this.xref.trailer.get("ID");
            let M, $;
            return Array.isArray(y) && s(y[0]) ? (M = (0, n.stringToBytes)(y[0]), y[1] !== y[0] && s(y[1]) && ($ = (0, n.stringToBytes)(y[1]))) : M = (0, j.calculateMD5)(this.stream.getByteRange(0, p), 0, p), (0, n.shadow)(this, "fingerprints", [r(M), $ ? r($) : null]);
          }
          async _getLinearizationPage(s) {
            const {
              catalog: r,
              linearization: y,
              xref: M
            } = this, $ = e.Ref.get(y.objectNumberFirst, 0);
            try {
              const G = await M.fetchAsync($);
              if (G instanceof e.Dict) {
                let ce = G.getRaw("Type");
                if (ce instanceof e.Ref && (ce = await M.fetchAsync(ce)), (0, e.isName)(ce, "Page") || !G.has("Type") && !G.has("Kids"))
                  return r.pageKidsCountCache.has($) || r.pageKidsCountCache.put($, 1), r.pageIndexCache.has($) || r.pageIndexCache.put($, 0), [G, $];
              }
              throw new n.FormatError("The Linearization dictionary doesn't point to a valid Page dictionary.");
            } catch (G) {
              return (0, n.warn)(`_getLinearizationPage: "${G.message}".`), r.getPageDict(s);
            }
          }
          getPage(s) {
            const r = this._pagePromises.get(s);
            if (r)
              return r;
            const {
              catalog: y,
              linearization: M,
              xfaFactory: $
            } = this;
            let G;
            return $ ? G = Promise.resolve([e.Dict.empty, null]) : (M == null ? void 0 : M.pageFirst) === s ? G = this._getLinearizationPage(s) : G = y.getPageDict(s), G = G.then(([ce, q]) => new f({
              pdfManager: this.pdfManager,
              xref: this.xref,
              pageIndex: s,
              pageDict: ce,
              ref: q,
              globalIdFactory: this._globalIdFactory,
              fontCache: y.fontCache,
              builtInCMapCache: y.builtInCMapCache,
              standardFontDataCache: y.standardFontDataCache,
              globalImageCache: y.globalImageCache,
              systemFontCache: y.systemFontCache,
              nonBlendModesSet: y.nonBlendModesSet,
              xfaFactory: $
            })), this._pagePromises.set(s, G), G;
          }
          async checkFirstPage(s = !1) {
            if (!s)
              try {
                await this.getPage(0);
              } catch (r) {
                if (r instanceof C.XRefEntryException)
                  throw this._pagePromises.delete(0), await this.cleanup(), new C.XRefParseException();
              }
          }
          async checkLastPage(s = !1) {
            const {
              catalog: r,
              pdfManager: y
            } = this;
            r.setActualNumPages();
            let M;
            try {
              if (await Promise.all([y.ensureDoc("xfaFactory"), y.ensureDoc("linearization"), y.ensureCatalog("numPages")]), this.xfaFactory)
                return;
              if (this.linearization ? M = this.linearization.numPages : M = r.numPages, Number.isInteger(M)) {
                if (M <= 1)
                  return;
              } else
                throw new n.FormatError("Page count is not an integer.");
              await this.getPage(M - 1);
            } catch ($) {
              if (this._pagePromises.delete(M - 1), await this.cleanup(), $ instanceof C.XRefEntryException && !s)
                throw new C.XRefParseException();
              (0, n.warn)(`checkLastPage - invalid /Pages tree /Count: ${M}.`);
              let G;
              try {
                G = await r.getAllPageDicts(s);
              } catch (ce) {
                if (ce instanceof C.XRefEntryException && !s)
                  throw new C.XRefParseException();
                r.setActualNumPages(1);
                return;
              }
              for (const [ce, [q, re]] of G) {
                let Z;
                q instanceof Error ? (Z = Promise.reject(q), Z.catch(() => {
                })) : Z = Promise.resolve(new f({
                  pdfManager: y,
                  xref: this.xref,
                  pageIndex: ce,
                  pageDict: q,
                  ref: re,
                  globalIdFactory: this._globalIdFactory,
                  fontCache: r.fontCache,
                  builtInCMapCache: r.builtInCMapCache,
                  standardFontDataCache: r.standardFontDataCache,
                  globalImageCache: r.globalImageCache,
                  systemFontCache: r.systemFontCache,
                  nonBlendModesSet: r.nonBlendModesSet,
                  xfaFactory: null
                })), this._pagePromises.set(ce, Z);
              }
              r.setActualNumPages(G.size);
            }
          }
          fontFallback(s, r) {
            return this.catalog.fontFallback(s, r);
          }
          async cleanup(s = !1) {
            return this.catalog ? this.catalog.cleanup(s) : (0, O.clearGlobalCaches)();
          }
          get fieldObjects() {
            if (!this.formInfo.hasFields)
              return (0, n.shadow)(this, "fieldObjects", Promise.resolve(null));
            const s = this.pdfManager.ensureDoc("annotationGlobals").then(async (r) => {
              if (!r)
                return null;
              const y = /* @__PURE__ */ Object.create(null), M = /* @__PURE__ */ new Map();
              for (const G of this.catalog.acroForm.get("Fields"))
                De(this, _, _i).call(this, "", G, M, r);
              const $ = [];
              for (const [G, ce] of M)
                $.push(Promise.all(ce).then((q) => {
                  q = q.filter((re) => !!re), q.length > 0 && (y[G] = q);
                }));
              return await Promise.all($), y;
            });
            return (0, n.shadow)(this, "fieldObjects", s);
          }
          get hasJSActions() {
            const s = this.pdfManager.ensureDoc("_parseHasJSActions");
            return (0, n.shadow)(this, "hasJSActions", s);
          }
          async _parseHasJSActions() {
            const [s, r] = await Promise.all([this.pdfManager.ensureCatalog("jsActions"), this.pdfManager.ensureDoc("fieldObjects")]);
            return s ? !0 : r ? Object.values(r).some((y) => y.some((M) => M.actions !== null)) : !1;
          }
          get calculationOrderIds() {
            const s = this.catalog.acroForm;
            if (!(s != null && s.has("CO")))
              return (0, n.shadow)(this, "calculationOrderIds", null);
            const r = s.get("CO");
            if (!Array.isArray(r) || r.length === 0)
              return (0, n.shadow)(this, "calculationOrderIds", null);
            const y = [];
            for (const M of r)
              M instanceof e.Ref && y.push(M.toString());
            return y.length === 0 ? (0, n.shadow)(this, "calculationOrderIds", null) : (0, n.shadow)(this, "calculationOrderIds", y);
          }
          get annotationGlobals() {
            return (0, n.shadow)(this, "annotationGlobals", F.AnnotationFactory.createGlobals(this.pdfManager));
          }
        }
        _ = new WeakSet(), _i = function(s, r, y, M) {
          const $ = this.xref.fetchIfRef(r);
          if ($.has("T")) {
            const G = (0, n.stringToPDFString)($.get("T"));
            s = s === "" ? G : `${s}.${G}`;
          }
          if (y.has(s) || y.set(s, []), y.get(s).push(F.AnnotationFactory.create(this.xref, r, M, this._localIdFactory, !0, null).then((G) => G == null ? void 0 : G.getFieldObject()).catch(function(G) {
            return (0, n.warn)(`#collectFieldObjects: "${G}".`), null;
          })), $.has("Kids"))
            for (const G of $.get("Kids"))
              De(this, _, _i).call(this, s, G, y, M);
        }, w.PDFDocument = T;
      },
      /* 10 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.PopupAnnotation = w.MarkupAnnotation = w.AnnotationFactory = w.AnnotationBorderStyle = w.Annotation = void 0, w.getQuadPoints = k;
        var n = V(2), F = V(3), C = V(11), e = V(4), t = V(8), l = V(5), j = V(60), U = V(66), O = V(12), v = V(69), g = V(26), b = V(76), i = V(64), P = V(73), d = V(77);
        class A {
          static createGlobals(L) {
            return Promise.all([L.ensureCatalog("acroForm"), L.ensureDoc("xfaDatasets"), L.ensureCatalog("structTreeRoot"), L.ensureCatalog("baseUrl"), L.ensureCatalog("attachments")]).then(([X, J, Y, ae, se]) => ({
              pdfManager: L,
              acroForm: X instanceof e.Dict ? X : e.Dict.empty,
              xfaDatasets: J,
              structTreeRoot: Y,
              baseUrl: ae,
              attachments: se
            }), (X) => ((0, n.warn)(`createGlobals: "${X}".`), null));
          }
          static async create(L, X, J, Y, ae, se) {
            const Q = ae ? await this._getPageIndex(L, X, J.pdfManager) : null;
            return J.pdfManager.ensure(this, "_create", [L, X, J, Y, ae, Q, se]);
          }
          static _create(L, X, J, Y, ae = !1, se = null, Q = null) {
            const z = L.fetchIfRef(X);
            if (!(z instanceof e.Dict))
              return;
            const {
              acroForm: ie,
              pdfManager: ne
            } = J, W = X instanceof e.Ref ? X.toString() : `annot_${Y.createObjId()}`;
            let oe = z.get("Subtype");
            oe = oe instanceof e.Name ? oe.name : null;
            const ue = {
              xref: L,
              ref: X,
              dict: z,
              subtype: oe,
              id: W,
              annotationGlobals: J,
              collectFields: ae,
              needAppearances: !ae && ie.get("NeedAppearances") === !0,
              pageIndex: se,
              evaluatorOptions: ne.evaluatorOptions,
              pageRef: Q
            };
            switch (oe) {
              case "Link":
                return new T(ue);
              case "Text":
                return new B(ue);
              case "Widget":
                let pe = (0, F.getInheritableProperty)({
                  dict: z,
                  key: "FT"
                });
                switch (pe = pe instanceof e.Name ? pe.name : null, pe) {
                  case "Tx":
                    return new N(ue);
                  case "Btn":
                    return new u(ue);
                  case "Ch":
                    return new p(ue);
                  case "Sig":
                    return new S(ue);
                }
                return (0, n.warn)(`Unimplemented widget field type "${pe}", falling back to base field type.`), new c(ue);
              case "Popup":
                return new D(ue);
              case "FreeText":
                return new K(ue);
              case "Line":
                return new _(ue);
              case "Square":
                return new o(ue);
              case "Circle":
                return new m(ue);
              case "PolyLine":
                return new s(ue);
              case "Polygon":
                return new r(ue);
              case "Caret":
                return new y(ue);
              case "Ink":
                return new M(ue);
              case "Highlight":
                return new $(ue);
              case "Underline":
                return new G(ue);
              case "Squiggly":
                return new ce(ue);
              case "StrikeOut":
                return new q(ue);
              case "Stamp":
                return new re(ue);
              case "FileAttachment":
                return new Z(ue);
              default:
                return ae || (oe ? (0, n.warn)(`Unimplemented annotation type "${oe}", falling back to base annotation.`) : (0, n.warn)("Annotation is missing the required /Subtype.")), new x(ue);
            }
          }
          static async _getPageIndex(L, X, J) {
            try {
              const Y = await L.fetchIfRefAsync(X);
              if (!(Y instanceof e.Dict))
                return -1;
              const ae = Y.getRaw("P");
              if (ae instanceof e.Ref)
                try {
                  return await J.ensureCatalog("getPageIndex", [ae]);
                } catch (Q) {
                  (0, n.info)(`_getPageIndex -- not a valid page reference: "${Q}".`);
                }
              if (Y.has("Kids"))
                return -1;
              const se = await J.ensureDoc("numPages");
              for (let Q = 0; Q < se; Q++) {
                const z = await J.getPage(Q), ie = await J.ensure(z, "annotations");
                for (const ne of ie)
                  if (ne instanceof e.Ref && (0, e.isRefsEqual)(ne, X))
                    return Q;
              }
            } catch (Y) {
              (0, n.warn)(`_getPageIndex: "${Y}".`);
            }
            return -1;
          }
          static generateImages(L, X, J) {
            if (!J)
              return (0, n.warn)("generateImages: OffscreenCanvas is not supported, cannot save or print some annotations with images."), null;
            let Y;
            for (const {
              bitmapId: ae,
              bitmap: se
            } of L)
              se && (Y || (Y = /* @__PURE__ */ new Map()), Y.set(ae, re.createImage(se, X)));
            return Y;
          }
          static async saveNewAnnotations(L, X, J, Y) {
            const ae = L.xref;
            let se;
            const Q = [], z = [], {
              isOffscreenCanvasSupported: ie
            } = L.options;
            for (const ne of J)
              if (!ne.deleted)
                switch (ne.annotationType) {
                  case n.AnnotationEditorType.FREETEXT:
                    if (!se) {
                      const oe = new e.Dict(ae);
                      oe.set("BaseFont", e.Name.get("Helvetica")), oe.set("Type", e.Name.get("Font")), oe.set("Subtype", e.Name.get("Type1")), oe.set("Encoding", e.Name.get("WinAnsiEncoding"));
                      const ue = [];
                      se = ae.getNewTemporaryRef(), await (0, P.writeObject)(se, oe, ue, ae), Q.push({
                        ref: se,
                        data: ue.join("")
                      });
                    }
                    z.push(K.createNewAnnotation(ae, ne, Q, {
                      evaluator: L,
                      task: X,
                      baseFontRef: se
                    }));
                    break;
                  case n.AnnotationEditorType.INK:
                    z.push(M.createNewAnnotation(ae, ne, Q));
                    break;
                  case n.AnnotationEditorType.STAMP:
                    if (!ie)
                      break;
                    const W = await Y.get(ne.bitmapId);
                    if (W.imageStream) {
                      const {
                        imageStream: oe,
                        smaskStream: ue
                      } = W, pe = [];
                      if (ue) {
                        const Ce = ae.getNewTemporaryRef();
                        await (0, P.writeObject)(Ce, ue, pe, ae), Q.push({
                          ref: Ce,
                          data: pe.join("")
                        }), oe.dict.set("SMask", Ce), pe.length = 0;
                      }
                      const ve = W.imageRef = ae.getNewTemporaryRef();
                      await (0, P.writeObject)(ve, oe, pe, ae), Q.push({
                        ref: ve,
                        data: pe.join("")
                      }), W.imageStream = W.smaskStream = null;
                    }
                    z.push(re.createNewAnnotation(ae, ne, Q, {
                      image: W
                    }));
                    break;
                }
            return {
              annotations: await Promise.all(z),
              dependencies: Q
            };
          }
          static async printNewAnnotations(L, X, J, Y, ae) {
            if (!Y)
              return null;
            const {
              options: se,
              xref: Q
            } = X, z = [];
            for (const ie of Y)
              if (!ie.deleted)
                switch (ie.annotationType) {
                  case n.AnnotationEditorType.FREETEXT:
                    z.push(K.createNewPrintAnnotation(L, Q, ie, {
                      evaluator: X,
                      task: J,
                      evaluatorOptions: se
                    }));
                    break;
                  case n.AnnotationEditorType.INK:
                    z.push(M.createNewPrintAnnotation(L, Q, ie, {
                      evaluatorOptions: se
                    }));
                    break;
                  case n.AnnotationEditorType.STAMP:
                    if (!se.isOffscreenCanvasSupported)
                      break;
                    const ne = await ae.get(ie.bitmapId);
                    if (ne.imageStream) {
                      const {
                        imageStream: W,
                        smaskStream: oe
                      } = ne;
                      oe && W.dict.set("SMask", oe), ne.imageRef = new g.JpegStream(W, W.length), ne.imageStream = ne.smaskStream = null;
                    }
                    z.push(re.createNewPrintAnnotation(L, Q, ie, {
                      image: ne,
                      evaluatorOptions: se
                    }));
                    break;
                }
            return Promise.all(z);
          }
        }
        w.AnnotationFactory = A;
        function I(te, L = new Uint8ClampedArray(3)) {
          if (!Array.isArray(te))
            return L;
          const X = L || new Uint8ClampedArray(3);
          switch (te.length) {
            case 0:
              return null;
            case 1:
              return O.ColorSpace.singletons.gray.getRgbItem(te, 0, X, 0), X;
            case 3:
              return O.ColorSpace.singletons.rgb.getRgbItem(te, 0, X, 0), X;
            case 4:
              return O.ColorSpace.singletons.cmyk.getRgbItem(te, 0, X, 0), X;
            default:
              return L;
          }
        }
        function E(te) {
          return Array.from(te, (L) => L / 255);
        }
        function k(te, L) {
          const X = te.getArray("QuadPoints");
          if (!Array.isArray(X) || X.length === 0 || X.length % 8 > 0)
            return null;
          const J = [];
          for (let Y = 0, ae = X.length / 8; Y < ae; Y++) {
            let se = 1 / 0, Q = -1 / 0, z = 1 / 0, ie = -1 / 0;
            for (let ne = Y * 8, W = Y * 8 + 8; ne < W; ne += 2) {
              const oe = X[ne], ue = X[ne + 1];
              se = Math.min(oe, se), Q = Math.max(oe, Q), z = Math.min(ue, z), ie = Math.max(ue, ie);
            }
            if (L !== null && (se < L[0] || Q > L[2] || z < L[1] || ie > L[3]))
              return null;
            J.push([{
              x: se,
              y: ie
            }, {
              x: Q,
              y: ie
            }, {
              x: se,
              y: z
            }, {
              x: Q,
              y: z
            }]);
          }
          return J;
        }
        function H(te, L, X) {
          const [J, Y, ae, se] = n.Util.getAxialAlignedBoundingBox(L, X);
          if (J === ae || Y === se)
            return [1, 0, 0, 1, te[0], te[1]];
          const Q = (te[2] - te[0]) / (ae - J), z = (te[3] - te[1]) / (se - Y);
          return [Q, 0, 0, z, te[0] - J * Q, te[1] - Y * z];
        }
        class x {
          constructor(L) {
            const {
              dict: X,
              xref: J,
              annotationGlobals: Y
            } = L;
            this.setTitle(X.get("T")), this.setContents(X.get("Contents")), this.setModificationDate(X.get("M")), this.setFlags(X.get("F")), this.setRectangle(X.getArray("Rect")), this.setColor(X.getArray("C")), this.setBorderStyle(X), this.setAppearance(X), this.setOptionalContent(X);
            const ae = X.get("MK");
            this.setBorderAndBackgroundColors(ae), this.setRotation(ae, X), this.ref = L.ref instanceof e.Ref ? L.ref : null, this._streams = [], this.appearance && this._streams.push(this.appearance);
            const se = !!(this.flags & n.AnnotationFlag.LOCKED), Q = !!(this.flags & n.AnnotationFlag.LOCKEDCONTENTS);
            if (Y.structTreeRoot) {
              let z = X.get("StructParent");
              z = Number.isInteger(z) && z >= 0 ? z : -1, Y.structTreeRoot.addAnnotationIdToPage(L.pageRef, z);
            }
            if (this.data = {
              annotationFlags: this.flags,
              borderStyle: this.borderStyle,
              color: this.color,
              backgroundColor: this.backgroundColor,
              borderColor: this.borderColor,
              rotation: this.rotation,
              contentsObj: this._contents,
              hasAppearance: !!this.appearance,
              id: L.id,
              modificationDate: this.modificationDate,
              rect: this.rectangle,
              subtype: L.subtype,
              hasOwnCanvas: !1,
              noRotate: !!(this.flags & n.AnnotationFlag.NOROTATE),
              noHTML: se && Q
            }, L.collectFields) {
              const z = X.get("Kids");
              if (Array.isArray(z)) {
                const ie = [];
                for (const ne of z)
                  ne instanceof e.Ref && ie.push(ne.toString());
                ie.length !== 0 && (this.data.kidIds = ie);
              }
              this.data.actions = (0, F.collectActions)(J, X, n.AnnotationActionEventType), this.data.fieldName = this._constructFieldName(X), this.data.pageIndex = L.pageIndex;
            }
            this._isOffscreenCanvasSupported = L.evaluatorOptions.isOffscreenCanvasSupported, this._fallbackFontDict = null, this._needAppearances = !1;
          }
          _hasFlag(L, X) {
            return !!(L & X);
          }
          _isViewable(L) {
            return !this._hasFlag(L, n.AnnotationFlag.INVISIBLE) && !this._hasFlag(L, n.AnnotationFlag.NOVIEW);
          }
          _isPrintable(L) {
            return this._hasFlag(L, n.AnnotationFlag.PRINT) && !this._hasFlag(L, n.AnnotationFlag.HIDDEN) && !this._hasFlag(L, n.AnnotationFlag.INVISIBLE);
          }
          mustBeViewed(L, X) {
            var Y;
            const J = (Y = L == null ? void 0 : L.get(this.data.id)) == null ? void 0 : Y.noView;
            return J !== void 0 ? !J : this.viewable && !this._hasFlag(this.flags, n.AnnotationFlag.HIDDEN);
          }
          mustBePrinted(L) {
            var J;
            const X = (J = L == null ? void 0 : L.get(this.data.id)) == null ? void 0 : J.noPrint;
            return X !== void 0 ? !X : this.printable;
          }
          get viewable() {
            return this.data.quadPoints === null ? !1 : this.flags === 0 ? !0 : this._isViewable(this.flags);
          }
          get printable() {
            return this.data.quadPoints === null || this.flags === 0 ? !1 : this._isPrintable(this.flags);
          }
          _parseStringHelper(L) {
            const X = typeof L == "string" ? (0, n.stringToPDFString)(L) : "", J = X && (0, j.bidi)(X).dir === "rtl" ? "rtl" : "ltr";
            return {
              str: X,
              dir: J
            };
          }
          setDefaultAppearance(L) {
            const {
              dict: X,
              annotationGlobals: J
            } = L, Y = (0, F.getInheritableProperty)({
              dict: X,
              key: "DA"
            }) || J.acroForm.get("DA");
            this._defaultAppearance = typeof Y == "string" ? Y : "", this.data.defaultAppearanceData = (0, C.parseDefaultAppearance)(this._defaultAppearance);
          }
          setTitle(L) {
            this._title = this._parseStringHelper(L);
          }
          setContents(L) {
            this._contents = this._parseStringHelper(L);
          }
          setModificationDate(L) {
            this.modificationDate = typeof L == "string" ? L : null;
          }
          setFlags(L) {
            this.flags = Number.isInteger(L) && L > 0 ? L : 0;
          }
          hasFlag(L) {
            return this._hasFlag(this.flags, L);
          }
          setRectangle(L) {
            this.rectangle = Array.isArray(L) && L.length === 4 ? n.Util.normalizeRect(L) : [0, 0, 0, 0];
          }
          setColor(L) {
            this.color = I(L);
          }
          setLineEndings(L) {
            if (this.lineEndings = ["None", "None"], Array.isArray(L) && L.length === 2)
              for (let X = 0; X < 2; X++) {
                const J = L[X];
                if (J instanceof e.Name)
                  switch (J.name) {
                    case "None":
                      continue;
                    case "Square":
                    case "Circle":
                    case "Diamond":
                    case "OpenArrow":
                    case "ClosedArrow":
                    case "Butt":
                    case "ROpenArrow":
                    case "RClosedArrow":
                    case "Slash":
                      this.lineEndings[X] = J.name;
                      continue;
                  }
                (0, n.warn)(`Ignoring invalid lineEnding: ${J}`);
              }
          }
          setRotation(L, X) {
            this.rotation = 0;
            let J = L instanceof e.Dict ? L.get("R") || 0 : X.get("Rotate") || 0;
            Number.isInteger(J) && J !== 0 && (J %= 360, J < 0 && (J += 360), J % 90 === 0 && (this.rotation = J));
          }
          setBorderAndBackgroundColors(L) {
            L instanceof e.Dict ? (this.borderColor = I(L.getArray("BC"), null), this.backgroundColor = I(L.getArray("BG"), null)) : this.borderColor = this.backgroundColor = null;
          }
          setBorderStyle(L) {
            if (this.borderStyle = new R(), L instanceof e.Dict)
              if (L.has("BS")) {
                const X = L.get("BS"), J = X.get("Type");
                (!J || (0, e.isName)(J, "Border")) && (this.borderStyle.setWidth(X.get("W"), this.rectangle), this.borderStyle.setStyle(X.get("S")), this.borderStyle.setDashArray(X.getArray("D")));
              } else if (L.has("Border")) {
                const X = L.getArray("Border");
                Array.isArray(X) && X.length >= 3 && (this.borderStyle.setHorizontalCornerRadius(X[0]), this.borderStyle.setVerticalCornerRadius(X[1]), this.borderStyle.setWidth(X[2], this.rectangle), X.length === 4 && this.borderStyle.setDashArray(X[3], !0));
              } else
                this.borderStyle.setWidth(0);
          }
          setAppearance(L) {
            this.appearance = null;
            const X = L.get("AP");
            if (!(X instanceof e.Dict))
              return;
            const J = X.get("N");
            if (J instanceof l.BaseStream) {
              this.appearance = J;
              return;
            }
            if (!(J instanceof e.Dict))
              return;
            const Y = L.get("AS");
            if (!(Y instanceof e.Name) || !J.has(Y.name))
              return;
            const ae = J.get(Y.name);
            ae instanceof l.BaseStream && (this.appearance = ae);
          }
          setOptionalContent(L) {
            this.oc = null;
            const X = L.get("OC");
            X instanceof e.Name ? (0, n.warn)("setOptionalContent: Support for /Name-entry is not implemented.") : X instanceof e.Dict && (this.oc = X);
          }
          loadResources(L, X) {
            return X.dict.getAsync("Resources").then((J) => J ? new b.ObjectLoader(J, L, J.xref).load().then(function() {
              return J;
            }) : void 0);
          }
          async getOperatorList(L, X, J, Y, ae) {
            const se = this.data;
            let Q = this.appearance;
            const z = !!(this.data.hasOwnCanvas && J & n.RenderingIntentFlag.DISPLAY);
            if (!Q) {
              if (!z)
                return {
                  opList: new i.OperatorList(),
                  separateForm: !1,
                  separateCanvas: !1
                };
              Q = new t.StringStream(""), Q.dict = new e.Dict();
            }
            const ie = Q.dict, ne = await this.loadResources(["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"], Q), W = ie.getArray("BBox") || [0, 0, 1, 1], oe = ie.getArray("Matrix") || [1, 0, 0, 1, 0, 0], ue = H(se.rect, W, oe), pe = new i.OperatorList();
            let ve;
            return this.oc && (ve = await L.parseMarkedContentProps(this.oc, null)), ve !== void 0 && pe.addOp(n.OPS.beginMarkedContentProps, ["OC", ve]), pe.addOp(n.OPS.beginAnnotation, [se.id, se.rect, ue, oe, z]), await L.getOperatorList({
              stream: Q,
              task: X,
              resources: ne,
              operatorList: pe,
              fallbackFontDict: this._fallbackFontDict
            }), pe.addOp(n.OPS.endAnnotation, []), ve !== void 0 && pe.addOp(n.OPS.endMarkedContent, []), this.reset(), {
              opList: pe,
              separateForm: !1,
              separateCanvas: z
            };
          }
          async save(L, X, J) {
            return null;
          }
          get hasTextContent() {
            return !1;
          }
          async extractTextContent(L, X, J) {
            if (!this.appearance)
              return;
            const Y = await this.loadResources(["ExtGState", "Font", "Properties", "XObject"], this.appearance), ae = [], se = [];
            let Q = null;
            const z = {
              desiredSize: Math.Infinity,
              ready: !0,
              enqueue(ie, ne) {
                for (const W of ie.items)
                  W.str !== void 0 && (Q || (Q = W.transform.slice(-2)), se.push(W.str), W.hasEOL && (ae.push(se.join("")), se.length = 0));
              }
            };
            if (await L.getTextContent({
              stream: this.appearance,
              task: X,
              resources: Y,
              includeMarkedContent: !0,
              sink: z,
              viewBox: J
            }), this.reset(), se.length && ae.push(se.join("")), ae.length > 1 || ae[0]) {
              const ie = this.appearance.dict, ne = ie.getArray("BBox") || [0, 0, 1, 1], W = ie.getArray("Matrix") || [1, 0, 0, 1, 0, 0], oe = this.data.rect, ue = H(oe, ne, W);
              ue[4] -= oe[0], ue[5] -= oe[1], Q = n.Util.applyTransform(Q, ue), Q = n.Util.applyTransform(Q, W), this.data.textPosition = Q, this.data.textContent = ae;
            }
          }
          getFieldObject() {
            return this.data.kidIds ? {
              id: this.data.id,
              actions: this.data.actions,
              name: this.data.fieldName,
              strokeColor: this.data.borderColor,
              fillColor: this.data.backgroundColor,
              type: "",
              kidIds: this.data.kidIds,
              page: this.data.pageIndex,
              rotation: this.rotation
            } : null;
          }
          reset() {
            for (const L of this._streams)
              L.reset();
          }
          _constructFieldName(L) {
            if (!L.has("T") && !L.has("Parent"))
              return (0, n.warn)("Unknown field name, falling back to empty field name."), "";
            if (!L.has("Parent"))
              return (0, n.stringToPDFString)(L.get("T"));
            const X = [];
            L.has("T") && X.unshift((0, n.stringToPDFString)(L.get("T")));
            let J = L;
            const Y = new e.RefSet();
            for (L.objId && Y.put(L.objId); J.has("Parent") && (J = J.get("Parent"), !(!(J instanceof e.Dict) || J.objId && Y.has(J.objId))); )
              J.objId && Y.put(J.objId), J.has("T") && X.unshift((0, n.stringToPDFString)(J.get("T")));
            return X.join(".");
          }
        }
        w.Annotation = x;
        class R {
          constructor() {
            this.width = 1, this.style = n.AnnotationBorderStyleType.SOLID, this.dashArray = [3], this.horizontalCornerRadius = 0, this.verticalCornerRadius = 0;
          }
          setWidth(L, X = [0, 0, 0, 0]) {
            if (L instanceof e.Name) {
              this.width = 0;
              return;
            }
            if (typeof L == "number") {
              if (L > 0) {
                const J = (X[2] - X[0]) / 2, Y = (X[3] - X[1]) / 2;
                J > 0 && Y > 0 && (L > J || L > Y) && ((0, n.warn)(`AnnotationBorderStyle.setWidth - ignoring width: ${L}`), L = 1);
              }
              this.width = L;
            }
          }
          setStyle(L) {
            if (L instanceof e.Name)
              switch (L.name) {
                case "S":
                  this.style = n.AnnotationBorderStyleType.SOLID;
                  break;
                case "D":
                  this.style = n.AnnotationBorderStyleType.DASHED;
                  break;
                case "B":
                  this.style = n.AnnotationBorderStyleType.BEVELED;
                  break;
                case "I":
                  this.style = n.AnnotationBorderStyleType.INSET;
                  break;
                case "U":
                  this.style = n.AnnotationBorderStyleType.UNDERLINE;
                  break;
              }
          }
          setDashArray(L, X = !1) {
            if (Array.isArray(L) && L.length > 0) {
              let J = !0, Y = !0;
              for (const ae of L)
                if (+ae >= 0)
                  ae > 0 && (Y = !1);
                else {
                  J = !1;
                  break;
                }
              J && !Y ? (this.dashArray = L, X && this.setStyle(e.Name.get("D"))) : this.width = 0;
            } else
              L && (this.width = 0);
          }
          setHorizontalCornerRadius(L) {
            Number.isInteger(L) && (this.horizontalCornerRadius = L);
          }
          setVerticalCornerRadius(L) {
            Number.isInteger(L) && (this.verticalCornerRadius = L);
          }
        }
        w.AnnotationBorderStyle = R;
        class f extends x {
          constructor(L) {
            super(L);
            const {
              dict: X
            } = L;
            if (X.has("IRT")) {
              const Y = X.getRaw("IRT");
              this.data.inReplyTo = Y instanceof e.Ref ? Y.toString() : null;
              const ae = X.get("RT");
              this.data.replyType = ae instanceof e.Name ? ae.name : n.AnnotationReplyType.REPLY;
            }
            let J = null;
            if (this.data.replyType === n.AnnotationReplyType.GROUP) {
              const Y = X.get("IRT");
              this.setTitle(Y.get("T")), this.data.titleObj = this._title, this.setContents(Y.get("Contents")), this.data.contentsObj = this._contents, Y.has("CreationDate") ? (this.setCreationDate(Y.get("CreationDate")), this.data.creationDate = this.creationDate) : this.data.creationDate = null, Y.has("M") ? (this.setModificationDate(Y.get("M")), this.data.modificationDate = this.modificationDate) : this.data.modificationDate = null, J = Y.getRaw("Popup"), Y.has("C") ? (this.setColor(Y.getArray("C")), this.data.color = this.color) : this.data.color = null;
            } else
              this.data.titleObj = this._title, this.setCreationDate(X.get("CreationDate")), this.data.creationDate = this.creationDate, J = X.getRaw("Popup"), X.has("C") || (this.data.color = null);
            this.data.popupRef = J instanceof e.Ref ? J.toString() : null, X.has("RC") && (this.data.richText = d.XFAFactory.getRichTextAsHtml(X.get("RC")));
          }
          setCreationDate(L) {
            this.creationDate = typeof L == "string" ? L : null;
          }
          _setDefaultAppearance({
            xref: L,
            extra: X,
            strokeColor: J,
            fillColor: Y,
            blendMode: ae,
            strokeAlpha: se,
            fillAlpha: Q,
            pointsCallback: z
          }) {
            let ie = Number.MAX_VALUE, ne = Number.MAX_VALUE, W = Number.MIN_VALUE, oe = Number.MIN_VALUE;
            const ue = ["q"];
            X && ue.push(X), J && ue.push(`${J[0]} ${J[1]} ${J[2]} RG`), Y && ue.push(`${Y[0]} ${Y[1]} ${Y[2]} rg`);
            let pe = this.data.quadPoints;
            pe || (pe = [[{
              x: this.rectangle[0],
              y: this.rectangle[3]
            }, {
              x: this.rectangle[2],
              y: this.rectangle[3]
            }, {
              x: this.rectangle[0],
              y: this.rectangle[1]
            }, {
              x: this.rectangle[2],
              y: this.rectangle[1]
            }]]);
            for (const Se of pe) {
              const [Ae, Te, ke, Ee] = z(ue, Se);
              ie = Math.min(ie, Ae), W = Math.max(W, Te), ne = Math.min(ne, ke), oe = Math.max(oe, Ee);
            }
            ue.push("Q");
            const ve = new e.Dict(L), Ce = new e.Dict(L);
            Ce.set("Subtype", e.Name.get("Form"));
            const Fe = new t.StringStream(ue.join(" "));
            Fe.dict = Ce, ve.set("Fm0", Fe);
            const Pe = new e.Dict(L);
            ae && Pe.set("BM", e.Name.get(ae)), typeof se == "number" && Pe.set("CA", se), typeof Q == "number" && Pe.set("ca", Q);
            const be = new e.Dict(L);
            be.set("GS0", Pe);
            const me = new e.Dict(L);
            me.set("ExtGState", be), me.set("XObject", ve);
            const we = new e.Dict(L);
            we.set("Resources", me);
            const _e = this.data.rect = [ie, ne, W, oe];
            we.set("BBox", _e), this.appearance = new t.StringStream("/GS0 gs /Fm0 Do"), this.appearance.dict = we, this._streams.push(this.appearance, Fe);
          }
          static async createNewAnnotation(L, X, J, Y) {
            const ae = X.ref || (X.ref = L.getNewTemporaryRef()), se = await this.createNewAppearanceStream(X, L, Y), Q = [];
            let z;
            if (se) {
              const ie = L.getNewTemporaryRef();
              z = this.createNewDict(X, L, {
                apRef: ie
              }), await (0, P.writeObject)(ie, se, Q, L), J.push({
                ref: ie,
                data: Q.join("")
              });
            } else
              z = this.createNewDict(X, L, {});
            return Number.isInteger(X.parentTreeId) && z.set("StructParent", X.parentTreeId), Q.length = 0, await (0, P.writeObject)(ae, z, Q, L), {
              ref: ae,
              data: Q.join("")
            };
          }
          static async createNewPrintAnnotation(L, X, J, Y) {
            const ae = await this.createNewAppearanceStream(J, X, Y), se = this.createNewDict(J, X, {
              ap: ae
            }), Q = new this.prototype.constructor({
              dict: se,
              xref: X,
              annotationGlobals: L,
              evaluatorOptions: Y.evaluatorOptions
            });
            return J.ref && (Q.ref = Q.refToReplace = J.ref), Q;
          }
        }
        w.MarkupAnnotation = f;
        class c extends x {
          constructor(L) {
            var oe;
            super(L);
            const {
              dict: X,
              xref: J,
              annotationGlobals: Y
            } = L, ae = this.data;
            this._needAppearances = L.needAppearances, ae.annotationType = n.AnnotationType.WIDGET, ae.fieldName === void 0 && (ae.fieldName = this._constructFieldName(X)), ae.actions === void 0 && (ae.actions = (0, F.collectActions)(J, X, n.AnnotationActionEventType));
            let se = (0, F.getInheritableProperty)({
              dict: X,
              key: "V",
              getArray: !0
            });
            ae.fieldValue = this._decodeFormValue(se);
            const Q = (0, F.getInheritableProperty)({
              dict: X,
              key: "DV",
              getArray: !0
            });
            if (ae.defaultFieldValue = this._decodeFormValue(Q), se === void 0 && Y.xfaDatasets) {
              const ue = this._title.str;
              ue && (this._hasValueFromXFA = !0, ae.fieldValue = se = Y.xfaDatasets.getValue(ue));
            }
            se === void 0 && ae.defaultFieldValue !== null && (ae.fieldValue = ae.defaultFieldValue), ae.alternativeText = (0, n.stringToPDFString)(X.get("TU") || ""), this.setDefaultAppearance(L), ae.hasAppearance || (ae.hasAppearance = this._needAppearances && ae.fieldValue !== void 0 && ae.fieldValue !== null);
            const z = (0, F.getInheritableProperty)({
              dict: X,
              key: "FT"
            });
            ae.fieldType = z instanceof e.Name ? z.name : null;
            const ie = (0, F.getInheritableProperty)({
              dict: X,
              key: "DR"
            }), ne = Y.acroForm.get("DR"), W = (oe = this.appearance) == null ? void 0 : oe.dict.get("Resources");
            this._fieldResources = {
              localResources: ie,
              acroFormResources: ne,
              appearanceResources: W,
              mergedResources: e.Dict.merge({
                xref: J,
                dictArray: [ie, W, ne],
                mergeSubDicts: !0
              })
            }, ae.fieldFlags = (0, F.getInheritableProperty)({
              dict: X,
              key: "Ff"
            }), (!Number.isInteger(ae.fieldFlags) || ae.fieldFlags < 0) && (ae.fieldFlags = 0), ae.readOnly = this.hasFieldFlag(n.AnnotationFieldFlag.READONLY), ae.required = this.hasFieldFlag(n.AnnotationFieldFlag.REQUIRED), ae.hidden = this._hasFlag(ae.annotationFlags, n.AnnotationFlag.HIDDEN) || this._hasFlag(ae.annotationFlags, n.AnnotationFlag.NOVIEW);
          }
          _decodeFormValue(L) {
            return Array.isArray(L) ? L.filter((X) => typeof X == "string").map((X) => (0, n.stringToPDFString)(X)) : L instanceof e.Name ? (0, n.stringToPDFString)(L.name) : typeof L == "string" ? (0, n.stringToPDFString)(L) : null;
          }
          hasFieldFlag(L) {
            return !!(this.data.fieldFlags & L);
          }
          _isViewable(L) {
            return !this._hasFlag(L, n.AnnotationFlag.INVISIBLE);
          }
          mustBeViewed(L, X) {
            return X ? this.viewable : super.mustBeViewed(L, X) && !this._hasFlag(this.flags, n.AnnotationFlag.NOVIEW);
          }
          getRotationMatrix(L) {
            var ae;
            let X = (ae = L == null ? void 0 : L.get(this.data.id)) == null ? void 0 : ae.rotation;
            if (X === void 0 && (X = this.rotation), X === 0)
              return n.IDENTITY_MATRIX;
            const J = this.data.rect[2] - this.data.rect[0], Y = this.data.rect[3] - this.data.rect[1];
            return (0, F.getRotationMatrix)(X, J, Y);
          }
          getBorderAndBackgroundAppearances(L) {
            var Q;
            let X = (Q = L == null ? void 0 : L.get(this.data.id)) == null ? void 0 : Q.rotation;
            if (X === void 0 && (X = this.rotation), !this.backgroundColor && !this.borderColor)
              return "";
            const J = this.data.rect[2] - this.data.rect[0], Y = this.data.rect[3] - this.data.rect[1], ae = X === 0 || X === 180 ? `0 0 ${J} ${Y} re` : `0 0 ${Y} ${J} re`;
            let se = "";
            if (this.backgroundColor && (se = `${(0, C.getPdfColor)(this.backgroundColor, !0)} ${ae} f `), this.borderColor) {
              const z = this.borderStyle.width || 1;
              se += `${z} w ${(0, C.getPdfColor)(this.borderColor, !1)} ${ae} S `;
            }
            return se;
          }
          async getOperatorList(L, X, J, Y, ae) {
            if (Y && !(this instanceof S) && !this.data.noHTML && !this.data.hasOwnCanvas)
              return {
                opList: new i.OperatorList(),
                separateForm: !0,
                separateCanvas: !1
              };
            if (!this._hasText)
              return super.getOperatorList(L, X, J, Y, ae);
            const se = await this._getAppearance(L, X, J, ae);
            if (this.appearance && se === null)
              return super.getOperatorList(L, X, J, Y, ae);
            const Q = new i.OperatorList();
            if (!this._defaultAppearance || se === null)
              return {
                opList: Q,
                separateForm: !1,
                separateCanvas: !1
              };
            const z = !!(this.data.hasOwnCanvas && J & n.RenderingIntentFlag.DISPLAY), ie = [1, 0, 0, 1, 0, 0], ne = [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]], W = H(this.data.rect, ne, ie);
            let oe;
            this.oc && (oe = await L.parseMarkedContentProps(this.oc, null)), oe !== void 0 && Q.addOp(n.OPS.beginMarkedContentProps, ["OC", oe]), Q.addOp(n.OPS.beginAnnotation, [this.data.id, this.data.rect, W, this.getRotationMatrix(ae), z]);
            const ue = new t.StringStream(se);
            return await L.getOperatorList({
              stream: ue,
              task: X,
              resources: this._fieldResources.mergedResources,
              operatorList: Q
            }), Q.addOp(n.OPS.endAnnotation, []), oe !== void 0 && Q.addOp(n.OPS.endMarkedContent, []), {
              opList: Q,
              separateForm: !1,
              separateCanvas: z
            };
          }
          _getMKDict(L) {
            const X = new e.Dict(null);
            return L && X.set("R", L), this.borderColor && X.set("BC", E(this.borderColor)), this.backgroundColor && X.set("BG", E(this.backgroundColor)), X.size > 0 ? X : null;
          }
          amendSavedDict(L, X) {
          }
          async save(L, X, J) {
            const Y = J == null ? void 0 : J.get(this.data.id);
            let ae = Y == null ? void 0 : Y.value, se = Y == null ? void 0 : Y.rotation;
            if (ae === this.data.fieldValue || ae === void 0) {
              if (!this._hasValueFromXFA && se === void 0)
                return null;
              ae || (ae = this.data.fieldValue);
            }
            if (se === void 0 && !this._hasValueFromXFA && Array.isArray(ae) && Array.isArray(this.data.fieldValue) && ae.length === this.data.fieldValue.length && ae.every((Fe, Pe) => Fe === this.data.fieldValue[Pe]))
              return null;
            se === void 0 && (se = this.rotation);
            let Q = null;
            if (!this._needAppearances && (Q = await this._getAppearance(L, X, n.RenderingIntentFlag.SAVE, J), Q === null))
              return null;
            let z = !1;
            Q != null && Q.needAppearances && (z = !0, Q = null);
            const {
              xref: ie
            } = L, ne = ie.fetchIfRef(this.ref);
            if (!(ne instanceof e.Dict))
              return null;
            const W = new e.Dict(ie);
            for (const Fe of ne.getKeys())
              Fe !== "AP" && W.set(Fe, ne.getRaw(Fe));
            const oe = {
              path: this.data.fieldName,
              value: ae
            }, ue = (Fe) => (0, F.isAscii)(Fe) ? Fe : (0, F.stringToUTF16String)(Fe, !0);
            W.set("V", Array.isArray(ae) ? ae.map(ue) : ue(ae)), this.amendSavedDict(J, W);
            const pe = this._getMKDict(se);
            pe && W.set("MK", pe);
            const ve = [], Ce = [{
              ref: this.ref,
              data: "",
              xfa: oe,
              needAppearances: z
            }];
            if (Q !== null) {
              const Fe = ie.getNewTemporaryRef(), Pe = new e.Dict(ie);
              W.set("AP", Pe), Pe.set("N", Fe);
              const be = this._getSaveFieldResources(ie), me = new t.StringStream(Q), we = me.dict = new e.Dict(ie);
              we.set("Subtype", e.Name.get("Form")), we.set("Resources", be), we.set("BBox", [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]]);
              const _e = this.getRotationMatrix(J);
              _e !== n.IDENTITY_MATRIX && we.set("Matrix", _e), await (0, P.writeObject)(Fe, me, ve, ie), Ce.push({
                ref: Fe,
                data: ve.join(""),
                xfa: null,
                needAppearances: !1
              }), ve.length = 0;
            }
            return W.set("M", `D:${(0, n.getModificationDate)()}`), await (0, P.writeObject)(this.ref, W, ve, ie), Ce[0].data = ve.join(""), Ce;
          }
          async _getAppearance(L, X, J, Y) {
            if (this.hasFieldFlag(n.AnnotationFieldFlag.PASSWORD))
              return null;
            const se = Y == null ? void 0 : Y.get(this.data.id);
            let Q, z;
            if (se && (Q = se.formattedValue || se.value, z = se.rotation), z === void 0 && Q === void 0 && !this._needAppearances && (!this._hasValueFromXFA || this.appearance))
              return null;
            const ie = this.getBorderAndBackgroundAppearances(Y);
            if (Q === void 0 && (Q = this.data.fieldValue, !Q))
              return `/Tx BMC q ${ie}Q EMC`;
            if (Array.isArray(Q) && Q.length === 1 && (Q = Q[0]), (0, n.assert)(typeof Q == "string", "Expected `value` to be a string."), Q = Q.trim(), this.data.combo) {
              const Ve = this.data.options.find(({
                exportValue: je
              }) => Q === je);
              Q = (Ve == null ? void 0 : Ve.displayValue) || Q;
            }
            if (Q === "")
              return `/Tx BMC q ${ie}Q EMC`;
            z === void 0 && (z = this.rotation);
            let ne = -1, W;
            this.data.multiLine ? (W = Q.split(/\r\n?|\n/).map((Ve) => Ve.normalize("NFC")), ne = W.length) : W = [Q.replace(/\r\n?|\n/, "").normalize("NFC")];
            const oe = 1, ue = 2;
            let pe = this.data.rect[3] - this.data.rect[1], ve = this.data.rect[2] - this.data.rect[0];
            (z === 90 || z === 270) && ([ve, pe] = [pe, ve]), this._defaultAppearance || (this.data.defaultAppearanceData = (0, C.parseDefaultAppearance)(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
            let Ce = await c._getFontData(L, X, this.data.defaultAppearanceData, this._fieldResources.mergedResources), Fe, Pe, be;
            const me = [];
            let we = !1;
            for (const Ve of W) {
              const je = Ce.encodeString(Ve);
              je.length > 1 && (we = !0), me.push(je.join(""));
            }
            if (we && J & n.RenderingIntentFlag.SAVE)
              return {
                needAppearances: !0
              };
            if (we && this._isOffscreenCanvasSupported) {
              const Ve = this.data.comb ? "monospace" : "sans-serif", je = new C.FakeUnicodeFont(L.xref, Ve), at = je.createFontResources(W.join("")), $e = at.getRaw("Font");
              if (this._fieldResources.mergedResources.has("Font")) {
                const Ye = this._fieldResources.mergedResources.get("Font");
                for (const Qe of $e.getKeys())
                  Ye.set(Qe, $e.getRaw(Qe));
              } else
                this._fieldResources.mergedResources.set("Font", $e);
              const ct = je.fontName.name;
              Ce = await c._getFontData(L, X, {
                fontName: ct,
                fontSize: 0
              }, at);
              for (let Ye = 0, Qe = me.length; Ye < Qe; Ye++)
                me[Ye] = (0, F.stringToUTF16String)(W[Ye]);
              const ze = Object.assign(/* @__PURE__ */ Object.create(null), this.data.defaultAppearanceData);
              this.data.defaultAppearanceData.fontSize = 0, this.data.defaultAppearanceData.fontName = ct, [Fe, Pe, be] = this._computeFontSize(pe - 2 * oe, ve - 2 * ue, Q, Ce, ne), this.data.defaultAppearanceData = ze;
            } else
              this._isOffscreenCanvasSupported || (0, n.warn)("_getAppearance: OffscreenCanvas is not supported, annotation may not render correctly."), [Fe, Pe, be] = this._computeFontSize(pe - 2 * oe, ve - 2 * ue, Q, Ce, ne);
            let _e = Ce.descent;
            isNaN(_e) ? _e = n.BASELINE_FACTOR * be : _e = Math.max(n.BASELINE_FACTOR * be, Math.abs(_e) * Pe);
            const Se = Math.min(Math.floor((pe - Pe) / 2), oe), Ae = this.data.textAlignment;
            if (this.data.multiLine)
              return this._getMultilineAppearance(Fe, me, Ce, Pe, ve, pe, Ae, ue, Se, _e, be, Y);
            if (this.data.comb)
              return this._getCombAppearance(Fe, Ce, me[0], Pe, ve, pe, ue, Se, _e, be, Y);
            const Te = Se + _e;
            if (Ae === 0 || Ae > 2)
              return `/Tx BMC q ${ie}BT ` + Fe + ` 1 0 0 1 ${(0, F.numberToString)(ue)} ${(0, F.numberToString)(Te)} Tm (${(0, F.escapeString)(me[0])}) Tj ET Q EMC`;
            const ke = {
              shift: 0
            }, Ee = this._renderText(me[0], Ce, Pe, ve, Ae, ke, ue, Te);
            return `/Tx BMC q ${ie}BT ` + Fe + ` 1 0 0 1 0 0 Tm ${Ee} ET Q EMC`;
          }
          static async _getFontData(L, X, J, Y) {
            const ae = new i.OperatorList(), se = {
              font: null,
              clone() {
                return this;
              }
            }, {
              fontName: Q,
              fontSize: z
            } = J;
            return await L.handleSetFont(Y, [Q && e.Name.get(Q), z], null, ae, X, se, null), se.font;
          }
          _getTextWidth(L, X) {
            return X.charsToGlyphs(L).reduce((J, Y) => J + Y.width, 0) / 1e3;
          }
          _computeFontSize(L, X, J, Y, ae) {
            let {
              fontSize: se
            } = this.data.defaultAppearanceData, Q = (se || 12) * n.LINE_FACTOR, z = Math.round(L / Q);
            if (!se) {
              const ie = (oe) => Math.floor(oe * 100) / 100;
              if (ae === -1) {
                const oe = this._getTextWidth(J, Y);
                se = ie(Math.min(L / n.LINE_FACTOR, oe > X ? X / oe : 1 / 0)), z = 1;
              } else {
                const oe = J.split(/\r\n?|\n/), ue = [];
                for (const ve of oe) {
                  const Ce = Y.encodeString(ve).join(""), Fe = Y.charsToGlyphs(Ce), Pe = Y.getCharPositions(Ce);
                  ue.push({
                    line: Ce,
                    glyphs: Fe,
                    positions: Pe
                  });
                }
                const pe = (ve) => {
                  let Ce = 0;
                  for (const Fe of ue) {
                    const Pe = this._splitLine(null, Y, ve, X, Fe);
                    if (Ce += Pe.length * ve, Ce > L)
                      return !0;
                  }
                  return !1;
                };
                for (z = Math.max(z, ae); ; ) {
                  if (Q = L / z, se = ie(Q / n.LINE_FACTOR), pe(se)) {
                    z++;
                    continue;
                  }
                  break;
                }
              }
              const {
                fontName: ne,
                fontColor: W
              } = this.data.defaultAppearanceData;
              this._defaultAppearance = (0, C.createDefaultAppearance)({
                fontSize: se,
                fontName: ne,
                fontColor: W
              });
            }
            return [this._defaultAppearance, se, L / z];
          }
          _renderText(L, X, J, Y, ae, se, Q, z) {
            let ie;
            if (ae === 1) {
              const W = this._getTextWidth(L, X) * J;
              ie = (Y - W) / 2;
            } else if (ae === 2) {
              const W = this._getTextWidth(L, X) * J;
              ie = Y - W - Q;
            } else
              ie = Q;
            const ne = (0, F.numberToString)(ie - se.shift);
            return se.shift = ie, z = (0, F.numberToString)(z), `${ne} ${z} Td (${(0, F.escapeString)(L)}) Tj`;
          }
          _getSaveFieldResources(L) {
            var se;
            const {
              localResources: X,
              appearanceResources: J,
              acroFormResources: Y
            } = this._fieldResources, ae = (se = this.data.defaultAppearanceData) == null ? void 0 : se.fontName;
            if (!ae)
              return X || e.Dict.empty;
            for (const Q of [X, J])
              if (Q instanceof e.Dict) {
                const z = Q.get("Font");
                if (z instanceof e.Dict && z.has(ae))
                  return Q;
              }
            if (Y instanceof e.Dict) {
              const Q = Y.get("Font");
              if (Q instanceof e.Dict && Q.has(ae)) {
                const z = new e.Dict(L);
                z.set(ae, Q.getRaw(ae));
                const ie = new e.Dict(L);
                return ie.set("Font", z), e.Dict.merge({
                  xref: L,
                  dictArray: [ie, X],
                  mergeSubDicts: !0
                });
              }
            }
            return X || e.Dict.empty;
          }
          getFieldObject() {
            return null;
          }
        }
        class N extends c {
          constructor(L) {
            super(L), this.data.hasOwnCanvas = this.data.readOnly && !this.data.noHTML, this._hasText = !0;
            const X = L.dict;
            typeof this.data.fieldValue != "string" && (this.data.fieldValue = "");
            let J = (0, F.getInheritableProperty)({
              dict: X,
              key: "Q"
            });
            (!Number.isInteger(J) || J < 0 || J > 2) && (J = null), this.data.textAlignment = J;
            let Y = (0, F.getInheritableProperty)({
              dict: X,
              key: "MaxLen"
            });
            (!Number.isInteger(Y) || Y < 0) && (Y = 0), this.data.maxLen = Y, this.data.multiLine = this.hasFieldFlag(n.AnnotationFieldFlag.MULTILINE), this.data.comb = this.hasFieldFlag(n.AnnotationFieldFlag.COMB) && !this.hasFieldFlag(n.AnnotationFieldFlag.MULTILINE) && !this.hasFieldFlag(n.AnnotationFieldFlag.PASSWORD) && !this.hasFieldFlag(n.AnnotationFieldFlag.FILESELECT) && this.data.maxLen !== 0, this.data.doNotScroll = this.hasFieldFlag(n.AnnotationFieldFlag.DONOTSCROLL);
          }
          get hasTextContent() {
            return !!this.appearance && !this._needAppearances;
          }
          _getCombAppearance(L, X, J, Y, ae, se, Q, z, ie, ne, W) {
            const oe = ae / this.data.maxLen, ue = this.getBorderAndBackgroundAppearances(W), pe = [], ve = X.getCharPositions(J);
            for (const [Fe, Pe] of ve)
              pe.push(`(${(0, F.escapeString)(J.substring(Fe, Pe))}) Tj`);
            const Ce = pe.join(` ${(0, F.numberToString)(oe)} 0 Td `);
            return `/Tx BMC q ${ue}BT ` + L + ` 1 0 0 1 ${(0, F.numberToString)(Q)} ${(0, F.numberToString)(z + ie)} Tm ${Ce} ET Q EMC`;
          }
          _getMultilineAppearance(L, X, J, Y, ae, se, Q, z, ie, ne, W, oe) {
            const ue = [], pe = ae - 2 * z, ve = {
              shift: 0
            };
            for (let Pe = 0, be = X.length; Pe < be; Pe++) {
              const me = X[Pe], we = this._splitLine(me, J, Y, pe);
              for (let _e = 0, Se = we.length; _e < Se; _e++) {
                const Ae = we[_e], Te = Pe === 0 && _e === 0 ? -ie - (W - ne) : -W;
                ue.push(this._renderText(Ae, J, Y, ae, Q, ve, z, Te));
              }
            }
            const Ce = this.getBorderAndBackgroundAppearances(oe), Fe = ue.join(`
`);
            return `/Tx BMC q ${Ce}BT ` + L + ` 1 0 0 1 0 ${(0, F.numberToString)(se)} Tm ${Fe} ET Q EMC`;
          }
          _splitLine(L, X, J, Y, ae = {}) {
            L = ae.line || L;
            const se = ae.glyphs || X.charsToGlyphs(L);
            if (se.length <= 1)
              return [L];
            const Q = ae.positions || X.getCharPositions(L), z = J / 1e3, ie = [];
            let ne = -1, W = -1, oe = -1, ue = 0, pe = 0;
            for (let ve = 0, Ce = se.length; ve < Ce; ve++) {
              const [Fe, Pe] = Q[ve], be = se[ve], me = be.width * z;
              be.unicode === " " ? pe + me > Y ? (ie.push(L.substring(ue, Fe)), ue = Fe, pe = me, ne = -1, oe = -1) : (pe += me, ne = Fe, W = Pe, oe = ve) : pe + me > Y ? ne !== -1 ? (ie.push(L.substring(ue, W)), ue = W, ve = oe + 1, ne = -1, pe = 0) : (ie.push(L.substring(ue, Fe)), ue = Fe, pe = me) : pe += me;
            }
            return ue < L.length && ie.push(L.substring(ue, L.length)), ie;
          }
          getFieldObject() {
            return {
              id: this.data.id,
              value: this.data.fieldValue,
              defaultValue: this.data.defaultFieldValue || "",
              multiline: this.data.multiLine,
              password: this.hasFieldFlag(n.AnnotationFieldFlag.PASSWORD),
              charLimit: this.data.maxLen,
              comb: this.data.comb,
              editable: !this.data.readOnly,
              hidden: this.data.hidden,
              name: this.data.fieldName,
              rect: this.data.rect,
              actions: this.data.actions,
              page: this.data.pageIndex,
              strokeColor: this.data.borderColor,
              fillColor: this.data.backgroundColor,
              rotation: this.rotation,
              type: "text"
            };
          }
        }
        class u extends c {
          constructor(L) {
            super(L), this.checkedAppearance = null, this.uncheckedAppearance = null, this.data.checkBox = !this.hasFieldFlag(n.AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(n.AnnotationFieldFlag.PUSHBUTTON), this.data.radioButton = this.hasFieldFlag(n.AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(n.AnnotationFieldFlag.PUSHBUTTON), this.data.pushButton = this.hasFieldFlag(n.AnnotationFieldFlag.PUSHBUTTON), this.data.isTooltipOnly = !1, this.data.checkBox ? this._processCheckBox(L) : this.data.radioButton ? this._processRadioButton(L) : this.data.pushButton ? (this.data.hasOwnCanvas = !0, this._processPushButton(L)) : (0, n.warn)("Invalid field flags for button widget annotation");
          }
          async getOperatorList(L, X, J, Y, ae) {
            if (this.data.pushButton)
              return super.getOperatorList(L, X, J, !1, ae);
            let se = null, Q = null;
            if (ae) {
              const ie = ae.get(this.data.id);
              se = ie ? ie.value : null, Q = ie ? ie.rotation : null;
            }
            if (se === null && this.appearance)
              return super.getOperatorList(L, X, J, Y, ae);
            se == null && (se = this.data.checkBox ? this.data.fieldValue === this.data.exportValue : this.data.fieldValue === this.data.buttonValue);
            const z = se ? this.checkedAppearance : this.uncheckedAppearance;
            if (z) {
              const ie = this.appearance, ne = z.dict.getArray("Matrix") || n.IDENTITY_MATRIX;
              Q && z.dict.set("Matrix", this.getRotationMatrix(ae)), this.appearance = z;
              const W = super.getOperatorList(L, X, J, Y, ae);
              return this.appearance = ie, z.dict.set("Matrix", ne), W;
            }
            return {
              opList: new i.OperatorList(),
              separateForm: !1,
              separateCanvas: !1
            };
          }
          async save(L, X, J) {
            return this.data.checkBox ? this._saveCheckbox(L, X, J) : this.data.radioButton ? this._saveRadioButton(L, X, J) : null;
          }
          async _saveCheckbox(L, X, J) {
            if (!J)
              return null;
            const Y = J.get(this.data.id);
            let ae = Y == null ? void 0 : Y.rotation, se = Y == null ? void 0 : Y.value;
            if (ae === void 0 && (se === void 0 || this.data.fieldValue === this.data.exportValue === se))
              return null;
            const Q = L.xref.fetchIfRef(this.ref);
            if (!(Q instanceof e.Dict))
              return null;
            ae === void 0 && (ae = this.rotation), se === void 0 && (se = this.data.fieldValue === this.data.exportValue);
            const z = {
              path: this.data.fieldName,
              value: se ? this.data.exportValue : ""
            }, ie = e.Name.get(se ? this.data.exportValue : "Off");
            Q.set("V", ie), Q.set("AS", ie), Q.set("M", `D:${(0, n.getModificationDate)()}`);
            const ne = this._getMKDict(ae);
            ne && Q.set("MK", ne);
            const W = [];
            return await (0, P.writeObject)(this.ref, Q, W, L.xref), [{
              ref: this.ref,
              data: W.join(""),
              xfa: z
            }];
          }
          async _saveRadioButton(L, X, J) {
            if (!J)
              return null;
            const Y = J.get(this.data.id);
            let ae = Y == null ? void 0 : Y.rotation, se = Y == null ? void 0 : Y.value;
            if (ae === void 0 && (se === void 0 || this.data.fieldValue === this.data.buttonValue === se))
              return null;
            const Q = L.xref.fetchIfRef(this.ref);
            if (!(Q instanceof e.Dict))
              return null;
            se === void 0 && (se = this.data.fieldValue === this.data.buttonValue), ae === void 0 && (ae = this.rotation);
            const z = {
              path: this.data.fieldName,
              value: se ? this.data.buttonValue : ""
            }, ie = e.Name.get(se ? this.data.buttonValue : "Off"), ne = [];
            let W = null;
            if (se)
              if (this.parent instanceof e.Ref) {
                const pe = L.xref.fetch(this.parent);
                pe.set("V", ie), await (0, P.writeObject)(this.parent, pe, ne, L.xref), W = ne.join(""), ne.length = 0;
              } else
                this.parent instanceof e.Dict && this.parent.set("V", ie);
            Q.set("AS", ie), Q.set("M", `D:${(0, n.getModificationDate)()}`);
            const oe = this._getMKDict(ae);
            oe && Q.set("MK", oe), await (0, P.writeObject)(this.ref, Q, ne, L.xref);
            const ue = [{
              ref: this.ref,
              data: ne.join(""),
              xfa: z
            }];
            return W && ue.push({
              ref: this.parent,
              data: W,
              xfa: null
            }), ue;
          }
          _getDefaultCheckedAppearance(L, X) {
            const J = this.data.rect[2] - this.data.rect[0], Y = this.data.rect[3] - this.data.rect[1], ae = [0, 0, J, Y], Q = Math.min(J, Y) * 0.8;
            let z, ie;
            X === "check" ? (z = {
              width: 0.755 * Q,
              height: 0.705 * Q
            }, ie = "3") : X === "disc" ? (z = {
              width: 0.791 * Q,
              height: 0.705 * Q
            }, ie = "l") : (0, n.unreachable)(`_getDefaultCheckedAppearance - unsupported type: ${X}`);
            const ne = (0, F.numberToString)((J - z.width) / 2), W = (0, F.numberToString)((Y - z.height) / 2), oe = `q BT /PdfJsZaDb ${Q} Tf 0 g ${ne} ${W} Td (${ie}) Tj ET Q`, ue = new e.Dict(L.xref);
            ue.set("FormType", 1), ue.set("Subtype", e.Name.get("Form")), ue.set("Type", e.Name.get("XObject")), ue.set("BBox", ae), ue.set("Matrix", [1, 0, 0, 1, 0, 0]), ue.set("Length", oe.length);
            const pe = new e.Dict(L.xref), ve = new e.Dict(L.xref);
            ve.set("PdfJsZaDb", this.fallbackFontDict), pe.set("Font", ve), ue.set("Resources", pe), this.checkedAppearance = new t.StringStream(oe), this.checkedAppearance.dict = ue, this._streams.push(this.checkedAppearance);
          }
          _processCheckBox(L) {
            const X = L.dict.get("AP");
            if (!(X instanceof e.Dict))
              return;
            const J = X.get("N");
            if (!(J instanceof e.Dict))
              return;
            const Y = this._decodeFormValue(L.dict.get("AS"));
            typeof Y == "string" && (this.data.fieldValue = Y);
            const ae = this.data.fieldValue !== null && this.data.fieldValue !== "Off" ? this.data.fieldValue : "Yes", se = J.getKeys();
            if (se.length === 0)
              se.push("Off", ae);
            else if (se.length === 1)
              se[0] === "Off" ? se.push(ae) : se.unshift("Off");
            else if (se.includes(ae))
              se.length = 0, se.push("Off", ae);
            else {
              const ie = se.find((ne) => ne !== "Off");
              se.length = 0, se.push("Off", ie);
            }
            se.includes(this.data.fieldValue) || (this.data.fieldValue = "Off"), this.data.exportValue = se[1];
            const Q = J.get(this.data.exportValue);
            this.checkedAppearance = Q instanceof l.BaseStream ? Q : null;
            const z = J.get("Off");
            this.uncheckedAppearance = z instanceof l.BaseStream ? z : null, this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(L, "check"), this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance), this._fallbackFontDict = this.fallbackFontDict, this.data.defaultFieldValue === null && (this.data.defaultFieldValue = "Off");
          }
          _processRadioButton(L) {
            this.data.fieldValue = this.data.buttonValue = null;
            const X = L.dict.get("Parent");
            if (X instanceof e.Dict) {
              this.parent = L.dict.getRaw("Parent");
              const Q = X.get("V");
              Q instanceof e.Name && (this.data.fieldValue = this._decodeFormValue(Q));
            }
            const J = L.dict.get("AP");
            if (!(J instanceof e.Dict))
              return;
            const Y = J.get("N");
            if (!(Y instanceof e.Dict))
              return;
            for (const Q of Y.getKeys())
              if (Q !== "Off") {
                this.data.buttonValue = this._decodeFormValue(Q);
                break;
              }
            const ae = Y.get(this.data.buttonValue);
            this.checkedAppearance = ae instanceof l.BaseStream ? ae : null;
            const se = Y.get("Off");
            this.uncheckedAppearance = se instanceof l.BaseStream ? se : null, this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(L, "disc"), this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance), this._fallbackFontDict = this.fallbackFontDict, this.data.defaultFieldValue === null && (this.data.defaultFieldValue = "Off");
          }
          _processPushButton(L) {
            const {
              dict: X,
              annotationGlobals: J
            } = L;
            if (!X.has("A") && !X.has("AA") && !this.data.alternativeText) {
              (0, n.warn)("Push buttons without action dictionaries are not supported");
              return;
            }
            this.data.isTooltipOnly = !X.has("A") && !X.has("AA"), U.Catalog.parseDestDictionary({
              destDict: X,
              resultObj: this.data,
              docBaseUrl: J.baseUrl,
              docAttachments: J.attachments
            });
          }
          getFieldObject() {
            let L = "button", X;
            return this.data.checkBox ? (L = "checkbox", X = this.data.exportValue) : this.data.radioButton && (L = "radiobutton", X = this.data.buttonValue), {
              id: this.data.id,
              value: this.data.fieldValue || "Off",
              defaultValue: this.data.defaultFieldValue,
              exportValues: X,
              editable: !this.data.readOnly,
              name: this.data.fieldName,
              rect: this.data.rect,
              hidden: this.data.hidden,
              actions: this.data.actions,
              page: this.data.pageIndex,
              strokeColor: this.data.borderColor,
              fillColor: this.data.backgroundColor,
              rotation: this.rotation,
              type: L
            };
          }
          get fallbackFontDict() {
            const L = new e.Dict();
            return L.set("BaseFont", e.Name.get("ZapfDingbats")), L.set("Type", e.Name.get("FallbackType")), L.set("Subtype", e.Name.get("FallbackType")), L.set("Encoding", e.Name.get("ZapfDingbatsEncoding")), (0, n.shadow)(this, "fallbackFontDict", L);
          }
        }
        class p extends c {
          constructor(L) {
            super(L);
            const {
              dict: X,
              xref: J
            } = L;
            this.indices = X.getArray("I"), this.hasIndices = Array.isArray(this.indices) && this.indices.length > 0, this.data.options = [];
            const Y = (0, F.getInheritableProperty)({
              dict: X,
              key: "Opt"
            });
            if (Array.isArray(Y))
              for (let ae = 0, se = Y.length; ae < se; ae++) {
                const Q = J.fetchIfRef(Y[ae]), z = Array.isArray(Q);
                this.data.options[ae] = {
                  exportValue: this._decodeFormValue(z ? J.fetchIfRef(Q[0]) : Q),
                  displayValue: this._decodeFormValue(z ? J.fetchIfRef(Q[1]) : Q)
                };
              }
            if (!this.hasIndices)
              typeof this.data.fieldValue == "string" ? this.data.fieldValue = [this.data.fieldValue] : this.data.fieldValue || (this.data.fieldValue = []);
            else {
              this.data.fieldValue = [];
              const ae = this.data.options.length;
              for (const se of this.indices)
                Number.isInteger(se) && se >= 0 && se < ae && this.data.fieldValue.push(this.data.options[se].exportValue);
            }
            this.data.combo = this.hasFieldFlag(n.AnnotationFieldFlag.COMBO), this.data.multiSelect = this.hasFieldFlag(n.AnnotationFieldFlag.MULTISELECT), this._hasText = !0;
          }
          getFieldObject() {
            const L = this.data.combo ? "combobox" : "listbox", X = this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
            return {
              id: this.data.id,
              value: X,
              defaultValue: this.data.defaultFieldValue,
              editable: !this.data.readOnly,
              name: this.data.fieldName,
              rect: this.data.rect,
              numItems: this.data.fieldValue.length,
              multipleSelection: this.data.multiSelect,
              hidden: this.data.hidden,
              actions: this.data.actions,
              items: this.data.options,
              page: this.data.pageIndex,
              strokeColor: this.data.borderColor,
              fillColor: this.data.backgroundColor,
              rotation: this.rotation,
              type: L
            };
          }
          amendSavedDict(L, X) {
            var se;
            if (!this.hasIndices)
              return;
            let J = (se = L == null ? void 0 : L.get(this.data.id)) == null ? void 0 : se.value;
            Array.isArray(J) || (J = [J]);
            const Y = [], {
              options: ae
            } = this.data;
            for (let Q = 0, z = 0, ie = ae.length; Q < ie; Q++)
              ae[Q].exportValue === J[z] && (Y.push(Q), z += 1);
            X.set("I", Y);
          }
          async _getAppearance(L, X, J, Y) {
            if (this.data.combo)
              return super._getAppearance(L, X, J, Y);
            let ae, se;
            const Q = Y == null ? void 0 : Y.get(this.data.id);
            if (Q && (se = Q.rotation, ae = Q.value), se === void 0 && ae === void 0 && !this._needAppearances)
              return null;
            ae === void 0 ? ae = this.data.fieldValue : Array.isArray(ae) || (ae = [ae]);
            const z = 1, ie = 2;
            let ne = this.data.rect[3] - this.data.rect[1], W = this.data.rect[2] - this.data.rect[0];
            (se === 90 || se === 270) && ([W, ne] = [ne, W]);
            const oe = this.data.options.length, ue = [];
            for (let Ae = 0; Ae < oe; Ae++) {
              const {
                exportValue: Te
              } = this.data.options[Ae];
              ae.includes(Te) && ue.push(Ae);
            }
            this._defaultAppearance || (this.data.defaultAppearanceData = (0, C.parseDefaultAppearance)(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
            const pe = await c._getFontData(L, X, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
            let ve, {
              fontSize: Ce
            } = this.data.defaultAppearanceData;
            if (Ce)
              ve = this._defaultAppearance;
            else {
              const Ae = (ne - z) / oe;
              let Te = -1, ke;
              for (const {
                displayValue: Ee
              } of this.data.options) {
                const Ve = this._getTextWidth(Ee, pe);
                Ve > Te && (Te = Ve, ke = Ee);
              }
              [ve, Ce] = this._computeFontSize(Ae, W - 2 * ie, ke, pe, -1);
            }
            const Fe = Ce * n.LINE_FACTOR, Pe = (Fe - Ce) / 2, be = Math.floor(ne / Fe);
            let me = 0;
            if (ue.length > 0) {
              const Ae = Math.min(...ue), Te = Math.max(...ue);
              me = Math.max(0, Te - be + 1), me > Ae && (me = Ae);
            }
            const we = Math.min(me + be + 1, oe), _e = ["/Tx BMC q", `1 1 ${W} ${ne} re W n`];
            if (ue.length) {
              _e.push("0.600006 0.756866 0.854904 rg");
              for (const Ae of ue)
                me <= Ae && Ae < we && _e.push(`1 ${ne - (Ae - me + 1) * Fe} ${W} ${Fe} re f`);
            }
            _e.push("BT", ve, `1 0 0 1 0 ${ne} Tm`);
            const Se = {
              shift: 0
            };
            for (let Ae = me; Ae < we; Ae++) {
              const {
                displayValue: Te
              } = this.data.options[Ae], ke = Ae === me ? Pe : 0;
              _e.push(this._renderText(Te, pe, Ce, W, 0, Se, ie, -Fe + ke));
            }
            return _e.push("ET Q EMC"), _e.join(`
`);
          }
        }
        class S extends c {
          constructor(L) {
            super(L), this.data.fieldValue = null, this.data.hasOwnCanvas = this.data.noRotate;
          }
          getFieldObject() {
            return {
              id: this.data.id,
              value: null,
              page: this.data.pageIndex,
              type: "signature"
            };
          }
        }
        class B extends f {
          constructor(L) {
            super(L), this.data.noRotate = !0, this.data.hasOwnCanvas = this.data.noRotate;
            const {
              dict: J
            } = L;
            this.data.annotationType = n.AnnotationType.TEXT, this.data.hasAppearance ? this.data.name = "NoIcon" : (this.data.rect[1] = this.data.rect[3] - 22, this.data.rect[2] = this.data.rect[0] + 22, this.data.name = J.has("Name") ? J.get("Name").name : "Note"), J.has("State") ? (this.data.state = J.get("State") || null, this.data.stateModel = J.get("StateModel") || null) : (this.data.state = null, this.data.stateModel = null);
          }
        }
        class T extends x {
          constructor(L) {
            var ae;
            super(L);
            const {
              dict: X,
              annotationGlobals: J
            } = L;
            this.data.annotationType = n.AnnotationType.LINK;
            const Y = k(X, this.rectangle);
            Y && (this.data.quadPoints = Y), (ae = this.data).borderColor || (ae.borderColor = this.data.color), U.Catalog.parseDestDictionary({
              destDict: X,
              resultObj: this.data,
              docBaseUrl: J.baseUrl,
              docAttachments: J.attachments
            });
          }
        }
        class D extends x {
          constructor(L) {
            super(L);
            const {
              dict: X
            } = L;
            this.data.annotationType = n.AnnotationType.POPUP, (this.data.rect[0] === this.data.rect[2] || this.data.rect[1] === this.data.rect[3]) && (this.data.rect = null);
            let J = X.get("Parent");
            if (!J) {
              (0, n.warn)("Popup annotation has a missing or invalid parent annotation.");
              return;
            }
            const Y = J.getArray("Rect");
            this.data.parentRect = Array.isArray(Y) && Y.length === 4 ? n.Util.normalizeRect(Y) : null;
            const ae = J.get("RT");
            if ((0, e.isName)(ae, n.AnnotationReplyType.GROUP) && (J = J.get("IRT")), J.has("M") ? (this.setModificationDate(J.get("M")), this.data.modificationDate = this.modificationDate) : this.data.modificationDate = null, J.has("C") ? (this.setColor(J.getArray("C")), this.data.color = this.color) : this.data.color = null, !this.viewable) {
              const se = J.get("F");
              this._isViewable(se) && this.setFlags(se);
            }
            this.setTitle(J.get("T")), this.data.titleObj = this._title, this.setContents(J.get("Contents")), this.data.contentsObj = this._contents, J.has("RC") && (this.data.richText = d.XFAFactory.getRichTextAsHtml(J.get("RC"))), this.data.open = !!X.get("Open");
          }
        }
        w.PopupAnnotation = D;
        class K extends f {
          constructor(L) {
            var Y;
            super(L), this.data.hasOwnCanvas = !0;
            const {
              evaluatorOptions: X,
              xref: J
            } = L;
            if (this.data.annotationType = n.AnnotationType.FREETEXT, this.setDefaultAppearance(L), this.appearance) {
              const {
                fontColor: ae,
                fontSize: se
              } = (0, C.parseAppearanceStream)(this.appearance, X, J);
              this.data.defaultAppearanceData.fontColor = ae, this.data.defaultAppearanceData.fontSize = se || 10;
            } else if (this._isOffscreenCanvasSupported) {
              const ae = L.dict.get("CA"), se = new C.FakeUnicodeFont(J, "sans-serif");
              (Y = this.data.defaultAppearanceData).fontSize || (Y.fontSize = 10);
              const {
                fontColor: Q,
                fontSize: z
              } = this.data.defaultAppearanceData;
              this.appearance = se.createAppearance(this._contents.str, this.rectangle, this.rotation, z, Q, ae), this._streams.push(this.appearance, C.FakeUnicodeFont.toUnicodeStream);
            } else
              (0, n.warn)("FreeTextAnnotation: OffscreenCanvas is not supported, annotation may not render correctly.");
          }
          get hasTextContent() {
            return !!this.appearance;
          }
          static createNewDict(L, X, {
            apRef: J,
            ap: Y
          }) {
            const {
              color: ae,
              fontSize: se,
              rect: Q,
              rotation: z,
              user: ie,
              value: ne
            } = L, W = new e.Dict(X);
            W.set("Type", e.Name.get("Annot")), W.set("Subtype", e.Name.get("FreeText")), W.set("CreationDate", `D:${(0, n.getModificationDate)()}`), W.set("Rect", Q);
            const oe = `/Helv ${se} Tf ${(0, C.getPdfColor)(ae, !0)}`;
            if (W.set("DA", oe), W.set("Contents", (0, F.isAscii)(ne) ? ne : (0, F.stringToUTF16String)(ne, !0)), W.set("F", 4), W.set("Border", [0, 0, 0]), W.set("Rotate", z), ie && W.set("T", (0, F.isAscii)(ie) ? ie : (0, F.stringToUTF16String)(ie, !0)), J || Y) {
              const ue = new e.Dict(X);
              W.set("AP", ue), J ? ue.set("N", J) : ue.set("N", Y);
            }
            return W;
          }
          static async createNewAppearanceStream(L, X, J) {
            const {
              baseFontRef: Y,
              evaluator: ae,
              task: se
            } = J, {
              color: Q,
              fontSize: z,
              rect: ie,
              rotation: ne,
              value: W
            } = L, oe = new e.Dict(X), ue = new e.Dict(X);
            if (Y)
              ue.set("Helv", Y);
            else {
              const Le = new e.Dict(X);
              Le.set("BaseFont", e.Name.get("Helvetica")), Le.set("Type", e.Name.get("Font")), Le.set("Subtype", e.Name.get("Type1")), Le.set("Encoding", e.Name.get("WinAnsiEncoding")), ue.set("Helv", Le);
            }
            oe.set("Font", ue);
            const pe = await c._getFontData(ae, se, {
              fontName: "Helv",
              fontSize: z
            }, oe), [ve, Ce, Fe, Pe] = ie;
            let be = Fe - ve, me = Pe - Ce;
            ne % 180 !== 0 && ([be, me] = [me, be]);
            const we = W.split(`
`), _e = z / 1e3;
            let Se = -1 / 0;
            const Ae = [];
            for (let Le of we) {
              const Be = pe.encodeString(Le);
              if (Be.length > 1)
                return null;
              Le = Be.join(""), Ae.push(Le);
              let Ne = 0;
              const Ue = pe.charsToGlyphs(Le);
              for (const qe of Ue)
                Ne += qe.width * _e;
              Se = Math.max(Se, Ne);
            }
            let Te = 1;
            Se > be && (Te = be / Se);
            let ke = 1;
            const Ee = n.LINE_FACTOR * z, Ve = (n.LINE_FACTOR - n.LINE_DESCENT_FACTOR) * z, je = Ee * we.length;
            je > me && (ke = me / je);
            const at = Math.min(Te, ke), $e = z * at;
            let ct, ze, Ye;
            switch (ne) {
              case 0:
                Ye = [1, 0, 0, 1], ze = [ie[0], ie[1], be, me], ct = [ie[0], ie[3] - Ve];
                break;
              case 90:
                Ye = [0, 1, -1, 0], ze = [ie[1], -ie[2], be, me], ct = [ie[1], -ie[0] - Ve];
                break;
              case 180:
                Ye = [-1, 0, 0, -1], ze = [-ie[2], -ie[3], be, me], ct = [-ie[2], -ie[1] - Ve];
                break;
              case 270:
                Ye = [0, -1, 1, 0], ze = [-ie[3], ie[0], be, me], ct = [-ie[3], ie[2] - Ve];
                break;
            }
            const Qe = ["q", `${Ye.join(" ")} 0 0 cm`, `${ze.join(" ")} re W n`, "BT", `${(0, C.getPdfColor)(Q, !0)}`, `0 Tc /Helv ${(0, F.numberToString)($e)} Tf`];
            Qe.push(`${ct.join(" ")} Td (${(0, F.escapeString)(Ae[0])}) Tj`);
            const Oe = (0, F.numberToString)(Ee);
            for (let Le = 1, Be = Ae.length; Le < Be; Le++) {
              const Ne = Ae[Le];
              Qe.push(`0 -${Oe} Td (${(0, F.escapeString)(Ne)}) Tj`);
            }
            Qe.push("ET", "Q");
            const he = Qe.join(`
`), ye = new e.Dict(X);
            ye.set("FormType", 1), ye.set("Subtype", e.Name.get("Form")), ye.set("Type", e.Name.get("XObject")), ye.set("BBox", ie), ye.set("Resources", oe), ye.set("Matrix", [1, 0, 0, 1, -ie[0], -ie[1]]);
            const Ie = new t.StringStream(he);
            return Ie.dict = ye, Ie;
          }
        }
        class _ extends f {
          constructor(L) {
            super(L);
            const {
              dict: X,
              xref: J
            } = L;
            this.data.annotationType = n.AnnotationType.LINE, this.data.hasOwnCanvas = this.data.noRotate;
            const Y = X.getArray("L");
            if (this.data.lineCoordinates = n.Util.normalizeRect(Y), this.setLineEndings(X.getArray("LE")), this.data.lineEndings = this.lineEndings, !this.appearance) {
              const ae = this.color ? E(this.color) : [0, 0, 0], se = X.get("CA"), Q = I(X.getArray("IC"), null), z = Q ? E(Q) : null, ie = z ? se : null, ne = this.borderStyle.width || 1, W = 2 * ne, oe = [this.data.lineCoordinates[0] - W, this.data.lineCoordinates[1] - W, this.data.lineCoordinates[2] + W, this.data.lineCoordinates[3] + W];
              n.Util.intersect(this.rectangle, oe) || (this.rectangle = oe), this._setDefaultAppearance({
                xref: J,
                extra: `${ne} w`,
                strokeColor: ae,
                fillColor: z,
                strokeAlpha: se,
                fillAlpha: ie,
                pointsCallback: (ue, pe) => (ue.push(`${Y[0]} ${Y[1]} m`, `${Y[2]} ${Y[3]} l`, "S"), [pe[0].x - ne, pe[1].x + ne, pe[3].y - ne, pe[1].y + ne])
              });
            }
          }
        }
        class o extends f {
          constructor(L) {
            super(L);
            const {
              dict: X,
              xref: J
            } = L;
            if (this.data.annotationType = n.AnnotationType.SQUARE, this.data.hasOwnCanvas = this.data.noRotate, !this.appearance) {
              const Y = this.color ? E(this.color) : [0, 0, 0], ae = X.get("CA"), se = I(X.getArray("IC"), null), Q = se ? E(se) : null, z = Q ? ae : null;
              if (this.borderStyle.width === 0 && !Q)
                return;
              this._setDefaultAppearance({
                xref: J,
                extra: `${this.borderStyle.width} w`,
                strokeColor: Y,
                fillColor: Q,
                strokeAlpha: ae,
                fillAlpha: z,
                pointsCallback: (ie, ne) => {
                  const W = ne[2].x + this.borderStyle.width / 2, oe = ne[2].y + this.borderStyle.width / 2, ue = ne[3].x - ne[2].x - this.borderStyle.width, pe = ne[1].y - ne[3].y - this.borderStyle.width;
                  return ie.push(`${W} ${oe} ${ue} ${pe} re`), Q ? ie.push("B") : ie.push("S"), [ne[0].x, ne[1].x, ne[3].y, ne[1].y];
                }
              });
            }
          }
        }
        class m extends f {
          constructor(L) {
            super(L);
            const {
              dict: X,
              xref: J
            } = L;
            if (this.data.annotationType = n.AnnotationType.CIRCLE, !this.appearance) {
              const Y = this.color ? E(this.color) : [0, 0, 0], ae = X.get("CA"), se = I(X.getArray("IC"), null), Q = se ? E(se) : null, z = Q ? ae : null;
              if (this.borderStyle.width === 0 && !Q)
                return;
              const ie = 4 / 3 * Math.tan(Math.PI / (2 * 4));
              this._setDefaultAppearance({
                xref: J,
                extra: `${this.borderStyle.width} w`,
                strokeColor: Y,
                fillColor: Q,
                strokeAlpha: ae,
                fillAlpha: z,
                pointsCallback: (ne, W) => {
                  const oe = W[0].x + this.borderStyle.width / 2, ue = W[0].y - this.borderStyle.width / 2, pe = W[3].x - this.borderStyle.width / 2, ve = W[3].y + this.borderStyle.width / 2, Ce = oe + (pe - oe) / 2, Fe = ue + (ve - ue) / 2, Pe = (pe - oe) / 2 * ie, be = (ve - ue) / 2 * ie;
                  return ne.push(`${Ce} ${ve} m`, `${Ce + Pe} ${ve} ${pe} ${Fe + be} ${pe} ${Fe} c`, `${pe} ${Fe - be} ${Ce + Pe} ${ue} ${Ce} ${ue} c`, `${Ce - Pe} ${ue} ${oe} ${Fe - be} ${oe} ${Fe} c`, `${oe} ${Fe + be} ${Ce - Pe} ${ve} ${Ce} ${ve} c`, "h"), Q ? ne.push("B") : ne.push("S"), [W[0].x, W[1].x, W[3].y, W[1].y];
                }
              });
            }
          }
        }
        class s extends f {
          constructor(L) {
            super(L);
            const {
              dict: X,
              xref: J
            } = L;
            this.data.annotationType = n.AnnotationType.POLYLINE, this.data.hasOwnCanvas = this.data.noRotate, this.data.vertices = [], this instanceof r || (this.setLineEndings(X.getArray("LE")), this.data.lineEndings = this.lineEndings);
            const Y = X.getArray("Vertices");
            if (Array.isArray(Y)) {
              for (let ae = 0, se = Y.length; ae < se; ae += 2)
                this.data.vertices.push({
                  x: Y[ae],
                  y: Y[ae + 1]
                });
              if (!this.appearance) {
                const ae = this.color ? E(this.color) : [0, 0, 0], se = X.get("CA"), Q = this.borderStyle.width || 1, z = 2 * Q, ie = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                for (const ne of this.data.vertices)
                  ie[0] = Math.min(ie[0], ne.x - z), ie[1] = Math.min(ie[1], ne.y - z), ie[2] = Math.max(ie[2], ne.x + z), ie[3] = Math.max(ie[3], ne.y + z);
                n.Util.intersect(this.rectangle, ie) || (this.rectangle = ie), this._setDefaultAppearance({
                  xref: J,
                  extra: `${Q} w`,
                  strokeColor: ae,
                  strokeAlpha: se,
                  pointsCallback: (ne, W) => {
                    const oe = this.data.vertices;
                    for (let ue = 0, pe = oe.length; ue < pe; ue++)
                      ne.push(`${oe[ue].x} ${oe[ue].y} ${ue === 0 ? "m" : "l"}`);
                    return ne.push("S"), [W[0].x, W[1].x, W[3].y, W[1].y];
                  }
                });
              }
            }
          }
        }
        class r extends s {
          constructor(L) {
            super(L), this.data.annotationType = n.AnnotationType.POLYGON;
          }
        }
        class y extends f {
          constructor(L) {
            super(L), this.data.annotationType = n.AnnotationType.CARET;
          }
        }
        class M extends f {
          constructor(L) {
            super(L), this.data.hasOwnCanvas = this.data.noRotate;
            const {
              dict: X,
              xref: J
            } = L;
            this.data.annotationType = n.AnnotationType.INK, this.data.inkLists = [];
            const Y = X.getArray("InkList");
            if (Array.isArray(Y)) {
              for (let ae = 0, se = Y.length; ae < se; ++ae) {
                this.data.inkLists.push([]);
                for (let Q = 0, z = Y[ae].length; Q < z; Q += 2)
                  this.data.inkLists[ae].push({
                    x: J.fetchIfRef(Y[ae][Q]),
                    y: J.fetchIfRef(Y[ae][Q + 1])
                  });
              }
              if (!this.appearance) {
                const ae = this.color ? E(this.color) : [0, 0, 0], se = X.get("CA"), Q = this.borderStyle.width || 1, z = 2 * Q, ie = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                for (const ne of this.data.inkLists)
                  for (const W of ne)
                    ie[0] = Math.min(ie[0], W.x - z), ie[1] = Math.min(ie[1], W.y - z), ie[2] = Math.max(ie[2], W.x + z), ie[3] = Math.max(ie[3], W.y + z);
                n.Util.intersect(this.rectangle, ie) || (this.rectangle = ie), this._setDefaultAppearance({
                  xref: J,
                  extra: `${Q} w`,
                  strokeColor: ae,
                  strokeAlpha: se,
                  pointsCallback: (ne, W) => {
                    for (const oe of this.data.inkLists) {
                      for (let ue = 0, pe = oe.length; ue < pe; ue++)
                        ne.push(`${oe[ue].x} ${oe[ue].y} ${ue === 0 ? "m" : "l"}`);
                      ne.push("S");
                    }
                    return [W[0].x, W[1].x, W[3].y, W[1].y];
                  }
                });
              }
            }
          }
          static createNewDict(L, X, {
            apRef: J,
            ap: Y
          }) {
            const {
              color: ae,
              opacity: se,
              paths: Q,
              rect: z,
              rotation: ie,
              thickness: ne
            } = L, W = new e.Dict(X);
            W.set("Type", e.Name.get("Annot")), W.set("Subtype", e.Name.get("Ink")), W.set("CreationDate", `D:${(0, n.getModificationDate)()}`), W.set("Rect", z), W.set("InkList", Q.map((pe) => pe.points)), W.set("F", 4), W.set("Rotate", ie);
            const oe = new e.Dict(X);
            W.set("BS", oe), oe.set("W", ne), W.set("C", Array.from(ae, (pe) => pe / 255)), W.set("CA", se);
            const ue = new e.Dict(X);
            return W.set("AP", ue), J ? ue.set("N", J) : ue.set("N", Y), W;
          }
          static async createNewAppearanceStream(L, X, J) {
            const {
              color: Y,
              rect: ae,
              paths: se,
              thickness: Q,
              opacity: z
            } = L, ie = [`${Q} w 1 J 1 j`, `${(0, C.getPdfColor)(Y, !1)}`];
            z !== 1 && ie.push("/R0 gs");
            const ne = [];
            for (const {
              bezier: pe
            } of se) {
              ne.length = 0, ne.push(`${(0, F.numberToString)(pe[0])} ${(0, F.numberToString)(pe[1])} m`);
              for (let ve = 2, Ce = pe.length; ve < Ce; ve += 6) {
                const Fe = pe.slice(ve, ve + 6).map(F.numberToString).join(" ");
                ne.push(`${Fe} c`);
              }
              ne.push("S"), ie.push(ne.join(`
`));
            }
            const W = ie.join(`
`), oe = new e.Dict(X);
            if (oe.set("FormType", 1), oe.set("Subtype", e.Name.get("Form")), oe.set("Type", e.Name.get("XObject")), oe.set("BBox", ae), oe.set("Length", W.length), z !== 1) {
              const pe = new e.Dict(X), ve = new e.Dict(X), Ce = new e.Dict(X);
              Ce.set("CA", z), Ce.set("Type", e.Name.get("ExtGState")), ve.set("R0", Ce), pe.set("ExtGState", ve), oe.set("Resources", pe);
            }
            const ue = new t.StringStream(W);
            return ue.dict = oe, ue;
          }
        }
        class $ extends f {
          constructor(L) {
            var ae;
            super(L);
            const {
              dict: X,
              xref: J
            } = L;
            if (this.data.annotationType = n.AnnotationType.HIGHLIGHT, this.data.quadPoints = k(X, null)) {
              const se = (ae = this.appearance) == null ? void 0 : ae.dict.get("Resources");
              if (!this.appearance || !(se != null && se.has("ExtGState"))) {
                this.appearance && (0, n.warn)("HighlightAnnotation - ignoring built-in appearance stream.");
                const Q = this.color ? E(this.color) : [1, 1, 0], z = X.get("CA");
                this._setDefaultAppearance({
                  xref: J,
                  fillColor: Q,
                  blendMode: "Multiply",
                  fillAlpha: z,
                  pointsCallback: (ie, ne) => (ie.push(`${ne[0].x} ${ne[0].y} m`, `${ne[1].x} ${ne[1].y} l`, `${ne[3].x} ${ne[3].y} l`, `${ne[2].x} ${ne[2].y} l`, "f"), [ne[0].x, ne[1].x, ne[3].y, ne[1].y])
                });
              }
            } else
              this.data.popupRef = null;
          }
        }
        class G extends f {
          constructor(L) {
            super(L);
            const {
              dict: X,
              xref: J
            } = L;
            if (this.data.annotationType = n.AnnotationType.UNDERLINE, this.data.quadPoints = k(X, null)) {
              if (!this.appearance) {
                const ae = this.color ? E(this.color) : [0, 0, 0], se = X.get("CA");
                this._setDefaultAppearance({
                  xref: J,
                  extra: "[] 0 d 0.571 w",
                  strokeColor: ae,
                  strokeAlpha: se,
                  pointsCallback: (Q, z) => (Q.push(`${z[2].x} ${z[2].y + 1.3} m`, `${z[3].x} ${z[3].y + 1.3} l`, "S"), [z[0].x, z[1].x, z[3].y, z[1].y])
                });
              }
            } else
              this.data.popupRef = null;
          }
        }
        class ce extends f {
          constructor(L) {
            super(L);
            const {
              dict: X,
              xref: J
            } = L;
            if (this.data.annotationType = n.AnnotationType.SQUIGGLY, this.data.quadPoints = k(X, null)) {
              if (!this.appearance) {
                const ae = this.color ? E(this.color) : [0, 0, 0], se = X.get("CA");
                this._setDefaultAppearance({
                  xref: J,
                  extra: "[] 0 d 1 w",
                  strokeColor: ae,
                  strokeAlpha: se,
                  pointsCallback: (Q, z) => {
                    const ie = (z[0].y - z[2].y) / 6;
                    let ne = ie, W = z[2].x;
                    const oe = z[2].y, ue = z[3].x;
                    Q.push(`${W} ${oe + ne} m`);
                    do
                      W += 2, ne = ne === 0 ? ie : 0, Q.push(`${W} ${oe + ne} l`);
                    while (W < ue);
                    return Q.push("S"), [z[2].x, ue, oe - 2 * ie, oe + 2 * ie];
                  }
                });
              }
            } else
              this.data.popupRef = null;
          }
        }
        class q extends f {
          constructor(L) {
            super(L);
            const {
              dict: X,
              xref: J
            } = L;
            if (this.data.annotationType = n.AnnotationType.STRIKEOUT, this.data.quadPoints = k(X, null)) {
              if (!this.appearance) {
                const ae = this.color ? E(this.color) : [0, 0, 0], se = X.get("CA");
                this._setDefaultAppearance({
                  xref: J,
                  extra: "[] 0 d 1 w",
                  strokeColor: ae,
                  strokeAlpha: se,
                  pointsCallback: (Q, z) => (Q.push(`${(z[0].x + z[2].x) / 2} ${(z[0].y + z[2].y) / 2} m`, `${(z[1].x + z[3].x) / 2} ${(z[1].y + z[3].y) / 2} l`, "S"), [z[0].x, z[1].x, z[3].y, z[1].y])
                });
              }
            } else
              this.data.popupRef = null;
          }
        }
        class re extends f {
          constructor(L) {
            super(L), this.data.annotationType = n.AnnotationType.STAMP, this.data.hasOwnCanvas = this.data.noRotate;
          }
          static async createImage(L, X) {
            const {
              width: J,
              height: Y
            } = L, ae = new OffscreenCanvas(J, Y), se = ae.getContext("2d", {
              alpha: !0
            });
            se.drawImage(L, 0, 0);
            const Q = se.getImageData(0, 0, J, Y).data, z = new Uint32Array(Q.buffer), ie = z.some(n.FeatureTest.isLittleEndian ? (Ce) => Ce >>> 24 !== 255 : (Ce) => (Ce & 255) !== 255);
            ie && (se.fillStyle = "white", se.fillRect(0, 0, J, Y), se.drawImage(L, 0, 0));
            const ne = ae.convertToBlob({
              type: "image/jpeg",
              quality: 1
            }).then((Ce) => Ce.arrayBuffer()), W = e.Name.get("XObject"), oe = e.Name.get("Image"), ue = new e.Dict(X);
            ue.set("Type", W), ue.set("Subtype", oe), ue.set("BitsPerComponent", 8), ue.set("ColorSpace", e.Name.get("DeviceRGB")), ue.set("Filter", e.Name.get("DCTDecode")), ue.set("BBox", [0, 0, J, Y]), ue.set("Width", J), ue.set("Height", Y);
            let pe = null;
            if (ie) {
              const Ce = new Uint8Array(z.length);
              if (n.FeatureTest.isLittleEndian)
                for (let Pe = 0, be = z.length; Pe < be; Pe++)
                  Ce[Pe] = z[Pe] >>> 24;
              else
                for (let Pe = 0, be = z.length; Pe < be; Pe++)
                  Ce[Pe] = z[Pe] & 255;
              const Fe = new e.Dict(X);
              Fe.set("Type", W), Fe.set("Subtype", oe), Fe.set("BitsPerComponent", 8), Fe.set("ColorSpace", e.Name.get("DeviceGray")), Fe.set("Width", J), Fe.set("Height", Y), pe = new t.Stream(Ce, 0, 0, Fe);
            }
            return {
              imageStream: new t.Stream(await ne, 0, 0, ue),
              smaskStream: pe,
              width: J,
              height: Y
            };
          }
          static createNewDict(L, X, {
            apRef: J,
            ap: Y
          }) {
            const {
              rect: ae,
              rotation: se,
              user: Q
            } = L, z = new e.Dict(X);
            if (z.set("Type", e.Name.get("Annot")), z.set("Subtype", e.Name.get("Stamp")), z.set("CreationDate", `D:${(0, n.getModificationDate)()}`), z.set("Rect", ae), z.set("F", 4), z.set("Border", [0, 0, 0]), z.set("Rotate", se), Q && z.set("T", (0, F.isAscii)(Q) ? Q : (0, F.stringToUTF16String)(Q, !0)), J || Y) {
              const ie = new e.Dict(X);
              z.set("AP", ie), J ? ie.set("N", J) : ie.set("N", Y);
            }
            return z;
          }
          static async createNewAppearanceStream(L, X, J) {
            const {
              rotation: Y
            } = L, {
              imageRef: ae,
              width: se,
              height: Q
            } = J.image, z = new e.Dict(X), ie = new e.Dict(X);
            z.set("XObject", ie), ie.set("Im0", ae);
            const ne = `q ${se} 0 0 ${Q} 0 0 cm /Im0 Do Q`, W = new e.Dict(X);
            if (W.set("FormType", 1), W.set("Subtype", e.Name.get("Form")), W.set("Type", e.Name.get("XObject")), W.set("BBox", [0, 0, se, Q]), W.set("Resources", z), Y) {
              const ue = (0, F.getRotationMatrix)(Y, se, Q);
              W.set("Matrix", ue);
            }
            const oe = new t.StringStream(ne);
            return oe.dict = W, oe;
          }
        }
        class Z extends f {
          constructor(L) {
            super(L);
            const {
              dict: X,
              xref: J
            } = L, Y = new v.FileSpec(X.get("FS"), J);
            this.data.annotationType = n.AnnotationType.FILEATTACHMENT, this.data.hasOwnCanvas = this.data.noRotate, this.data.file = Y.serializable;
            const ae = X.get("Name");
            this.data.name = ae instanceof e.Name ? (0, n.stringToPDFString)(ae.name) : "PushPin";
            const se = X.get("ca");
            this.data.fillAlpha = typeof se == "number" && se >= 0 && se <= 1 ? se : null;
          }
        }
      },
      /* 11 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.FakeUnicodeFont = void 0, w.createDefaultAppearance = P, w.getPdfColor = i, w.parseAppearanceStream = b, w.parseDefaultAppearance = v;
        var n = V(4), F = V(3), C = V(2), e = V(12), t = V(13), l = V(59), j = V(57), U = V(8);
        class O extends t.EvaluatorPreprocessor {
          constructor(I) {
            super(new U.StringStream(I));
          }
          parse() {
            const I = {
              fn: 0,
              args: []
            }, E = {
              fontSize: 0,
              fontName: "",
              fontColor: new Uint8ClampedArray(3)
            };
            try {
              for (; I.args.length = 0, !!this.read(I); ) {
                if (this.savedStatesDepth !== 0)
                  continue;
                const {
                  fn: k,
                  args: H
                } = I;
                switch (k | 0) {
                  case C.OPS.setFont:
                    const [x, R] = H;
                    x instanceof n.Name && (E.fontName = x.name), typeof R == "number" && R > 0 && (E.fontSize = R);
                    break;
                  case C.OPS.setFillRGBColor:
                    e.ColorSpace.singletons.rgb.getRgbItem(H, 0, E.fontColor, 0);
                    break;
                  case C.OPS.setFillGray:
                    e.ColorSpace.singletons.gray.getRgbItem(H, 0, E.fontColor, 0);
                    break;
                  case C.OPS.setFillCMYKColor:
                    e.ColorSpace.singletons.cmyk.getRgbItem(H, 0, E.fontColor, 0);
                    break;
                }
              }
            } catch (k) {
              (0, C.warn)(`parseDefaultAppearance - ignoring errors: "${k}".`);
            }
            return E;
          }
        }
        function v(A) {
          return new O(A).parse();
        }
        class g extends t.EvaluatorPreprocessor {
          constructor(I, E, k) {
            var H;
            super(I), this.stream = I, this.evaluatorOptions = E, this.xref = k, this.resources = (H = I.dict) == null ? void 0 : H.get("Resources");
          }
          parse() {
            const I = {
              fn: 0,
              args: []
            };
            let E = {
              scaleFactor: 1,
              fontSize: 0,
              fontName: "",
              fontColor: new Uint8ClampedArray(3),
              fillColorSpace: e.ColorSpace.singletons.gray
            }, k = !1;
            const H = [];
            try {
              for (; I.args.length = 0, !(k || !this.read(I)); ) {
                const {
                  fn: x,
                  args: R
                } = I;
                switch (x | 0) {
                  case C.OPS.save:
                    H.push({
                      scaleFactor: E.scaleFactor,
                      fontSize: E.fontSize,
                      fontName: E.fontName,
                      fontColor: E.fontColor.slice(),
                      fillColorSpace: E.fillColorSpace
                    });
                    break;
                  case C.OPS.restore:
                    E = H.pop() || E;
                    break;
                  case C.OPS.setTextMatrix:
                    E.scaleFactor *= Math.hypot(R[0], R[1]);
                    break;
                  case C.OPS.setFont:
                    const [f, c] = R;
                    f instanceof n.Name && (E.fontName = f.name), typeof c == "number" && c > 0 && (E.fontSize = c * E.scaleFactor);
                    break;
                  case C.OPS.setFillColorSpace:
                    E.fillColorSpace = e.ColorSpace.parse({
                      cs: R[0],
                      xref: this.xref,
                      resources: this.resources,
                      pdfFunctionFactory: this._pdfFunctionFactory,
                      localColorSpaceCache: this._localColorSpaceCache
                    });
                    break;
                  case C.OPS.setFillColor:
                    E.fillColorSpace.getRgbItem(R, 0, E.fontColor, 0);
                    break;
                  case C.OPS.setFillRGBColor:
                    e.ColorSpace.singletons.rgb.getRgbItem(R, 0, E.fontColor, 0);
                    break;
                  case C.OPS.setFillGray:
                    e.ColorSpace.singletons.gray.getRgbItem(R, 0, E.fontColor, 0);
                    break;
                  case C.OPS.setFillCMYKColor:
                    e.ColorSpace.singletons.cmyk.getRgbItem(R, 0, E.fontColor, 0);
                    break;
                  case C.OPS.showText:
                  case C.OPS.showSpacedText:
                  case C.OPS.nextLineShowText:
                  case C.OPS.nextLineSetSpacingShowText:
                    k = !0;
                    break;
                }
              }
            } catch (x) {
              (0, C.warn)(`parseAppearanceStream - ignoring errors: "${x}".`);
            }
            return this.stream.reset(), delete E.scaleFactor, delete E.fillColorSpace, E;
          }
          get _localColorSpaceCache() {
            return (0, C.shadow)(this, "_localColorSpaceCache", new l.LocalColorSpaceCache());
          }
          get _pdfFunctionFactory() {
            const I = new j.PDFFunctionFactory({
              xref: this.xref,
              isEvalSupported: this.evaluatorOptions.isEvalSupported
            });
            return (0, C.shadow)(this, "_pdfFunctionFactory", I);
          }
        }
        function b(A, I, E) {
          return new g(A, I, E).parse();
        }
        function i(A, I) {
          if (A[0] === A[1] && A[1] === A[2]) {
            const E = A[0] / 255;
            return `${(0, F.numberToString)(E)} ${I ? "g" : "G"}`;
          }
          return Array.from(A, (E) => (0, F.numberToString)(E / 255)).join(" ") + ` ${I ? "rg" : "RG"}`;
        }
        function P({
          fontSize: A,
          fontName: I,
          fontColor: E
        }) {
          return `/${(0, F.escapePDFName)(I)} ${A} Tf ${i(E, !0)}`;
        }
        class d {
          constructor(I, E) {
            this.xref = I, this.widths = null, this.firstChar = 1 / 0, this.lastChar = -1 / 0, this.fontFamily = E;
            const k = new OffscreenCanvas(1, 1);
            this.ctxMeasure = k.getContext("2d"), d._fontNameId || (d._fontNameId = 1), this.fontName = n.Name.get(`InvalidPDFjsFont_${E}_${d._fontNameId++}`);
          }
          get toUnicodeRef() {
            if (!d._toUnicodeRef) {
              const I = `/CIDInit /ProcSet findresource begin
12 dict begin
begincmap
/CIDSystemInfo
<< /Registry (Adobe)
/Ordering (UCS) /Supplement 0 >> def
/CMapName /Adobe-Identity-UCS def
/CMapType 2 def
1 begincodespacerange
<0000> <FFFF>
endcodespacerange
1 beginbfrange
<0000> <FFFF> <0000>
endbfrange
endcmap CMapName currentdict /CMap defineresource pop end end`, E = d.toUnicodeStream = new U.StringStream(I), k = new n.Dict(this.xref);
              E.dict = k, k.set("Length", I.length), d._toUnicodeRef = this.xref.getNewPersistentRef(E);
            }
            return d._toUnicodeRef;
          }
          get fontDescriptorRef() {
            if (!d._fontDescriptorRef) {
              const I = new n.Dict(this.xref);
              I.set("Type", n.Name.get("FontDescriptor")), I.set("FontName", this.fontName), I.set("FontFamily", "MyriadPro Regular"), I.set("FontBBox", [0, 0, 0, 0]), I.set("FontStretch", n.Name.get("Normal")), I.set("FontWeight", 400), I.set("ItalicAngle", 0), d._fontDescriptorRef = this.xref.getNewPersistentRef(I);
            }
            return d._fontDescriptorRef;
          }
          get descendantFontRef() {
            const I = new n.Dict(this.xref);
            I.set("BaseFont", this.fontName), I.set("Type", n.Name.get("Font")), I.set("Subtype", n.Name.get("CIDFontType0")), I.set("CIDToGIDMap", n.Name.get("Identity")), I.set("FirstChar", this.firstChar), I.set("LastChar", this.lastChar), I.set("FontDescriptor", this.fontDescriptorRef), I.set("DW", 1e3);
            const E = [], k = [...this.widths.entries()].sort();
            let H = null, x = null;
            for (const [f, c] of k) {
              if (!H) {
                H = f, x = [c];
                continue;
              }
              f === H + x.length ? x.push(c) : (E.push(H, x), H = f, x = [c]);
            }
            H && E.push(H, x), I.set("W", E);
            const R = new n.Dict(this.xref);
            return R.set("Ordering", "Identity"), R.set("Registry", "Adobe"), R.set("Supplement", 0), I.set("CIDSystemInfo", R), this.xref.getNewPersistentRef(I);
          }
          get baseFontRef() {
            const I = new n.Dict(this.xref);
            return I.set("BaseFont", this.fontName), I.set("Type", n.Name.get("Font")), I.set("Subtype", n.Name.get("Type0")), I.set("Encoding", n.Name.get("Identity-H")), I.set("DescendantFonts", [this.descendantFontRef]), I.set("ToUnicode", this.toUnicodeRef), this.xref.getNewPersistentRef(I);
          }
          get resources() {
            const I = new n.Dict(this.xref), E = new n.Dict(this.xref);
            return E.set(this.fontName.name, this.baseFontRef), I.set("Font", E), I;
          }
          _createContext() {
            return this.widths = /* @__PURE__ */ new Map(), this.ctxMeasure.font = `1000px ${this.fontFamily}`, this.ctxMeasure;
          }
          createFontResources(I) {
            const E = this._createContext();
            for (const k of I.split(/\r\n?|\n/))
              for (const H of k.split("")) {
                const x = H.charCodeAt(0);
                if (this.widths.has(x))
                  continue;
                const R = E.measureText(H), f = Math.ceil(R.width);
                this.widths.set(x, f), this.firstChar = Math.min(x, this.firstChar), this.lastChar = Math.max(x, this.lastChar);
              }
            return this.resources;
          }
          createAppearance(I, E, k, H, x, R) {
            const f = this._createContext(), c = [];
            let N = -1 / 0;
            for (const Z of I.split(/\r\n?|\n/)) {
              c.push(Z);
              const te = f.measureText(Z).width;
              N = Math.max(N, te);
              for (const L of Z.split("")) {
                const X = L.charCodeAt(0);
                let J = this.widths.get(X);
                if (J === void 0) {
                  const Y = f.measureText(L);
                  J = Math.ceil(Y.width), this.widths.set(X, J), this.firstChar = Math.min(X, this.firstChar), this.lastChar = Math.max(X, this.lastChar);
                }
              }
            }
            N *= H / 1e3;
            const [u, p, S, B] = E;
            let T = S - u, D = B - p;
            k % 180 !== 0 && ([T, D] = [D, T]);
            let K = 1;
            N > T && (K = T / N);
            let _ = 1;
            const o = C.LINE_FACTOR * H, m = C.LINE_DESCENT_FACTOR * H, s = o * c.length;
            s > D && (_ = D / s);
            const r = Math.min(K, _), y = H * r, M = ["q", `0 0 ${(0, F.numberToString)(T)} ${(0, F.numberToString)(D)} re W n`, "BT", `1 0 0 1 0 ${(0, F.numberToString)(D + m)} Tm 0 Tc ${i(x, !0)}`, `/${this.fontName.name} ${(0, F.numberToString)(y)} Tf`], {
              resources: $
            } = this;
            if (R = typeof R == "number" && R >= 0 && R <= 1 ? R : 1, R !== 1) {
              M.push("/R0 gs");
              const Z = new n.Dict(this.xref), te = new n.Dict(this.xref);
              te.set("ca", R), te.set("CA", R), te.set("Type", n.Name.get("ExtGState")), Z.set("R0", te), $.set("ExtGState", Z);
            }
            const G = (0, F.numberToString)(o);
            for (const Z of c)
              M.push(`0 -${G} Td <${(0, F.stringToUTF16HexString)(Z)}> Tj`);
            M.push("ET", "Q");
            const ce = M.join(`
`), q = new n.Dict(this.xref);
            if (q.set("Subtype", n.Name.get("Form")), q.set("Type", n.Name.get("XObject")), q.set("BBox", [0, 0, T, D]), q.set("Length", ce.length), q.set("Resources", $), k) {
              const Z = (0, F.getRotationMatrix)(k, T, D);
              q.set("Matrix", Z);
            }
            const re = new U.StringStream(ce);
            return re.dict = q, re;
          }
        }
        w.FakeUnicodeFont = d;
      },
      /* 12 */
      /***/
      (fe, w, V) => {
        var A, Ri, E, Di, H, x, R, f, c, N, u, p, S, bn, T, Aa, K, Sa, o, Hn, s, yn, y, wn, $, va, ce, Ca, re, ka, te, Li, J, Xn, ae, zn, Q, Ni;
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.ColorSpace = void 0;
        var n = V(2), F = V(4), C = V(5), e = V(3);
        function t(ie, ne, W, oe, ue, pe, ve) {
          ve = ve !== 1 ? 0 : ve;
          const Fe = W / ue, Pe = oe / pe;
          let be = 0, me;
          const we = new Uint16Array(ue), _e = W * 3;
          for (let Se = 0; Se < ue; Se++)
            we[Se] = Math.floor(Se * Fe) * 3;
          for (let Se = 0; Se < pe; Se++) {
            const Ae = Math.floor(Se * Pe) * _e;
            for (let Te = 0; Te < ue; Te++)
              me = Ae + we[Te], ne[be++] = ie[me++], ne[be++] = ie[me++], ne[be++] = ie[me++], be += ve;
          }
        }
        class l {
          constructor(ne, W) {
            this.constructor === l && (0, n.unreachable)("Cannot initialize ColorSpace."), this.name = ne, this.numComps = W;
          }
          getRgb(ne, W) {
            const oe = new Uint8ClampedArray(3);
            return this.getRgbItem(ne, W, oe, 0), oe;
          }
          getRgbItem(ne, W, oe, ue) {
            (0, n.unreachable)("Should not call ColorSpace.getRgbItem");
          }
          getRgbBuffer(ne, W, oe, ue, pe, ve, Ce) {
            (0, n.unreachable)("Should not call ColorSpace.getRgbBuffer");
          }
          getOutputLength(ne, W) {
            (0, n.unreachable)("Should not call ColorSpace.getOutputLength");
          }
          isPassthrough(ne) {
            return !1;
          }
          isDefaultDecode(ne, W) {
            return l.isDefaultDecode(ne, this.numComps);
          }
          fillRgb(ne, W, oe, ue, pe, ve, Ce, Fe, Pe) {
            const be = W * oe;
            let me = null;
            const we = 1 << Ce, _e = oe !== pe || W !== ue;
            if (this.isPassthrough(Ce))
              me = Fe;
            else if (this.numComps === 1 && be > we && this.name !== "DeviceGray" && this.name !== "DeviceRGB") {
              const Se = Ce <= 8 ? new Uint8Array(we) : new Uint16Array(we);
              for (let Te = 0; Te < we; Te++)
                Se[Te] = Te;
              const Ae = new Uint8ClampedArray(we * 3);
              if (this.getRgbBuffer(Se, 0, we, Ae, 0, Ce, 0), _e) {
                me = new Uint8Array(be * 3);
                let Te = 0;
                for (let ke = 0; ke < be; ++ke) {
                  const Ee = Fe[ke] * 3;
                  me[Te++] = Ae[Ee], me[Te++] = Ae[Ee + 1], me[Te++] = Ae[Ee + 2];
                }
              } else {
                let Te = 0;
                for (let ke = 0; ke < be; ++ke) {
                  const Ee = Fe[ke] * 3;
                  ne[Te++] = Ae[Ee], ne[Te++] = Ae[Ee + 1], ne[Te++] = Ae[Ee + 2], Te += Pe;
                }
              }
            } else
              _e ? (me = new Uint8ClampedArray(be * 3), this.getRgbBuffer(Fe, 0, be, me, 0, Ce, 0)) : this.getRgbBuffer(Fe, 0, ue * ve, ne, 0, Ce, Pe);
            if (me)
              if (_e)
                t(me, ne, W, oe, ue, pe, Pe);
              else {
                let Se = 0, Ae = 0;
                for (let Te = 0, ke = ue * ve; Te < ke; Te++)
                  ne[Se++] = me[Ae++], ne[Se++] = me[Ae++], ne[Se++] = me[Ae++], Se += Pe;
              }
          }
          get usesZeroToOneRange() {
            return (0, n.shadow)(this, "usesZeroToOneRange", !0);
          }
          static _cache(ne, W, oe, ue) {
            if (!oe)
              throw new Error('ColorSpace._cache - expected "localColorSpaceCache" argument.');
            if (!ue)
              throw new Error('ColorSpace._cache - expected "parsedColorSpace" argument.');
            let pe, ve;
            ne instanceof F.Ref && (ve = ne, ne = W.fetch(ne)), ne instanceof F.Name && (pe = ne.name), (pe || ve) && oe.set(pe, ve, ue);
          }
          static getCached(ne, W, oe) {
            if (!oe)
              throw new Error('ColorSpace.getCached - expected "localColorSpaceCache" argument.');
            if (ne instanceof F.Ref) {
              const ue = oe.getByRef(ne);
              if (ue)
                return ue;
              try {
                ne = W.fetch(ne);
              } catch (pe) {
                if (pe instanceof e.MissingDataException)
                  throw pe;
              }
            }
            if (ne instanceof F.Name) {
              const ue = oe.getByName(ne.name);
              if (ue)
                return ue;
            }
            return null;
          }
          static async parseAsync({
            cs: ne,
            xref: W,
            resources: oe = null,
            pdfFunctionFactory: ue,
            localColorSpaceCache: pe
          }) {
            const ve = this._parse(ne, W, oe, ue);
            return this._cache(ne, W, pe, ve), ve;
          }
          static parse({
            cs: ne,
            xref: W,
            resources: oe = null,
            pdfFunctionFactory: ue,
            localColorSpaceCache: pe
          }) {
            const ve = this.getCached(ne, W, pe);
            if (ve)
              return ve;
            const Ce = this._parse(ne, W, oe, ue);
            return this._cache(ne, W, pe, Ce), Ce;
          }
          static _parse(ne, W, oe = null, ue) {
            if (ne = W.fetchIfRef(ne), ne instanceof F.Name)
              switch (ne.name) {
                case "G":
                case "DeviceGray":
                  return this.singletons.gray;
                case "RGB":
                case "DeviceRGB":
                  return this.singletons.rgb;
                case "CMYK":
                case "DeviceCMYK":
                  return this.singletons.cmyk;
                case "Pattern":
                  return new U(null);
                default:
                  if (oe instanceof F.Dict) {
                    const pe = oe.get("ColorSpace");
                    if (pe instanceof F.Dict) {
                      const ve = pe.get(ne.name);
                      if (ve) {
                        if (ve instanceof F.Name)
                          return this._parse(ve, W, oe, ue);
                        ne = ve;
                        break;
                      }
                    }
                  }
                  throw new n.FormatError(`Unrecognized ColorSpace: ${ne.name}`);
              }
            if (Array.isArray(ne)) {
              const pe = W.fetchIfRef(ne[0]).name;
              let ve, Ce, Fe, Pe, be, me;
              switch (pe) {
                case "G":
                case "DeviceGray":
                  return this.singletons.gray;
                case "RGB":
                case "DeviceRGB":
                  return this.singletons.rgb;
                case "CMYK":
                case "DeviceCMYK":
                  return this.singletons.cmyk;
                case "CalGray":
                  return ve = W.fetchIfRef(ne[1]), Pe = ve.getArray("WhitePoint"), be = ve.getArray("BlackPoint"), me = ve.get("Gamma"), new i(Pe, be, me);
                case "CalRGB":
                  ve = W.fetchIfRef(ne[1]), Pe = ve.getArray("WhitePoint"), be = ve.getArray("BlackPoint"), me = ve.getArray("Gamma");
                  const we = ve.getArray("Matrix");
                  return new P(Pe, be, me, we);
                case "ICCBased":
                  const Se = W.fetchIfRef(ne[1]).dict;
                  Ce = Se.get("N");
                  const Ae = Se.get("Alternate");
                  if (Ae) {
                    const at = this._parse(Ae, W, oe, ue);
                    if (at.numComps === Ce)
                      return at;
                    (0, n.warn)("ICCBased color space: Ignoring incorrect /Alternate entry.");
                  }
                  if (Ce === 1)
                    return this.singletons.gray;
                  if (Ce === 3)
                    return this.singletons.rgb;
                  if (Ce === 4)
                    return this.singletons.cmyk;
                  break;
                case "Pattern":
                  return Fe = ne[1] || null, Fe && (Fe = this._parse(Fe, W, oe, ue)), new U(Fe);
                case "I":
                case "Indexed":
                  Fe = this._parse(ne[1], W, oe, ue);
                  const Te = W.fetchIfRef(ne[2]) + 1, ke = W.fetchIfRef(ne[3]);
                  return new O(Fe, Te, ke);
                case "Separation":
                case "DeviceN":
                  const Ee = W.fetchIfRef(ne[1]);
                  Ce = Array.isArray(Ee) ? Ee.length : 1, Fe = this._parse(ne[2], W, oe, ue);
                  const Ve = ue.create(ne[3]);
                  return new j(Ce, Fe, Ve);
                case "Lab":
                  ve = W.fetchIfRef(ne[1]), Pe = ve.getArray("WhitePoint"), be = ve.getArray("BlackPoint");
                  const je = ve.getArray("Range");
                  return new d(Pe, be, je);
                default:
                  throw new n.FormatError(`Unimplemented ColorSpace object: ${pe}`);
              }
            }
            throw new n.FormatError(`Unrecognized ColorSpace object: ${ne}`);
          }
          static isDefaultDecode(ne, W) {
            if (!Array.isArray(ne))
              return !0;
            if (W * 2 !== ne.length)
              return (0, n.warn)("The decode map is not the correct length"), !0;
            for (let oe = 0, ue = ne.length; oe < ue; oe += 2)
              if (ne[oe] !== 0 || ne[oe + 1] !== 1)
                return !1;
            return !0;
          }
          static get singletons() {
            return (0, n.shadow)(this, "singletons", {
              get gray() {
                return (0, n.shadow)(this, "gray", new v());
              },
              get rgb() {
                return (0, n.shadow)(this, "rgb", new g());
              },
              get cmyk() {
                return (0, n.shadow)(this, "cmyk", new b());
              }
            });
          }
        }
        w.ColorSpace = l;
        class j extends l {
          constructor(ne, W, oe) {
            super("Alternate", ne), this.base = W, this.tintFn = oe, this.tmpBuf = new Float32Array(W.numComps);
          }
          getRgbItem(ne, W, oe, ue) {
            const pe = this.tmpBuf;
            this.tintFn(ne, W, pe, 0), this.base.getRgbItem(pe, 0, oe, ue);
          }
          getRgbBuffer(ne, W, oe, ue, pe, ve, Ce) {
            const Fe = this.tintFn, Pe = this.base, be = 1 / ((1 << ve) - 1), me = Pe.numComps, we = Pe.usesZeroToOneRange, _e = (Pe.isPassthrough(8) || !we) && Ce === 0;
            let Se = _e ? pe : 0;
            const Ae = _e ? ue : new Uint8ClampedArray(me * oe), Te = this.numComps, ke = new Float32Array(Te), Ee = new Float32Array(me);
            let Ve, je;
            for (Ve = 0; Ve < oe; Ve++) {
              for (je = 0; je < Te; je++)
                ke[je] = ne[W++] * be;
              if (Fe(ke, 0, Ee, 0), we)
                for (je = 0; je < me; je++)
                  Ae[Se++] = Ee[je] * 255;
              else
                Pe.getRgbItem(Ee, 0, Ae, Se), Se += me;
            }
            _e || Pe.getRgbBuffer(Ae, 0, oe, ue, pe, 8, Ce);
          }
          getOutputLength(ne, W) {
            return this.base.getOutputLength(ne * this.base.numComps / this.numComps, W);
          }
        }
        class U extends l {
          constructor(ne) {
            super("Pattern", null), this.base = ne;
          }
          isDefaultDecode(ne, W) {
            (0, n.unreachable)("Should not call PatternCS.isDefaultDecode");
          }
        }
        class O extends l {
          constructor(ne, W, oe) {
            super("Indexed", 1), this.base = ne, this.highVal = W;
            const ue = ne.numComps * W;
            if (this.lookup = new Uint8Array(ue), oe instanceof C.BaseStream) {
              const pe = oe.getBytes(ue);
              this.lookup.set(pe);
            } else if (typeof oe == "string")
              for (let pe = 0; pe < ue; ++pe)
                this.lookup[pe] = oe.charCodeAt(pe) & 255;
            else
              throw new n.FormatError(`IndexedCS - unrecognized lookup table: ${oe}`);
          }
          getRgbItem(ne, W, oe, ue) {
            const pe = this.base.numComps, ve = ne[W] * pe;
            this.base.getRgbBuffer(this.lookup, ve, 1, oe, ue, 8, 0);
          }
          getRgbBuffer(ne, W, oe, ue, pe, ve, Ce) {
            const Fe = this.base, Pe = Fe.numComps, be = Fe.getOutputLength(Pe, Ce), me = this.lookup;
            for (let we = 0; we < oe; ++we) {
              const _e = ne[W++] * Pe;
              Fe.getRgbBuffer(me, _e, 1, ue, pe, 8, Ce), pe += be;
            }
          }
          getOutputLength(ne, W) {
            return this.base.getOutputLength(ne * this.base.numComps, W);
          }
          isDefaultDecode(ne, W) {
            return Array.isArray(ne) ? ne.length !== 2 ? ((0, n.warn)("Decode map length is not correct"), !0) : !Number.isInteger(W) || W < 1 ? ((0, n.warn)("Bits per component is not correct"), !0) : ne[0] === 0 && ne[1] === (1 << W) - 1 : !0;
          }
        }
        class v extends l {
          constructor() {
            super("DeviceGray", 1);
          }
          getRgbItem(ne, W, oe, ue) {
            const pe = ne[W] * 255;
            oe[ue] = oe[ue + 1] = oe[ue + 2] = pe;
          }
          getRgbBuffer(ne, W, oe, ue, pe, ve, Ce) {
            const Fe = 255 / ((1 << ve) - 1);
            let Pe = W, be = pe;
            for (let me = 0; me < oe; ++me) {
              const we = Fe * ne[Pe++];
              ue[be++] = we, ue[be++] = we, ue[be++] = we, be += Ce;
            }
          }
          getOutputLength(ne, W) {
            return ne * (3 + W);
          }
        }
        class g extends l {
          constructor() {
            super("DeviceRGB", 3);
          }
          getRgbItem(ne, W, oe, ue) {
            oe[ue] = ne[W] * 255, oe[ue + 1] = ne[W + 1] * 255, oe[ue + 2] = ne[W + 2] * 255;
          }
          getRgbBuffer(ne, W, oe, ue, pe, ve, Ce) {
            if (ve === 8 && Ce === 0) {
              ue.set(ne.subarray(W, W + oe * 3), pe);
              return;
            }
            const Fe = 255 / ((1 << ve) - 1);
            let Pe = W, be = pe;
            for (let me = 0; me < oe; ++me)
              ue[be++] = Fe * ne[Pe++], ue[be++] = Fe * ne[Pe++], ue[be++] = Fe * ne[Pe++], be += Ce;
          }
          getOutputLength(ne, W) {
            return ne * (3 + W) / 3 | 0;
          }
          isPassthrough(ne) {
            return ne === 8;
          }
        }
        class b extends l {
          constructor() {
            super("DeviceCMYK", 4);
            Me(this, A);
          }
          getRgbItem(W, oe, ue, pe) {
            De(this, A, Ri).call(this, W, oe, 1, ue, pe);
          }
          getRgbBuffer(W, oe, ue, pe, ve, Ce, Fe) {
            const Pe = 1 / ((1 << Ce) - 1);
            for (let be = 0; be < ue; be++)
              De(this, A, Ri).call(this, W, oe, Pe, pe, ve), oe += 4, ve += 3 + Fe;
          }
          getOutputLength(W, oe) {
            return W / 4 * (3 + oe) | 0;
          }
        }
        A = new WeakSet(), Ri = function(W, oe, ue, pe, ve) {
          const Ce = W[oe] * ue, Fe = W[oe + 1] * ue, Pe = W[oe + 2] * ue, be = W[oe + 3] * ue;
          pe[ve] = 255 + Ce * (-4.387332384609988 * Ce + 54.48615194189176 * Fe + 18.82290502165302 * Pe + 212.25662451639585 * be + -285.2331026137004) + Fe * (1.7149763477362134 * Fe - 5.6096736904047315 * Pe + -17.873870861415444 * be - 5.497006427196366) + Pe * (-2.5217340131683033 * Pe - 21.248923337353073 * be + 17.5119270841813) + be * (-21.86122147463605 * be - 189.48180835922747), pe[ve + 1] = 255 + Ce * (8.841041422036149 * Ce + 60.118027045597366 * Fe + 6.871425592049007 * Pe + 31.159100130055922 * be + -79.2970844816548) + Fe * (-15.310361306967817 * Fe + 17.575251261109482 * Pe + 131.35250912493976 * be - 190.9453302588951) + Pe * (4.444339102852739 * Pe + 9.8632861493405 * be - 24.86741582555878) + be * (-20.737325471181034 * be - 187.80453709719578), pe[ve + 2] = 255 + Ce * (0.8842522430003296 * Ce + 8.078677503112928 * Fe + 30.89978309703729 * Pe - 0.23883238689178934 * be + -14.183576799673286) + Fe * (10.49593273432072 * Fe + 63.02378494754052 * Pe + 50.606957656360734 * be - 112.23884253719248) + Pe * (0.03296041114873217 * Pe + 115.60384449646641 * be + -193.58209356861505) + be * (-22.33816807309886 * be - 180.12613974708367);
        };
        class i extends l {
          constructor(W, oe, ue) {
            super("CalGray", 1);
            Me(this, E);
            if (!W)
              throw new n.FormatError("WhitePoint missing - required for color space CalGray");
            if ([this.XW, this.YW, this.ZW] = W, [this.XB, this.YB, this.ZB] = oe || [0, 0, 0], this.G = ue || 1, this.XW < 0 || this.ZW < 0 || this.YW !== 1)
              throw new n.FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
            (this.XB < 0 || this.YB < 0 || this.ZB < 0) && ((0, n.info)(`Invalid BlackPoint for ${this.name}, falling back to default.`), this.XB = this.YB = this.ZB = 0), (this.XB !== 0 || this.YB !== 0 || this.ZB !== 0) && (0, n.warn)(`${this.name}, BlackPoint: XB: ${this.XB}, YB: ${this.YB}, ZB: ${this.ZB}, only default values are supported.`), this.G < 1 && ((0, n.info)(`Invalid Gamma: ${this.G} for ${this.name}, falling back to default.`), this.G = 1);
          }
          getRgbItem(W, oe, ue, pe) {
            De(this, E, Di).call(this, W, oe, ue, pe, 1);
          }
          getRgbBuffer(W, oe, ue, pe, ve, Ce, Fe) {
            const Pe = 1 / ((1 << Ce) - 1);
            for (let be = 0; be < ue; ++be)
              De(this, E, Di).call(this, W, oe, pe, ve, Pe), oe += 1, ve += 3 + Fe;
          }
          getOutputLength(W, oe) {
            return W * (3 + oe);
          }
        }
        E = new WeakSet(), Di = function(W, oe, ue, pe, ve) {
          const Fe = (W[oe] * ve) ** this.G, Pe = this.YW * Fe, be = Math.max(295.8 * Pe ** 0.3333333333333333 - 40.8, 0);
          ue[pe] = be, ue[pe + 1] = be, ue[pe + 2] = be;
        };
        const X = class X extends l {
          constructor(W, oe, ue, pe) {
            super("CalRGB", 3);
            Me(this, S);
            Me(this, T);
            Me(this, K);
            Me(this, o);
            Me(this, s);
            Me(this, y);
            Me(this, $);
            Me(this, ce);
            Me(this, re);
            Me(this, te);
            if (!W)
              throw new n.FormatError("WhitePoint missing - required for color space CalRGB");
            const [ve, Ce, Fe] = this.whitePoint = W, [Pe, be, me] = this.blackPoint = oe || new Float32Array(3);
            if ([this.GR, this.GG, this.GB] = ue || new Float32Array([1, 1, 1]), [this.MXA, this.MYA, this.MZA, this.MXB, this.MYB, this.MZB, this.MXC, this.MYC, this.MZC] = pe || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]), ve < 0 || Fe < 0 || Ce !== 1)
              throw new n.FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
            (Pe < 0 || be < 0 || me < 0) && ((0, n.info)(`Invalid BlackPoint for ${this.name} [${Pe}, ${be}, ${me}], falling back to default.`), this.blackPoint = new Float32Array(3)), (this.GR < 0 || this.GG < 0 || this.GB < 0) && ((0, n.info)(`Invalid Gamma [${this.GR}, ${this.GG}, ${this.GB}] for ${this.name}, falling back to default.`), this.GR = this.GG = this.GB = 1);
          }
          getRgbItem(W, oe, ue, pe) {
            De(this, te, Li).call(this, W, oe, ue, pe, 1);
          }
          getRgbBuffer(W, oe, ue, pe, ve, Ce, Fe) {
            const Pe = 1 / ((1 << Ce) - 1);
            for (let be = 0; be < ue; ++be)
              De(this, te, Li).call(this, W, oe, pe, ve, Pe), oe += 3, ve += 3 + Fe;
          }
          getOutputLength(W, oe) {
            return W * (3 + oe) / 3 | 0;
          }
        };
        H = new WeakMap(), x = new WeakMap(), R = new WeakMap(), f = new WeakMap(), c = new WeakMap(), N = new WeakMap(), u = new WeakMap(), p = new WeakMap(), S = new WeakSet(), bn = function(W, oe, ue) {
          ue[0] = W[0] * oe[0] + W[1] * oe[1] + W[2] * oe[2], ue[1] = W[3] * oe[0] + W[4] * oe[1] + W[5] * oe[2], ue[2] = W[6] * oe[0] + W[7] * oe[1] + W[8] * oe[2];
        }, T = new WeakSet(), Aa = function(W, oe, ue) {
          ue[0] = oe[0] * 1 / W[0], ue[1] = oe[1] * 1 / W[1], ue[2] = oe[2] * 1 / W[2];
        }, K = new WeakSet(), Sa = function(W, oe, ue) {
          ue[0] = oe[0] * 0.95047 / W[0], ue[1] = oe[1] * 1 / W[1], ue[2] = oe[2] * 1.08883 / W[2];
        }, o = new WeakSet(), Hn = function(W) {
          return W <= 31308e-7 ? De(this, s, yn).call(this, 0, 1, 12.92 * W) : W >= 0.99554525 ? 1 : De(this, s, yn).call(this, 0, 1, 1.055 * W ** 0.4166666666666667 - 0.055);
        }, s = new WeakSet(), yn = function(W, oe, ue) {
          return Math.max(W, Math.min(oe, ue));
        }, y = new WeakSet(), wn = function(W) {
          return W < 0 ? -De(this, y, wn).call(this, -W) : W > 8 ? ((W + 16) / 116) ** 3 : W * le(X, p);
        }, $ = new WeakSet(), va = function(W, oe, ue) {
          if (W[0] === 0 && W[1] === 0 && W[2] === 0) {
            ue[0] = oe[0], ue[1] = oe[1], ue[2] = oe[2];
            return;
          }
          const pe = De(this, y, wn).call(this, 0), ve = pe, Ce = De(this, y, wn).call(this, W[0]), Fe = pe, Pe = De(this, y, wn).call(this, W[1]), be = pe, me = De(this, y, wn).call(this, W[2]), we = (1 - ve) / (1 - Ce), _e = 1 - we, Se = (1 - Fe) / (1 - Pe), Ae = 1 - Se, Te = (1 - be) / (1 - me), ke = 1 - Te;
          ue[0] = oe[0] * we + _e, ue[1] = oe[1] * Se + Ae, ue[2] = oe[2] * Te + ke;
        }, ce = new WeakSet(), Ca = function(W, oe, ue) {
          if (W[0] === 1 && W[2] === 1) {
            ue[0] = oe[0], ue[1] = oe[1], ue[2] = oe[2];
            return;
          }
          const pe = ue;
          De(this, S, bn).call(this, le(X, H), oe, pe);
          const ve = le(X, c);
          De(this, T, Aa).call(this, W, pe, ve), De(this, S, bn).call(this, le(X, x), ve, ue);
        }, re = new WeakSet(), ka = function(W, oe, ue) {
          const pe = ue;
          De(this, S, bn).call(this, le(X, H), oe, pe);
          const ve = le(X, c);
          De(this, K, Sa).call(this, W, pe, ve), De(this, S, bn).call(this, le(X, x), ve, ue);
        }, te = new WeakSet(), Li = function(W, oe, ue, pe, ve) {
          const Ce = De(this, s, yn).call(this, 0, 1, W[oe] * ve), Fe = De(this, s, yn).call(this, 0, 1, W[oe + 1] * ve), Pe = De(this, s, yn).call(this, 0, 1, W[oe + 2] * ve), be = Ce === 1 ? 1 : Ce ** this.GR, me = Fe === 1 ? 1 : Fe ** this.GG, we = Pe === 1 ? 1 : Pe ** this.GB, _e = this.MXA * be + this.MXB * me + this.MXC * we, Se = this.MYA * be + this.MYB * me + this.MYC * we, Ae = this.MZA * be + this.MZB * me + this.MZC * we, Te = le(X, N);
          Te[0] = _e, Te[1] = Se, Te[2] = Ae;
          const ke = le(X, u);
          De(this, ce, Ca).call(this, this.whitePoint, Te, ke);
          const Ee = le(X, N);
          De(this, $, va).call(this, this.blackPoint, ke, Ee);
          const Ve = le(X, u);
          De(this, re, ka).call(this, le(X, f), Ee, Ve);
          const je = le(X, N);
          De(this, S, bn).call(this, le(X, R), Ve, je), ue[pe] = De(this, o, Hn).call(this, je[0]) * 255, ue[pe + 1] = De(this, o, Hn).call(this, je[1]) * 255, ue[pe + 2] = De(this, o, Hn).call(this, je[2]) * 255;
        }, Me(X, H, new Float32Array([0.8951, 0.2664, -0.1614, -0.7502, 1.7135, 0.0367, 0.0389, -0.0685, 1.0296])), Me(X, x, new Float32Array([0.9869929, -0.1470543, 0.1599627, 0.4323053, 0.5183603, 0.0492912, -85287e-7, 0.0400428, 0.9684867])), Me(X, R, new Float32Array([3.2404542, -1.5371385, -0.4985314, -0.969266, 1.8760108, 0.041556, 0.0556434, -0.2040259, 1.0572252])), Me(X, f, new Float32Array([1, 1, 1])), Me(X, c, new Float32Array(3)), Me(X, N, new Float32Array(3)), Me(X, u, new Float32Array(3)), Me(X, p, 0.0011070564598794539);
        let P = X;
        class d extends l {
          constructor(W, oe, ue) {
            super("Lab", 3);
            Me(this, J);
            Me(this, ae);
            Me(this, Q);
            if (!W)
              throw new n.FormatError("WhitePoint missing - required for color space Lab");
            if ([this.XW, this.YW, this.ZW] = W, [this.amin, this.amax, this.bmin, this.bmax] = ue || [-100, 100, -100, 100], [this.XB, this.YB, this.ZB] = oe || [0, 0, 0], this.XW < 0 || this.ZW < 0 || this.YW !== 1)
              throw new n.FormatError("Invalid WhitePoint components, no fallback available");
            (this.XB < 0 || this.YB < 0 || this.ZB < 0) && ((0, n.info)("Invalid BlackPoint, falling back to default"), this.XB = this.YB = this.ZB = 0), (this.amin > this.amax || this.bmin > this.bmax) && ((0, n.info)("Invalid Range, falling back to defaults"), this.amin = -100, this.amax = 100, this.bmin = -100, this.bmax = 100);
          }
          getRgbItem(W, oe, ue, pe) {
            De(this, Q, Ni).call(this, W, oe, !1, ue, pe);
          }
          getRgbBuffer(W, oe, ue, pe, ve, Ce, Fe) {
            const Pe = (1 << Ce) - 1;
            for (let be = 0; be < ue; be++)
              De(this, Q, Ni).call(this, W, oe, Pe, pe, ve), oe += 3, ve += 3 + Fe;
          }
          getOutputLength(W, oe) {
            return W * (3 + oe) / 3 | 0;
          }
          isDefaultDecode(W, oe) {
            return !0;
          }
          get usesZeroToOneRange() {
            return (0, n.shadow)(this, "usesZeroToOneRange", !1);
          }
        }
        J = new WeakSet(), Xn = function(W) {
          return W >= 0.20689655172413793 ? W ** 3 : 0.12841854934601665 * (W - 0.13793103448275862);
        }, ae = new WeakSet(), zn = function(W, oe, ue, pe) {
          return ue + W * (pe - ue) / oe;
        }, Q = new WeakSet(), Ni = function(W, oe, ue, pe, ve) {
          let Ce = W[oe], Fe = W[oe + 1], Pe = W[oe + 2];
          ue !== !1 && (Ce = De(this, ae, zn).call(this, Ce, ue, 0, 100), Fe = De(this, ae, zn).call(this, Fe, ue, this.amin, this.amax), Pe = De(this, ae, zn).call(this, Pe, ue, this.bmin, this.bmax)), Fe > this.amax ? Fe = this.amax : Fe < this.amin && (Fe = this.amin), Pe > this.bmax ? Pe = this.bmax : Pe < this.bmin && (Pe = this.bmin);
          const be = (Ce + 16) / 116, me = be + Fe / 500, we = be - Pe / 200, _e = this.XW * De(this, J, Xn).call(this, me), Se = this.YW * De(this, J, Xn).call(this, be), Ae = this.ZW * De(this, J, Xn).call(this, we);
          let Te, ke, Ee;
          this.ZW < 1 ? (Te = _e * 3.1339 + Se * -1.617 + Ae * -0.4906, ke = _e * -0.9785 + Se * 1.916 + Ae * 0.0333, Ee = _e * 0.072 + Se * -0.229 + Ae * 1.4057) : (Te = _e * 3.2406 + Se * -1.5372 + Ae * -0.4986, ke = _e * -0.9689 + Se * 1.8758 + Ae * 0.0415, Ee = _e * 0.0557 + Se * -0.204 + Ae * 1.057), pe[ve] = Math.sqrt(Te) * 255, pe[ve + 1] = Math.sqrt(ke) * 255, pe[ve + 2] = Math.sqrt(Ee) * 255;
        };
      },
      /* 13 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.PartialEvaluator = w.EvaluatorPreprocessor = void 0;
        var n = V(2), F = V(14), C = V(4), e = V(34), t = V(37), l = V(41), j = V(50), U = V(51), O = V(42), v = V(57), g = V(16), b = V(59), i = V(8), P = V(5), d = V(60), A = V(12), I = V(18), E = V(38), k = V(61), H = V(39), x = V(45), R = V(40), f = V(62), c = V(63), N = V(64), u = V(65);
        const p = Object.freeze({
          maxImageSize: -1,
          disableFontFace: !1,
          ignoreErrors: !1,
          isEvalSupported: !0,
          isOffscreenCanvasSupported: !1,
          canvasMaxAreaInBytes: -1,
          fontExtraProperties: !1,
          useSystemFonts: !0,
          cMapUrl: null,
          standardFontDataUrl: null
        }), S = {
          TILING: 1,
          SHADING: 2
        }, B = 10, T = Promise.resolve();
        function D(ce, q = !1) {
          if (Array.isArray(ce)) {
            for (const re of ce) {
              const Z = D(re, !0);
              if (Z)
                return Z;
            }
            return (0, n.warn)(`Unsupported blend mode Array: ${ce}`), "source-over";
          }
          if (!(ce instanceof C.Name))
            return q ? null : "source-over";
          switch (ce.name) {
            case "Normal":
            case "Compatible":
              return "source-over";
            case "Multiply":
              return "multiply";
            case "Screen":
              return "screen";
            case "Overlay":
              return "overlay";
            case "Darken":
              return "darken";
            case "Lighten":
              return "lighten";
            case "ColorDodge":
              return "color-dodge";
            case "ColorBurn":
              return "color-burn";
            case "HardLight":
              return "hard-light";
            case "SoftLight":
              return "soft-light";
            case "Difference":
              return "difference";
            case "Exclusion":
              return "exclusion";
            case "Hue":
              return "hue";
            case "Saturation":
              return "saturation";
            case "Color":
              return "color";
            case "Luminosity":
              return "luminosity";
          }
          return q ? null : ((0, n.warn)(`Unsupported blend mode: ${ce.name}`), "source-over");
        }
        function K(ce) {
          var q;
          ce.fn === n.OPS.paintImageMaskXObject && ((q = ce.args[0]) == null ? void 0 : q.count) > 0 && ce.args[0].count++;
        }
        const $ = class $ {
          constructor() {
            this.reset();
          }
          check() {
            return ++this.checked < $.CHECK_TIME_EVERY ? !1 : (this.checked = 0, this.endTime <= Date.now());
          }
          reset() {
            this.endTime = Date.now() + $.TIME_SLOT_DURATION_MS, this.checked = 0;
          }
        };
        Ot($, "TIME_SLOT_DURATION_MS", 20), Ot($, "CHECK_TIME_EVERY", 100);
        let _ = $;
        class o {
          constructor({
            xref: q,
            handler: re,
            pageIndex: Z,
            idFactory: te,
            fontCache: L,
            builtInCMapCache: X,
            standardFontDataCache: J,
            globalImageCache: Y,
            systemFontCache: ae,
            options: se = null
          }) {
            this.xref = q, this.handler = re, this.pageIndex = Z, this.idFactory = te, this.fontCache = L, this.builtInCMapCache = X, this.standardFontDataCache = J, this.globalImageCache = Y, this.systemFontCache = ae, this.options = se || p, this.parsingType3Font = !1, this._regionalImageCache = new b.RegionalImageCache(), this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this), f.ImageResizer.setMaxArea(this.options.canvasMaxAreaInBytes);
          }
          get _pdfFunctionFactory() {
            const q = new v.PDFFunctionFactory({
              xref: this.xref,
              isEvalSupported: this.options.isEvalSupported
            });
            return (0, n.shadow)(this, "_pdfFunctionFactory", q);
          }
          clone(q = null) {
            const re = Object.create(this);
            return re.options = Object.assign(/* @__PURE__ */ Object.create(null), this.options, q), re;
          }
          hasBlendModes(q, re) {
            if (!(q instanceof C.Dict) || q.objId && re.has(q.objId))
              return !1;
            const Z = new C.RefSet(re);
            q.objId && Z.put(q.objId);
            const te = [q], L = this.xref;
            for (; te.length; ) {
              const X = te.shift(), J = X.get("ExtGState");
              if (J instanceof C.Dict)
                for (let ae of J.getRawValues()) {
                  if (ae instanceof C.Ref) {
                    if (Z.has(ae))
                      continue;
                    try {
                      ae = L.fetch(ae);
                    } catch (Q) {
                      Z.put(ae), (0, n.info)(`hasBlendModes - ignoring ExtGState: "${Q}".`);
                      continue;
                    }
                  }
                  if (!(ae instanceof C.Dict))
                    continue;
                  ae.objId && Z.put(ae.objId);
                  const se = ae.get("BM");
                  if (se instanceof C.Name) {
                    if (se.name !== "Normal")
                      return !0;
                    continue;
                  }
                  if (se !== void 0 && Array.isArray(se)) {
                    for (const Q of se)
                      if (Q instanceof C.Name && Q.name !== "Normal")
                        return !0;
                  }
                }
              const Y = X.get("XObject");
              if (Y instanceof C.Dict)
                for (let ae of Y.getRawValues()) {
                  if (ae instanceof C.Ref) {
                    if (Z.has(ae))
                      continue;
                    try {
                      ae = L.fetch(ae);
                    } catch (Q) {
                      Z.put(ae), (0, n.info)(`hasBlendModes - ignoring XObject: "${Q}".`);
                      continue;
                    }
                  }
                  if (!(ae instanceof P.BaseStream))
                    continue;
                  ae.dict.objId && Z.put(ae.dict.objId);
                  const se = ae.dict.get("Resources");
                  se instanceof C.Dict && (se.objId && Z.has(se.objId) || (te.push(se), se.objId && Z.put(se.objId)));
                }
            }
            for (const X of Z)
              re.put(X);
            return !1;
          }
          async fetchBuiltInCMap(q) {
            const re = this.builtInCMapCache.get(q);
            if (re)
              return re;
            let Z;
            if (this.options.cMapUrl !== null) {
              const te = `${this.options.cMapUrl}${q}.bcmap`, L = await fetch(te);
              if (!L.ok)
                throw new Error(`fetchBuiltInCMap: failed to fetch file "${te}" with "${L.statusText}".`);
              Z = {
                cMapData: new Uint8Array(await L.arrayBuffer()),
                compressionType: n.CMapCompressionType.BINARY
              };
            } else
              Z = await this.handler.sendWithPromise("FetchBuiltInCMap", {
                name: q
              });
            return Z.compressionType !== n.CMapCompressionType.NONE && this.builtInCMapCache.set(q, Z), Z;
          }
          async fetchStandardFontData(q) {
            const re = this.standardFontDataCache.get(q);
            if (re)
              return new i.Stream(re);
            if (this.options.useSystemFonts && q !== "Symbol" && q !== "ZapfDingbats")
              return null;
            const Z = (0, l.getFontNameToFileMap)(), te = Z[q];
            let L;
            if (this.options.standardFontDataUrl !== null) {
              const X = `${this.options.standardFontDataUrl}${te}`, J = await fetch(X);
              J.ok ? L = await J.arrayBuffer() : (0, n.warn)(`fetchStandardFontData: failed to fetch file "${X}" with "${J.statusText}".`);
            } else
              try {
                L = await this.handler.sendWithPromise("FetchStandardFontData", {
                  filename: te
                });
              } catch (X) {
                (0, n.warn)(`fetchStandardFontData: failed to fetch file "${te}" with "${X}".`);
              }
            return L ? (this.standardFontDataCache.set(q, L), new i.Stream(L)) : null;
          }
          async buildFormXObject(q, re, Z, te, L, X, J) {
            const Y = re.dict, ae = Y.getArray("Matrix");
            let se = Y.getArray("BBox");
            se = Array.isArray(se) && se.length === 4 ? n.Util.normalizeRect(se) : null;
            let Q, z;
            Y.has("OC") && (Q = await this.parseMarkedContentProps(Y.get("OC"), q)), Q !== void 0 && te.addOp(n.OPS.beginMarkedContentProps, ["OC", Q]);
            const ie = Y.get("Group");
            if (ie) {
              z = {
                matrix: ae,
                bbox: se,
                smask: Z,
                isolated: !1,
                knockout: !1
              };
              const W = ie.get("S");
              let oe = null;
              if ((0, C.isName)(W, "Transparency") && (z.isolated = ie.get("I") || !1, z.knockout = ie.get("K") || !1, ie.has("CS"))) {
                const ue = ie.getRaw("CS"), pe = A.ColorSpace.getCached(ue, this.xref, J);
                pe ? oe = pe : oe = await this.parseColorSpace({
                  cs: ue,
                  resources: q,
                  localColorSpaceCache: J
                });
              }
              Z != null && Z.backdrop && (oe || (oe = A.ColorSpace.singletons.rgb), Z.backdrop = oe.getRgb(Z.backdrop, 0)), te.addOp(n.OPS.beginGroup, [z]);
            }
            const ne = ie ? [ae, null] : [ae, se];
            return te.addOp(n.OPS.paintFormXObjectBegin, ne), this.getOperatorList({
              stream: re,
              task: L,
              resources: Y.get("Resources") || q,
              operatorList: te,
              initialState: X
            }).then(function() {
              te.addOp(n.OPS.paintFormXObjectEnd, []), ie && te.addOp(n.OPS.endGroup, [z]), Q !== void 0 && te.addOp(n.OPS.endMarkedContent, []);
            });
          }
          _sendImgData(q, re, Z = !1) {
            const te = re ? [re.bitmap || re.data.buffer] : null;
            return this.parsingType3Font || Z ? this.handler.send("commonobj", [q, "Image", re], te) : this.handler.send("obj", [q, this.pageIndex, "Image", re], te);
          }
          async buildPaintImageXObject({
            resources: q,
            image: re,
            isInline: Z = !1,
            operatorList: te,
            cacheKey: L,
            localImageCache: X,
            localColorSpaceCache: J
          }) {
            const Y = re.dict, ae = Y.objId, se = Y.get("W", "Width"), Q = Y.get("H", "Height");
            if (!(se && typeof se == "number") || !(Q && typeof Q == "number")) {
              (0, n.warn)("Image dimensions are missing, or not numbers.");
              return;
            }
            const z = this.options.maxImageSize;
            if (z !== -1 && se * Q > z) {
              const Ce = "Image exceeded maximum allowed size and was removed.";
              if (this.options.ignoreErrors) {
                (0, n.warn)(Ce);
                return;
              }
              throw new Error(Ce);
            }
            let ie;
            Y.has("OC") && (ie = await this.parseMarkedContentProps(Y.get("OC"), q));
            const ne = Y.get("IM", "ImageMask") || !1;
            let W, oe;
            if (ne) {
              const Ce = Y.get("I", "Interpolate"), Fe = se + 7 >> 3, Pe = re.getBytes(Fe * Q), be = Y.getArray("D", "Decode");
              if (this.parsingType3Font) {
                if (W = u.PDFImage.createRawMask({
                  imgArray: Pe,
                  width: se,
                  height: Q,
                  imageIsFromDecodeStream: re instanceof I.DecodeStream,
                  inverseDecode: (be == null ? void 0 : be[0]) > 0,
                  interpolate: Ce
                }), W.cached = !!L, oe = [W], te.addImageOps(n.OPS.paintImageMaskXObject, oe, ie), L) {
                  const we = {
                    fn: n.OPS.paintImageMaskXObject,
                    args: oe,
                    optionalContent: ie
                  };
                  X.set(L, ae, we), ae && this._regionalImageCache.set(null, ae, we);
                }
                return;
              }
              if (W = await u.PDFImage.createMask({
                imgArray: Pe,
                width: se,
                height: Q,
                imageIsFromDecodeStream: re instanceof I.DecodeStream,
                inverseDecode: (be == null ? void 0 : be[0]) > 0,
                interpolate: Ce,
                isOffscreenCanvasSupported: this.options.isOffscreenCanvasSupported
              }), W.isSingleOpaquePixel) {
                if (te.addImageOps(n.OPS.paintSolidColorImageMask, [], ie), L) {
                  const we = {
                    fn: n.OPS.paintSolidColorImageMask,
                    args: [],
                    optionalContent: ie
                  };
                  X.set(L, ae, we), ae && this._regionalImageCache.set(null, ae, we);
                }
                return;
              }
              const me = `mask_${this.idFactory.createObjId()}`;
              if (te.addDependency(me), this._sendImgData(me, W), oe = [{
                data: me,
                width: W.width,
                height: W.height,
                interpolate: W.interpolate,
                count: 1
              }], te.addImageOps(n.OPS.paintImageMaskXObject, oe, ie), L) {
                const we = {
                  fn: n.OPS.paintImageMaskXObject,
                  args: oe,
                  optionalContent: ie
                };
                X.set(L, ae, we), ae && this._regionalImageCache.set(null, ae, we);
              }
              return;
            }
            if (Z && !Y.has("SMask") && !Y.has("Mask") && se + Q < 200) {
              W = await new u.PDFImage({
                xref: this.xref,
                res: q,
                image: re,
                isInline: Z,
                pdfFunctionFactory: this._pdfFunctionFactory,
                localColorSpaceCache: J
              }).createImageData(!0, !1), te.isOffscreenCanvasSupported = this.options.isOffscreenCanvasSupported, te.addImageOps(n.OPS.paintInlineImageXObject, [W], ie);
              return;
            }
            let pe = `img_${this.idFactory.createObjId()}`, ve = !1;
            if (this.parsingType3Font ? pe = `${this.idFactory.getDocId()}_type3_${pe}` : ae && (ve = this.globalImageCache.shouldCache(ae, this.pageIndex), ve && (pe = `${this.idFactory.getDocId()}_${pe}`)), te.addDependency(pe), oe = [pe, se, Q], u.PDFImage.buildImage({
              xref: this.xref,
              res: q,
              image: re,
              isInline: Z,
              pdfFunctionFactory: this._pdfFunctionFactory,
              localColorSpaceCache: J
            }).then(async (Ce) => {
              if (W = await Ce.createImageData(!1, this.options.isOffscreenCanvasSupported), L && ae && ve) {
                const Fe = W.bitmap ? W.width * W.height * 4 : W.data.length;
                this.globalImageCache.addByteSize(ae, Fe);
              }
              return this._sendImgData(pe, W, ve);
            }).catch((Ce) => ((0, n.warn)(`Unable to decode image "${pe}": "${Ce}".`), this._sendImgData(pe, null, ve))), te.addImageOps(n.OPS.paintImageXObject, oe, ie), L) {
              const Ce = {
                fn: n.OPS.paintImageXObject,
                args: oe,
                optionalContent: ie
              };
              X.set(L, ae, Ce), ae && (this._regionalImageCache.set(null, ae, Ce), ve && ((0, n.assert)(!Z, "Cannot cache an inline image globally."), this.globalImageCache.setData(ae, {
                objId: pe,
                fn: n.OPS.paintImageXObject,
                args: oe,
                optionalContent: ie,
                byteSize: 0
              })));
            }
          }
          handleSMask(q, re, Z, te, L, X) {
            const J = q.get("G"), Y = {
              subtype: q.get("S").name,
              backdrop: q.get("BC")
            }, ae = q.get("TR");
            if ((0, v.isPDFFunction)(ae)) {
              const se = this._pdfFunctionFactory.create(ae), Q = new Uint8Array(256), z = new Float32Array(1);
              for (let ie = 0; ie < 256; ie++)
                z[0] = ie / 255, se(z, 0, z, 0), Q[ie] = z[0] * 255 | 0;
              Y.transferMap = Q;
            }
            return this.buildFormXObject(re, J, Y, Z, te, L.state.clone(), X);
          }
          handleTransferFunction(q) {
            let re;
            if (Array.isArray(q))
              re = q;
            else if ((0, v.isPDFFunction)(q))
              re = [q];
            else
              return null;
            const Z = [];
            let te = 0, L = 0;
            for (const X of re) {
              const J = this.xref.fetchIfRef(X);
              if (te++, (0, C.isName)(J, "Identity")) {
                Z.push(null);
                continue;
              } else if (!(0, v.isPDFFunction)(J))
                return null;
              const Y = this._pdfFunctionFactory.create(J), ae = new Uint8Array(256), se = new Float32Array(1);
              for (let Q = 0; Q < 256; Q++)
                se[0] = Q / 255, Y(se, 0, se, 0), ae[Q] = se[0] * 255 | 0;
              Z.push(ae), L++;
            }
            return !(te === 1 || te === 4) || L === 0 ? null : Z;
          }
          handleTilingType(q, re, Z, te, L, X, J, Y) {
            const ae = new N.OperatorList(), se = C.Dict.merge({
              xref: this.xref,
              dictArray: [L.get("Resources"), Z]
            });
            return this.getOperatorList({
              stream: te,
              task: J,
              resources: se,
              operatorList: ae
            }).then(function() {
              const Q = ae.getIR(), z = (0, j.getTilingPatternIR)(Q, L, re);
              X.addDependencies(ae.dependencies), X.addOp(q, z), L.objId && Y.set(null, L.objId, {
                operatorListIR: Q,
                dict: L
              });
            }).catch((Q) => {
              if (!(Q instanceof n.AbortException)) {
                if (this.options.ignoreErrors) {
                  (0, n.warn)(`handleTilingType - ignoring pattern: "${Q}".`);
                  return;
                }
                throw Q;
              }
            });
          }
          handleSetFont(q, re, Z, te, L, X, J = null, Y = null) {
            const ae = (re == null ? void 0 : re[0]) instanceof C.Name ? re[0].name : null;
            return this.loadFont(ae, Z, q, J, Y).then((se) => se.font.isType3Font ? se.loadType3Data(this, q, L).then(function() {
              return te.addDependencies(se.type3Dependencies), se;
            }).catch((Q) => new m({
              loadedName: "g_font_error",
              font: new e.ErrorFont(`Type3 font load error: ${Q}`),
              dict: se.font,
              evaluatorOptions: this.options
            })) : se).then((se) => (X.font = se.font, se.send(this.handler), se.loadedName));
          }
          handleText(q, re) {
            const Z = re.font, te = Z.charsToGlyphs(q);
            return Z.data && (re.textRenderingMode & n.TextRenderingMode.ADD_TO_PATH_FLAG || re.fillColorSpace.name === "Pattern" || Z.disableFontFace || this.options.disableFontFace) && o.buildFontPaths(Z, te, this.handler, this.options), te;
          }
          ensureStateFont(q) {
            if (q.font)
              return;
            const re = new n.FormatError("Missing setFont (Tf) operator before text rendering operator.");
            if (this.options.ignoreErrors) {
              (0, n.warn)(`ensureStateFont: "${re}".`);
              return;
            }
            throw re;
          }
          async setGState({
            resources: q,
            gState: re,
            operatorList: Z,
            cacheKey: te,
            task: L,
            stateManager: X,
            localGStateCache: J,
            localColorSpaceCache: Y
          }) {
            const ae = re.objId;
            let se = !0;
            const Q = [];
            let z = Promise.resolve();
            for (const ie of re.getKeys()) {
              const ne = re.get(ie);
              switch (ie) {
                case "Type":
                  break;
                case "LW":
                case "LC":
                case "LJ":
                case "ML":
                case "D":
                case "RI":
                case "FL":
                case "CA":
                case "ca":
                  Q.push([ie, ne]);
                  break;
                case "Font":
                  se = !1, z = z.then(() => this.handleSetFont(q, null, ne[0], Z, L, X.state).then(function(oe) {
                    Z.addDependency(oe), Q.push([ie, [oe, ne[1]]]);
                  }));
                  break;
                case "BM":
                  Q.push([ie, D(ne)]);
                  break;
                case "SMask":
                  if ((0, C.isName)(ne, "None")) {
                    Q.push([ie, !1]);
                    break;
                  }
                  ne instanceof C.Dict ? (se = !1, z = z.then(() => this.handleSMask(ne, q, Z, L, X, Y)), Q.push([ie, !0])) : (0, n.warn)("Unsupported SMask type");
                  break;
                case "TR":
                  const W = this.handleTransferFunction(ne);
                  Q.push([ie, W]);
                  break;
                case "OP":
                case "op":
                case "OPM":
                case "BG":
                case "BG2":
                case "UCR":
                case "UCR2":
                case "TR2":
                case "HT":
                case "SM":
                case "SA":
                case "AIS":
                case "TK":
                  (0, n.info)("graphic state operator " + ie);
                  break;
                default:
                  (0, n.info)("Unknown graphic state operator " + ie);
                  break;
              }
            }
            return z.then(function() {
              Q.length > 0 && Z.addOp(n.OPS.setGState, [Q]), se && J.set(te, ae, Q);
            });
          }
          loadFont(q, re, Z, te = null, L = null) {
            const X = async () => new m({
              loadedName: "g_font_error",
              font: new e.ErrorFont(`Font "${q}" is not available.`),
              dict: re,
              evaluatorOptions: this.options
            });
            let J;
            if (re)
              re instanceof C.Ref && (J = re);
            else {
              const ne = Z.get("Font");
              ne && (J = ne.getRaw(q));
            }
            if (J) {
              if (this.parsingType3Font && this.type3FontRefs.has(J))
                return X();
              if (this.fontCache.has(J))
                return this.fontCache.get(J);
              re = this.xref.fetchIfRef(J);
            }
            if (!(re instanceof C.Dict)) {
              if (!this.options.ignoreErrors && !this.parsingType3Font)
                return (0, n.warn)(`Font "${q}" is not available.`), X();
              (0, n.warn)(`Font "${q}" is not available -- attempting to fallback to a default font.`), re = te || o.fallbackFontDict;
            }
            if (re.cacheKey && this.fontCache.has(re.cacheKey))
              return this.fontCache.get(re.cacheKey);
            const Y = new n.PromiseCapability();
            let ae;
            try {
              ae = this.preEvaluateFont(re), ae.cssFontInfo = L;
            } catch (ne) {
              return (0, n.warn)(`loadFont - preEvaluateFont failed: "${ne}".`), X();
            }
            const {
              descriptor: se,
              hash: Q
            } = ae, z = J instanceof C.Ref;
            let ie;
            if (Q && se instanceof C.Dict) {
              const ne = se.fontAliases || (se.fontAliases = /* @__PURE__ */ Object.create(null));
              if (ne[Q]) {
                const W = ne[Q].aliasRef;
                if (z && W && this.fontCache.has(W))
                  return this.fontCache.putAlias(J, W), this.fontCache.get(J);
              } else
                ne[Q] = {
                  fontID: this.idFactory.createFontId()
                };
              z && (ne[Q].aliasRef = J), ie = ne[Q].fontID;
            } else
              ie = this.idFactory.createFontId();
            return (0, n.assert)(ie == null ? void 0 : ie.startsWith("f"), 'The "fontID" must be (correctly) defined.'), z ? this.fontCache.put(J, Y.promise) : (re.cacheKey = `cacheKey_${ie}`, this.fontCache.put(re.cacheKey, Y.promise)), re.loadedName = `${this.idFactory.getDocId()}_${ie}`, this.translateFont(ae).then((ne) => {
              Y.resolve(new m({
                loadedName: re.loadedName,
                font: ne,
                dict: re,
                evaluatorOptions: this.options
              }));
            }).catch((ne) => {
              (0, n.warn)(`loadFont - translateFont failed: "${ne}".`), Y.resolve(new m({
                loadedName: re.loadedName,
                font: new e.ErrorFont(ne instanceof Error ? ne.message : ne),
                dict: re,
                evaluatorOptions: this.options
              }));
            }), Y.promise;
          }
          buildPath(q, re, Z, te = !1) {
            const L = q.length - 1;
            if (Z || (Z = []), L < 0 || q.fnArray[L] !== n.OPS.constructPath) {
              te && ((0, n.warn)(`Encountered path operator "${re}" inside of a text object.`), q.addOp(n.OPS.save, null));
              let X;
              switch (re) {
                case n.OPS.rectangle:
                  const J = Z[0] + Z[2], Y = Z[1] + Z[3];
                  X = [Math.min(Z[0], J), Math.max(Z[0], J), Math.min(Z[1], Y), Math.max(Z[1], Y)];
                  break;
                case n.OPS.moveTo:
                case n.OPS.lineTo:
                  X = [Z[0], Z[0], Z[1], Z[1]];
                  break;
                default:
                  X = [1 / 0, -1 / 0, 1 / 0, -1 / 0];
                  break;
              }
              q.addOp(n.OPS.constructPath, [[re], Z, X]), te && q.addOp(n.OPS.restore, null);
            } else {
              const X = q.argsArray[L];
              X[0].push(re), X[1].push(...Z);
              const J = X[2];
              switch (re) {
                case n.OPS.rectangle:
                  const Y = Z[0] + Z[2], ae = Z[1] + Z[3];
                  J[0] = Math.min(J[0], Z[0], Y), J[1] = Math.max(J[1], Z[0], Y), J[2] = Math.min(J[2], Z[1], ae), J[3] = Math.max(J[3], Z[1], ae);
                  break;
                case n.OPS.moveTo:
                case n.OPS.lineTo:
                  J[0] = Math.min(J[0], Z[0]), J[1] = Math.max(J[1], Z[0]), J[2] = Math.min(J[2], Z[1]), J[3] = Math.max(J[3], Z[1]);
                  break;
              }
            }
          }
          parseColorSpace({
            cs: q,
            resources: re,
            localColorSpaceCache: Z
          }) {
            return A.ColorSpace.parseAsync({
              cs: q,
              xref: this.xref,
              resources: re,
              pdfFunctionFactory: this._pdfFunctionFactory,
              localColorSpaceCache: Z
            }).catch((te) => {
              if (te instanceof n.AbortException)
                return null;
              if (this.options.ignoreErrors)
                return (0, n.warn)(`parseColorSpace - ignoring ColorSpace: "${te}".`), null;
              throw te;
            });
          }
          parseShading({
            shading: q,
            resources: re,
            localColorSpaceCache: Z,
            localShadingPatternCache: te
          }) {
            let L = te.get(q);
            if (!L) {
              var X = j.Pattern.parseShading(q, this.xref, re, this._pdfFunctionFactory, Z);
              const J = X.getIR();
              L = `pattern_${this.idFactory.createObjId()}`, this.parsingType3Font && (L = `${this.idFactory.getDocId()}_type3_${L}`), te.set(q, L), this.parsingType3Font ? this.handler.send("commonobj", [L, "Pattern", J]) : this.handler.send("obj", [L, this.pageIndex, "Pattern", J]);
            }
            return L;
          }
          handleColorN(q, re, Z, te, L, X, J, Y, ae, se) {
            const Q = Z.pop();
            if (Q instanceof C.Name) {
              const z = L.getRaw(Q.name), ie = z instanceof C.Ref && ae.getByRef(z);
              if (ie)
                try {
                  const W = te.base ? te.base.getRgb(Z, 0) : null, oe = (0, j.getTilingPatternIR)(ie.operatorListIR, ie.dict, W);
                  q.addOp(re, oe);
                  return;
                } catch {
                }
              const ne = this.xref.fetchIfRef(z);
              if (ne) {
                const W = ne instanceof P.BaseStream ? ne.dict : ne, oe = W.get("PatternType");
                if (oe === S.TILING) {
                  const ue = te.base ? te.base.getRgb(Z, 0) : null;
                  return this.handleTilingType(re, ue, X, ne, W, q, J, ae);
                } else if (oe === S.SHADING) {
                  const ue = W.get("Shading"), pe = W.getArray("Matrix"), ve = this.parseShading({
                    shading: ue,
                    resources: X,
                    localColorSpaceCache: Y,
                    localShadingPatternCache: se
                  });
                  q.addOp(re, ["Shading", ve, pe]);
                  return;
                }
                throw new n.FormatError(`Unknown PatternType: ${oe}`);
              }
            }
            throw new n.FormatError(`Unknown PatternName: ${Q}`);
          }
          _parseVisibilityExpression(q, re, Z) {
            if (++re > 10) {
              (0, n.warn)("Visibility expression is too deeply nested");
              return;
            }
            const L = q.length, X = this.xref.fetchIfRef(q[0]);
            if (L < 2 || !(X instanceof C.Name)) {
              (0, n.warn)("Invalid visibility expression");
              return;
            }
            switch (X.name) {
              case "And":
              case "Or":
              case "Not":
                Z.push(X.name);
                break;
              default:
                (0, n.warn)(`Invalid operator ${X.name} in visibility expression`);
                return;
            }
            for (let J = 1; J < L; J++) {
              const Y = q[J], ae = this.xref.fetchIfRef(Y);
              if (Array.isArray(ae)) {
                const se = [];
                Z.push(se), this._parseVisibilityExpression(ae, re, se);
              } else
                Y instanceof C.Ref && Z.push(Y.toString());
            }
          }
          async parseMarkedContentProps(q, re) {
            var L;
            let Z;
            if (q instanceof C.Name)
              Z = re.get("Properties").get(q.name);
            else if (q instanceof C.Dict)
              Z = q;
            else
              throw new n.FormatError("Optional content properties malformed.");
            const te = (L = Z.get("Type")) == null ? void 0 : L.name;
            if (te === "OCG")
              return {
                type: te,
                id: Z.objId
              };
            if (te === "OCMD") {
              const X = Z.get("VE");
              if (Array.isArray(X)) {
                const Y = [];
                if (this._parseVisibilityExpression(X, 0, Y), Y.length > 0)
                  return {
                    type: "OCMD",
                    expression: Y
                  };
              }
              const J = Z.get("OCGs");
              if (Array.isArray(J) || J instanceof C.Dict) {
                const Y = [];
                if (Array.isArray(J))
                  for (const ae of J)
                    Y.push(ae.toString());
                else
                  Y.push(J.objId);
                return {
                  type: te,
                  ids: Y,
                  policy: Z.get("P") instanceof C.Name ? Z.get("P").name : null,
                  expression: null
                };
              } else if (J instanceof C.Ref)
                return {
                  type: te,
                  id: J.toString()
                };
            }
            return null;
          }
          getOperatorList({
            stream: q,
            task: re,
            resources: Z,
            operatorList: te,
            initialState: L = null,
            fallbackFontDict: X = null
          }) {
            if (Z || (Z = C.Dict.empty), L || (L = new y()), !te)
              throw new Error('getOperatorList: missing "operatorList" parameter');
            const J = this, Y = this.xref;
            let ae = !1;
            const se = new b.LocalImageCache(), Q = new b.LocalColorSpaceCache(), z = new b.LocalGStateCache(), ie = new b.LocalTilingPatternCache(), ne = /* @__PURE__ */ new Map(), W = Z.get("XObject") || C.Dict.empty, oe = Z.get("Pattern") || C.Dict.empty, ue = new s(L), pe = new M(q, Y, ue), ve = new _();
            function Ce(Fe) {
              for (let Pe = 0, be = pe.savedStatesDepth; Pe < be; Pe++)
                te.addOp(n.OPS.restore, []);
            }
            return new Promise(function Fe(Pe, be) {
              const me = function(Ye) {
                Promise.all([Ye, te.ready]).then(function() {
                  try {
                    Fe(Pe, be);
                  } catch (Qe) {
                    be(Qe);
                  }
                }, be);
              };
              re.ensureNotTerminated(), ve.reset();
              const we = {};
              let _e, Se, Ae, Te, ke, Ee;
              for (; !(_e = ve.check()) && (we.args = null, !!pe.read(we)); ) {
                let Ye = we.args, Qe = we.fn;
                switch (Qe | 0) {
                  case n.OPS.paintXObject:
                    if (Ee = Ye[0] instanceof C.Name, ke = Ye[0].name, Ee) {
                      const he = se.getByName(ke);
                      if (he) {
                        te.addImageOps(he.fn, he.args, he.optionalContent), K(he), Ye = null;
                        continue;
                      }
                    }
                    me(new Promise(function(he, ye) {
                      if (!Ee)
                        throw new n.FormatError("XObject must be referred to by name.");
                      let Ie = W.getRaw(ke);
                      if (Ie instanceof C.Ref) {
                        const Be = se.getByRef(Ie) || J._regionalImageCache.getByRef(Ie);
                        if (Be) {
                          te.addImageOps(Be.fn, Be.args, Be.optionalContent), K(Be), he();
                          return;
                        }
                        const Ne = J.globalImageCache.getData(Ie, J.pageIndex);
                        if (Ne) {
                          te.addDependency(Ne.objId), te.addImageOps(Ne.fn, Ne.args, Ne.optionalContent), he();
                          return;
                        }
                        Ie = Y.fetch(Ie);
                      }
                      if (!(Ie instanceof P.BaseStream))
                        throw new n.FormatError("XObject should be a stream");
                      const Le = Ie.dict.get("Subtype");
                      if (!(Le instanceof C.Name))
                        throw new n.FormatError("XObject should have a Name subtype");
                      if (Le.name === "Form") {
                        ue.save(), J.buildFormXObject(Z, Ie, null, te, re, ue.state.clone(), Q).then(function() {
                          ue.restore(), he();
                        }, ye);
                        return;
                      } else if (Le.name === "Image") {
                        J.buildPaintImageXObject({
                          resources: Z,
                          image: Ie,
                          operatorList: te,
                          cacheKey: ke,
                          localImageCache: se,
                          localColorSpaceCache: Q
                        }).then(he, ye);
                        return;
                      } else if (Le.name === "PS")
                        (0, n.info)("Ignored XObject subtype PS");
                      else
                        throw new n.FormatError(`Unhandled XObject subtype ${Le.name}`);
                      he();
                    }).catch(function(he) {
                      if (!(he instanceof n.AbortException)) {
                        if (J.options.ignoreErrors) {
                          (0, n.warn)(`getOperatorList - ignoring XObject: "${he}".`);
                          return;
                        }
                        throw he;
                      }
                    }));
                    return;
                  case n.OPS.setFont:
                    var Ve = Ye[1];
                    me(J.handleSetFont(Z, Ye, null, te, re, ue.state, X).then(function(he) {
                      te.addDependency(he), te.addOp(n.OPS.setFont, [he, Ve]);
                    }));
                    return;
                  case n.OPS.beginText:
                    ae = !0;
                    break;
                  case n.OPS.endText:
                    ae = !1;
                    break;
                  case n.OPS.endInlineImage:
                    var je = Ye[0].cacheKey;
                    if (je) {
                      const he = se.getByName(je);
                      if (he) {
                        te.addImageOps(he.fn, he.args, he.optionalContent), K(he), Ye = null;
                        continue;
                      }
                    }
                    me(J.buildPaintImageXObject({
                      resources: Z,
                      image: Ye[0],
                      isInline: !0,
                      operatorList: te,
                      cacheKey: je,
                      localImageCache: se,
                      localColorSpaceCache: Q
                    }));
                    return;
                  case n.OPS.showText:
                    if (!ue.state.font) {
                      J.ensureStateFont(ue.state);
                      continue;
                    }
                    Ye[0] = J.handleText(Ye[0], ue.state);
                    break;
                  case n.OPS.showSpacedText:
                    if (!ue.state.font) {
                      J.ensureStateFont(ue.state);
                      continue;
                    }
                    var at = [], $e = ue.state;
                    for (const he of Ye[0])
                      typeof he == "string" ? at.push(...J.handleText(he, $e)) : typeof he == "number" && at.push(he);
                    Ye[0] = at, Qe = n.OPS.showText;
                    break;
                  case n.OPS.nextLineShowText:
                    if (!ue.state.font) {
                      J.ensureStateFont(ue.state);
                      continue;
                    }
                    te.addOp(n.OPS.nextLine), Ye[0] = J.handleText(Ye[0], ue.state), Qe = n.OPS.showText;
                    break;
                  case n.OPS.nextLineSetSpacingShowText:
                    if (!ue.state.font) {
                      J.ensureStateFont(ue.state);
                      continue;
                    }
                    te.addOp(n.OPS.nextLine), te.addOp(n.OPS.setWordSpacing, [Ye.shift()]), te.addOp(n.OPS.setCharSpacing, [Ye.shift()]), Ye[0] = J.handleText(Ye[0], ue.state), Qe = n.OPS.showText;
                    break;
                  case n.OPS.setTextRenderingMode:
                    ue.state.textRenderingMode = Ye[0];
                    break;
                  case n.OPS.setFillColorSpace: {
                    const he = A.ColorSpace.getCached(Ye[0], Y, Q);
                    if (he) {
                      ue.state.fillColorSpace = he;
                      continue;
                    }
                    me(J.parseColorSpace({
                      cs: Ye[0],
                      resources: Z,
                      localColorSpaceCache: Q
                    }).then(function(ye) {
                      ye && (ue.state.fillColorSpace = ye);
                    }));
                    return;
                  }
                  case n.OPS.setStrokeColorSpace: {
                    const he = A.ColorSpace.getCached(Ye[0], Y, Q);
                    if (he) {
                      ue.state.strokeColorSpace = he;
                      continue;
                    }
                    me(J.parseColorSpace({
                      cs: Ye[0],
                      resources: Z,
                      localColorSpaceCache: Q
                    }).then(function(ye) {
                      ye && (ue.state.strokeColorSpace = ye);
                    }));
                    return;
                  }
                  case n.OPS.setFillColor:
                    Te = ue.state.fillColorSpace, Ye = Te.getRgb(Ye, 0), Qe = n.OPS.setFillRGBColor;
                    break;
                  case n.OPS.setStrokeColor:
                    Te = ue.state.strokeColorSpace, Ye = Te.getRgb(Ye, 0), Qe = n.OPS.setStrokeRGBColor;
                    break;
                  case n.OPS.setFillGray:
                    ue.state.fillColorSpace = A.ColorSpace.singletons.gray, Ye = A.ColorSpace.singletons.gray.getRgb(Ye, 0), Qe = n.OPS.setFillRGBColor;
                    break;
                  case n.OPS.setStrokeGray:
                    ue.state.strokeColorSpace = A.ColorSpace.singletons.gray, Ye = A.ColorSpace.singletons.gray.getRgb(Ye, 0), Qe = n.OPS.setStrokeRGBColor;
                    break;
                  case n.OPS.setFillCMYKColor:
                    ue.state.fillColorSpace = A.ColorSpace.singletons.cmyk, Ye = A.ColorSpace.singletons.cmyk.getRgb(Ye, 0), Qe = n.OPS.setFillRGBColor;
                    break;
                  case n.OPS.setStrokeCMYKColor:
                    ue.state.strokeColorSpace = A.ColorSpace.singletons.cmyk, Ye = A.ColorSpace.singletons.cmyk.getRgb(Ye, 0), Qe = n.OPS.setStrokeRGBColor;
                    break;
                  case n.OPS.setFillRGBColor:
                    ue.state.fillColorSpace = A.ColorSpace.singletons.rgb, Ye = A.ColorSpace.singletons.rgb.getRgb(Ye, 0);
                    break;
                  case n.OPS.setStrokeRGBColor:
                    ue.state.strokeColorSpace = A.ColorSpace.singletons.rgb, Ye = A.ColorSpace.singletons.rgb.getRgb(Ye, 0);
                    break;
                  case n.OPS.setFillColorN:
                    if (Te = ue.state.fillColorSpace, Te.name === "Pattern") {
                      me(J.handleColorN(te, n.OPS.setFillColorN, Ye, Te, oe, Z, re, Q, ie, ne));
                      return;
                    }
                    Ye = Te.getRgb(Ye, 0), Qe = n.OPS.setFillRGBColor;
                    break;
                  case n.OPS.setStrokeColorN:
                    if (Te = ue.state.strokeColorSpace, Te.name === "Pattern") {
                      me(J.handleColorN(te, n.OPS.setStrokeColorN, Ye, Te, oe, Z, re, Q, ie, ne));
                      return;
                    }
                    Ye = Te.getRgb(Ye, 0), Qe = n.OPS.setStrokeRGBColor;
                    break;
                  case n.OPS.shadingFill:
                    var ct = Z.get("Shading");
                    if (!ct)
                      throw new n.FormatError("No shading resource found");
                    var ze = ct.get(Ye[0].name);
                    if (!ze)
                      throw new n.FormatError("No shading object found");
                    Ye = [J.parseShading({
                      shading: ze,
                      resources: Z,
                      localColorSpaceCache: Q,
                      localShadingPatternCache: ne
                    })], Qe = n.OPS.shadingFill;
                    break;
                  case n.OPS.setGState:
                    if (Ee = Ye[0] instanceof C.Name, ke = Ye[0].name, Ee) {
                      const he = z.getByName(ke);
                      if (he) {
                        he.length > 0 && te.addOp(n.OPS.setGState, [he]), Ye = null;
                        continue;
                      }
                    }
                    me(new Promise(function(he, ye) {
                      if (!Ee)
                        throw new n.FormatError("GState must be referred to by name.");
                      const Ie = Z.get("ExtGState");
                      if (!(Ie instanceof C.Dict))
                        throw new n.FormatError("ExtGState should be a dictionary.");
                      const Le = Ie.get(ke);
                      if (!(Le instanceof C.Dict))
                        throw new n.FormatError("GState should be a dictionary.");
                      J.setGState({
                        resources: Z,
                        gState: Le,
                        operatorList: te,
                        cacheKey: ke,
                        task: re,
                        stateManager: ue,
                        localGStateCache: z,
                        localColorSpaceCache: Q
                      }).then(he, ye);
                    }).catch(function(he) {
                      if (!(he instanceof n.AbortException)) {
                        if (J.options.ignoreErrors) {
                          (0, n.warn)(`getOperatorList - ignoring ExtGState: "${he}".`);
                          return;
                        }
                        throw he;
                      }
                    }));
                    return;
                  case n.OPS.moveTo:
                  case n.OPS.lineTo:
                  case n.OPS.curveTo:
                  case n.OPS.curveTo2:
                  case n.OPS.curveTo3:
                  case n.OPS.closePath:
                  case n.OPS.rectangle:
                    J.buildPath(te, Qe, Ye, ae);
                    continue;
                  case n.OPS.markPoint:
                  case n.OPS.markPointProps:
                  case n.OPS.beginCompat:
                  case n.OPS.endCompat:
                    continue;
                  case n.OPS.beginMarkedContentProps:
                    if (!(Ye[0] instanceof C.Name)) {
                      (0, n.warn)(`Expected name for beginMarkedContentProps arg0=${Ye[0]}`);
                      continue;
                    }
                    if (Ye[0].name === "OC") {
                      me(J.parseMarkedContentProps(Ye[1], Z).then((he) => {
                        te.addOp(n.OPS.beginMarkedContentProps, ["OC", he]);
                      }).catch((he) => {
                        if (!(he instanceof n.AbortException)) {
                          if (J.options.ignoreErrors) {
                            (0, n.warn)(`getOperatorList - ignoring beginMarkedContentProps: "${he}".`);
                            return;
                          }
                          throw he;
                        }
                      }));
                      return;
                    }
                    Ye = [Ye[0].name, Ye[1] instanceof C.Dict ? Ye[1].get("MCID") : null];
                    break;
                  case n.OPS.beginMarkedContent:
                  case n.OPS.endMarkedContent:
                  default:
                    if (Ye !== null) {
                      for (Se = 0, Ae = Ye.length; Se < Ae && !(Ye[Se] instanceof C.Dict); Se++)
                        ;
                      if (Se < Ae) {
                        (0, n.warn)("getOperatorList - ignoring operator: " + Qe);
                        continue;
                      }
                    }
                }
                te.addOp(Qe, Ye);
              }
              if (_e) {
                me(T);
                return;
              }
              Ce(), Pe();
            }).catch((Fe) => {
              if (!(Fe instanceof n.AbortException)) {
                if (this.options.ignoreErrors) {
                  (0, n.warn)(`getOperatorList - ignoring errors during "${re.name}" task: "${Fe}".`), Ce();
                  return;
                }
                throw Fe;
              }
            });
          }
          getTextContent({
            stream: q,
            task: re,
            resources: Z,
            stateManager: te = null,
            includeMarkedContent: L = !1,
            sink: X,
            seenStyles: J = /* @__PURE__ */ new Set(),
            viewBox: Y,
            markedContentData: ae = null,
            disableNormalization: se = !1
          }) {
            Z || (Z = C.Dict.empty), te || (te = new s(new r())), L && (ae || (ae = {
              level: 0
            }));
            const Q = {
              items: [],
              styles: /* @__PURE__ */ Object.create(null)
            }, z = {
              initialized: !1,
              str: [],
              totalWidth: 0,
              totalHeight: 0,
              width: 0,
              height: 0,
              vertical: !1,
              prevTransform: null,
              textAdvanceScale: 0,
              spaceInFlowMin: 0,
              spaceInFlowMax: 0,
              trackingSpaceMin: 1 / 0,
              negativeSpaceMax: -1 / 0,
              notASpace: -1 / 0,
              transform: null,
              fontName: null,
              hasEOL: !1
            }, ie = [" ", " "];
            let ne = 0;
            function W(Ne) {
              const Ue = (ne + 1) % 2, qe = ie[ne] !== " " && ie[Ue] === " ";
              return ie[ne] = Ne, ne = Ue, qe;
            }
            function oe() {
              return ie[ne] !== " " && ie[(ne + 1) % 2] === " ";
            }
            function ue() {
              ie[0] = ie[1] = " ", ne = 0;
            }
            const pe = 0.102, ve = 0.03, Ce = -0.2, Fe = 0.102, Pe = 0.6, be = 0.25, me = this, we = this.xref, _e = [];
            let Se = null;
            const Ae = new b.LocalImageCache(), Te = new b.LocalGStateCache(), ke = new M(q, we, te);
            let Ee;
            function Ve({
              width: Ne = 0,
              height: Ue = 0,
              transform: qe = z.prevTransform,
              fontName: tt = z.fontName
            }) {
              Q.items.push({
                str: " ",
                dir: "ltr",
                width: Ne,
                height: Ue,
                transform: qe,
                fontName: tt,
                hasEOL: !1
              });
            }
            function je() {
              const Ne = Ee.font, Ue = [Ee.fontSize * Ee.textHScale, 0, 0, Ee.fontSize, 0, Ee.textRise];
              if (Ne.isType3Font && (Ee.fontSize <= 1 || Ne.isCharBBox) && !(0, n.isArrayEqual)(Ee.fontMatrix, n.FONT_IDENTITY_MATRIX)) {
                const qe = Ne.bbox[3] - Ne.bbox[1];
                qe > 0 && (Ue[3] *= qe * Ee.fontMatrix[3]);
              }
              return n.Util.transform(Ee.ctm, n.Util.transform(Ee.textMatrix, Ue));
            }
            function at() {
              if (z.initialized)
                return z;
              const {
                font: Ne,
                loadedName: Ue
              } = Ee;
              J.has(Ue) || (J.add(Ue), Q.styles[Ue] = {
                fontFamily: Ne.fallbackName,
                ascent: Ne.ascent,
                descent: Ne.descent,
                vertical: Ne.vertical
              }), z.fontName = Ue;
              const qe = z.transform = je();
              Ne.vertical ? (z.width = z.totalWidth = Math.hypot(qe[0], qe[1]), z.height = z.totalHeight = 0, z.vertical = !0) : (z.width = z.totalWidth = 0, z.height = z.totalHeight = Math.hypot(qe[2], qe[3]), z.vertical = !1);
              const tt = Math.hypot(Ee.textLineMatrix[0], Ee.textLineMatrix[1]), ht = Math.hypot(Ee.ctm[0], Ee.ctm[1]);
              z.textAdvanceScale = ht * tt;
              const {
                fontSize: rt
              } = Ee;
              return z.trackingSpaceMin = rt * pe, z.notASpace = rt * ve, z.negativeSpaceMax = rt * Ce, z.spaceInFlowMin = rt * Fe, z.spaceInFlowMax = rt * Pe, z.hasEOL = !1, z.initialized = !0, z;
            }
            function $e() {
              if (!z.initialized)
                return;
              const Ne = Math.hypot(Ee.textLineMatrix[0], Ee.textLineMatrix[1]), qe = Math.hypot(Ee.ctm[0], Ee.ctm[1]) * Ne;
              qe !== z.textAdvanceScale && (z.vertical ? (z.totalHeight += z.height * z.textAdvanceScale, z.height = 0) : (z.totalWidth += z.width * z.textAdvanceScale, z.width = 0), z.textAdvanceScale = qe);
            }
            function ct(Ne) {
              let Ue = Ne.str.join("");
              se || (Ue = (0, n.normalizeUnicode)(Ue));
              const qe = (0, d.bidi)(Ue, -1, Ne.vertical);
              return {
                str: qe.str,
                dir: qe.dir,
                width: Math.abs(Ne.totalWidth),
                height: Math.abs(Ne.totalHeight),
                transform: Ne.transform,
                fontName: Ne.fontName,
                hasEOL: Ne.hasEOL
              };
            }
            function ze(Ne, Ue) {
              return me.loadFont(Ne, Ue, Z).then(function(qe) {
                return qe.font.isType3Font ? qe.loadType3Data(me, Z, re).catch(function() {
                }).then(function() {
                  return qe;
                }) : qe;
              }).then(function(qe) {
                Ee.loadedName = qe.loadedName, Ee.font = qe.font, Ee.fontMatrix = qe.font.fontMatrix || n.FONT_IDENTITY_MATRIX;
              });
            }
            function Ye(Ne, Ue, qe) {
              const tt = Math.hypot(qe[0], qe[1]);
              return [(qe[0] * Ne + qe[1] * Ue) / tt, (qe[2] * Ne + qe[3] * Ue) / tt];
            }
            function Qe(Ne) {
              var We;
              const Ue = je();
              let qe = Ue[4], tt = Ue[5];
              if ((We = Ee.font) != null && We.vertical) {
                if (qe < Y[0] || qe > Y[2] || tt + Ne < Y[1] || tt > Y[3])
                  return !1;
              } else if (qe + Ne < Y[0] || qe > Y[2] || tt < Y[1] || tt > Y[3])
                return !1;
              if (!Ee.font || !z.prevTransform)
                return !0;
              let ht = z.prevTransform[4], rt = z.prevTransform[5];
              if (ht === qe && rt === tt)
                return !0;
              let nt = -1;
              switch (Ue[0] && Ue[1] === 0 && Ue[2] === 0 ? nt = Ue[0] > 0 ? 0 : 180 : Ue[1] && Ue[0] === 0 && Ue[3] === 0 && (nt = Ue[1] > 0 ? 90 : 270), nt) {
                case 0:
                  break;
                case 90:
                  [qe, tt] = [tt, qe], [ht, rt] = [rt, ht];
                  break;
                case 180:
                  [qe, tt, ht, rt] = [-qe, -tt, -ht, -rt];
                  break;
                case 270:
                  [qe, tt] = [-tt, -qe], [ht, rt] = [-rt, -ht];
                  break;
                default:
                  [qe, tt] = Ye(qe, tt, Ue), [ht, rt] = Ye(ht, rt, z.prevTransform);
              }
              if (Ee.font.vertical) {
                const Je = (rt - tt) / z.textAdvanceScale, et = qe - ht, lt = Math.sign(z.height);
                return Je < lt * z.negativeSpaceMax ? Math.abs(et) > 0.5 * z.width ? (he(), !0) : (ue(), Ie(), !0) : Math.abs(et) > z.width ? (he(), !0) : (Je <= lt * z.notASpace && ue(), Je <= lt * z.trackingSpaceMin ? oe() ? (ue(), Ie(), Ve({
                  height: Math.abs(Je)
                })) : z.height += Je : ye(Je, z.prevTransform, lt) || (z.str.length === 0 ? (ue(), Ve({
                  height: Math.abs(Je)
                })) : z.height += Je), Math.abs(et) > z.width * be && Ie(), !0);
              }
              const ut = (qe - ht) / z.textAdvanceScale, bt = tt - rt, Ge = Math.sign(z.width);
              return ut < Ge * z.negativeSpaceMax ? Math.abs(bt) > 0.5 * z.height ? (he(), !0) : (ue(), Ie(), !0) : Math.abs(bt) > z.height ? (he(), !0) : (ut <= Ge * z.notASpace && ue(), ut <= Ge * z.trackingSpaceMin ? oe() ? (ue(), Ie(), Ve({
                width: Math.abs(ut)
              })) : z.width += ut : ye(ut, z.prevTransform, Ge) || (z.str.length === 0 ? (ue(), Ve({
                width: Math.abs(ut)
              })) : z.width += ut), Math.abs(bt) > z.height * be && Ie(), !0);
            }
            function Oe({
              chars: Ne,
              extraSpacing: Ue
            }) {
              const qe = Ee.font;
              if (!Ne) {
                const rt = Ee.charSpacing + Ue;
                rt && (qe.vertical ? Ee.translateTextMatrix(0, -rt) : Ee.translateTextMatrix(rt * Ee.textHScale, 0));
                return;
              }
              const tt = qe.charsToGlyphs(Ne), ht = Ee.fontMatrix[0] * Ee.fontSize;
              for (let rt = 0, nt = tt.length; rt < nt; rt++) {
                const ut = tt[rt], {
                  category: bt
                } = ut;
                if (bt.isInvisibleFormatMark)
                  continue;
                let Ge = Ee.charSpacing + (rt + 1 === nt ? Ue : 0), We = ut.width;
                qe.vertical && (We = ut.vmetric ? ut.vmetric[0] : -We);
                let Je = We * ht;
                if (bt.isWhitespace) {
                  qe.vertical ? (Ge += -Je + Ee.wordSpacing, Ee.translateTextMatrix(0, -Ge)) : (Ge += Je + Ee.wordSpacing, Ee.translateTextMatrix(Ge * Ee.textHScale, 0)), W(" ");
                  continue;
                }
                if (!bt.isZeroWidthDiacritic && !Qe(Je)) {
                  qe.vertical ? Ee.translateTextMatrix(0, Je) : Ee.translateTextMatrix(Je * Ee.textHScale, 0);
                  continue;
                }
                const et = at();
                bt.isZeroWidthDiacritic && (Je = 0), qe.vertical ? (Ee.translateTextMatrix(0, Je), Je = Math.abs(Je), et.height += Je) : (Je *= Ee.textHScale, Ee.translateTextMatrix(Je, 0), et.width += Je), Je && (et.prevTransform = je());
                const lt = ut.unicode;
                W(lt) && et.str.push(" "), et.str.push(lt), Ge && (qe.vertical ? Ee.translateTextMatrix(0, -Ge) : Ee.translateTextMatrix(Ge * Ee.textHScale, 0));
              }
            }
            function he() {
              ue(), z.initialized ? (z.hasEOL = !0, Ie()) : Q.items.push({
                str: "",
                dir: "ltr",
                width: 0,
                height: 0,
                transform: je(),
                fontName: Ee.loadedName,
                hasEOL: !0
              });
            }
            function ye(Ne, Ue, qe) {
              if (qe * z.spaceInFlowMin <= Ne && Ne <= qe * z.spaceInFlowMax)
                return z.initialized && (ue(), z.str.push(" ")), !1;
              const tt = z.fontName;
              let ht = 0;
              return z.vertical && (ht = Ne, Ne = 0), Ie(), ue(), Ve({
                width: Math.abs(Ne),
                height: Math.abs(ht),
                transform: Ue || je(),
                fontName: tt
              }), !0;
            }
            function Ie() {
              !z.initialized || !z.str || (z.vertical ? z.totalHeight += z.height * z.textAdvanceScale : z.totalWidth += z.width * z.textAdvanceScale, Q.items.push(ct(z)), z.initialized = !1, z.str.length = 0);
            }
            function Le(Ne = !1) {
              const Ue = Q.items.length;
              Ue !== 0 && (Ne && Ue < B || (X.enqueue(Q, Ue), Q.items = [], Q.styles = /* @__PURE__ */ Object.create(null)));
            }
            const Be = new _();
            return new Promise(function Ne(Ue, qe) {
              const tt = function(Je) {
                Le(!0), Promise.all([Je, X.ready]).then(function() {
                  try {
                    Ne(Ue, qe);
                  } catch (et) {
                    qe(et);
                  }
                }, qe);
              };
              re.ensureNotTerminated(), Be.reset();
              const ht = {};
              let rt, nt = [];
              for (; !(rt = Be.check()) && (nt.length = 0, ht.args = nt, !!ke.read(ht)); ) {
                const Je = Ee;
                Ee = te.state;
                const et = ht.fn;
                switch (nt = ht.args, et | 0) {
                  case n.OPS.setFont:
                    var ut = nt[0].name, bt = nt[1];
                    if (Ee.font && ut === Ee.fontName && bt === Ee.fontSize)
                      break;
                    Ie(), Ee.fontName = ut, Ee.fontSize = bt, tt(ze(ut, null));
                    return;
                  case n.OPS.setTextRise:
                    Ee.textRise = nt[0];
                    break;
                  case n.OPS.setHScale:
                    Ee.textHScale = nt[0] / 100;
                    break;
                  case n.OPS.setLeading:
                    Ee.leading = nt[0];
                    break;
                  case n.OPS.moveText:
                    Ee.translateTextLineMatrix(nt[0], nt[1]), Ee.textMatrix = Ee.textLineMatrix.slice();
                    break;
                  case n.OPS.setLeadingMoveText:
                    Ee.leading = -nt[1], Ee.translateTextLineMatrix(nt[0], nt[1]), Ee.textMatrix = Ee.textLineMatrix.slice();
                    break;
                  case n.OPS.nextLine:
                    Ee.carriageReturn();
                    break;
                  case n.OPS.setTextMatrix:
                    Ee.setTextMatrix(nt[0], nt[1], nt[2], nt[3], nt[4], nt[5]), Ee.setTextLineMatrix(nt[0], nt[1], nt[2], nt[3], nt[4], nt[5]), $e();
                    break;
                  case n.OPS.setCharSpacing:
                    Ee.charSpacing = nt[0];
                    break;
                  case n.OPS.setWordSpacing:
                    Ee.wordSpacing = nt[0];
                    break;
                  case n.OPS.beginText:
                    Ee.textMatrix = n.IDENTITY_MATRIX.slice(), Ee.textLineMatrix = n.IDENTITY_MATRIX.slice();
                    break;
                  case n.OPS.showSpacedText:
                    if (!te.state.font) {
                      me.ensureStateFont(te.state);
                      continue;
                    }
                    const lt = (Ee.font.vertical ? 1 : -1) * Ee.fontSize / 1e3, pt = nt[0];
                    for (let ot = 0, st = pt.length; ot < st; ot++) {
                      const gt = pt[ot];
                      if (typeof gt == "string")
                        _e.push(gt);
                      else if (typeof gt == "number" && gt !== 0) {
                        const vt = _e.join("");
                        _e.length = 0, Oe({
                          chars: vt,
                          extraSpacing: gt * lt
                        });
                      }
                    }
                    if (_e.length > 0) {
                      const ot = _e.join("");
                      _e.length = 0, Oe({
                        chars: ot,
                        extraSpacing: 0
                      });
                    }
                    break;
                  case n.OPS.showText:
                    if (!te.state.font) {
                      me.ensureStateFont(te.state);
                      continue;
                    }
                    Oe({
                      chars: nt[0],
                      extraSpacing: 0
                    });
                    break;
                  case n.OPS.nextLineShowText:
                    if (!te.state.font) {
                      me.ensureStateFont(te.state);
                      continue;
                    }
                    Ee.carriageReturn(), Oe({
                      chars: nt[0],
                      extraSpacing: 0
                    });
                    break;
                  case n.OPS.nextLineSetSpacingShowText:
                    if (!te.state.font) {
                      me.ensureStateFont(te.state);
                      continue;
                    }
                    Ee.wordSpacing = nt[0], Ee.charSpacing = nt[1], Ee.carriageReturn(), Oe({
                      chars: nt[2],
                      extraSpacing: 0
                    });
                    break;
                  case n.OPS.paintXObject:
                    Ie(), Se || (Se = Z.get("XObject") || C.Dict.empty);
                    var Ge = nt[0] instanceof C.Name, We = nt[0].name;
                    if (Ge && Ae.getByName(We))
                      break;
                    tt(new Promise(function(ot, st) {
                      if (!Ge)
                        throw new n.FormatError("XObject must be referred to by name.");
                      let gt = Se.getRaw(We);
                      if (gt instanceof C.Ref) {
                        if (Ae.getByRef(gt)) {
                          ot();
                          return;
                        }
                        if (me.globalImageCache.getData(gt, me.pageIndex)) {
                          ot();
                          return;
                        }
                        gt = we.fetch(gt);
                      }
                      if (!(gt instanceof P.BaseStream))
                        throw new n.FormatError("XObject should be a stream");
                      const vt = gt.dict.get("Subtype");
                      if (!(vt instanceof C.Name))
                        throw new n.FormatError("XObject should have a Name subtype");
                      if (vt.name !== "Form") {
                        Ae.set(We, gt.dict.objId, !0), ot();
                        return;
                      }
                      const Mt = te.state.clone(), At = new s(Mt), St = gt.dict.getArray("Matrix");
                      Array.isArray(St) && St.length === 6 && At.transform(St), Le();
                      const Et = {
                        enqueueInvoked: !1,
                        enqueue(mt, Ct) {
                          this.enqueueInvoked = !0, X.enqueue(mt, Ct);
                        },
                        get desiredSize() {
                          return X.desiredSize;
                        },
                        get ready() {
                          return X.ready;
                        }
                      };
                      me.getTextContent({
                        stream: gt,
                        task: re,
                        resources: gt.dict.get("Resources") || Z,
                        stateManager: At,
                        includeMarkedContent: L,
                        sink: Et,
                        seenStyles: J,
                        viewBox: Y,
                        markedContentData: ae,
                        disableNormalization: se
                      }).then(function() {
                        Et.enqueueInvoked || Ae.set(We, gt.dict.objId, !0), ot();
                      }, st);
                    }).catch(function(ot) {
                      if (!(ot instanceof n.AbortException)) {
                        if (me.options.ignoreErrors) {
                          (0, n.warn)(`getTextContent - ignoring XObject: "${ot}".`);
                          return;
                        }
                        throw ot;
                      }
                    }));
                    return;
                  case n.OPS.setGState:
                    if (Ge = nt[0] instanceof C.Name, We = nt[0].name, Ge && Te.getByName(We))
                      break;
                    tt(new Promise(function(ot, st) {
                      if (!Ge)
                        throw new n.FormatError("GState must be referred to by name.");
                      const gt = Z.get("ExtGState");
                      if (!(gt instanceof C.Dict))
                        throw new n.FormatError("ExtGState should be a dictionary.");
                      const vt = gt.get(We);
                      if (!(vt instanceof C.Dict))
                        throw new n.FormatError("GState should be a dictionary.");
                      const Mt = vt.get("Font");
                      if (!Mt) {
                        Te.set(We, vt.objId, !0), ot();
                        return;
                      }
                      Ie(), Ee.fontName = null, Ee.fontSize = Mt[1], ze(null, Mt[0]).then(ot, st);
                    }).catch(function(ot) {
                      if (!(ot instanceof n.AbortException)) {
                        if (me.options.ignoreErrors) {
                          (0, n.warn)(`getTextContent - ignoring ExtGState: "${ot}".`);
                          return;
                        }
                        throw ot;
                      }
                    }));
                    return;
                  case n.OPS.beginMarkedContent:
                    Ie(), L && (ae.level++, Q.items.push({
                      type: "beginMarkedContent",
                      tag: nt[0] instanceof C.Name ? nt[0].name : null
                    }));
                    break;
                  case n.OPS.beginMarkedContentProps:
                    if (Ie(), L) {
                      ae.level++;
                      let ot = null;
                      nt[1] instanceof C.Dict && (ot = nt[1].get("MCID")), Q.items.push({
                        type: "beginMarkedContentProps",
                        id: Number.isInteger(ot) ? `${me.idFactory.getPageObjId()}_mc${ot}` : null,
                        tag: nt[0] instanceof C.Name ? nt[0].name : null
                      });
                    }
                    break;
                  case n.OPS.endMarkedContent:
                    if (Ie(), L) {
                      if (ae.level === 0)
                        break;
                      ae.level--, Q.items.push({
                        type: "endMarkedContent"
                      });
                    }
                    break;
                  case n.OPS.restore:
                    Je && (Je.font !== Ee.font || Je.fontSize !== Ee.fontSize || Je.fontName !== Ee.fontName) && Ie();
                    break;
                }
                if (Q.items.length >= X.desiredSize) {
                  rt = !0;
                  break;
                }
              }
              if (rt) {
                tt(T);
                return;
              }
              Ie(), Le(), Ue();
            }).catch((Ne) => {
              if (!(Ne instanceof n.AbortException)) {
                if (this.options.ignoreErrors) {
                  (0, n.warn)(`getTextContent - ignoring errors during "${re.name}" task: "${Ne}".`), Ie(), Le();
                  return;
                }
                throw Ne;
              }
            });
          }
          extractDataStructures(q, re, Z) {
            const te = this.xref;
            let L;
            const X = this.readToUnicode(Z.toUnicode || q.get("ToUnicode") || re.get("ToUnicode"));
            if (Z.composite) {
              const z = q.get("CIDSystemInfo");
              z instanceof C.Dict && (Z.cidSystemInfo = {
                registry: (0, n.stringToPDFString)(z.get("Registry")),
                ordering: (0, n.stringToPDFString)(z.get("Ordering")),
                supplement: z.get("Supplement")
              });
              try {
                const ie = q.get("CIDToGIDMap");
                ie instanceof P.BaseStream && (L = ie.getBytes());
              } catch (ie) {
                if (!this.options.ignoreErrors)
                  throw ie;
                (0, n.warn)(`extractDataStructures - ignoring CIDToGIDMap data: "${ie}".`);
              }
            }
            const J = [];
            let Y = null, ae;
            if (q.has("Encoding")) {
              if (ae = q.get("Encoding"), ae instanceof C.Dict) {
                if (Y = ae.get("BaseEncoding"), Y = Y instanceof C.Name ? Y.name : null, ae.has("Differences")) {
                  const z = ae.get("Differences");
                  let ie = 0;
                  for (const ne of z) {
                    const W = te.fetchIfRef(ne);
                    if (typeof W == "number")
                      ie = W;
                    else if (W instanceof C.Name)
                      J[ie++] = W.name;
                    else
                      throw new n.FormatError(`Invalid entry in 'Differences' array: ${W}`);
                  }
                }
              } else if (ae instanceof C.Name)
                Y = ae.name;
              else {
                const z = "Encoding is not a Name nor a Dict";
                if (!this.options.ignoreErrors)
                  throw new n.FormatError(z);
                (0, n.warn)(z);
              }
              Y !== "MacRomanEncoding" && Y !== "MacExpertEncoding" && Y !== "WinAnsiEncoding" && (Y = null);
            }
            const se = !Z.file || Z.isInternalFont, Q = (0, l.getSymbolsFonts)()[Z.name];
            if (Y && se && Q && (Y = null), Y)
              Z.defaultEncoding = (0, t.getEncoding)(Y);
            else {
              const z = !!(Z.flags & E.FontFlags.Symbolic), ie = !!(Z.flags & E.FontFlags.Nonsymbolic);
              ae = t.StandardEncoding, Z.type === "TrueType" && !ie && (ae = t.WinAnsiEncoding), (z || Q) && (ae = t.MacRomanEncoding, se && (/Symbol/i.test(Z.name) ? ae = t.SymbolSetEncoding : /Dingbats/i.test(Z.name) ? ae = t.ZapfDingbatsEncoding : /Wingdings/i.test(Z.name) && (ae = t.WinAnsiEncoding))), Z.defaultEncoding = ae;
            }
            return Z.differences = J, Z.baseEncodingName = Y, Z.hasEncoding = !!Y || J.length > 0, Z.dict = q, X.then((z) => (Z.toUnicode = z, this.buildToUnicode(Z))).then((z) => (Z.toUnicode = z, L && (Z.cidToGidMap = this.readCidToGidMap(L, z)), Z));
          }
          _simpleFontToUnicode(q, re = !1) {
            (0, n.assert)(!q.composite, "Must be a simple font.");
            const Z = [], te = q.defaultEncoding.slice(), L = q.baseEncodingName, X = q.differences;
            for (const Y in X) {
              const ae = X[Y];
              ae !== ".notdef" && (te[Y] = ae);
            }
            const J = (0, H.getGlyphsUnicode)();
            for (const Y in te) {
              let ae = te[Y];
              if (ae === "")
                continue;
              let se = J[ae];
              if (se !== void 0) {
                Z[Y] = String.fromCharCode(se);
                continue;
              }
              let Q = 0;
              switch (ae[0]) {
                case "G":
                  ae.length === 3 && (Q = parseInt(ae.substring(1), 16));
                  break;
                case "g":
                  ae.length === 5 && (Q = parseInt(ae.substring(1), 16));
                  break;
                case "C":
                case "c":
                  if (ae.length >= 3 && ae.length <= 4) {
                    const z = ae.substring(1);
                    if (re) {
                      Q = parseInt(z, 16);
                      break;
                    }
                    if (Q = +z, Number.isNaN(Q) && Number.isInteger(parseInt(z, 16)))
                      return this._simpleFontToUnicode(q, !0);
                  }
                  break;
                case "u":
                  se = (0, R.getUnicodeForGlyph)(ae, J), se !== -1 && (Q = se);
                  break;
                default:
                  switch (ae) {
                    case "f_h":
                    case "f_t":
                    case "T_h":
                      Z[Y] = ae.replaceAll("_", "");
                      continue;
                  }
                  break;
              }
              if (Q > 0 && Q <= 1114111 && Number.isInteger(Q)) {
                if (L && Q === +Y) {
                  const z = (0, t.getEncoding)(L);
                  if (z && (ae = z[Y])) {
                    Z[Y] = String.fromCharCode(J[ae]);
                    continue;
                  }
                }
                Z[Y] = String.fromCodePoint(Q);
              }
            }
            return Z;
          }
          async buildToUnicode(q) {
            var re;
            if (q.hasIncludedToUnicodeMap = ((re = q.toUnicode) == null ? void 0 : re.length) > 0, q.hasIncludedToUnicodeMap)
              return !q.composite && q.hasEncoding && (q.fallbackToUnicode = this._simpleFontToUnicode(q)), q.toUnicode;
            if (!q.composite)
              return new O.ToUnicodeMap(this._simpleFontToUnicode(q));
            if (q.composite && (q.cMap.builtInCMap && !(q.cMap instanceof F.IdentityCMap) || q.cidSystemInfo.registry === "Adobe" && (q.cidSystemInfo.ordering === "GB1" || q.cidSystemInfo.ordering === "CNS1" || q.cidSystemInfo.ordering === "Japan1" || q.cidSystemInfo.ordering === "Korea1"))) {
              const {
                registry: Z,
                ordering: te
              } = q.cidSystemInfo, L = C.Name.get(`${Z}-${te}-UCS2`), X = await F.CMapFactory.create({
                encoding: L,
                fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                useCMap: null
              }), J = [], Y = [];
              return q.cMap.forEach(function(ae, se) {
                if (se > 65535)
                  throw new n.FormatError("Max size of CID is 65,535");
                const Q = X.lookup(se);
                if (Q) {
                  Y.length = 0;
                  for (let z = 0, ie = Q.length; z < ie; z += 2)
                    Y.push((Q.charCodeAt(z) << 8) + Q.charCodeAt(z + 1));
                  J[ae] = String.fromCharCode(...Y);
                }
              }), new O.ToUnicodeMap(J);
            }
            return new O.IdentityToUnicodeMap(q.firstChar, q.lastChar);
          }
          readToUnicode(q) {
            return q ? q instanceof C.Name ? F.CMapFactory.create({
              encoding: q,
              fetchBuiltInCMap: this._fetchBuiltInCMapBound,
              useCMap: null
            }).then(function(re) {
              return re instanceof F.IdentityCMap ? new O.IdentityToUnicodeMap(0, 65535) : new O.ToUnicodeMap(re.getMap());
            }) : q instanceof P.BaseStream ? F.CMapFactory.create({
              encoding: q,
              fetchBuiltInCMap: this._fetchBuiltInCMapBound,
              useCMap: null
            }).then(function(re) {
              if (re instanceof F.IdentityCMap)
                return new O.IdentityToUnicodeMap(0, 65535);
              const Z = new Array(re.length);
              return re.forEach(function(te, L) {
                if (typeof L == "number") {
                  Z[te] = String.fromCodePoint(L);
                  return;
                }
                const X = [];
                for (let J = 0; J < L.length; J += 2) {
                  const Y = L.charCodeAt(J) << 8 | L.charCodeAt(J + 1);
                  if ((Y & 63488) !== 55296) {
                    X.push(Y);
                    continue;
                  }
                  J += 2;
                  const ae = L.charCodeAt(J) << 8 | L.charCodeAt(J + 1);
                  X.push(((Y & 1023) << 10) + (ae & 1023) + 65536);
                }
                Z[te] = String.fromCodePoint(...X);
              }), new O.ToUnicodeMap(Z);
            }, (re) => {
              if (re instanceof n.AbortException)
                return null;
              if (this.options.ignoreErrors)
                return (0, n.warn)(`readToUnicode - ignoring ToUnicode data: "${re}".`), null;
              throw re;
            }) : Promise.resolve(null) : Promise.resolve(null);
          }
          readCidToGidMap(q, re) {
            const Z = [];
            for (let te = 0, L = q.length; te < L; te++) {
              const X = q[te++] << 8 | q[te], J = te >> 1;
              X === 0 && !re.has(J) || (Z[J] = X);
            }
            return Z;
          }
          extractWidths(q, re, Z) {
            const te = this.xref;
            let L = [], X = 0;
            const J = [];
            let Y, ae, se, Q, z, ie, ne, W;
            if (Z.composite) {
              if (X = q.has("DW") ? q.get("DW") : 1e3, W = q.get("W"), W)
                for (ae = 0, se = W.length; ae < se; ae++)
                  if (ie = te.fetchIfRef(W[ae++]), ne = te.fetchIfRef(W[ae]), Array.isArray(ne))
                    for (Q = 0, z = ne.length; Q < z; Q++)
                      L[ie++] = te.fetchIfRef(ne[Q]);
                  else {
                    const pe = te.fetchIfRef(W[++ae]);
                    for (Q = ie; Q <= ne; Q++)
                      L[Q] = pe;
                  }
              if (Z.vertical) {
                let pe = q.getArray("DW2") || [880, -1e3];
                if (Y = [pe[1], X * 0.5, pe[0]], pe = q.get("W2"), pe)
                  for (ae = 0, se = pe.length; ae < se; ae++)
                    if (ie = te.fetchIfRef(pe[ae++]), ne = te.fetchIfRef(pe[ae]), Array.isArray(ne))
                      for (Q = 0, z = ne.length; Q < z; Q++)
                        J[ie++] = [te.fetchIfRef(ne[Q++]), te.fetchIfRef(ne[Q++]), te.fetchIfRef(ne[Q])];
                    else {
                      const ve = [te.fetchIfRef(pe[++ae]), te.fetchIfRef(pe[++ae]), te.fetchIfRef(pe[++ae])];
                      for (Q = ie; Q <= ne; Q++)
                        J[Q] = ve;
                    }
              }
            } else {
              const pe = Z.firstChar;
              if (W = q.get("Widths"), W) {
                for (Q = pe, ae = 0, se = W.length; ae < se; ae++)
                  L[Q++] = te.fetchIfRef(W[ae]);
                X = parseFloat(re.get("MissingWidth")) || 0;
              } else {
                const ve = q.get("BaseFont");
                if (ve instanceof C.Name) {
                  const Ce = this.getBaseFontMetrics(ve.name);
                  L = this.buildCharCodeToWidth(Ce.widths, Z), X = Ce.defaultWidth;
                }
              }
            }
            let oe = !0, ue = X;
            for (const pe in L) {
              const ve = L[pe];
              if (ve) {
                if (!ue) {
                  ue = ve;
                  continue;
                }
                if (ue !== ve) {
                  oe = !1;
                  break;
                }
              }
            }
            oe ? Z.flags |= E.FontFlags.FixedPitch : Z.flags &= ~E.FontFlags.FixedPitch, Z.defaultWidth = X, Z.widths = L, Z.defaultVMetrics = Y, Z.vmetrics = J;
          }
          isSerifFont(q) {
            const re = q.split("-")[0];
            return re in (0, l.getSerifFonts)() || /serif/gi.test(re);
          }
          getBaseFontMetrics(q) {
            let re = 0, Z = /* @__PURE__ */ Object.create(null), te = !1, X = (0, l.getStdFontMap)()[q] || q;
            const J = (0, x.getMetrics)();
            X in J || (X = this.isSerifFont(q) ? "Times-Roman" : "Helvetica");
            const Y = J[X];
            return typeof Y == "number" ? (re = Y, te = !0) : Z = Y(), {
              defaultWidth: re,
              monospace: te,
              widths: Z
            };
          }
          buildCharCodeToWidth(q, re) {
            const Z = /* @__PURE__ */ Object.create(null), te = re.differences, L = re.defaultEncoding;
            for (let X = 0; X < 256; X++) {
              if (X in te && q[te[X]]) {
                Z[X] = q[te[X]];
                continue;
              }
              if (X in L && q[L[X]]) {
                Z[X] = q[L[X]];
                continue;
              }
            }
            return Z;
          }
          preEvaluateFont(q) {
            const re = q;
            let Z = q.get("Subtype");
            if (!(Z instanceof C.Name))
              throw new n.FormatError("invalid font Subtype");
            let te = !1, L, X;
            if (Z.name === "Type0") {
              const se = q.get("DescendantFonts");
              if (!se)
                throw new n.FormatError("Descendant fonts are not specified");
              if (q = Array.isArray(se) ? this.xref.fetchIfRef(se[0]) : se, !(q instanceof C.Dict))
                throw new n.FormatError("Descendant font is not a dictionary.");
              if (Z = q.get("Subtype"), !(Z instanceof C.Name))
                throw new n.FormatError("invalid font Subtype");
              te = !0;
            }
            const J = q.get("FirstChar") || 0, Y = q.get("LastChar") || (te ? 65535 : 255), ae = q.get("FontDescriptor");
            if (ae) {
              L = new c.MurmurHash3_64();
              const se = re.getRaw("Encoding");
              if (se instanceof C.Name)
                L.update(se.name);
              else if (se instanceof C.Ref)
                L.update(se.toString());
              else if (se instanceof C.Dict) {
                for (const z of se.getRawValues())
                  if (z instanceof C.Name)
                    L.update(z.name);
                  else if (z instanceof C.Ref)
                    L.update(z.toString());
                  else if (Array.isArray(z)) {
                    const ie = z.length, ne = new Array(ie);
                    for (let W = 0; W < ie; W++) {
                      const oe = z[W];
                      oe instanceof C.Name ? ne[W] = oe.name : (typeof oe == "number" || oe instanceof C.Ref) && (ne[W] = oe.toString());
                    }
                    L.update(ne.join());
                  }
              }
              if (L.update(`${J}-${Y}`), X = q.get("ToUnicode") || re.get("ToUnicode"), X instanceof P.BaseStream) {
                const z = X.str || X, ie = z.buffer ? new Uint8Array(z.buffer.buffer, 0, z.bufferLength) : new Uint8Array(z.bytes.buffer, z.start, z.end - z.start);
                L.update(ie);
              } else
                X instanceof C.Name && L.update(X.name);
              const Q = q.get("Widths") || re.get("Widths");
              if (Array.isArray(Q)) {
                const z = [];
                for (const ie of Q)
                  (typeof ie == "number" || ie instanceof C.Ref) && z.push(ie.toString());
                L.update(z.join());
              }
              if (te) {
                L.update("compositeFont");
                const z = q.get("W") || re.get("W");
                if (Array.isArray(z)) {
                  const ne = [];
                  for (const W of z)
                    if (typeof W == "number" || W instanceof C.Ref)
                      ne.push(W.toString());
                    else if (Array.isArray(W)) {
                      const oe = [];
                      for (const ue of W)
                        (typeof ue == "number" || ue instanceof C.Ref) && oe.push(ue.toString());
                      ne.push(`[${oe.join()}]`);
                    }
                  L.update(ne.join());
                }
                const ie = q.getRaw("CIDToGIDMap") || re.getRaw("CIDToGIDMap");
                ie instanceof C.Name ? L.update(ie.name) : ie instanceof C.Ref ? L.update(ie.toString()) : ie instanceof P.BaseStream && L.update(ie.peekBytes());
              }
            }
            return {
              descriptor: ae,
              dict: q,
              baseDict: re,
              composite: te,
              type: Z.name,
              firstChar: J,
              lastChar: Y,
              toUnicode: X,
              hash: L ? L.hexdigest() : ""
            };
          }
          async translateFont({
            descriptor: q,
            dict: re,
            baseDict: Z,
            composite: te,
            type: L,
            firstChar: X,
            lastChar: J,
            toUnicode: Y,
            cssFontInfo: ae
          }) {
            const se = L === "Type3";
            let Q;
            if (!q)
              if (se)
                q = new C.Dict(null), q.set("FontName", C.Name.get(L)), q.set("FontBBox", re.getArray("FontBBox") || [0, 0, 0, 0]);
              else {
                let me = re.get("BaseFont");
                if (!(me instanceof C.Name))
                  throw new n.FormatError("Base font is not specified");
                me = me.name.replaceAll(/[,_]/g, "-");
                const we = this.getBaseFontMetrics(me), _e = me.split("-")[0], Se = (this.isSerifFont(_e) ? E.FontFlags.Serif : 0) | (we.monospace ? E.FontFlags.FixedPitch : 0) | ((0, l.getSymbolsFonts)()[_e] ? E.FontFlags.Symbolic : E.FontFlags.Nonsymbolic);
                Q = {
                  type: L,
                  name: me,
                  loadedName: Z.loadedName,
                  systemFontInfo: null,
                  widths: we.widths,
                  defaultWidth: we.defaultWidth,
                  isSimulatedFlags: !0,
                  flags: Se,
                  firstChar: X,
                  lastChar: J,
                  toUnicode: Y,
                  xHeight: 0,
                  capHeight: 0,
                  italicAngle: 0,
                  isType3Font: se
                };
                const Ae = re.get("Widths"), Te = (0, l.getStandardFontName)(me);
                let ke = null;
                return Te && (ke = await this.fetchStandardFontData(Te), Q.isInternalFont = !!ke), !Q.isInternalFont && this.options.useSystemFonts && (Q.systemFontInfo = (0, k.getFontSubstitution)(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, me, Te)), this.extractDataStructures(re, re, Q).then((Ee) => {
                  if (Ae) {
                    const Ve = [];
                    let je = X;
                    for (const at of Ae)
                      Ve[je++] = this.xref.fetchIfRef(at);
                    Ee.widths = Ve;
                  } else
                    Ee.widths = this.buildCharCodeToWidth(we.widths, Ee);
                  return new e.Font(me, ke, Ee);
                });
              }
            let z = q.get("FontName"), ie = re.get("BaseFont");
            typeof z == "string" && (z = C.Name.get(z)), typeof ie == "string" && (ie = C.Name.get(ie));
            const ne = z == null ? void 0 : z.name, W = ie == null ? void 0 : ie.name;
            if (!se && ne !== W && ((0, n.info)(`The FontDescriptor's FontName is "${ne}" but should be the same as the Font's BaseFont "${W}".`), ne && W && (W.startsWith(ne) || !(0, l.isKnownFontName)(ne) && (0, l.isKnownFontName)(W)) && (z = null)), z || (z = ie), !(z instanceof C.Name))
              throw new n.FormatError("invalid font name");
            let oe, ue, pe, ve, Ce;
            try {
              oe = q.get("FontFile", "FontFile2", "FontFile3");
            } catch (me) {
              if (!this.options.ignoreErrors)
                throw me;
              (0, n.warn)(`translateFont - fetching "${z.name}" font file: "${me}".`), oe = new i.NullStream();
            }
            let Fe = !1, Pe = null, be = null;
            if (oe) {
              if (oe.dict) {
                const me = oe.dict.get("Subtype");
                me instanceof C.Name && (ue = me.name), pe = oe.dict.get("Length1"), ve = oe.dict.get("Length2"), Ce = oe.dict.get("Length3");
              }
            } else if (ae) {
              const me = (0, U.getXfaFontName)(z.name);
              me && (ae.fontFamily = `${ae.fontFamily}-PdfJS-XFA`, ae.metrics = me.metrics || null, Pe = me.factors || null, oe = await this.fetchStandardFontData(me.name), Fe = !!oe, Z = re = (0, U.getXfaFontDict)(z.name), te = !0);
            } else if (!se) {
              const me = (0, l.getStandardFontName)(z.name);
              me && (oe = await this.fetchStandardFontData(me), Fe = !!oe), !Fe && this.options.useSystemFonts && (be = (0, k.getFontSubstitution)(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, z.name, me));
            }
            if (Q = {
              type: L,
              name: z.name,
              subtype: ue,
              file: oe,
              length1: pe,
              length2: ve,
              length3: Ce,
              isInternalFont: Fe,
              loadedName: Z.loadedName,
              composite: te,
              fixedPitch: !1,
              fontMatrix: re.getArray("FontMatrix") || n.FONT_IDENTITY_MATRIX,
              firstChar: X,
              lastChar: J,
              toUnicode: Y,
              bbox: q.getArray("FontBBox") || re.getArray("FontBBox"),
              ascent: q.get("Ascent"),
              descent: q.get("Descent"),
              xHeight: q.get("XHeight") || 0,
              capHeight: q.get("CapHeight") || 0,
              flags: q.get("Flags"),
              italicAngle: q.get("ItalicAngle") || 0,
              isType3Font: se,
              cssFontInfo: ae,
              scaleFactors: Pe,
              systemFontInfo: be
            }, te) {
              const me = Z.get("Encoding");
              me instanceof C.Name && (Q.cidEncoding = me.name);
              const we = await F.CMapFactory.create({
                encoding: me,
                fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                useCMap: null
              });
              Q.cMap = we, Q.vertical = Q.cMap.vertical;
            }
            return this.extractDataStructures(re, Z, Q).then((me) => (this.extractWidths(re, q, me), new e.Font(z.name, oe, me)));
          }
          static buildFontPaths(q, re, Z, te) {
            function L(X) {
              const J = `${q.loadedName}_path_${X}`;
              try {
                if (q.renderer.hasBuiltPath(X))
                  return;
                Z.send("commonobj", [J, "FontPath", q.renderer.getPathJs(X)]);
              } catch (Y) {
                if (te.ignoreErrors) {
                  (0, n.warn)(`buildFontPaths - ignoring ${J} glyph: "${Y}".`);
                  return;
                }
                throw Y;
              }
            }
            for (const X of re) {
              L(X.fontChar);
              const J = X.accent;
              J != null && J.fontChar && L(J.fontChar);
            }
          }
          static get fallbackFontDict() {
            const q = new C.Dict();
            return q.set("BaseFont", C.Name.get("Helvetica")), q.set("Type", C.Name.get("FallbackType")), q.set("Subtype", C.Name.get("FallbackType")), q.set("Encoding", C.Name.get("WinAnsiEncoding")), (0, n.shadow)(this, "fallbackFontDict", q);
          }
        }
        w.PartialEvaluator = o;
        class m {
          constructor({
            loadedName: q,
            font: re,
            dict: Z,
            evaluatorOptions: te
          }) {
            this.loadedName = q, this.font = re, this.dict = Z, this._evaluatorOptions = te || p, this.type3Loaded = null, this.type3Dependencies = re.isType3Font ? /* @__PURE__ */ new Set() : null, this.sent = !1;
          }
          send(q) {
            this.sent || (this.sent = !0, q.send("commonobj", [this.loadedName, "Font", this.font.exportData(this._evaluatorOptions.fontExtraProperties)]));
          }
          fallback(q) {
            this.font.data && (this.font.disableFontFace = !0, o.buildFontPaths(this.font, this.font.glyphCacheValues, q, this._evaluatorOptions));
          }
          loadType3Data(q, re, Z) {
            if (this.type3Loaded)
              return this.type3Loaded;
            if (!this.font.isType3Font)
              throw new Error("Must be a Type3 font.");
            const te = q.clone({
              ignoreErrors: !1
            });
            te.parsingType3Font = !0;
            const L = new C.RefSet(q.type3FontRefs);
            this.dict.objId && !L.has(this.dict.objId) && L.put(this.dict.objId), te.type3FontRefs = L;
            const X = this.font, J = this.type3Dependencies;
            let Y = Promise.resolve();
            const ae = this.dict.get("CharProcs"), se = this.dict.get("Resources") || re, Q = /* @__PURE__ */ Object.create(null), z = n.Util.normalizeRect(X.bbox || [0, 0, 0, 0]), ie = z[2] - z[0], ne = z[3] - z[1], W = Math.hypot(ie, ne);
            for (const oe of ae.getKeys())
              Y = Y.then(() => {
                const ue = ae.get(oe), pe = new N.OperatorList();
                return te.getOperatorList({
                  stream: ue,
                  task: Z,
                  resources: se,
                  operatorList: pe
                }).then(() => {
                  pe.fnArray[0] === n.OPS.setCharWidthAndBounds && this._removeType3ColorOperators(pe, W), Q[oe] = pe.getIR();
                  for (const ve of pe.dependencies)
                    J.add(ve);
                }).catch(function(ve) {
                  (0, n.warn)(`Type3 font resource "${oe}" is not available.`);
                  const Ce = new N.OperatorList();
                  Q[oe] = Ce.getIR();
                });
              });
            return this.type3Loaded = Y.then(() => {
              X.charProcOperatorList = Q, this._bbox && (X.isCharBBox = !0, X.bbox = this._bbox);
            }), this.type3Loaded;
          }
          _removeType3ColorOperators(q, re = NaN) {
            const Z = n.Util.normalizeRect(q.argsArray[0].slice(2)), te = Z[2] - Z[0], L = Z[3] - Z[1], X = Math.hypot(te, L);
            te === 0 || L === 0 ? (q.fnArray.splice(0, 1), q.argsArray.splice(0, 1)) : (re === 0 || Math.round(X / re) >= 10) && (this._bbox || (this._bbox = [1 / 0, 1 / 0, -1 / 0, -1 / 0]), this._bbox[0] = Math.min(this._bbox[0], Z[0]), this._bbox[1] = Math.min(this._bbox[1], Z[1]), this._bbox[2] = Math.max(this._bbox[2], Z[2]), this._bbox[3] = Math.max(this._bbox[3], Z[3]));
            let J = 0, Y = q.length;
            for (; J < Y; ) {
              switch (q.fnArray[J]) {
                case n.OPS.setCharWidthAndBounds:
                  break;
                case n.OPS.setStrokeColorSpace:
                case n.OPS.setFillColorSpace:
                case n.OPS.setStrokeColor:
                case n.OPS.setStrokeColorN:
                case n.OPS.setFillColor:
                case n.OPS.setFillColorN:
                case n.OPS.setStrokeGray:
                case n.OPS.setFillGray:
                case n.OPS.setStrokeRGBColor:
                case n.OPS.setFillRGBColor:
                case n.OPS.setStrokeCMYKColor:
                case n.OPS.setFillCMYKColor:
                case n.OPS.shadingFill:
                case n.OPS.setRenderingIntent:
                  q.fnArray.splice(J, 1), q.argsArray.splice(J, 1), Y--;
                  continue;
                case n.OPS.setGState:
                  const [ae] = q.argsArray[J];
                  let se = 0, Q = ae.length;
                  for (; se < Q; ) {
                    const [z] = ae[se];
                    switch (z) {
                      case "TR":
                      case "TR2":
                      case "HT":
                      case "BG":
                      case "BG2":
                      case "UCR":
                      case "UCR2":
                        ae.splice(se, 1), Q--;
                        continue;
                    }
                    se++;
                  }
                  break;
              }
              J++;
            }
          }
        }
        class s {
          constructor(q = new y()) {
            this.state = q, this.stateStack = [];
          }
          save() {
            const q = this.state;
            this.stateStack.push(this.state), this.state = q.clone();
          }
          restore() {
            const q = this.stateStack.pop();
            q && (this.state = q);
          }
          transform(q) {
            this.state.ctm = n.Util.transform(this.state.ctm, q);
          }
        }
        class r {
          constructor() {
            this.ctm = new Float32Array(n.IDENTITY_MATRIX), this.fontName = null, this.fontSize = 0, this.loadedName = null, this.font = null, this.fontMatrix = n.FONT_IDENTITY_MATRIX, this.textMatrix = n.IDENTITY_MATRIX.slice(), this.textLineMatrix = n.IDENTITY_MATRIX.slice(), this.charSpacing = 0, this.wordSpacing = 0, this.leading = 0, this.textHScale = 1, this.textRise = 0;
          }
          setTextMatrix(q, re, Z, te, L, X) {
            const J = this.textMatrix;
            J[0] = q, J[1] = re, J[2] = Z, J[3] = te, J[4] = L, J[5] = X;
          }
          setTextLineMatrix(q, re, Z, te, L, X) {
            const J = this.textLineMatrix;
            J[0] = q, J[1] = re, J[2] = Z, J[3] = te, J[4] = L, J[5] = X;
          }
          translateTextMatrix(q, re) {
            const Z = this.textMatrix;
            Z[4] = Z[0] * q + Z[2] * re + Z[4], Z[5] = Z[1] * q + Z[3] * re + Z[5];
          }
          translateTextLineMatrix(q, re) {
            const Z = this.textLineMatrix;
            Z[4] = Z[0] * q + Z[2] * re + Z[4], Z[5] = Z[1] * q + Z[3] * re + Z[5];
          }
          carriageReturn() {
            this.translateTextLineMatrix(0, -this.leading), this.textMatrix = this.textLineMatrix.slice();
          }
          clone() {
            const q = Object.create(this);
            return q.textMatrix = this.textMatrix.slice(), q.textLineMatrix = this.textLineMatrix.slice(), q.fontMatrix = this.fontMatrix.slice(), q;
          }
        }
        class y {
          constructor() {
            this.ctm = new Float32Array(n.IDENTITY_MATRIX), this.font = null, this.textRenderingMode = n.TextRenderingMode.FILL, this.fillColorSpace = A.ColorSpace.singletons.gray, this.strokeColorSpace = A.ColorSpace.singletons.gray;
          }
          clone() {
            return Object.create(this);
          }
        }
        const G = class G {
          static get opMap() {
            return (0, n.shadow)(this, "opMap", {
              w: {
                id: n.OPS.setLineWidth,
                numArgs: 1,
                variableArgs: !1
              },
              J: {
                id: n.OPS.setLineCap,
                numArgs: 1,
                variableArgs: !1
              },
              j: {
                id: n.OPS.setLineJoin,
                numArgs: 1,
                variableArgs: !1
              },
              M: {
                id: n.OPS.setMiterLimit,
                numArgs: 1,
                variableArgs: !1
              },
              d: {
                id: n.OPS.setDash,
                numArgs: 2,
                variableArgs: !1
              },
              ri: {
                id: n.OPS.setRenderingIntent,
                numArgs: 1,
                variableArgs: !1
              },
              i: {
                id: n.OPS.setFlatness,
                numArgs: 1,
                variableArgs: !1
              },
              gs: {
                id: n.OPS.setGState,
                numArgs: 1,
                variableArgs: !1
              },
              q: {
                id: n.OPS.save,
                numArgs: 0,
                variableArgs: !1
              },
              Q: {
                id: n.OPS.restore,
                numArgs: 0,
                variableArgs: !1
              },
              cm: {
                id: n.OPS.transform,
                numArgs: 6,
                variableArgs: !1
              },
              m: {
                id: n.OPS.moveTo,
                numArgs: 2,
                variableArgs: !1
              },
              l: {
                id: n.OPS.lineTo,
                numArgs: 2,
                variableArgs: !1
              },
              c: {
                id: n.OPS.curveTo,
                numArgs: 6,
                variableArgs: !1
              },
              v: {
                id: n.OPS.curveTo2,
                numArgs: 4,
                variableArgs: !1
              },
              y: {
                id: n.OPS.curveTo3,
                numArgs: 4,
                variableArgs: !1
              },
              h: {
                id: n.OPS.closePath,
                numArgs: 0,
                variableArgs: !1
              },
              re: {
                id: n.OPS.rectangle,
                numArgs: 4,
                variableArgs: !1
              },
              S: {
                id: n.OPS.stroke,
                numArgs: 0,
                variableArgs: !1
              },
              s: {
                id: n.OPS.closeStroke,
                numArgs: 0,
                variableArgs: !1
              },
              f: {
                id: n.OPS.fill,
                numArgs: 0,
                variableArgs: !1
              },
              F: {
                id: n.OPS.fill,
                numArgs: 0,
                variableArgs: !1
              },
              "f*": {
                id: n.OPS.eoFill,
                numArgs: 0,
                variableArgs: !1
              },
              B: {
                id: n.OPS.fillStroke,
                numArgs: 0,
                variableArgs: !1
              },
              "B*": {
                id: n.OPS.eoFillStroke,
                numArgs: 0,
                variableArgs: !1
              },
              b: {
                id: n.OPS.closeFillStroke,
                numArgs: 0,
                variableArgs: !1
              },
              "b*": {
                id: n.OPS.closeEOFillStroke,
                numArgs: 0,
                variableArgs: !1
              },
              n: {
                id: n.OPS.endPath,
                numArgs: 0,
                variableArgs: !1
              },
              W: {
                id: n.OPS.clip,
                numArgs: 0,
                variableArgs: !1
              },
              "W*": {
                id: n.OPS.eoClip,
                numArgs: 0,
                variableArgs: !1
              },
              BT: {
                id: n.OPS.beginText,
                numArgs: 0,
                variableArgs: !1
              },
              ET: {
                id: n.OPS.endText,
                numArgs: 0,
                variableArgs: !1
              },
              Tc: {
                id: n.OPS.setCharSpacing,
                numArgs: 1,
                variableArgs: !1
              },
              Tw: {
                id: n.OPS.setWordSpacing,
                numArgs: 1,
                variableArgs: !1
              },
              Tz: {
                id: n.OPS.setHScale,
                numArgs: 1,
                variableArgs: !1
              },
              TL: {
                id: n.OPS.setLeading,
                numArgs: 1,
                variableArgs: !1
              },
              Tf: {
                id: n.OPS.setFont,
                numArgs: 2,
                variableArgs: !1
              },
              Tr: {
                id: n.OPS.setTextRenderingMode,
                numArgs: 1,
                variableArgs: !1
              },
              Ts: {
                id: n.OPS.setTextRise,
                numArgs: 1,
                variableArgs: !1
              },
              Td: {
                id: n.OPS.moveText,
                numArgs: 2,
                variableArgs: !1
              },
              TD: {
                id: n.OPS.setLeadingMoveText,
                numArgs: 2,
                variableArgs: !1
              },
              Tm: {
                id: n.OPS.setTextMatrix,
                numArgs: 6,
                variableArgs: !1
              },
              "T*": {
                id: n.OPS.nextLine,
                numArgs: 0,
                variableArgs: !1
              },
              Tj: {
                id: n.OPS.showText,
                numArgs: 1,
                variableArgs: !1
              },
              TJ: {
                id: n.OPS.showSpacedText,
                numArgs: 1,
                variableArgs: !1
              },
              "'": {
                id: n.OPS.nextLineShowText,
                numArgs: 1,
                variableArgs: !1
              },
              '"': {
                id: n.OPS.nextLineSetSpacingShowText,
                numArgs: 3,
                variableArgs: !1
              },
              d0: {
                id: n.OPS.setCharWidth,
                numArgs: 2,
                variableArgs: !1
              },
              d1: {
                id: n.OPS.setCharWidthAndBounds,
                numArgs: 6,
                variableArgs: !1
              },
              CS: {
                id: n.OPS.setStrokeColorSpace,
                numArgs: 1,
                variableArgs: !1
              },
              cs: {
                id: n.OPS.setFillColorSpace,
                numArgs: 1,
                variableArgs: !1
              },
              SC: {
                id: n.OPS.setStrokeColor,
                numArgs: 4,
                variableArgs: !0
              },
              SCN: {
                id: n.OPS.setStrokeColorN,
                numArgs: 33,
                variableArgs: !0
              },
              sc: {
                id: n.OPS.setFillColor,
                numArgs: 4,
                variableArgs: !0
              },
              scn: {
                id: n.OPS.setFillColorN,
                numArgs: 33,
                variableArgs: !0
              },
              G: {
                id: n.OPS.setStrokeGray,
                numArgs: 1,
                variableArgs: !1
              },
              g: {
                id: n.OPS.setFillGray,
                numArgs: 1,
                variableArgs: !1
              },
              RG: {
                id: n.OPS.setStrokeRGBColor,
                numArgs: 3,
                variableArgs: !1
              },
              rg: {
                id: n.OPS.setFillRGBColor,
                numArgs: 3,
                variableArgs: !1
              },
              K: {
                id: n.OPS.setStrokeCMYKColor,
                numArgs: 4,
                variableArgs: !1
              },
              k: {
                id: n.OPS.setFillCMYKColor,
                numArgs: 4,
                variableArgs: !1
              },
              sh: {
                id: n.OPS.shadingFill,
                numArgs: 1,
                variableArgs: !1
              },
              BI: {
                id: n.OPS.beginInlineImage,
                numArgs: 0,
                variableArgs: !1
              },
              ID: {
                id: n.OPS.beginImageData,
                numArgs: 0,
                variableArgs: !1
              },
              EI: {
                id: n.OPS.endInlineImage,
                numArgs: 1,
                variableArgs: !1
              },
              Do: {
                id: n.OPS.paintXObject,
                numArgs: 1,
                variableArgs: !1
              },
              MP: {
                id: n.OPS.markPoint,
                numArgs: 1,
                variableArgs: !1
              },
              DP: {
                id: n.OPS.markPointProps,
                numArgs: 2,
                variableArgs: !1
              },
              BMC: {
                id: n.OPS.beginMarkedContent,
                numArgs: 1,
                variableArgs: !1
              },
              BDC: {
                id: n.OPS.beginMarkedContentProps,
                numArgs: 2,
                variableArgs: !1
              },
              EMC: {
                id: n.OPS.endMarkedContent,
                numArgs: 0,
                variableArgs: !1
              },
              BX: {
                id: n.OPS.beginCompat,
                numArgs: 0,
                variableArgs: !1
              },
              EX: {
                id: n.OPS.endCompat,
                numArgs: 0,
                variableArgs: !1
              },
              BM: null,
              BD: null,
              true: null,
              fa: null,
              fal: null,
              fals: null,
              false: null,
              nu: null,
              nul: null,
              null: null
            });
          }
          constructor(q, re, Z = new s()) {
            this.parser = new g.Parser({
              lexer: new g.Lexer(q, G.opMap),
              xref: re
            }), this.stateManager = Z, this.nonProcessedArgs = [], this._isPathOp = !1, this._numInvalidPathOPS = 0;
          }
          get savedStatesDepth() {
            return this.stateManager.stateStack.length;
          }
          read(q) {
            let re = q.args;
            for (; ; ) {
              const Z = this.parser.getObj();
              if (Z instanceof C.Cmd) {
                const te = Z.cmd, L = G.opMap[te];
                if (!L) {
                  (0, n.warn)(`Unknown command "${te}".`);
                  continue;
                }
                const X = L.id, J = L.numArgs;
                let Y = re !== null ? re.length : 0;
                if (this._isPathOp || (this._numInvalidPathOPS = 0), this._isPathOp = X >= n.OPS.moveTo && X <= n.OPS.endPath, L.variableArgs)
                  Y > J && (0, n.info)(`Command ${te}: expected [0, ${J}] args, but received ${Y} args.`);
                else {
                  if (Y !== J) {
                    const ae = this.nonProcessedArgs;
                    for (; Y > J; )
                      ae.push(re.shift()), Y--;
                    for (; Y < J && ae.length !== 0; )
                      re === null && (re = []), re.unshift(ae.pop()), Y++;
                  }
                  if (Y < J) {
                    const ae = `command ${te}: expected ${J} args, but received ${Y} args.`;
                    if (this._isPathOp && ++this._numInvalidPathOPS > G.MAX_INVALID_PATH_OPS)
                      throw new n.FormatError(`Invalid ${ae}`);
                    (0, n.warn)(`Skipping ${ae}`), re !== null && (re.length = 0);
                    continue;
                  }
                }
                return this.preprocessCommand(X, re), q.fn = X, q.args = re, !0;
              }
              if (Z === C.EOF)
                return !1;
              if (Z !== null && (re === null && (re = []), re.push(Z), re.length > 33))
                throw new n.FormatError("Too many arguments");
            }
          }
          preprocessCommand(q, re) {
            switch (q | 0) {
              case n.OPS.save:
                this.stateManager.save();
                break;
              case n.OPS.restore:
                this.stateManager.restore();
                break;
              case n.OPS.transform:
                this.stateManager.transform(re);
                break;
            }
          }
        };
        Ot(G, "MAX_INVALID_PATH_OPS", 10);
        let M = G;
        w.EvaluatorPreprocessor = M;
      },
      /* 14 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.IdentityCMap = w.CMapFactory = w.CMap = void 0;
        var n = V(2), F = V(4), C = V(5), e = V(15), t = V(16), l = V(3), j = V(8);
        const U = ["Adobe-GB1-UCS2", "Adobe-CNS1-UCS2", "Adobe-Japan1-UCS2", "Adobe-Korea1-UCS2", "78-EUC-H", "78-EUC-V", "78-H", "78-RKSJ-H", "78-RKSJ-V", "78-V", "78ms-RKSJ-H", "78ms-RKSJ-V", "83pv-RKSJ-H", "90ms-RKSJ-H", "90ms-RKSJ-V", "90msp-RKSJ-H", "90msp-RKSJ-V", "90pv-RKSJ-H", "90pv-RKSJ-V", "Add-H", "Add-RKSJ-H", "Add-RKSJ-V", "Add-V", "Adobe-CNS1-0", "Adobe-CNS1-1", "Adobe-CNS1-2", "Adobe-CNS1-3", "Adobe-CNS1-4", "Adobe-CNS1-5", "Adobe-CNS1-6", "Adobe-GB1-0", "Adobe-GB1-1", "Adobe-GB1-2", "Adobe-GB1-3", "Adobe-GB1-4", "Adobe-GB1-5", "Adobe-Japan1-0", "Adobe-Japan1-1", "Adobe-Japan1-2", "Adobe-Japan1-3", "Adobe-Japan1-4", "Adobe-Japan1-5", "Adobe-Japan1-6", "Adobe-Korea1-0", "Adobe-Korea1-1", "Adobe-Korea1-2", "B5-H", "B5-V", "B5pc-H", "B5pc-V", "CNS-EUC-H", "CNS-EUC-V", "CNS1-H", "CNS1-V", "CNS2-H", "CNS2-V", "ETHK-B5-H", "ETHK-B5-V", "ETen-B5-H", "ETen-B5-V", "ETenms-B5-H", "ETenms-B5-V", "EUC-H", "EUC-V", "Ext-H", "Ext-RKSJ-H", "Ext-RKSJ-V", "Ext-V", "GB-EUC-H", "GB-EUC-V", "GB-H", "GB-V", "GBK-EUC-H", "GBK-EUC-V", "GBK2K-H", "GBK2K-V", "GBKp-EUC-H", "GBKp-EUC-V", "GBT-EUC-H", "GBT-EUC-V", "GBT-H", "GBT-V", "GBTpc-EUC-H", "GBTpc-EUC-V", "GBpc-EUC-H", "GBpc-EUC-V", "H", "HKdla-B5-H", "HKdla-B5-V", "HKdlb-B5-H", "HKdlb-B5-V", "HKgccs-B5-H", "HKgccs-B5-V", "HKm314-B5-H", "HKm314-B5-V", "HKm471-B5-H", "HKm471-B5-V", "HKscs-B5-H", "HKscs-B5-V", "Hankaku", "Hiragana", "KSC-EUC-H", "KSC-EUC-V", "KSC-H", "KSC-Johab-H", "KSC-Johab-V", "KSC-V", "KSCms-UHC-H", "KSCms-UHC-HW-H", "KSCms-UHC-HW-V", "KSCms-UHC-V", "KSCpc-EUC-H", "KSCpc-EUC-V", "Katakana", "NWP-H", "NWP-V", "RKSJ-H", "RKSJ-V", "Roman", "UniCNS-UCS2-H", "UniCNS-UCS2-V", "UniCNS-UTF16-H", "UniCNS-UTF16-V", "UniCNS-UTF32-H", "UniCNS-UTF32-V", "UniCNS-UTF8-H", "UniCNS-UTF8-V", "UniGB-UCS2-H", "UniGB-UCS2-V", "UniGB-UTF16-H", "UniGB-UTF16-V", "UniGB-UTF32-H", "UniGB-UTF32-V", "UniGB-UTF8-H", "UniGB-UTF8-V", "UniJIS-UCS2-H", "UniJIS-UCS2-HW-H", "UniJIS-UCS2-HW-V", "UniJIS-UCS2-V", "UniJIS-UTF16-H", "UniJIS-UTF16-V", "UniJIS-UTF32-H", "UniJIS-UTF32-V", "UniJIS-UTF8-H", "UniJIS-UTF8-V", "UniJIS2004-UTF16-H", "UniJIS2004-UTF16-V", "UniJIS2004-UTF32-H", "UniJIS2004-UTF32-V", "UniJIS2004-UTF8-H", "UniJIS2004-UTF8-V", "UniJISPro-UCS2-HW-V", "UniJISPro-UCS2-V", "UniJISPro-UTF8-V", "UniJISX0213-UTF32-H", "UniJISX0213-UTF32-V", "UniJISX02132004-UTF32-H", "UniJISX02132004-UTF32-V", "UniKS-UCS2-H", "UniKS-UCS2-V", "UniKS-UTF16-H", "UniKS-UTF16-V", "UniKS-UTF32-H", "UniKS-UTF32-V", "UniKS-UTF8-H", "UniKS-UTF8-V", "V", "WP-Symbol"], O = 2 ** 24 - 1;
        class v {
          constructor(p = !1) {
            this.codespaceRanges = [[], [], [], []], this.numCodespaceRanges = 0, this._map = [], this.name = "", this.vertical = !1, this.useCMap = null, this.builtInCMap = p;
          }
          addCodespaceRange(p, S, B) {
            this.codespaceRanges[p - 1].push(S, B), this.numCodespaceRanges++;
          }
          mapCidRange(p, S, B) {
            if (S - p > O)
              throw new Error("mapCidRange - ignoring data above MAX_MAP_RANGE.");
            for (; p <= S; )
              this._map[p++] = B++;
          }
          mapBfRange(p, S, B) {
            if (S - p > O)
              throw new Error("mapBfRange - ignoring data above MAX_MAP_RANGE.");
            const T = B.length - 1;
            for (; p <= S; ) {
              this._map[p++] = B;
              const D = B.charCodeAt(T) + 1;
              if (D > 255) {
                B = B.substring(0, T - 1) + String.fromCharCode(B.charCodeAt(T - 1) + 1) + "\0";
                continue;
              }
              B = B.substring(0, T) + String.fromCharCode(D);
            }
          }
          mapBfRangeToArray(p, S, B) {
            if (S - p > O)
              throw new Error("mapBfRangeToArray - ignoring data above MAX_MAP_RANGE.");
            const T = B.length;
            let D = 0;
            for (; p <= S && D < T; )
              this._map[p] = B[D++], ++p;
          }
          mapOne(p, S) {
            this._map[p] = S;
          }
          lookup(p) {
            return this._map[p];
          }
          contains(p) {
            return this._map[p] !== void 0;
          }
          forEach(p) {
            const S = this._map, B = S.length;
            if (B <= 65536)
              for (let T = 0; T < B; T++)
                S[T] !== void 0 && p(T, S[T]);
            else
              for (const T in S)
                p(T, S[T]);
          }
          charCodeOf(p) {
            const S = this._map;
            if (S.length <= 65536)
              return S.indexOf(p);
            for (const B in S)
              if (S[B] === p)
                return B | 0;
            return -1;
          }
          getMap() {
            return this._map;
          }
          readCharCode(p, S, B) {
            let T = 0;
            const D = this.codespaceRanges;
            for (let K = 0, _ = D.length; K < _; K++) {
              T = (T << 8 | p.charCodeAt(S + K)) >>> 0;
              const o = D[K];
              for (let m = 0, s = o.length; m < s; ) {
                const r = o[m++], y = o[m++];
                if (T >= r && T <= y) {
                  B.charcode = T, B.length = K + 1;
                  return;
                }
              }
            }
            B.charcode = 0, B.length = 1;
          }
          getCharCodeLength(p) {
            const S = this.codespaceRanges;
            for (let B = 0, T = S.length; B < T; B++) {
              const D = S[B];
              for (let K = 0, _ = D.length; K < _; ) {
                const o = D[K++], m = D[K++];
                if (p >= o && p <= m)
                  return B + 1;
              }
            }
            return 1;
          }
          get length() {
            return this._map.length;
          }
          get isIdentityCMap() {
            if (!(this.name === "Identity-H" || this.name === "Identity-V") || this._map.length !== 65536)
              return !1;
            for (let p = 0; p < 65536; p++)
              if (this._map[p] !== p)
                return !1;
            return !0;
          }
        }
        w.CMap = v;
        class g extends v {
          constructor(p, S) {
            super(), this.vertical = p, this.addCodespaceRange(S, 0, 65535);
          }
          mapCidRange(p, S, B) {
            (0, n.unreachable)("should not call mapCidRange");
          }
          mapBfRange(p, S, B) {
            (0, n.unreachable)("should not call mapBfRange");
          }
          mapBfRangeToArray(p, S, B) {
            (0, n.unreachable)("should not call mapBfRangeToArray");
          }
          mapOne(p, S) {
            (0, n.unreachable)("should not call mapCidOne");
          }
          lookup(p) {
            return Number.isInteger(p) && p <= 65535 ? p : void 0;
          }
          contains(p) {
            return Number.isInteger(p) && p <= 65535;
          }
          forEach(p) {
            for (let S = 0; S <= 65535; S++)
              p(S, S);
          }
          charCodeOf(p) {
            return Number.isInteger(p) && p <= 65535 ? p : -1;
          }
          getMap() {
            const p = new Array(65536);
            for (let S = 0; S <= 65535; S++)
              p[S] = S;
            return p;
          }
          get length() {
            return 65536;
          }
          get isIdentityCMap() {
            (0, n.unreachable)("should not access .isIdentityCMap");
          }
        }
        w.IdentityCMap = g;
        function b(u) {
          let p = 0;
          for (let S = 0; S < u.length; S++)
            p = p << 8 | u.charCodeAt(S);
          return p >>> 0;
        }
        function i(u) {
          if (typeof u != "string")
            throw new n.FormatError("Malformed CMap: expected string.");
        }
        function P(u) {
          if (!Number.isInteger(u))
            throw new n.FormatError("Malformed CMap: expected int.");
        }
        function d(u, p) {
          for (; ; ) {
            let S = p.getObj();
            if (S === F.EOF)
              break;
            if ((0, F.isCmd)(S, "endbfchar"))
              return;
            i(S);
            const B = b(S);
            S = p.getObj(), i(S);
            const T = S;
            u.mapOne(B, T);
          }
        }
        function A(u, p) {
          for (; ; ) {
            let S = p.getObj();
            if (S === F.EOF)
              break;
            if ((0, F.isCmd)(S, "endbfrange"))
              return;
            i(S);
            const B = b(S);
            S = p.getObj(), i(S);
            const T = b(S);
            if (S = p.getObj(), Number.isInteger(S) || typeof S == "string") {
              const D = Number.isInteger(S) ? String.fromCharCode(S) : S;
              u.mapBfRange(B, T, D);
            } else if ((0, F.isCmd)(S, "[")) {
              S = p.getObj();
              const D = [];
              for (; !(0, F.isCmd)(S, "]") && S !== F.EOF; )
                D.push(S), S = p.getObj();
              u.mapBfRangeToArray(B, T, D);
            } else
              break;
          }
          throw new n.FormatError("Invalid bf range.");
        }
        function I(u, p) {
          for (; ; ) {
            let S = p.getObj();
            if (S === F.EOF)
              break;
            if ((0, F.isCmd)(S, "endcidchar"))
              return;
            i(S);
            const B = b(S);
            S = p.getObj(), P(S);
            const T = S;
            u.mapOne(B, T);
          }
        }
        function E(u, p) {
          for (; ; ) {
            let S = p.getObj();
            if (S === F.EOF)
              break;
            if ((0, F.isCmd)(S, "endcidrange"))
              return;
            i(S);
            const B = b(S);
            S = p.getObj(), i(S);
            const T = b(S);
            S = p.getObj(), P(S);
            const D = S;
            u.mapCidRange(B, T, D);
          }
        }
        function k(u, p) {
          for (; ; ) {
            let S = p.getObj();
            if (S === F.EOF)
              break;
            if ((0, F.isCmd)(S, "endcodespacerange"))
              return;
            if (typeof S != "string")
              break;
            const B = b(S);
            if (S = p.getObj(), typeof S != "string")
              break;
            const T = b(S);
            u.addCodespaceRange(S.length, B, T);
          }
          throw new n.FormatError("Invalid codespace range.");
        }
        function H(u, p) {
          const S = p.getObj();
          Number.isInteger(S) && (u.vertical = !!S);
        }
        function x(u, p) {
          const S = p.getObj();
          S instanceof F.Name && (u.name = S.name);
        }
        async function R(u, p, S, B) {
          let T, D;
          e:
            for (; ; )
              try {
                const K = p.getObj();
                if (K === F.EOF)
                  break;
                if (K instanceof F.Name)
                  K.name === "WMode" ? H(u, p) : K.name === "CMapName" && x(u, p), T = K;
                else if (K instanceof F.Cmd)
                  switch (K.cmd) {
                    case "endcmap":
                      break e;
                    case "usecmap":
                      T instanceof F.Name && (D = T.name);
                      break;
                    case "begincodespacerange":
                      k(u, p);
                      break;
                    case "beginbfchar":
                      d(u, p);
                      break;
                    case "begincidchar":
                      I(u, p);
                      break;
                    case "beginbfrange":
                      A(u, p);
                      break;
                    case "begincidrange":
                      E(u, p);
                      break;
                  }
              } catch (K) {
                if (K instanceof l.MissingDataException)
                  throw K;
                (0, n.warn)("Invalid cMap data: " + K);
                continue;
              }
          return !B && D && (B = D), B ? f(u, S, B) : u;
        }
        async function f(u, p, S) {
          if (u.useCMap = await c(S, p), u.numCodespaceRanges === 0) {
            const B = u.useCMap.codespaceRanges;
            for (let T = 0; T < B.length; T++)
              u.codespaceRanges[T] = B[T].slice();
            u.numCodespaceRanges = u.useCMap.numCodespaceRanges;
          }
          return u.useCMap.forEach(function(B, T) {
            u.contains(B) || u.mapOne(B, u.useCMap.lookup(B));
          }), u;
        }
        async function c(u, p) {
          if (u === "Identity-H")
            return new g(!1, 2);
          if (u === "Identity-V")
            return new g(!0, 2);
          if (!U.includes(u))
            throw new Error("Unknown CMap name: " + u);
          if (!p)
            throw new Error("Built-in CMap parameters are not provided.");
          const {
            cMapData: S,
            compressionType: B
          } = await p(u), T = new v(!0);
          if (B === n.CMapCompressionType.BINARY)
            return new e.BinaryCMapReader().process(S, T, (D) => f(T, p, D));
          if (B === n.CMapCompressionType.NONE) {
            const D = new t.Lexer(new j.Stream(S));
            return R(T, D, p, null);
          }
          throw new Error(`Invalid CMap "compressionType" value: ${B}`);
        }
        class N {
          static async create({
            encoding: p,
            fetchBuiltInCMap: S,
            useCMap: B
          }) {
            if (p instanceof F.Name)
              return c(p.name, S);
            if (p instanceof C.BaseStream) {
              const T = await R(new v(), new t.Lexer(p), S, B);
              return T.isIdentityCMap ? c(T.name, S) : T;
            }
            throw new Error("Encoding required.");
          }
        }
        w.CMapFactory = N;
      },
      /* 15 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.BinaryCMapReader = void 0;
        var n = V(2);
        function F(v, g) {
          let b = 0;
          for (let i = 0; i <= g; i++)
            b = b << 8 | v[i];
          return b >>> 0;
        }
        function C(v, g) {
          return g === 1 ? String.fromCharCode(v[0], v[1]) : g === 3 ? String.fromCharCode(v[0], v[1], v[2], v[3]) : String.fromCharCode(...v.subarray(0, g + 1));
        }
        function e(v, g, b) {
          let i = 0;
          for (let P = b; P >= 0; P--)
            i += v[P] + g[P], v[P] = i & 255, i >>= 8;
        }
        function t(v, g) {
          let b = 1;
          for (let i = g; i >= 0 && b > 0; i--)
            b += v[i], v[i] = b & 255, b >>= 8;
        }
        const l = 16, j = 19;
        class U {
          constructor(g) {
            this.buffer = g, this.pos = 0, this.end = g.length, this.tmpBuf = new Uint8Array(j);
          }
          readByte() {
            return this.pos >= this.end ? -1 : this.buffer[this.pos++];
          }
          readNumber() {
            let g = 0, b;
            do {
              const i = this.readByte();
              if (i < 0)
                throw new n.FormatError("unexpected EOF in bcmap");
              b = !(i & 128), g = g << 7 | i & 127;
            } while (!b);
            return g;
          }
          readSigned() {
            const g = this.readNumber();
            return g & 1 ? ~(g >>> 1) : g >>> 1;
          }
          readHex(g, b) {
            g.set(this.buffer.subarray(this.pos, this.pos + b + 1)), this.pos += b + 1;
          }
          readHexNumber(g, b) {
            let i;
            const P = this.tmpBuf;
            let d = 0;
            do {
              const k = this.readByte();
              if (k < 0)
                throw new n.FormatError("unexpected EOF in bcmap");
              i = !(k & 128), P[d++] = k & 127;
            } while (!i);
            let A = b, I = 0, E = 0;
            for (; A >= 0; ) {
              for (; E < 8 && P.length > 0; )
                I |= P[--d] << E, E += 7;
              g[A] = I & 255, A--, I >>= 8, E -= 8;
            }
          }
          readHexSigned(g, b) {
            this.readHexNumber(g, b);
            const i = g[b] & 1 ? 255 : 0;
            let P = 0;
            for (let d = 0; d <= b; d++)
              P = (P & 1) << 8 | g[d], g[d] = P >> 1 ^ i;
          }
          readString() {
            const g = this.readNumber(), b = new Array(g);
            for (let i = 0; i < g; i++)
              b[i] = this.readNumber();
            return String.fromCharCode(...b);
          }
        }
        class O {
          async process(g, b, i) {
            const P = new U(g), d = P.readByte();
            b.vertical = !!(d & 1);
            let A = null;
            const I = new Uint8Array(l), E = new Uint8Array(l), k = new Uint8Array(l), H = new Uint8Array(l), x = new Uint8Array(l);
            let R, f;
            for (; (f = P.readByte()) >= 0; ) {
              const c = f >> 5;
              if (c === 7) {
                switch (f & 31) {
                  case 0:
                    P.readString();
                    break;
                  case 1:
                    A = P.readString();
                    break;
                }
                continue;
              }
              const N = !!(f & 16), u = f & 15;
              if (u + 1 > l)
                throw new Error("BinaryCMapReader.process: Invalid dataSize.");
              const p = 1, S = P.readNumber();
              switch (c) {
                case 0:
                  P.readHex(I, u), P.readHexNumber(E, u), e(E, I, u), b.addCodespaceRange(u + 1, F(I, u), F(E, u));
                  for (let B = 1; B < S; B++)
                    t(E, u), P.readHexNumber(I, u), e(I, E, u), P.readHexNumber(E, u), e(E, I, u), b.addCodespaceRange(u + 1, F(I, u), F(E, u));
                  break;
                case 1:
                  P.readHex(I, u), P.readHexNumber(E, u), e(E, I, u), P.readNumber();
                  for (let B = 1; B < S; B++)
                    t(E, u), P.readHexNumber(I, u), e(I, E, u), P.readHexNumber(E, u), e(E, I, u), P.readNumber();
                  break;
                case 2:
                  P.readHex(k, u), R = P.readNumber(), b.mapOne(F(k, u), R);
                  for (let B = 1; B < S; B++)
                    t(k, u), N || (P.readHexNumber(x, u), e(k, x, u)), R = P.readSigned() + (R + 1), b.mapOne(F(k, u), R);
                  break;
                case 3:
                  P.readHex(I, u), P.readHexNumber(E, u), e(E, I, u), R = P.readNumber(), b.mapCidRange(F(I, u), F(E, u), R);
                  for (let B = 1; B < S; B++)
                    t(E, u), N ? I.set(E) : (P.readHexNumber(I, u), e(I, E, u)), P.readHexNumber(E, u), e(E, I, u), R = P.readNumber(), b.mapCidRange(F(I, u), F(E, u), R);
                  break;
                case 4:
                  P.readHex(k, p), P.readHex(H, u), b.mapOne(F(k, p), C(H, u));
                  for (let B = 1; B < S; B++)
                    t(k, p), N || (P.readHexNumber(x, p), e(k, x, p)), t(H, u), P.readHexSigned(x, u), e(H, x, u), b.mapOne(F(k, p), C(H, u));
                  break;
                case 5:
                  P.readHex(I, p), P.readHexNumber(E, p), e(E, I, p), P.readHex(H, u), b.mapBfRange(F(I, p), F(E, p), C(H, u));
                  for (let B = 1; B < S; B++)
                    t(E, p), N ? I.set(E) : (P.readHexNumber(I, p), e(I, E, p)), P.readHexNumber(E, p), e(E, I, p), P.readHex(H, u), b.mapBfRange(F(I, p), F(E, p), C(H, u));
                  break;
                default:
                  throw new Error(`BinaryCMapReader.process - unknown type: ${c}`);
              }
            }
            return A ? i(A) : b;
          }
        }
        w.BinaryCMapReader = O;
      },
      /* 16 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.Parser = w.Linearization = w.Lexer = void 0;
        var n = V(2), F = V(4), C = V(3), e = V(8), t = V(17), l = V(19), j = V(20), U = V(22), O = V(23), v = V(26), g = V(29), b = V(31), i = V(32), P = V(33);
        const d = 1e3;
        function A(R) {
          const f = [], c = R.length;
          let N = 0;
          for (; N < c - 1; )
            f.push(R[N++] << 8 | R[N++]);
          return N < c && f.push(R[N]), c + "_" + String.fromCharCode.apply(null, f);
        }
        class I {
          constructor({
            lexer: f,
            xref: c,
            allowStreams: N = !1,
            recoveryMode: u = !1
          }) {
            this.lexer = f, this.xref = c, this.allowStreams = N, this.recoveryMode = u, this.imageCache = /* @__PURE__ */ Object.create(null), this._imageId = 0, this.refill();
          }
          refill() {
            this.buf1 = this.lexer.getObj(), this.buf2 = this.lexer.getObj();
          }
          shift() {
            this.buf2 instanceof F.Cmd && this.buf2.cmd === "ID" ? (this.buf1 = this.buf2, this.buf2 = null) : (this.buf1 = this.buf2, this.buf2 = this.lexer.getObj());
          }
          tryShift() {
            try {
              return this.shift(), !0;
            } catch (f) {
              if (f instanceof C.MissingDataException)
                throw f;
              return !1;
            }
          }
          getObj(f = null) {
            const c = this.buf1;
            if (this.shift(), c instanceof F.Cmd)
              switch (c.cmd) {
                case "BI":
                  return this.makeInlineImage(f);
                case "[":
                  const N = [];
                  for (; !(0, F.isCmd)(this.buf1, "]") && this.buf1 !== F.EOF; )
                    N.push(this.getObj(f));
                  if (this.buf1 === F.EOF) {
                    if (this.recoveryMode)
                      return N;
                    throw new C.ParserEOFException("End of file inside array.");
                  }
                  return this.shift(), N;
                case "<<":
                  const u = new F.Dict(this.xref);
                  for (; !(0, F.isCmd)(this.buf1, ">>") && this.buf1 !== F.EOF; ) {
                    if (!(this.buf1 instanceof F.Name)) {
                      (0, n.info)("Malformed dictionary: key must be a name object"), this.shift();
                      continue;
                    }
                    const p = this.buf1.name;
                    if (this.shift(), this.buf1 === F.EOF)
                      break;
                    u.set(p, this.getObj(f));
                  }
                  if (this.buf1 === F.EOF) {
                    if (this.recoveryMode)
                      return u;
                    throw new C.ParserEOFException("End of file inside dictionary.");
                  }
                  return (0, F.isCmd)(this.buf2, "stream") ? this.allowStreams ? this.makeStream(u, f) : u : (this.shift(), u);
                default:
                  return c;
              }
            if (Number.isInteger(c)) {
              if (Number.isInteger(this.buf1) && (0, F.isCmd)(this.buf2, "R")) {
                const N = F.Ref.get(c, this.buf1);
                return this.shift(), this.shift(), N;
              }
              return c;
            }
            return typeof c == "string" && f ? f.decryptString(c) : c;
          }
          findDefaultInlineStreamEnd(f) {
            const {
              knownCommands: T
            } = this.lexer, D = f.pos, K = 15;
            let _ = 0, o, m;
            for (; (o = f.getByte()) !== -1; )
              if (_ === 0)
                _ = o === 69 ? 1 : 0;
              else if (_ === 1)
                _ = o === 73 ? 2 : 0;
              else if (o === 32 || o === 10 || o === 13) {
                m = f.pos;
                const r = f.peekBytes(K), y = r.length;
                if (y === 0)
                  break;
                for (let G = 0; G < y; G++)
                  if (o = r[G], !(o === 0 && r[G + 1] !== 0) && o !== 10 && o !== 13 && (o < 32 || o > 127)) {
                    _ = 0;
                    break;
                  }
                if (_ !== 2)
                  continue;
                if (!T) {
                  (0, n.warn)("findDefaultInlineStreamEnd - `lexer.knownCommands` is undefined.");
                  continue;
                }
                const M = new H(new e.Stream(r.slice()), T);
                M._hexStringWarn = () => {
                };
                let $ = 0;
                for (; ; ) {
                  const G = M.getObj();
                  if (G === F.EOF) {
                    _ = 0;
                    break;
                  }
                  if (G instanceof F.Cmd) {
                    const ce = T[G.cmd];
                    if (ce) {
                      if (ce.variableArgs ? $ <= ce.numArgs : $ === ce.numArgs)
                        break;
                    } else {
                      _ = 0;
                      break;
                    }
                    $ = 0;
                    continue;
                  }
                  $++;
                }
                if (_ === 2)
                  break;
              } else
                _ = 0;
            o === -1 && ((0, n.warn)("findDefaultInlineStreamEnd: Reached the end of the stream without finding a valid EI marker"), m && ((0, n.warn)('... trying to recover by using the last "EI" occurrence.'), f.skip(-(f.pos - m))));
            let s = 4;
            return f.skip(-s), o = f.peekByte(), f.skip(s), (0, C.isWhiteSpace)(o) || s--, f.pos - s - D;
          }
          findDCTDecodeInlineStreamEnd(f) {
            const c = f.pos;
            let N = !1, u, p;
            for (; (u = f.getByte()) !== -1; )
              if (u === 255) {
                switch (f.getByte()) {
                  case 0:
                    break;
                  case 255:
                    f.skip(-1);
                    break;
                  case 217:
                    N = !0;
                    break;
                  case 192:
                  case 193:
                  case 194:
                  case 195:
                  case 197:
                  case 198:
                  case 199:
                  case 201:
                  case 202:
                  case 203:
                  case 205:
                  case 206:
                  case 207:
                  case 196:
                  case 204:
                  case 218:
                  case 219:
                  case 220:
                  case 221:
                  case 222:
                  case 223:
                  case 224:
                  case 225:
                  case 226:
                  case 227:
                  case 228:
                  case 229:
                  case 230:
                  case 231:
                  case 232:
                  case 233:
                  case 234:
                  case 235:
                  case 236:
                  case 237:
                  case 238:
                  case 239:
                  case 254:
                    p = f.getUint16(), p > 2 ? f.skip(p - 2) : f.skip(-2);
                    break;
                }
                if (N)
                  break;
              }
            const S = f.pos - c;
            return u === -1 ? ((0, n.warn)("Inline DCTDecode image stream: EOI marker not found, searching for /EI/ instead."), f.skip(-S), this.findDefaultInlineStreamEnd(f)) : (this.inlineStreamSkipEI(f), S);
          }
          findASCII85DecodeInlineStreamEnd(f) {
            const u = f.pos;
            let p;
            for (; (p = f.getByte()) !== -1; )
              if (p === 126) {
                const B = f.pos;
                for (p = f.peekByte(); (0, C.isWhiteSpace)(p); )
                  f.skip(), p = f.peekByte();
                if (p === 62) {
                  f.skip();
                  break;
                }
                if (f.pos > B) {
                  const T = f.peekBytes(2);
                  if (T[0] === 69 && T[1] === 73)
                    break;
                }
              }
            const S = f.pos - u;
            return p === -1 ? ((0, n.warn)("Inline ASCII85Decode image stream: EOD marker not found, searching for /EI/ instead."), f.skip(-S), this.findDefaultInlineStreamEnd(f)) : (this.inlineStreamSkipEI(f), S);
          }
          findASCIIHexDecodeInlineStreamEnd(f) {
            const N = f.pos;
            let u;
            for (; (u = f.getByte()) !== -1 && u !== 62; )
              ;
            const p = f.pos - N;
            return u === -1 ? ((0, n.warn)("Inline ASCIIHexDecode image stream: EOD marker not found, searching for /EI/ instead."), f.skip(-p), this.findDefaultInlineStreamEnd(f)) : (this.inlineStreamSkipEI(f), p);
          }
          inlineStreamSkipEI(f) {
            let u = 0, p;
            for (; (p = f.getByte()) !== -1; )
              if (u === 0)
                u = p === 69 ? 1 : 0;
              else if (u === 1)
                u = p === 73 ? 2 : 0;
              else if (u === 2)
                break;
          }
          makeInlineImage(f) {
            const c = this.lexer, N = c.stream, u = /* @__PURE__ */ Object.create(null);
            let p;
            for (; !(0, F.isCmd)(this.buf1, "ID") && this.buf1 !== F.EOF; ) {
              if (!(this.buf1 instanceof F.Name))
                throw new n.FormatError("Dictionary key must be a name object");
              const m = this.buf1.name;
              if (this.shift(), this.buf1 === F.EOF)
                break;
              u[m] = this.getObj(f);
            }
            c.beginInlineImagePos !== -1 && (p = N.pos - c.beginInlineImagePos);
            const S = this.xref.fetchIfRef(u.F || u.Filter);
            let B;
            if (S instanceof F.Name)
              B = S.name;
            else if (Array.isArray(S)) {
              const m = this.xref.fetchIfRef(S[0]);
              m instanceof F.Name && (B = m.name);
            }
            const T = N.pos;
            let D;
            switch (B) {
              case "DCT":
              case "DCTDecode":
                D = this.findDCTDecodeInlineStreamEnd(N);
                break;
              case "A85":
              case "ASCII85Decode":
                D = this.findASCII85DecodeInlineStreamEnd(N);
                break;
              case "AHx":
              case "ASCIIHexDecode":
                D = this.findASCIIHexDecodeInlineStreamEnd(N);
                break;
              default:
                D = this.findDefaultInlineStreamEnd(N);
            }
            let K;
            if (D < d && p > 0) {
              const m = N.pos;
              N.pos = c.beginInlineImagePos, K = A(N.getBytes(p + D)), N.pos = m;
              const s = this.imageCache[K];
              if (s !== void 0)
                return this.buf2 = F.Cmd.get("EI"), this.shift(), s.reset(), s;
            }
            const _ = new F.Dict(this.xref);
            for (const m in u)
              _.set(m, u[m]);
            let o = N.makeSubStream(T, D, _);
            return f && (o = f.createStream(o, D)), o = this.filter(o, _, D), o.dict = _, K !== void 0 && (o.cacheKey = `inline_img_${++this._imageId}`, this.imageCache[K] = o), this.buf2 = F.Cmd.get("EI"), this.shift(), o;
          }
          _findStreamLength(f, c) {
            const {
              stream: N
            } = this.lexer;
            N.pos = f;
            const u = 2048, p = c.length;
            for (; N.pos < N.end; ) {
              const S = N.peekBytes(u), B = S.length - p;
              if (B <= 0)
                break;
              let T = 0;
              for (; T < B; ) {
                let D = 0;
                for (; D < p && S[T + D] === c[D]; )
                  D++;
                if (D >= p)
                  return N.pos += T, N.pos - f;
                T++;
              }
              N.pos += B;
            }
            return -1;
          }
          makeStream(f, c) {
            const N = this.lexer;
            let u = N.stream;
            N.skipToNextLine();
            const p = u.pos - 1;
            let S = f.get("Length");
            if (Number.isInteger(S) || ((0, n.info)(`Bad length "${S && S.toString()}" in stream.`), S = 0), u.pos = p + S, N.nextChar(), this.tryShift() && (0, F.isCmd)(this.buf2, "endstream"))
              this.shift();
            else {
              const B = new Uint8Array([101, 110, 100, 115, 116, 114, 101, 97, 109]);
              let T = this._findStreamLength(p, B);
              if (T < 0) {
                for (let K = 1; K <= 1; K++) {
                  const _ = B.length - K, o = B.slice(0, _), m = this._findStreamLength(p, o);
                  if (m >= 0) {
                    const s = u.peekBytes(_ + 1)[_];
                    if (!(0, C.isWhiteSpace)(s))
                      break;
                    (0, n.info)(`Found "${(0, n.bytesToString)(o)}" when searching for endstream command.`), T = m;
                    break;
                  }
                }
                if (T < 0)
                  throw new n.FormatError("Missing endstream command.");
              }
              S = T, N.nextChar(), this.shift(), this.shift();
            }
            return this.shift(), u = u.makeSubStream(p, S, f), c && (u = c.createStream(u, S)), u = this.filter(u, f, S), u.dict = f, u;
          }
          filter(f, c, N) {
            let u = c.get("F", "Filter"), p = c.get("DP", "DecodeParms");
            if (u instanceof F.Name)
              return Array.isArray(p) && (0, n.warn)("/DecodeParms should not be an Array, when /Filter is a Name."), this.makeFilter(f, u.name, N, p);
            let S = N;
            if (Array.isArray(u)) {
              const B = u, T = p;
              for (let D = 0, K = B.length; D < K; ++D) {
                if (u = this.xref.fetchIfRef(B[D]), !(u instanceof F.Name))
                  throw new n.FormatError(`Bad filter name "${u}"`);
                p = null, Array.isArray(T) && D in T && (p = this.xref.fetchIfRef(T[D])), f = this.makeFilter(f, u.name, S, p), S = null;
              }
            }
            return f;
          }
          makeFilter(f, c, N, u) {
            if (N === 0)
              return (0, n.warn)(`Empty "${c}" stream.`), new e.NullStream();
            try {
              switch (c) {
                case "Fl":
                case "FlateDecode":
                  return u ? new i.PredictorStream(new U.FlateStream(f, N), N, u) : new U.FlateStream(f, N);
                case "LZW":
                case "LZWDecode":
                  let p = 1;
                  return u ? (u.has("EarlyChange") && (p = u.get("EarlyChange")), new i.PredictorStream(new b.LZWStream(f, N, p), N, u)) : new b.LZWStream(f, N, p);
                case "DCT":
                case "DCTDecode":
                  return new v.JpegStream(f, N, u);
                case "JPX":
                case "JPXDecode":
                  return new g.JpxStream(f, N, u);
                case "A85":
                case "ASCII85Decode":
                  return new t.Ascii85Stream(f, N);
                case "AHx":
                case "ASCIIHexDecode":
                  return new l.AsciiHexStream(f, N);
                case "CCF":
                case "CCITTFaxDecode":
                  return new j.CCITTFaxStream(f, N, u);
                case "RL":
                case "RunLengthDecode":
                  return new P.RunLengthStream(f, N);
                case "JBIG2Decode":
                  return new O.Jbig2Stream(f, N, u);
              }
              return (0, n.warn)(`Filter "${c}" is not supported.`), f;
            } catch (p) {
              if (p instanceof C.MissingDataException)
                throw p;
              return (0, n.warn)(`Invalid stream: "${p}"`), new e.NullStream();
            }
          }
        }
        w.Parser = I;
        const E = [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        function k(R) {
          return R >= 48 && R <= 57 ? R & 15 : R >= 65 && R <= 70 || R >= 97 && R <= 102 ? (R & 15) + 9 : -1;
        }
        class H {
          constructor(f, c = null) {
            this.stream = f, this.nextChar(), this.strBuf = [], this.knownCommands = c, this._hexStringNumWarn = 0, this.beginInlineImagePos = -1;
          }
          nextChar() {
            return this.currentChar = this.stream.getByte();
          }
          peekChar() {
            return this.stream.peekByte();
          }
          getNumber() {
            let f = this.currentChar, c = !1, N = 0, u = 1;
            if (f === 45 ? (u = -1, f = this.nextChar(), f === 45 && (f = this.nextChar())) : f === 43 && (f = this.nextChar()), f === 10 || f === 13)
              do
                f = this.nextChar();
              while (f === 10 || f === 13);
            if (f === 46 && (N = 10, f = this.nextChar()), f < 48 || f > 57) {
              const T = `Invalid number: ${String.fromCharCode(f)} (charCode ${f})`;
              if ((0, C.isWhiteSpace)(f) || f === -1)
                return (0, n.info)(`Lexer.getNumber - "${T}".`), 0;
              throw new n.FormatError(T);
            }
            let p = f - 48, S = 0, B = 1;
            for (; (f = this.nextChar()) >= 0; )
              if (f >= 48 && f <= 57) {
                const T = f - 48;
                c ? S = S * 10 + T : (N !== 0 && (N *= 10), p = p * 10 + T);
              } else if (f === 46)
                if (N === 0)
                  N = 1;
                else
                  break;
              else if (f === 45)
                (0, n.warn)("Badly formatted number: minus sign in the middle");
              else if (f === 69 || f === 101) {
                if (f = this.peekChar(), f === 43 || f === 45)
                  B = f === 45 ? -1 : 1, this.nextChar();
                else if (f < 48 || f > 57)
                  break;
                c = !0;
              } else
                break;
            return N !== 0 && (p /= N), c && (p *= 10 ** (B * S)), u * p;
          }
          getString() {
            let f = 1, c = !1;
            const N = this.strBuf;
            N.length = 0;
            let u = this.nextChar();
            for (; ; ) {
              let p = !1;
              switch (u | 0) {
                case -1:
                  (0, n.warn)("Unterminated string"), c = !0;
                  break;
                case 40:
                  ++f, N.push("(");
                  break;
                case 41:
                  --f === 0 ? (this.nextChar(), c = !0) : N.push(")");
                  break;
                case 92:
                  switch (u = this.nextChar(), u) {
                    case -1:
                      (0, n.warn)("Unterminated string"), c = !0;
                      break;
                    case 110:
                      N.push(`
`);
                      break;
                    case 114:
                      N.push("\r");
                      break;
                    case 116:
                      N.push("	");
                      break;
                    case 98:
                      N.push("\b");
                      break;
                    case 102:
                      N.push("\f");
                      break;
                    case 92:
                    case 40:
                    case 41:
                      N.push(String.fromCharCode(u));
                      break;
                    case 48:
                    case 49:
                    case 50:
                    case 51:
                    case 52:
                    case 53:
                    case 54:
                    case 55:
                      let S = u & 15;
                      u = this.nextChar(), p = !0, u >= 48 && u <= 55 && (S = (S << 3) + (u & 15), u = this.nextChar(), u >= 48 && u <= 55 && (p = !1, S = (S << 3) + (u & 15))), N.push(String.fromCharCode(S));
                      break;
                    case 13:
                      this.peekChar() === 10 && this.nextChar();
                      break;
                    case 10:
                      break;
                    default:
                      N.push(String.fromCharCode(u));
                      break;
                  }
                  break;
                default:
                  N.push(String.fromCharCode(u));
                  break;
              }
              if (c)
                break;
              p || (u = this.nextChar());
            }
            return N.join("");
          }
          getName() {
            let f, c;
            const N = this.strBuf;
            for (N.length = 0; (f = this.nextChar()) >= 0 && !E[f]; )
              if (f === 35) {
                if (f = this.nextChar(), E[f]) {
                  (0, n.warn)("Lexer_getName: NUMBER SIGN (#) should be followed by a hexadecimal number."), N.push("#");
                  break;
                }
                const u = k(f);
                if (u !== -1) {
                  c = f, f = this.nextChar();
                  const p = k(f);
                  if (p === -1) {
                    if ((0, n.warn)(`Lexer_getName: Illegal digit (${String.fromCharCode(f)}) in hexadecimal number.`), N.push("#", String.fromCharCode(c)), E[f])
                      break;
                    N.push(String.fromCharCode(f));
                    continue;
                  }
                  N.push(String.fromCharCode(u << 4 | p));
                } else
                  N.push("#", String.fromCharCode(f));
              } else
                N.push(String.fromCharCode(f));
            return N.length > 127 && (0, n.warn)(`Name token is longer than allowed by the spec: ${N.length}`), F.Name.get(N.join(""));
          }
          _hexStringWarn(f) {
            if (this._hexStringNumWarn++ === 5) {
              (0, n.warn)("getHexString - ignoring additional invalid characters.");
              return;
            }
            this._hexStringNumWarn > 5 || (0, n.warn)(`getHexString - ignoring invalid character: ${f}`);
          }
          getHexString() {
            const f = this.strBuf;
            f.length = 0;
            let c = this.currentChar, N = !0, u, p;
            for (this._hexStringNumWarn = 0; ; )
              if (c < 0) {
                (0, n.warn)("Unterminated hex string");
                break;
              } else if (c === 62) {
                this.nextChar();
                break;
              } else if (E[c] === 1) {
                c = this.nextChar();
                continue;
              } else {
                if (N) {
                  if (u = k(c), u === -1) {
                    this._hexStringWarn(c), c = this.nextChar();
                    continue;
                  }
                } else {
                  if (p = k(c), p === -1) {
                    this._hexStringWarn(c), c = this.nextChar();
                    continue;
                  }
                  f.push(String.fromCharCode(u << 4 | p));
                }
                N = !N, c = this.nextChar();
              }
            return f.join("");
          }
          getObj() {
            let f = !1, c = this.currentChar;
            for (; ; ) {
              if (c < 0)
                return F.EOF;
              if (f)
                (c === 10 || c === 13) && (f = !1);
              else if (c === 37)
                f = !0;
              else if (E[c] !== 1)
                break;
              c = this.nextChar();
            }
            switch (c | 0) {
              case 48:
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
              case 43:
              case 45:
              case 46:
                return this.getNumber();
              case 40:
                return this.getString();
              case 47:
                return this.getName();
              case 91:
                return this.nextChar(), F.Cmd.get("[");
              case 93:
                return this.nextChar(), F.Cmd.get("]");
              case 60:
                return c = this.nextChar(), c === 60 ? (this.nextChar(), F.Cmd.get("<<")) : this.getHexString();
              case 62:
                return c = this.nextChar(), c === 62 ? (this.nextChar(), F.Cmd.get(">>")) : F.Cmd.get(">");
              case 123:
                return this.nextChar(), F.Cmd.get("{");
              case 125:
                return this.nextChar(), F.Cmd.get("}");
              case 41:
                throw this.nextChar(), new n.FormatError(`Illegal character: ${c}`);
            }
            let N = String.fromCharCode(c);
            if (c < 32 || c > 127) {
              const S = this.peekChar();
              if (S >= 32 && S <= 127)
                return this.nextChar(), F.Cmd.get(N);
            }
            const u = this.knownCommands;
            let p = (u == null ? void 0 : u[N]) !== void 0;
            for (; (c = this.nextChar()) >= 0 && !E[c]; ) {
              const S = N + String.fromCharCode(c);
              if (p && u[S] === void 0)
                break;
              if (N.length === 128)
                throw new n.FormatError(`Command token too long: ${N.length}`);
              N = S, p = (u == null ? void 0 : u[N]) !== void 0;
            }
            return N === "true" ? !0 : N === "false" ? !1 : N === "null" ? null : (N === "BI" && (this.beginInlineImagePos = this.stream.pos), F.Cmd.get(N));
          }
          skipToNextLine() {
            let f = this.currentChar;
            for (; f >= 0; ) {
              if (f === 13) {
                f = this.nextChar(), f === 10 && this.nextChar();
                break;
              } else if (f === 10) {
                this.nextChar();
                break;
              }
              f = this.nextChar();
            }
          }
        }
        w.Lexer = H;
        class x {
          static create(f) {
            function c(_, o, m = !1) {
              const s = _.get(o);
              if (Number.isInteger(s) && (m ? s >= 0 : s > 0))
                return s;
              throw new Error(`The "${o}" parameter in the linearization dictionary is invalid.`);
            }
            function N(_) {
              const o = _.get("H");
              let m;
              if (Array.isArray(o) && ((m = o.length) === 2 || m === 4)) {
                for (let s = 0; s < m; s++) {
                  const r = o[s];
                  if (!(Number.isInteger(r) && r > 0))
                    throw new Error(`Hint (${s}) in the linearization dictionary is invalid.`);
                }
                return o;
              }
              throw new Error("Hint array in the linearization dictionary is invalid.");
            }
            const u = new I({
              lexer: new H(f),
              xref: null
            }), p = u.getObj(), S = u.getObj(), B = u.getObj(), T = u.getObj();
            let D, K;
            if (Number.isInteger(p) && Number.isInteger(S) && (0, F.isCmd)(B, "obj") && T instanceof F.Dict && typeof (D = T.get("Linearized")) == "number" && D > 0) {
              if ((K = c(T, "L")) !== f.length)
                throw new Error('The "L" parameter in the linearization dictionary does not equal the stream length.');
            } else
              return null;
            return {
              length: K,
              hints: N(T),
              objectNumberFirst: c(T, "O"),
              endFirst: c(T, "E"),
              numPages: c(T, "N"),
              mainXRefEntriesOffset: c(T, "T"),
              pageFirst: T.has("P") ? c(T, "P", !0) : 0
            };
          }
        }
        w.Linearization = x;
      },
      /* 17 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.Ascii85Stream = void 0;
        var n = V(18), F = V(3);
        class C extends n.DecodeStream {
          constructor(t, l) {
            l && (l *= 0.8), super(l), this.str = t, this.dict = t.dict, this.input = new Uint8Array(5);
          }
          readBlock() {
            const U = this.str;
            let O = U.getByte();
            for (; (0, F.isWhiteSpace)(O); )
              O = U.getByte();
            if (O === -1 || O === 126) {
              this.eof = !0;
              return;
            }
            const v = this.bufferLength;
            let g, b;
            if (O === 122) {
              for (g = this.ensureBuffer(v + 4), b = 0; b < 4; ++b)
                g[v + b] = 0;
              this.bufferLength += 4;
            } else {
              const i = this.input;
              for (i[0] = O, b = 1; b < 5; ++b) {
                for (O = U.getByte(); (0, F.isWhiteSpace)(O); )
                  O = U.getByte();
                if (i[b] = O, O === -1 || O === 126)
                  break;
              }
              if (g = this.ensureBuffer(v + b - 1), this.bufferLength += b - 1, b < 5) {
                for (; b < 5; ++b)
                  i[b] = 117;
                this.eof = !0;
              }
              let P = 0;
              for (b = 0; b < 5; ++b)
                P = P * 85 + (i[b] - 33);
              for (b = 3; b >= 0; --b)
                g[v + b] = P & 255, P >>= 8;
            }
          }
        }
        w.Ascii85Stream = C;
      },
      /* 18 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.StreamsSequenceStream = w.DecodeStream = void 0;
        var n = V(5), F = V(8);
        const C = new Uint8Array(0);
        class e extends n.BaseStream {
          constructor(j) {
            if (super(), this._rawMinBufferLength = j || 0, this.pos = 0, this.bufferLength = 0, this.eof = !1, this.buffer = C, this.minBufferLength = 512, j)
              for (; this.minBufferLength < j; )
                this.minBufferLength *= 2;
          }
          get isEmpty() {
            for (; !this.eof && this.bufferLength === 0; )
              this.readBlock();
            return this.bufferLength === 0;
          }
          ensureBuffer(j) {
            const U = this.buffer;
            if (j <= U.byteLength)
              return U;
            let O = this.minBufferLength;
            for (; O < j; )
              O *= 2;
            const v = new Uint8Array(O);
            return v.set(U), this.buffer = v;
          }
          getByte() {
            const j = this.pos;
            for (; this.bufferLength <= j; ) {
              if (this.eof)
                return -1;
              this.readBlock();
            }
            return this.buffer[this.pos++];
          }
          getBytes(j) {
            const U = this.pos;
            let O;
            if (j) {
              for (this.ensureBuffer(U + j), O = U + j; !this.eof && this.bufferLength < O; )
                this.readBlock();
              const v = this.bufferLength;
              O > v && (O = v);
            } else {
              for (; !this.eof; )
                this.readBlock();
              O = this.bufferLength;
            }
            return this.pos = O, this.buffer.subarray(U, O);
          }
          reset() {
            this.pos = 0;
          }
          makeSubStream(j, U, O = null) {
            if (U === void 0)
              for (; !this.eof; )
                this.readBlock();
            else {
              const v = j + U;
              for (; this.bufferLength <= v && !this.eof; )
                this.readBlock();
            }
            return new F.Stream(this.buffer, j, U, O);
          }
          getBaseStreams() {
            return this.str ? this.str.getBaseStreams() : null;
          }
        }
        w.DecodeStream = e;
        class t extends e {
          constructor(j, U = null) {
            let O = 0;
            for (const v of j)
              O += v instanceof e ? v._rawMinBufferLength : v.length;
            super(O), this.streams = j, this._onError = U;
          }
          readBlock() {
            var i;
            const j = this.streams;
            if (j.length === 0) {
              this.eof = !0;
              return;
            }
            const U = j.shift();
            let O;
            try {
              O = U.getBytes();
            } catch (P) {
              if (this._onError) {
                this._onError(P, (i = U.dict) == null ? void 0 : i.objId);
                return;
              }
              throw P;
            }
            const v = this.bufferLength, g = v + O.length;
            this.ensureBuffer(g).set(O, v), this.bufferLength = g;
          }
          getBaseStreams() {
            const j = [];
            for (const U of this.streams) {
              const O = U.getBaseStreams();
              O && j.push(...O);
            }
            return j.length > 0 ? j : null;
          }
        }
        w.StreamsSequenceStream = t;
      },
      /* 19 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.AsciiHexStream = void 0;
        var n = V(18);
        class F extends n.DecodeStream {
          constructor(e, t) {
            t && (t *= 0.5), super(t), this.str = e, this.dict = e.dict, this.firstDigit = -1;
          }
          readBlock() {
            const t = this.str.getBytes(8e3);
            if (!t.length) {
              this.eof = !0;
              return;
            }
            const l = t.length + 1 >> 1, j = this.ensureBuffer(this.bufferLength + l);
            let U = this.bufferLength, O = this.firstDigit;
            for (const v of t) {
              let g;
              if (v >= 48 && v <= 57)
                g = v & 15;
              else if (v >= 65 && v <= 70 || v >= 97 && v <= 102)
                g = (v & 15) + 9;
              else if (v === 62) {
                this.eof = !0;
                break;
              } else
                continue;
              O < 0 ? O = g : (j[U++] = O << 4 | g, O = -1);
            }
            O >= 0 && this.eof && (j[U++] = O << 4, O = -1), this.firstDigit = O, this.bufferLength = U;
          }
        }
        w.AsciiHexStream = F;
      },
      /* 20 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.CCITTFaxStream = void 0;
        var n = V(21), F = V(18), C = V(4);
        class e extends F.DecodeStream {
          constructor(l, j, U) {
            super(j), this.str = l, this.dict = l.dict, U instanceof C.Dict || (U = C.Dict.empty);
            const O = {
              next() {
                return l.getByte();
              }
            };
            this.ccittFaxDecoder = new n.CCITTFaxDecoder(O, {
              K: U.get("K"),
              EndOfLine: U.get("EndOfLine"),
              EncodedByteAlign: U.get("EncodedByteAlign"),
              Columns: U.get("Columns"),
              Rows: U.get("Rows"),
              EndOfBlock: U.get("EndOfBlock"),
              BlackIs1: U.get("BlackIs1")
            });
          }
          readBlock() {
            for (; !this.eof; ) {
              const l = this.ccittFaxDecoder.readNextChar();
              if (l === -1) {
                this.eof = !0;
                return;
              }
              this.ensureBuffer(this.bufferLength + 1), this.buffer[this.bufferLength++] = l;
            }
          }
        }
        w.CCITTFaxStream = e;
      },
      /* 21 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.CCITTFaxDecoder = void 0;
        var n = V(2);
        const F = -2, C = -1, e = 0, t = 1, l = 2, j = 3, U = 4, O = 5, v = 6, g = 7, b = 8, i = [[-1, -1], [-1, -1], [7, b], [7, g], [6, v], [6, v], [6, O], [6, O], [4, e], [4, e], [4, e], [4, e], [4, e], [4, e], [4, e], [4, e], [3, t], [3, t], [3, t], [3, t], [3, t], [3, t], [3, t], [3, t], [3, t], [3, t], [3, t], [3, t], [3, t], [3, t], [3, t], [3, t], [3, U], [3, U], [3, U], [3, U], [3, U], [3, U], [3, U], [3, U], [3, U], [3, U], [3, U], [3, U], [3, U], [3, U], [3, U], [3, U], [3, j], [3, j], [3, j], [3, j], [3, j], [3, j], [3, j], [3, j], [3, j], [3, j], [3, j], [3, j], [3, j], [3, j], [3, j], [3, j], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l]], P = [[-1, -1], [12, F], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [12, 1984], [12, 2048], [12, 2112], [12, 2176], [12, 2240], [12, 2304], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [12, 2368], [12, 2432], [12, 2496], [12, 2560]], d = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [8, 29], [8, 29], [8, 30], [8, 30], [8, 45], [8, 45], [8, 46], [8, 46], [7, 22], [7, 22], [7, 22], [7, 22], [7, 23], [7, 23], [7, 23], [7, 23], [8, 47], [8, 47], [8, 48], [8, 48], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [7, 20], [7, 20], [7, 20], [7, 20], [8, 33], [8, 33], [8, 34], [8, 34], [8, 35], [8, 35], [8, 36], [8, 36], [8, 37], [8, 37], [8, 38], [8, 38], [7, 19], [7, 19], [7, 19], [7, 19], [8, 31], [8, 31], [8, 32], [8, 32], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [8, 53], [8, 53], [8, 54], [8, 54], [7, 26], [7, 26], [7, 26], [7, 26], [8, 39], [8, 39], [8, 40], [8, 40], [8, 41], [8, 41], [8, 42], [8, 42], [8, 43], [8, 43], [8, 44], [8, 44], [7, 21], [7, 21], [7, 21], [7, 21], [7, 28], [7, 28], [7, 28], [7, 28], [8, 61], [8, 61], [8, 62], [8, 62], [8, 63], [8, 63], [8, 0], [8, 0], [8, 320], [8, 320], [8, 384], [8, 384], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [7, 27], [7, 27], [7, 27], [7, 27], [8, 59], [8, 59], [8, 60], [8, 60], [9, 1472], [9, 1536], [9, 1600], [9, 1728], [7, 18], [7, 18], [7, 18], [7, 18], [7, 24], [7, 24], [7, 24], [7, 24], [8, 49], [8, 49], [8, 50], [8, 50], [8, 51], [8, 51], [8, 52], [8, 52], [7, 25], [7, 25], [7, 25], [7, 25], [8, 55], [8, 55], [8, 56], [8, 56], [8, 57], [8, 57], [8, 58], [8, 58], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [8, 448], [8, 448], [8, 512], [8, 512], [9, 704], [9, 768], [8, 640], [8, 640], [8, 576], [8, 576], [9, 832], [9, 896], [9, 960], [9, 1024], [9, 1088], [9, 1152], [9, 1216], [9, 1280], [9, 1344], [9, 1408], [7, 256], [7, 256], [7, 256], [7, 256], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7]], A = [[-1, -1], [-1, -1], [12, F], [12, F], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [11, 1792], [11, 1792], [12, 1984], [12, 1984], [12, 2048], [12, 2048], [12, 2112], [12, 2112], [12, 2176], [12, 2176], [12, 2240], [12, 2240], [12, 2304], [12, 2304], [11, 1856], [11, 1856], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [11, 1920], [11, 1920], [12, 2368], [12, 2368], [12, 2432], [12, 2432], [12, 2496], [12, 2496], [12, 2560], [12, 2560], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [12, 52], [12, 52], [13, 640], [13, 704], [13, 768], [13, 832], [12, 55], [12, 55], [12, 56], [12, 56], [13, 1280], [13, 1344], [13, 1408], [13, 1472], [12, 59], [12, 59], [12, 60], [12, 60], [13, 1536], [13, 1600], [11, 24], [11, 24], [11, 24], [11, 24], [11, 25], [11, 25], [11, 25], [11, 25], [13, 1664], [13, 1728], [12, 320], [12, 320], [12, 384], [12, 384], [12, 448], [12, 448], [13, 512], [13, 576], [12, 53], [12, 53], [12, 54], [12, 54], [13, 896], [13, 960], [13, 1024], [13, 1088], [13, 1152], [13, 1216], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64]], I = [[8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [11, 23], [11, 23], [12, 50], [12, 51], [12, 44], [12, 45], [12, 46], [12, 47], [12, 57], [12, 58], [12, 61], [12, 256], [10, 16], [10, 16], [10, 16], [10, 16], [10, 17], [10, 17], [10, 17], [10, 17], [12, 48], [12, 49], [12, 62], [12, 63], [12, 30], [12, 31], [12, 32], [12, 33], [12, 40], [12, 41], [11, 22], [11, 22], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [12, 128], [12, 192], [12, 26], [12, 27], [12, 28], [12, 29], [11, 19], [11, 19], [11, 20], [11, 20], [12, 34], [12, 35], [12, 36], [12, 37], [12, 38], [12, 39], [11, 21], [11, 21], [12, 42], [12, 43], [10, 0], [10, 0], [10, 0], [10, 0], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12]], E = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [6, 9], [6, 8], [5, 7], [5, 7], [4, 6], [4, 6], [4, 6], [4, 6], [4, 5], [4, 5], [4, 5], [4, 5], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2]];
        class k {
          constructor(x, R = {}) {
            if (!x || typeof x.next != "function")
              throw new Error('CCITTFaxDecoder - invalid "source" parameter.');
            this.source = x, this.eof = !1, this.encoding = R.K || 0, this.eoline = R.EndOfLine || !1, this.byteAlign = R.EncodedByteAlign || !1, this.columns = R.Columns || 1728, this.rows = R.Rows || 0, this.eoblock = R.EndOfBlock ?? !0, this.black = R.BlackIs1 || !1, this.codingLine = new Uint32Array(this.columns + 1), this.refLine = new Uint32Array(this.columns + 2), this.codingLine[0] = this.columns, this.codingPos = 0, this.row = 0, this.nextLine2D = this.encoding < 0, this.inputBits = 0, this.inputBuf = 0, this.outputBits = 0, this.rowsDone = !1;
            let f;
            for (; (f = this._lookBits(12)) === 0; )
              this._eatBits(1);
            f === 1 && this._eatBits(12), this.encoding > 0 && (this.nextLine2D = !this._lookBits(1), this._eatBits(1));
          }
          readNextChar() {
            if (this.eof)
              return -1;
            const x = this.refLine, R = this.codingLine, f = this.columns;
            let c, N, u, p;
            if (this.outputBits === 0) {
              if (this.rowsDone && (this.eof = !0), this.eof)
                return -1;
              this.err = !1;
              let B, T, D;
              if (this.nextLine2D) {
                for (p = 0; R[p] < f; ++p)
                  x[p] = R[p];
                for (x[p++] = f, x[p] = f, R[0] = 0, this.codingPos = 0, c = 0, N = 0; R[this.codingPos] < f; )
                  switch (B = this._getTwoDimCode(), B) {
                    case e:
                      this._addPixels(x[c + 1], N), x[c + 1] < f && (c += 2);
                      break;
                    case t:
                      if (B = T = 0, N) {
                        do
                          B += D = this._getBlackCode();
                        while (D >= 64);
                        do
                          T += D = this._getWhiteCode();
                        while (D >= 64);
                      } else {
                        do
                          B += D = this._getWhiteCode();
                        while (D >= 64);
                        do
                          T += D = this._getBlackCode();
                        while (D >= 64);
                      }
                      for (this._addPixels(R[this.codingPos] + B, N), R[this.codingPos] < f && this._addPixels(R[this.codingPos] + T, N ^ 1); x[c] <= R[this.codingPos] && x[c] < f; )
                        c += 2;
                      break;
                    case g:
                      if (this._addPixels(x[c] + 3, N), N ^= 1, R[this.codingPos] < f)
                        for (++c; x[c] <= R[this.codingPos] && x[c] < f; )
                          c += 2;
                      break;
                    case O:
                      if (this._addPixels(x[c] + 2, N), N ^= 1, R[this.codingPos] < f)
                        for (++c; x[c] <= R[this.codingPos] && x[c] < f; )
                          c += 2;
                      break;
                    case j:
                      if (this._addPixels(x[c] + 1, N), N ^= 1, R[this.codingPos] < f)
                        for (++c; x[c] <= R[this.codingPos] && x[c] < f; )
                          c += 2;
                      break;
                    case l:
                      if (this._addPixels(x[c], N), N ^= 1, R[this.codingPos] < f)
                        for (++c; x[c] <= R[this.codingPos] && x[c] < f; )
                          c += 2;
                      break;
                    case b:
                      if (this._addPixelsNeg(x[c] - 3, N), N ^= 1, R[this.codingPos] < f)
                        for (c > 0 ? --c : ++c; x[c] <= R[this.codingPos] && x[c] < f; )
                          c += 2;
                      break;
                    case v:
                      if (this._addPixelsNeg(x[c] - 2, N), N ^= 1, R[this.codingPos] < f)
                        for (c > 0 ? --c : ++c; x[c] <= R[this.codingPos] && x[c] < f; )
                          c += 2;
                      break;
                    case U:
                      if (this._addPixelsNeg(x[c] - 1, N), N ^= 1, R[this.codingPos] < f)
                        for (c > 0 ? --c : ++c; x[c] <= R[this.codingPos] && x[c] < f; )
                          c += 2;
                      break;
                    case C:
                      this._addPixels(f, 0), this.eof = !0;
                      break;
                    default:
                      (0, n.info)("bad 2d code"), this._addPixels(f, 0), this.err = !0;
                  }
              } else
                for (R[0] = 0, this.codingPos = 0, N = 0; R[this.codingPos] < f; ) {
                  if (B = 0, N)
                    do
                      B += D = this._getBlackCode();
                    while (D >= 64);
                  else
                    do
                      B += D = this._getWhiteCode();
                    while (D >= 64);
                  this._addPixels(R[this.codingPos] + B, N), N ^= 1;
                }
              let K = !1;
              if (this.byteAlign && (this.inputBits &= -8), !this.eoblock && this.row === this.rows - 1)
                this.rowsDone = !0;
              else {
                if (B = this._lookBits(12), this.eoline)
                  for (; B !== C && B !== 1; )
                    this._eatBits(1), B = this._lookBits(12);
                else
                  for (; B === 0; )
                    this._eatBits(1), B = this._lookBits(12);
                B === 1 ? (this._eatBits(12), K = !0) : B === C && (this.eof = !0);
              }
              if (!this.eof && this.encoding > 0 && !this.rowsDone && (this.nextLine2D = !this._lookBits(1), this._eatBits(1)), this.eoblock && K && this.byteAlign) {
                if (B = this._lookBits(12), B === 1) {
                  if (this._eatBits(12), this.encoding > 0 && (this._lookBits(1), this._eatBits(1)), this.encoding >= 0)
                    for (p = 0; p < 4; ++p)
                      B = this._lookBits(12), B !== 1 && (0, n.info)("bad rtc code: " + B), this._eatBits(12), this.encoding > 0 && (this._lookBits(1), this._eatBits(1));
                  this.eof = !0;
                }
              } else if (this.err && this.eoline) {
                for (; ; ) {
                  if (B = this._lookBits(13), B === C)
                    return this.eof = !0, -1;
                  if (B >> 1 === 1)
                    break;
                  this._eatBits(1);
                }
                this._eatBits(12), this.encoding > 0 && (this._eatBits(1), this.nextLine2D = !(B & 1));
              }
              this.outputBits = R[0] > 0 ? R[this.codingPos = 0] : R[this.codingPos = 1], this.row++;
            }
            let S;
            if (this.outputBits >= 8)
              S = this.codingPos & 1 ? 0 : 255, this.outputBits -= 8, this.outputBits === 0 && R[this.codingPos] < f && (this.codingPos++, this.outputBits = R[this.codingPos] - R[this.codingPos - 1]);
            else {
              u = 8, S = 0;
              do {
                if (typeof this.outputBits != "number")
                  throw new n.FormatError('Invalid /CCITTFaxDecode data, "outputBits" must be a number.');
                this.outputBits > u ? (S <<= u, this.codingPos & 1 || (S |= 255 >> 8 - u), this.outputBits -= u, u = 0) : (S <<= this.outputBits, this.codingPos & 1 || (S |= 255 >> 8 - this.outputBits), u -= this.outputBits, this.outputBits = 0, R[this.codingPos] < f ? (this.codingPos++, this.outputBits = R[this.codingPos] - R[this.codingPos - 1]) : u > 0 && (S <<= u, u = 0));
              } while (u);
            }
            return this.black && (S ^= 255), S;
          }
          _addPixels(x, R) {
            const f = this.codingLine;
            let c = this.codingPos;
            x > f[c] && (x > this.columns && ((0, n.info)("row is wrong length"), this.err = !0, x = this.columns), c & 1 ^ R && ++c, f[c] = x), this.codingPos = c;
          }
          _addPixelsNeg(x, R) {
            const f = this.codingLine;
            let c = this.codingPos;
            if (x > f[c])
              x > this.columns && ((0, n.info)("row is wrong length"), this.err = !0, x = this.columns), c & 1 ^ R && ++c, f[c] = x;
            else if (x < f[c]) {
              for (x < 0 && ((0, n.info)("invalid code"), this.err = !0, x = 0); c > 0 && x < f[c - 1]; )
                --c;
              f[c] = x;
            }
            this.codingPos = c;
          }
          _findTableCode(x, R, f, c) {
            const N = c || 0;
            for (let u = x; u <= R; ++u) {
              let p = this._lookBits(u);
              if (p === C)
                return [!0, 1, !1];
              if (u < R && (p <<= R - u), !N || p >= N) {
                const S = f[p - N];
                if (S[0] === u)
                  return this._eatBits(u), [!0, S[1], !0];
              }
            }
            return [!1, 0, !1];
          }
          _getTwoDimCode() {
            let x = 0, R;
            if (this.eoblock) {
              if (x = this._lookBits(7), R = i[x], (R == null ? void 0 : R[0]) > 0)
                return this._eatBits(R[0]), R[1];
            } else {
              const f = this._findTableCode(1, 7, i);
              if (f[0] && f[2])
                return f[1];
            }
            return (0, n.info)("Bad two dim code"), C;
          }
          _getWhiteCode() {
            let x = 0, R;
            if (this.eoblock) {
              if (x = this._lookBits(12), x === C)
                return 1;
              if (R = x >> 5 ? d[x >> 3] : P[x], R[0] > 0)
                return this._eatBits(R[0]), R[1];
            } else {
              let f = this._findTableCode(1, 9, d);
              if (f[0] || (f = this._findTableCode(11, 12, P), f[0]))
                return f[1];
            }
            return (0, n.info)("bad white code"), this._eatBits(1), 1;
          }
          _getBlackCode() {
            let x, R;
            if (this.eoblock) {
              if (x = this._lookBits(13), x === C)
                return 1;
              if (x >> 7 ? !(x >> 9) && x >> 7 ? R = I[(x >> 1) - 64] : R = E[x >> 7] : R = A[x], R[0] > 0)
                return this._eatBits(R[0]), R[1];
            } else {
              let f = this._findTableCode(2, 6, E);
              if (f[0] || (f = this._findTableCode(7, 12, I, 64), f[0]) || (f = this._findTableCode(10, 13, A), f[0]))
                return f[1];
            }
            return (0, n.info)("bad black code"), this._eatBits(1), 1;
          }
          _lookBits(x) {
            let R;
            for (; this.inputBits < x; ) {
              if ((R = this.source.next()) === -1)
                return this.inputBits === 0 ? C : this.inputBuf << x - this.inputBits & 65535 >> 16 - x;
              this.inputBuf = this.inputBuf << 8 | R, this.inputBits += 8;
            }
            return this.inputBuf >> this.inputBits - x & 65535 >> 16 - x;
          }
          _eatBits(x) {
            (this.inputBits -= x) < 0 && (this.inputBits = 0);
          }
        }
        w.CCITTFaxDecoder = k;
      },
      /* 22 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.FlateStream = void 0;
        var n = V(18), F = V(2);
        const C = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), e = new Int32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]), t = new Int32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]), l = [new Int32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9], j = [new Int32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5];
        class U extends n.DecodeStream {
          constructor(v, g) {
            super(g), this.str = v, this.dict = v.dict;
            const b = v.getByte(), i = v.getByte();
            if (b === -1 || i === -1)
              throw new F.FormatError(`Invalid header in flate stream: ${b}, ${i}`);
            if ((b & 15) !== 8)
              throw new F.FormatError(`Unknown compression method in flate stream: ${b}, ${i}`);
            if (((b << 8) + i) % 31 !== 0)
              throw new F.FormatError(`Bad FCHECK in flate stream: ${b}, ${i}`);
            if (i & 32)
              throw new F.FormatError(`FDICT bit set in flate stream: ${b}, ${i}`);
            this.codeSize = 0, this.codeBuf = 0;
          }
          getBits(v) {
            const g = this.str;
            let b = this.codeSize, i = this.codeBuf, P;
            for (; b < v; ) {
              if ((P = g.getByte()) === -1)
                throw new F.FormatError("Bad encoding in flate stream");
              i |= P << b, b += 8;
            }
            return P = i & (1 << v) - 1, this.codeBuf = i >> v, this.codeSize = b -= v, P;
          }
          getCode(v) {
            const g = this.str, b = v[0], i = v[1];
            let P = this.codeSize, d = this.codeBuf, A;
            for (; P < i && (A = g.getByte()) !== -1; )
              d |= A << P, P += 8;
            const I = b[d & (1 << i) - 1], E = I >> 16, k = I & 65535;
            if (E < 1 || P < E)
              throw new F.FormatError("Bad encoding in flate stream");
            return this.codeBuf = d >> E, this.codeSize = P - E, k;
          }
          generateHuffmanTable(v) {
            const g = v.length;
            let b = 0, i;
            for (i = 0; i < g; ++i)
              v[i] > b && (b = v[i]);
            const P = 1 << b, d = new Int32Array(P);
            for (let A = 1, I = 0, E = 2; A <= b; ++A, I <<= 1, E <<= 1)
              for (let k = 0; k < g; ++k)
                if (v[k] === A) {
                  let H = 0, x = I;
                  for (i = 0; i < A; ++i)
                    H = H << 1 | x & 1, x >>= 1;
                  for (i = H; i < P; i += E)
                    d[i] = A << 16 | k;
                  ++I;
                }
            return [d, b];
          }
          readBlock() {
            let v, g;
            const b = this.str;
            let i = this.getBits(3);
            if (i & 1 && (this.eof = !0), i >>= 1, i === 0) {
              let E;
              if ((E = b.getByte()) === -1)
                throw new F.FormatError("Bad block header in flate stream");
              let k = E;
              if ((E = b.getByte()) === -1)
                throw new F.FormatError("Bad block header in flate stream");
              if (k |= E << 8, (E = b.getByte()) === -1)
                throw new F.FormatError("Bad block header in flate stream");
              let H = E;
              if ((E = b.getByte()) === -1)
                throw new F.FormatError("Bad block header in flate stream");
              if (H |= E << 8, H !== (~k & 65535) && (k !== 0 || H !== 0))
                throw new F.FormatError("Bad uncompressed block length in flate stream");
              this.codeBuf = 0, this.codeSize = 0;
              const x = this.bufferLength, R = x + k;
              if (v = this.ensureBuffer(R), this.bufferLength = R, k === 0)
                b.peekByte() === -1 && (this.eof = !0);
              else {
                const f = b.getBytes(k);
                v.set(f, x), f.length < k && (this.eof = !0);
              }
              return;
            }
            let P, d;
            if (i === 1)
              P = l, d = j;
            else if (i === 2) {
              const E = this.getBits(5) + 257, k = this.getBits(5) + 1, H = this.getBits(4) + 4, x = new Uint8Array(C.length);
              let R;
              for (R = 0; R < H; ++R)
                x[C[R]] = this.getBits(3);
              const f = this.generateHuffmanTable(x);
              g = 0, R = 0;
              const c = E + k, N = new Uint8Array(c);
              let u, p, S;
              for (; R < c; ) {
                const B = this.getCode(f);
                if (B === 16)
                  u = 2, p = 3, S = g;
                else if (B === 17)
                  u = 3, p = 3, S = g = 0;
                else if (B === 18)
                  u = 7, p = 11, S = g = 0;
                else {
                  N[R++] = g = B;
                  continue;
                }
                let T = this.getBits(u) + p;
                for (; T-- > 0; )
                  N[R++] = S;
              }
              P = this.generateHuffmanTable(N.subarray(0, E)), d = this.generateHuffmanTable(N.subarray(E, c));
            } else
              throw new F.FormatError("Unknown block type in flate stream");
            v = this.buffer;
            let A = v ? v.length : 0, I = this.bufferLength;
            for (; ; ) {
              let E = this.getCode(P);
              if (E < 256) {
                I + 1 >= A && (v = this.ensureBuffer(I + 1), A = v.length), v[I++] = E;
                continue;
              }
              if (E === 256) {
                this.bufferLength = I;
                return;
              }
              E -= 257, E = e[E];
              let k = E >> 16;
              k > 0 && (k = this.getBits(k)), g = (E & 65535) + k, E = this.getCode(d), E = t[E], k = E >> 16, k > 0 && (k = this.getBits(k));
              const H = (E & 65535) + k;
              I + g >= A && (v = this.ensureBuffer(I + g), A = v.length);
              for (let x = 0; x < g; ++x, ++I)
                v[I] = v[I - H];
            }
          }
        }
        w.FlateStream = U;
      },
      /* 23 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.Jbig2Stream = void 0;
        var n = V(5), F = V(18), C = V(4), e = V(24), t = V(2);
        class l extends F.DecodeStream {
          constructor(U, O, v) {
            super(O), this.stream = U, this.dict = U.dict, this.maybeLength = O, this.params = v;
          }
          get bytes() {
            return (0, t.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
          }
          ensureBuffer(U) {
          }
          readBlock() {
            if (this.eof)
              return;
            const U = new e.Jbig2Image(), O = [];
            if (this.params instanceof C.Dict) {
              const b = this.params.get("JBIG2Globals");
              if (b instanceof n.BaseStream) {
                const i = b.getBytes();
                O.push({
                  data: i,
                  start: 0,
                  end: i.length
                });
              }
            }
            O.push({
              data: this.bytes,
              start: 0,
              end: this.bytes.length
            });
            const v = U.parseChunks(O), g = v.length;
            for (let b = 0; b < g; b++)
              v[b] ^= 255;
            this.buffer = v, this.bufferLength = g, this.eof = !0;
          }
        }
        w.Jbig2Stream = l;
      },
      /* 24 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.Jbig2Image = void 0;
        var n = V(2), F = V(3), C = V(25), e = V(21);
        class t extends n.BaseException {
          constructor(te) {
            super(`JBIG2 error: ${te}`, "Jbig2Error");
          }
        }
        class l {
          getContexts(te) {
            return te in this ? this[te] : this[te] = new Int8Array(65536);
          }
        }
        class j {
          constructor(te, L, X) {
            this.data = te, this.start = L, this.end = X;
          }
          get decoder() {
            const te = new C.ArithmeticDecoder(this.data, this.start, this.end);
            return (0, n.shadow)(this, "decoder", te);
          }
          get contextCache() {
            const te = new l();
            return (0, n.shadow)(this, "contextCache", te);
          }
        }
        const U = 2 ** 31 - 1, O = -(2 ** 31);
        function v(Z, te, L) {
          const X = Z.getContexts(te);
          let J = 1;
          function Y(z) {
            let ie = 0;
            for (let ne = 0; ne < z; ne++) {
              const W = L.readBit(X, J);
              J = J < 256 ? J << 1 | W : (J << 1 | W) & 511 | 256, ie = ie << 1 | W;
            }
            return ie >>> 0;
          }
          const ae = Y(1), se = Y(1) ? Y(1) ? Y(1) ? Y(1) ? Y(1) ? Y(32) + 4436 : Y(12) + 340 : Y(8) + 84 : Y(6) + 20 : Y(4) + 4 : Y(2);
          let Q;
          return ae === 0 ? Q = se : se > 0 && (Q = -se), Q >= O && Q <= U ? Q : null;
        }
        function g(Z, te, L) {
          const X = Z.getContexts("IAID");
          let J = 1;
          for (let Y = 0; Y < L; Y++) {
            const ae = te.readBit(X, J);
            J = J << 1 | ae;
          }
          return L < 31 ? J & (1 << L) - 1 : J & 2147483647;
        }
        const b = ["SymbolDictionary", null, null, null, "IntermediateTextRegion", null, "ImmediateTextRegion", "ImmediateLosslessTextRegion", null, null, null, null, null, null, null, null, "PatternDictionary", null, null, null, "IntermediateHalftoneRegion", null, "ImmediateHalftoneRegion", "ImmediateLosslessHalftoneRegion", null, null, null, null, null, null, null, null, null, null, null, null, "IntermediateGenericRegion", null, "ImmediateGenericRegion", "ImmediateLosslessGenericRegion", "IntermediateGenericRefinementRegion", null, "ImmediateGenericRefinementRegion", "ImmediateLosslessGenericRefinementRegion", null, null, null, null, "PageInformation", "EndOfPage", "EndOfStripe", "EndOfFile", "Profiles", "Tables", null, null, null, null, null, null, null, null, "Extension"], i = [[{
          x: -1,
          y: -2
        }, {
          x: 0,
          y: -2
        }, {
          x: 1,
          y: -2
        }, {
          x: -2,
          y: -1
        }, {
          x: -1,
          y: -1
        }, {
          x: 0,
          y: -1
        }, {
          x: 1,
          y: -1
        }, {
          x: 2,
          y: -1
        }, {
          x: -4,
          y: 0
        }, {
          x: -3,
          y: 0
        }, {
          x: -2,
          y: 0
        }, {
          x: -1,
          y: 0
        }], [{
          x: -1,
          y: -2
        }, {
          x: 0,
          y: -2
        }, {
          x: 1,
          y: -2
        }, {
          x: 2,
          y: -2
        }, {
          x: -2,
          y: -1
        }, {
          x: -1,
          y: -1
        }, {
          x: 0,
          y: -1
        }, {
          x: 1,
          y: -1
        }, {
          x: 2,
          y: -1
        }, {
          x: -3,
          y: 0
        }, {
          x: -2,
          y: 0
        }, {
          x: -1,
          y: 0
        }], [{
          x: -1,
          y: -2
        }, {
          x: 0,
          y: -2
        }, {
          x: 1,
          y: -2
        }, {
          x: -2,
          y: -1
        }, {
          x: -1,
          y: -1
        }, {
          x: 0,
          y: -1
        }, {
          x: 1,
          y: -1
        }, {
          x: -2,
          y: 0
        }, {
          x: -1,
          y: 0
        }], [{
          x: -3,
          y: -1
        }, {
          x: -2,
          y: -1
        }, {
          x: -1,
          y: -1
        }, {
          x: 0,
          y: -1
        }, {
          x: 1,
          y: -1
        }, {
          x: -4,
          y: 0
        }, {
          x: -3,
          y: 0
        }, {
          x: -2,
          y: 0
        }, {
          x: -1,
          y: 0
        }]], P = [{
          coding: [{
            x: 0,
            y: -1
          }, {
            x: 1,
            y: -1
          }, {
            x: -1,
            y: 0
          }],
          reference: [{
            x: 0,
            y: -1
          }, {
            x: 1,
            y: -1
          }, {
            x: -1,
            y: 0
          }, {
            x: 0,
            y: 0
          }, {
            x: 1,
            y: 0
          }, {
            x: -1,
            y: 1
          }, {
            x: 0,
            y: 1
          }, {
            x: 1,
            y: 1
          }]
        }, {
          coding: [{
            x: -1,
            y: -1
          }, {
            x: 0,
            y: -1
          }, {
            x: 1,
            y: -1
          }, {
            x: -1,
            y: 0
          }],
          reference: [{
            x: 0,
            y: -1
          }, {
            x: -1,
            y: 0
          }, {
            x: 0,
            y: 0
          }, {
            x: 1,
            y: 0
          }, {
            x: 0,
            y: 1
          }, {
            x: 1,
            y: 1
          }]
        }], d = [39717, 1941, 229, 405], A = [32, 8];
        function I(Z, te, L) {
          const X = L.decoder, J = L.contextCache.getContexts("GB"), Y = [];
          let ae, se, Q, z, ie, ne, W;
          const oe = 31735;
          for (se = 0; se < te; se++)
            for (ie = Y[se] = new Uint8Array(Z), ne = se < 1 ? ie : Y[se - 1], W = se < 2 ? ie : Y[se - 2], ae = W[0] << 13 | W[1] << 12 | W[2] << 11 | ne[0] << 7 | ne[1] << 6 | ne[2] << 5 | ne[3] << 4, Q = 0; Q < Z; Q++)
              ie[Q] = z = X.readBit(J, ae), ae = (ae & oe) << 1 | (Q + 3 < Z ? W[Q + 3] << 11 : 0) | (Q + 4 < Z ? ne[Q + 4] << 4 : 0) | z;
          return Y;
        }
        function E(Z, te, L, X, J, Y, ae, se) {
          if (Z) {
            const ye = new y(se.data, se.start, se.end);
            return q(ye, te, L, !1);
          }
          if (X === 0 && !Y && !J && ae.length === 4 && ae[0].x === 3 && ae[0].y === -1 && ae[1].x === -3 && ae[1].y === -1 && ae[2].x === 2 && ae[2].y === -2 && ae[3].x === -2 && ae[3].y === -2)
            return I(te, L, se);
          const Q = !!Y, z = i[X].concat(ae);
          z.sort(function(ye, Ie) {
            return ye.y - Ie.y || ye.x - Ie.x;
          });
          const ie = z.length, ne = new Int8Array(ie), W = new Int8Array(ie), oe = [];
          let ue = 0, pe = 0, ve = 0, Ce = 0, Fe, Pe;
          for (Pe = 0; Pe < ie; Pe++)
            ne[Pe] = z[Pe].x, W[Pe] = z[Pe].y, pe = Math.min(pe, z[Pe].x), ve = Math.max(ve, z[Pe].x), Ce = Math.min(Ce, z[Pe].y), Pe < ie - 1 && z[Pe].y === z[Pe + 1].y && z[Pe].x === z[Pe + 1].x - 1 ? ue |= 1 << ie - 1 - Pe : oe.push(Pe);
          const be = oe.length, me = new Int8Array(be), we = new Int8Array(be), _e = new Uint16Array(be);
          for (Fe = 0; Fe < be; Fe++)
            Pe = oe[Fe], me[Fe] = z[Pe].x, we[Fe] = z[Pe].y, _e[Fe] = 1 << ie - 1 - Pe;
          const Se = -pe, Ae = -Ce, Te = te - ve, ke = d[X];
          let Ee = new Uint8Array(te);
          const Ve = [], je = se.decoder, at = se.contextCache.getContexts("GB");
          let $e = 0, ct, ze, Ye, Qe = 0, Oe, he;
          for (let ye = 0; ye < L; ye++) {
            if (J) {
              const Ie = je.readBit(at, ke);
              if ($e ^= Ie, $e) {
                Ve.push(Ee);
                continue;
              }
            }
            for (Ee = new Uint8Array(Ee), Ve.push(Ee), ct = 0; ct < te; ct++) {
              if (Q && Y[ye][ct]) {
                Ee[ct] = 0;
                continue;
              }
              if (ct >= Se && ct < Te && ye >= Ae)
                for (Qe = Qe << 1 & ue, Pe = 0; Pe < be; Pe++)
                  ze = ye + we[Pe], Ye = ct + me[Pe], Oe = Ve[ze][Ye], Oe && (Oe = _e[Pe], Qe |= Oe);
              else
                for (Qe = 0, he = ie - 1, Pe = 0; Pe < ie; Pe++, he--)
                  Ye = ct + ne[Pe], Ye >= 0 && Ye < te && (ze = ye + W[Pe], ze >= 0 && (Oe = Ve[ze][Ye], Oe && (Qe |= Oe << he)));
              const Ie = je.readBit(at, Qe);
              Ee[ct] = Ie;
            }
          }
          return Ve;
        }
        function k(Z, te, L, X, J, Y, ae, se, Q) {
          let z = P[L].coding;
          L === 0 && (z = z.concat([se[0]]));
          const ie = z.length, ne = new Int32Array(ie), W = new Int32Array(ie);
          let oe;
          for (oe = 0; oe < ie; oe++)
            ne[oe] = z[oe].x, W[oe] = z[oe].y;
          let ue = P[L].reference;
          L === 0 && (ue = ue.concat([se[1]]));
          const pe = ue.length, ve = new Int32Array(pe), Ce = new Int32Array(pe);
          for (oe = 0; oe < pe; oe++)
            ve[oe] = ue[oe].x, Ce[oe] = ue[oe].y;
          const Fe = X[0].length, Pe = X.length, be = A[L], me = [], we = Q.decoder, _e = Q.contextCache.getContexts("GR");
          let Se = 0;
          for (let Ae = 0; Ae < te; Ae++) {
            if (ae) {
              const ke = we.readBit(_e, be);
              if (Se ^= ke, Se)
                throw new t("prediction is not supported");
            }
            const Te = new Uint8Array(Z);
            me.push(Te);
            for (let ke = 0; ke < Z; ke++) {
              let Ee, Ve, je = 0;
              for (oe = 0; oe < ie; oe++)
                Ee = Ae + W[oe], Ve = ke + ne[oe], Ee < 0 || Ve < 0 || Ve >= Z ? je <<= 1 : je = je << 1 | me[Ee][Ve];
              for (oe = 0; oe < pe; oe++)
                Ee = Ae + Ce[oe] - Y, Ve = ke + ve[oe] - J, Ee < 0 || Ee >= Pe || Ve < 0 || Ve >= Fe ? je <<= 1 : je = je << 1 | X[Ee][Ve];
              const at = we.readBit(_e, je);
              Te[ke] = at;
            }
          }
          return me;
        }
        function H(Z, te, L, X, J, Y, ae, se, Q, z, ie, ne) {
          if (Z && te)
            throw new t("symbol refinement with Huffman is not supported");
          const W = [];
          let oe = 0, ue = (0, F.log2)(L.length + X);
          const pe = ie.decoder, ve = ie.contextCache;
          let Ce, Fe;
          for (Z && (Ce = r(1), Fe = [], ue = Math.max(ue, 1)); W.length < X; ) {
            const Ae = Z ? Y.tableDeltaHeight.decode(ne) : v(ve, "IADH", pe);
            oe += Ae;
            let Te = 0, ke = 0;
            const Ee = Z ? Fe.length : 0;
            for (; ; ) {
              const Ve = Z ? Y.tableDeltaWidth.decode(ne) : v(ve, "IADW", pe);
              if (Ve === null)
                break;
              Te += Ve, ke += Te;
              let je;
              if (te) {
                const at = v(ve, "IAAI", pe);
                if (at > 1)
                  je = x(Z, te, Te, oe, 0, at, 1, L.concat(W), ue, 0, 0, 1, 0, Y, Q, z, ie, 0, ne);
                else {
                  const $e = g(ve, pe, ue), ct = v(ve, "IARDX", pe), ze = v(ve, "IARDY", pe), Ye = $e < L.length ? L[$e] : W[$e - L.length];
                  je = k(Te, oe, Q, Ye, ct, ze, !1, z, ie);
                }
                W.push(je);
              } else
                Z ? Fe.push(Te) : (je = E(!1, Te, oe, ae, !1, null, se, ie), W.push(je));
            }
            if (Z && !te) {
              const Ve = Y.tableBitmapSize.decode(ne);
              ne.byteAlign();
              let je;
              if (Ve === 0)
                je = ce(ne, ke, oe);
              else {
                const $e = ne.end, ct = ne.position + Ve;
                ne.end = ct, je = q(ne, ke, oe, !1), ne.end = $e, ne.position = ct;
              }
              const at = Fe.length;
              if (Ee === at - 1)
                W.push(je);
              else {
                let $e, ct, ze = 0, Ye, Qe, Oe;
                for ($e = Ee; $e < at; $e++) {
                  for (Qe = Fe[$e], Ye = ze + Qe, Oe = [], ct = 0; ct < oe; ct++)
                    Oe.push(je[ct].subarray(ze, Ye));
                  W.push(Oe), ze = Ye;
                }
              }
            }
          }
          const Pe = [], be = [];
          let me = !1, we, _e;
          const Se = L.length + X;
          for (; be.length < Se; ) {
            let Ae = Z ? Ce.decode(ne) : v(ve, "IAEX", pe);
            for (; Ae--; )
              be.push(me);
            me = !me;
          }
          for (we = 0, _e = L.length; we < _e; we++)
            be[we] && Pe.push(L[we]);
          for (let Ae = 0; Ae < X; we++, Ae++)
            be[we] && Pe.push(W[Ae]);
          return Pe;
        }
        function x(Z, te, L, X, J, Y, ae, se, Q, z, ie, ne, W, oe, ue, pe, ve, Ce, Fe) {
          if (Z && te)
            throw new t("refinement with Huffman is not supported");
          const Pe = [];
          let be, me;
          for (be = 0; be < X; be++) {
            if (me = new Uint8Array(L), J)
              for (let Te = 0; Te < L; Te++)
                me[Te] = J;
            Pe.push(me);
          }
          const we = ve.decoder, _e = ve.contextCache;
          let Se = Z ? -oe.tableDeltaT.decode(Fe) : -v(_e, "IADT", we), Ae = 0;
          for (be = 0; be < Y; ) {
            const Te = Z ? oe.tableDeltaT.decode(Fe) : v(_e, "IADT", we);
            Se += Te;
            const ke = Z ? oe.tableFirstS.decode(Fe) : v(_e, "IAFS", we);
            Ae += ke;
            let Ee = Ae;
            do {
              let Ve = 0;
              ae > 1 && (Ve = Z ? Fe.readBits(Ce) : v(_e, "IAIT", we));
              const je = ae * Se + Ve, at = Z ? oe.symbolIDTable.decode(Fe) : g(_e, we, Q), $e = te && (Z ? Fe.readBit() : v(_e, "IARI", we));
              let ct = se[at], ze = ct[0].length, Ye = ct.length;
              if ($e) {
                const Be = v(_e, "IARDW", we), Ne = v(_e, "IARDH", we), Ue = v(_e, "IARDX", we), qe = v(_e, "IARDY", we);
                ze += Be, Ye += Ne, ct = k(ze, Ye, ue, ct, (Be >> 1) + Ue, (Ne >> 1) + qe, !1, pe, ve);
              }
              const Qe = je - (ne & 1 ? 0 : Ye - 1), Oe = Ee - (ne & 2 ? ze - 1 : 0);
              let he, ye, Ie;
              if (z) {
                for (he = 0; he < Ye; he++) {
                  if (me = Pe[Oe + he], !me)
                    continue;
                  Ie = ct[he];
                  const Be = Math.min(L - Qe, ze);
                  switch (W) {
                    case 0:
                      for (ye = 0; ye < Be; ye++)
                        me[Qe + ye] |= Ie[ye];
                      break;
                    case 2:
                      for (ye = 0; ye < Be; ye++)
                        me[Qe + ye] ^= Ie[ye];
                      break;
                    default:
                      throw new t(`operator ${W} is not supported`);
                  }
                }
                Ee += Ye - 1;
              } else {
                for (ye = 0; ye < Ye; ye++)
                  if (me = Pe[Qe + ye], !!me)
                    switch (Ie = ct[ye], W) {
                      case 0:
                        for (he = 0; he < ze; he++)
                          me[Oe + he] |= Ie[he];
                        break;
                      case 2:
                        for (he = 0; he < ze; he++)
                          me[Oe + he] ^= Ie[he];
                        break;
                      default:
                        throw new t(`operator ${W} is not supported`);
                    }
                Ee += ze - 1;
              }
              be++;
              const Le = Z ? oe.tableDeltaS.decode(Fe) : v(_e, "IADS", we);
              if (Le === null)
                break;
              Ee += Le + ie;
            } while (!0);
          }
          return Pe;
        }
        function R(Z, te, L, X, J, Y) {
          const ae = [];
          Z || (ae.push({
            x: -te,
            y: 0
          }), J === 0 && ae.push({
            x: -3,
            y: -1
          }, {
            x: 2,
            y: -2
          }, {
            x: -2,
            y: -2
          }));
          const se = (X + 1) * te, Q = E(Z, se, L, J, !1, null, ae, Y), z = [];
          for (let ie = 0; ie <= X; ie++) {
            const ne = [], W = te * ie, oe = W + te;
            for (let ue = 0; ue < L; ue++)
              ne.push(Q[ue].subarray(W, oe));
            z.push(ne);
          }
          return z;
        }
        function f(Z, te, L, X, J, Y, ae, se, Q, z, ie, ne, W, oe, ue) {
          if (ae)
            throw new t("skip is not supported");
          if (se !== 0)
            throw new t(`operator "${se}" is not supported in halftone region`);
          const ve = [];
          let Ce, Fe, Pe;
          for (Ce = 0; Ce < J; Ce++) {
            if (Pe = new Uint8Array(X), Y)
              for (Fe = 0; Fe < X; Fe++)
                Pe[Fe] = Y;
            ve.push(Pe);
          }
          const be = te.length, me = te[0], we = me[0].length, _e = me.length, Se = (0, F.log2)(be), Ae = [];
          Z || (Ae.push({
            x: L <= 1 ? 3 : 2,
            y: -1
          }), L === 0 && Ae.push({
            x: -3,
            y: -1
          }, {
            x: 2,
            y: -2
          }, {
            x: -2,
            y: -2
          }));
          const Te = [];
          let ke, Ee;
          for (Z && (ke = new y(ue.data, ue.start, ue.end)), Ce = Se - 1; Ce >= 0; Ce--)
            Z ? Ee = q(ke, Q, z, !0) : Ee = E(!1, Q, z, L, !1, null, Ae, ue), Te[Ce] = Ee;
          let Ve, je, at, $e, ct, ze, Ye, Qe, Oe;
          for (Ve = 0; Ve < z; Ve++)
            for (je = 0; je < Q; je++) {
              for (at = 0, $e = 0, Fe = Se - 1; Fe >= 0; Fe--)
                at ^= Te[Fe][Ve][je], $e |= at << Fe;
              if (ct = te[$e], ze = ie + Ve * oe + je * W >> 8, Ye = ne + Ve * W - je * oe >> 8, ze >= 0 && ze + we <= X && Ye >= 0 && Ye + _e <= J)
                for (Ce = 0; Ce < _e; Ce++)
                  for (Oe = ve[Ye + Ce], Qe = ct[Ce], Fe = 0; Fe < we; Fe++)
                    Oe[ze + Fe] |= Qe[Fe];
              else {
                let he, ye;
                for (Ce = 0; Ce < _e; Ce++)
                  if (ye = Ye + Ce, !(ye < 0 || ye >= J))
                    for (Oe = ve[ye], Qe = ct[Ce], Fe = 0; Fe < we; Fe++)
                      he = ze + Fe, he >= 0 && he < X && (Oe[he] |= Qe[Fe]);
              }
            }
          return ve;
        }
        function c(Z, te) {
          const L = {};
          L.number = (0, F.readUint32)(Z, te);
          const X = Z[te + 4], J = X & 63;
          if (!b[J])
            throw new t("invalid segment type: " + J);
          L.type = J, L.typeName = b[J], L.deferredNonRetain = !!(X & 128);
          const Y = !!(X & 64), ae = Z[te + 5];
          let se = ae >> 5 & 7;
          const Q = [ae & 31];
          let z = te + 6;
          if (ae === 7) {
            se = (0, F.readUint32)(Z, z - 1) & 536870911, z += 3;
            let ue = se + 7 >> 3;
            for (Q[0] = Z[z++]; --ue > 0; )
              Q.push(Z[z++]);
          } else if (ae === 5 || ae === 6)
            throw new t("invalid referred-to flags");
          L.retainBits = Q;
          let ie = 4;
          L.number <= 256 ? ie = 1 : L.number <= 65536 && (ie = 2);
          const ne = [];
          let W, oe;
          for (W = 0; W < se; W++) {
            let ue;
            ie === 1 ? ue = Z[z] : ie === 2 ? ue = (0, F.readUint16)(Z, z) : ue = (0, F.readUint32)(Z, z), ne.push(ue), z += ie;
          }
          if (L.referredTo = ne, Y ? (L.pageAssociation = (0, F.readUint32)(Z, z), z += 4) : L.pageAssociation = Z[z++], L.length = (0, F.readUint32)(Z, z), z += 4, L.length === 4294967295)
            if (J === 38) {
              const ue = u(Z, z), ve = !!(Z[z + p] & 1), Ce = 6, Fe = new Uint8Array(Ce);
              for (ve || (Fe[0] = 255, Fe[1] = 172), Fe[2] = ue.height >>> 24 & 255, Fe[3] = ue.height >> 16 & 255, Fe[4] = ue.height >> 8 & 255, Fe[5] = ue.height & 255, W = z, oe = Z.length; W < oe; W++) {
                let Pe = 0;
                for (; Pe < Ce && Fe[Pe] === Z[W + Pe]; )
                  Pe++;
                if (Pe === Ce) {
                  L.length = W + Ce;
                  break;
                }
              }
              if (L.length === 4294967295)
                throw new t("segment end was not found");
            } else
              throw new t("invalid unknown segment length");
          return L.headerEnd = z, L;
        }
        function N(Z, te, L, X) {
          const J = [];
          let Y = L;
          for (; Y < X; ) {
            const ae = c(te, Y);
            Y = ae.headerEnd;
            const se = {
              header: ae,
              data: te
            };
            if (Z.randomAccess || (se.start = Y, Y += ae.length, se.end = Y), J.push(se), ae.type === 51)
              break;
          }
          if (Z.randomAccess)
            for (let ae = 0, se = J.length; ae < se; ae++)
              J[ae].start = Y, Y += J[ae].header.length, J[ae].end = Y;
          return J;
        }
        function u(Z, te) {
          return {
            width: (0, F.readUint32)(Z, te),
            height: (0, F.readUint32)(Z, te + 4),
            x: (0, F.readUint32)(Z, te + 8),
            y: (0, F.readUint32)(Z, te + 12),
            combinationOperator: Z[te + 16] & 7
          };
        }
        const p = 17;
        function S(Z, te) {
          const L = Z.header, X = Z.data, J = Z.end;
          let Y = Z.start, ae, se, Q, z;
          switch (L.type) {
            case 0:
              const ne = {}, W = (0, F.readUint16)(X, Y);
              if (ne.huffman = !!(W & 1), ne.refinement = !!(W & 2), ne.huffmanDHSelector = W >> 2 & 3, ne.huffmanDWSelector = W >> 4 & 3, ne.bitmapSizeSelector = W >> 6 & 1, ne.aggregationInstancesSelector = W >> 7 & 1, ne.bitmapCodingContextUsed = !!(W & 256), ne.bitmapCodingContextRetained = !!(W & 512), ne.template = W >> 10 & 3, ne.refinementTemplate = W >> 12 & 1, Y += 2, !ne.huffman) {
                for (z = ne.template === 0 ? 4 : 1, se = [], Q = 0; Q < z; Q++)
                  se.push({
                    x: (0, F.readInt8)(X, Y),
                    y: (0, F.readInt8)(X, Y + 1)
                  }), Y += 2;
                ne.at = se;
              }
              if (ne.refinement && !ne.refinementTemplate) {
                for (se = [], Q = 0; Q < 2; Q++)
                  se.push({
                    x: (0, F.readInt8)(X, Y),
                    y: (0, F.readInt8)(X, Y + 1)
                  }), Y += 2;
                ne.refinementAt = se;
              }
              ne.numberOfExportedSymbols = (0, F.readUint32)(X, Y), Y += 4, ne.numberOfNewSymbols = (0, F.readUint32)(X, Y), Y += 4, ae = [ne, L.number, L.referredTo, X, Y, J];
              break;
            case 6:
            case 7:
              const oe = {};
              oe.info = u(X, Y), Y += p;
              const ue = (0, F.readUint16)(X, Y);
              if (Y += 2, oe.huffman = !!(ue & 1), oe.refinement = !!(ue & 2), oe.logStripSize = ue >> 2 & 3, oe.stripSize = 1 << oe.logStripSize, oe.referenceCorner = ue >> 4 & 3, oe.transposed = !!(ue & 64), oe.combinationOperator = ue >> 7 & 3, oe.defaultPixelValue = ue >> 9 & 1, oe.dsOffset = ue << 17 >> 27, oe.refinementTemplate = ue >> 15 & 1, oe.huffman) {
                const _e = (0, F.readUint16)(X, Y);
                Y += 2, oe.huffmanFS = _e & 3, oe.huffmanDS = _e >> 2 & 3, oe.huffmanDT = _e >> 4 & 3, oe.huffmanRefinementDW = _e >> 6 & 3, oe.huffmanRefinementDH = _e >> 8 & 3, oe.huffmanRefinementDX = _e >> 10 & 3, oe.huffmanRefinementDY = _e >> 12 & 3, oe.huffmanRefinementSizeSelector = !!(_e & 16384);
              }
              if (oe.refinement && !oe.refinementTemplate) {
                for (se = [], Q = 0; Q < 2; Q++)
                  se.push({
                    x: (0, F.readInt8)(X, Y),
                    y: (0, F.readInt8)(X, Y + 1)
                  }), Y += 2;
                oe.refinementAt = se;
              }
              oe.numberOfSymbolInstances = (0, F.readUint32)(X, Y), Y += 4, ae = [oe, L.referredTo, X, Y, J];
              break;
            case 16:
              const pe = {}, ve = X[Y++];
              pe.mmr = !!(ve & 1), pe.template = ve >> 1 & 3, pe.patternWidth = X[Y++], pe.patternHeight = X[Y++], pe.maxPatternIndex = (0, F.readUint32)(X, Y), Y += 4, ae = [pe, L.number, X, Y, J];
              break;
            case 22:
            case 23:
              const Ce = {};
              Ce.info = u(X, Y), Y += p;
              const Fe = X[Y++];
              Ce.mmr = !!(Fe & 1), Ce.template = Fe >> 1 & 3, Ce.enableSkip = !!(Fe & 8), Ce.combinationOperator = Fe >> 4 & 7, Ce.defaultPixelValue = Fe >> 7 & 1, Ce.gridWidth = (0, F.readUint32)(X, Y), Y += 4, Ce.gridHeight = (0, F.readUint32)(X, Y), Y += 4, Ce.gridOffsetX = (0, F.readUint32)(X, Y) & 4294967295, Y += 4, Ce.gridOffsetY = (0, F.readUint32)(X, Y) & 4294967295, Y += 4, Ce.gridVectorX = (0, F.readUint16)(X, Y), Y += 2, Ce.gridVectorY = (0, F.readUint16)(X, Y), Y += 2, ae = [Ce, L.referredTo, X, Y, J];
              break;
            case 38:
            case 39:
              const Pe = {};
              Pe.info = u(X, Y), Y += p;
              const be = X[Y++];
              if (Pe.mmr = !!(be & 1), Pe.template = be >> 1 & 3, Pe.prediction = !!(be & 8), !Pe.mmr) {
                for (z = Pe.template === 0 ? 4 : 1, se = [], Q = 0; Q < z; Q++)
                  se.push({
                    x: (0, F.readInt8)(X, Y),
                    y: (0, F.readInt8)(X, Y + 1)
                  }), Y += 2;
                Pe.at = se;
              }
              ae = [Pe, X, Y, J];
              break;
            case 48:
              const me = {
                width: (0, F.readUint32)(X, Y),
                height: (0, F.readUint32)(X, Y + 4),
                resolutionX: (0, F.readUint32)(X, Y + 8),
                resolutionY: (0, F.readUint32)(X, Y + 12)
              };
              me.height === 4294967295 && delete me.height;
              const we = X[Y + 16];
              (0, F.readUint16)(X, Y + 17), me.lossless = !!(we & 1), me.refinement = !!(we & 2), me.defaultPixelValue = we >> 2 & 1, me.combinationOperator = we >> 3 & 3, me.requiresBuffer = !!(we & 32), me.combinationOperatorOverride = !!(we & 64), ae = [me];
              break;
            case 49:
              break;
            case 50:
              break;
            case 51:
              break;
            case 53:
              ae = [L.number, X, Y, J];
              break;
            case 62:
              break;
            default:
              throw new t(`segment type ${L.typeName}(${L.type}) is not implemented`);
          }
          const ie = "on" + L.typeName;
          ie in te && te[ie].apply(te, ae);
        }
        function B(Z, te) {
          for (let L = 0, X = Z.length; L < X; L++)
            S(Z[L], te);
        }
        function T(Z) {
          const te = new D();
          for (let L = 0, X = Z.length; L < X; L++) {
            const J = Z[L], Y = N({}, J.data, J.start, J.end);
            B(Y, te);
          }
          return te.buffer;
        }
        class D {
          onPageInformation(te) {
            this.currentPageInfo = te;
            const L = te.width + 7 >> 3, X = new Uint8ClampedArray(L * te.height);
            te.defaultPixelValue && X.fill(255), this.buffer = X;
          }
          drawBitmap(te, L) {
            const X = this.currentPageInfo, J = te.width, Y = te.height, ae = X.width + 7 >> 3, se = X.combinationOperatorOverride ? te.combinationOperator : X.combinationOperator, Q = this.buffer, z = 128 >> (te.x & 7);
            let ie = te.y * ae + (te.x >> 3), ne, W, oe, ue;
            switch (se) {
              case 0:
                for (ne = 0; ne < Y; ne++) {
                  for (oe = z, ue = ie, W = 0; W < J; W++)
                    L[ne][W] && (Q[ue] |= oe), oe >>= 1, oe || (oe = 128, ue++);
                  ie += ae;
                }
                break;
              case 2:
                for (ne = 0; ne < Y; ne++) {
                  for (oe = z, ue = ie, W = 0; W < J; W++)
                    L[ne][W] && (Q[ue] ^= oe), oe >>= 1, oe || (oe = 128, ue++);
                  ie += ae;
                }
                break;
              default:
                throw new t(`operator ${se} is not supported`);
            }
          }
          onImmediateGenericRegion(te, L, X, J) {
            const Y = te.info, ae = new j(L, X, J), se = E(te.mmr, Y.width, Y.height, te.template, te.prediction, null, te.at, ae);
            this.drawBitmap(Y, se);
          }
          onImmediateLosslessGenericRegion() {
            this.onImmediateGenericRegion(...arguments);
          }
          onSymbolDictionary(te, L, X, J, Y, ae) {
            let se, Q;
            te.huffman && (se = G(te, X, this.customTables), Q = new y(J, Y, ae));
            let z = this.symbols;
            z || (this.symbols = z = {});
            const ie = [];
            for (const W of X) {
              const oe = z[W];
              oe && ie.push(...oe);
            }
            const ne = new j(J, Y, ae);
            z[L] = H(te.huffman, te.refinement, ie, te.numberOfNewSymbols, te.numberOfExportedSymbols, se, te.template, te.at, te.refinementTemplate, te.refinementAt, ne, Q);
          }
          onImmediateTextRegion(te, L, X, J, Y) {
            const ae = te.info;
            let se, Q;
            const z = this.symbols, ie = [];
            for (const ue of L) {
              const pe = z[ue];
              pe && ie.push(...pe);
            }
            const ne = (0, F.log2)(ie.length);
            te.huffman && (Q = new y(X, J, Y), se = $(te, L, this.customTables, ie.length, Q));
            const W = new j(X, J, Y), oe = x(te.huffman, te.refinement, ae.width, ae.height, te.defaultPixelValue, te.numberOfSymbolInstances, te.stripSize, ie, ne, te.transposed, te.dsOffset, te.referenceCorner, te.combinationOperator, se, te.refinementTemplate, te.refinementAt, W, te.logStripSize, Q);
            this.drawBitmap(ae, oe);
          }
          onImmediateLosslessTextRegion() {
            this.onImmediateTextRegion(...arguments);
          }
          onPatternDictionary(te, L, X, J, Y) {
            let ae = this.patterns;
            ae || (this.patterns = ae = {});
            const se = new j(X, J, Y);
            ae[L] = R(te.mmr, te.patternWidth, te.patternHeight, te.maxPatternIndex, te.template, se);
          }
          onImmediateHalftoneRegion(te, L, X, J, Y) {
            const ae = this.patterns[L[0]], se = te.info, Q = new j(X, J, Y), z = f(te.mmr, ae, te.template, se.width, se.height, te.defaultPixelValue, te.enableSkip, te.combinationOperator, te.gridWidth, te.gridHeight, te.gridOffsetX, te.gridOffsetY, te.gridVectorX, te.gridVectorY, Q);
            this.drawBitmap(se, z);
          }
          onImmediateLosslessHalftoneRegion() {
            this.onImmediateHalftoneRegion(...arguments);
          }
          onTables(te, L, X, J) {
            let Y = this.customTables;
            Y || (this.customTables = Y = {}), Y[te] = m(L, X, J);
          }
        }
        class K {
          constructor(te) {
            te.length === 2 ? (this.isOOB = !0, this.rangeLow = 0, this.prefixLength = te[0], this.rangeLength = 0, this.prefixCode = te[1], this.isLowerRange = !1) : (this.isOOB = !1, this.rangeLow = te[0], this.prefixLength = te[1], this.rangeLength = te[2], this.prefixCode = te[3], this.isLowerRange = te[4] === "lower");
          }
        }
        class _ {
          constructor(te) {
            this.children = [], te ? (this.isLeaf = !0, this.rangeLength = te.rangeLength, this.rangeLow = te.rangeLow, this.isLowerRange = te.isLowerRange, this.isOOB = te.isOOB) : this.isLeaf = !1;
          }
          buildTree(te, L) {
            const X = te.prefixCode >> L & 1;
            if (L <= 0)
              this.children[X] = new _(te);
            else {
              let J = this.children[X];
              J || (this.children[X] = J = new _(null)), J.buildTree(te, L - 1);
            }
          }
          decodeNode(te) {
            if (this.isLeaf) {
              if (this.isOOB)
                return null;
              const X = te.readBits(this.rangeLength);
              return this.rangeLow + (this.isLowerRange ? -X : X);
            }
            const L = this.children[te.readBit()];
            if (!L)
              throw new t("invalid Huffman data");
            return L.decodeNode(te);
          }
        }
        class o {
          constructor(te, L) {
            L || this.assignPrefixCodes(te), this.rootNode = new _(null);
            for (let X = 0, J = te.length; X < J; X++) {
              const Y = te[X];
              Y.prefixLength > 0 && this.rootNode.buildTree(Y, Y.prefixLength - 1);
            }
          }
          decode(te) {
            return this.rootNode.decodeNode(te);
          }
          assignPrefixCodes(te) {
            const L = te.length;
            let X = 0;
            for (let ie = 0; ie < L; ie++)
              X = Math.max(X, te[ie].prefixLength);
            const J = new Uint32Array(X + 1);
            for (let ie = 0; ie < L; ie++)
              J[te[ie].prefixLength]++;
            let Y = 1, ae = 0, se, Q, z;
            for (J[0] = 0; Y <= X; ) {
              for (ae = ae + J[Y - 1] << 1, se = ae, Q = 0; Q < L; )
                z = te[Q], z.prefixLength === Y && (z.prefixCode = se, se++), Q++;
              Y++;
            }
          }
        }
        function m(Z, te, L) {
          const X = Z[te], J = (0, F.readUint32)(Z, te + 1) & 4294967295, Y = (0, F.readUint32)(Z, te + 5) & 4294967295, ae = new y(Z, te + 9, L), se = (X >> 1 & 7) + 1, Q = (X >> 4 & 7) + 1, z = [];
          let ie, ne, W = J;
          do
            ie = ae.readBits(se), ne = ae.readBits(Q), z.push(new K([W, ie, ne, 0])), W += 1 << ne;
          while (W < Y);
          return ie = ae.readBits(se), z.push(new K([J - 1, ie, 32, 0, "lower"])), ie = ae.readBits(se), z.push(new K([Y, ie, 32, 0])), X & 1 && (ie = ae.readBits(se), z.push(new K([ie, 0]))), new o(z, !1);
        }
        const s = {};
        function r(Z) {
          let te = s[Z];
          if (te)
            return te;
          let L;
          switch (Z) {
            case 1:
              L = [[0, 1, 4, 0], [16, 2, 8, 2], [272, 3, 16, 6], [65808, 3, 32, 7]];
              break;
            case 2:
              L = [[0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [75, 6, 32, 62], [6, 63]];
              break;
            case 3:
              L = [[-256, 8, 8, 254], [0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [-257, 8, 32, 255, "lower"], [75, 7, 32, 126], [6, 62]];
              break;
            case 4:
              L = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [76, 5, 32, 31]];
              break;
            case 5:
              L = [[-255, 7, 8, 126], [1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [-256, 7, 32, 127, "lower"], [76, 6, 32, 62]];
              break;
            case 6:
              L = [[-2048, 5, 10, 28], [-1024, 4, 9, 8], [-512, 4, 8, 9], [-256, 4, 7, 10], [-128, 5, 6, 29], [-64, 5, 5, 30], [-32, 4, 5, 11], [0, 2, 7, 0], [128, 3, 7, 2], [256, 3, 8, 3], [512, 4, 9, 12], [1024, 4, 10, 13], [-2049, 6, 32, 62, "lower"], [2048, 6, 32, 63]];
              break;
            case 7:
              L = [[-1024, 4, 9, 8], [-512, 3, 8, 0], [-256, 4, 7, 9], [-128, 5, 6, 26], [-64, 5, 5, 27], [-32, 4, 5, 10], [0, 4, 5, 11], [32, 5, 5, 28], [64, 5, 6, 29], [128, 4, 7, 12], [256, 3, 8, 1], [512, 3, 9, 2], [1024, 3, 10, 3], [-1025, 5, 32, 30, "lower"], [2048, 5, 32, 31]];
              break;
            case 8:
              L = [[-15, 8, 3, 252], [-7, 9, 1, 508], [-5, 8, 1, 253], [-3, 9, 0, 509], [-2, 7, 0, 124], [-1, 4, 0, 10], [0, 2, 1, 0], [2, 5, 0, 26], [3, 6, 0, 58], [4, 3, 4, 4], [20, 6, 1, 59], [22, 4, 4, 11], [38, 4, 5, 12], [70, 5, 6, 27], [134, 5, 7, 28], [262, 6, 7, 60], [390, 7, 8, 125], [646, 6, 10, 61], [-16, 9, 32, 510, "lower"], [1670, 9, 32, 511], [2, 1]];
              break;
            case 9:
              L = [[-31, 8, 4, 252], [-15, 9, 2, 508], [-11, 8, 2, 253], [-7, 9, 1, 509], [-5, 7, 1, 124], [-3, 4, 1, 10], [-1, 3, 1, 2], [1, 3, 1, 3], [3, 5, 1, 26], [5, 6, 1, 58], [7, 3, 5, 4], [39, 6, 2, 59], [43, 4, 5, 11], [75, 4, 6, 12], [139, 5, 7, 27], [267, 5, 8, 28], [523, 6, 8, 60], [779, 7, 9, 125], [1291, 6, 11, 61], [-32, 9, 32, 510, "lower"], [3339, 9, 32, 511], [2, 0]];
              break;
            case 10:
              L = [[-21, 7, 4, 122], [-5, 8, 0, 252], [-4, 7, 0, 123], [-3, 5, 0, 24], [-2, 2, 2, 0], [2, 5, 0, 25], [3, 6, 0, 54], [4, 7, 0, 124], [5, 8, 0, 253], [6, 2, 6, 1], [70, 5, 5, 26], [102, 6, 5, 55], [134, 6, 6, 56], [198, 6, 7, 57], [326, 6, 8, 58], [582, 6, 9, 59], [1094, 6, 10, 60], [2118, 7, 11, 125], [-22, 8, 32, 254, "lower"], [4166, 8, 32, 255], [2, 2]];
              break;
            case 11:
              L = [[1, 1, 0, 0], [2, 2, 1, 2], [4, 4, 0, 12], [5, 4, 1, 13], [7, 5, 1, 28], [9, 5, 2, 29], [13, 6, 2, 60], [17, 7, 2, 122], [21, 7, 3, 123], [29, 7, 4, 124], [45, 7, 5, 125], [77, 7, 6, 126], [141, 7, 32, 127]];
              break;
            case 12:
              L = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 1, 6], [5, 5, 0, 28], [6, 5, 1, 29], [8, 6, 1, 60], [10, 7, 0, 122], [11, 7, 1, 123], [13, 7, 2, 124], [17, 7, 3, 125], [25, 7, 4, 126], [41, 8, 5, 254], [73, 8, 32, 255]];
              break;
            case 13:
              L = [[1, 1, 0, 0], [2, 3, 0, 4], [3, 4, 0, 12], [4, 5, 0, 28], [5, 4, 1, 13], [7, 3, 3, 5], [15, 6, 1, 58], [17, 6, 2, 59], [21, 6, 3, 60], [29, 6, 4, 61], [45, 6, 5, 62], [77, 7, 6, 126], [141, 7, 32, 127]];
              break;
            case 14:
              L = [[-2, 3, 0, 4], [-1, 3, 0, 5], [0, 1, 0, 0], [1, 3, 0, 6], [2, 3, 0, 7]];
              break;
            case 15:
              L = [[-24, 7, 4, 124], [-8, 6, 2, 60], [-4, 5, 1, 28], [-2, 4, 0, 12], [-1, 3, 0, 4], [0, 1, 0, 0], [1, 3, 0, 5], [2, 4, 0, 13], [3, 5, 1, 29], [5, 6, 2, 61], [9, 7, 4, 125], [-25, 7, 32, 126, "lower"], [25, 7, 32, 127]];
              break;
            default:
              throw new t(`standard table B.${Z} does not exist`);
          }
          for (let X = 0, J = L.length; X < J; X++)
            L[X] = new K(L[X]);
          return te = new o(L, !0), s[Z] = te, te;
        }
        class y {
          constructor(te, L, X) {
            this.data = te, this.start = L, this.end = X, this.position = L, this.shift = -1, this.currentByte = 0;
          }
          readBit() {
            if (this.shift < 0) {
              if (this.position >= this.end)
                throw new t("end of data while reading bit");
              this.currentByte = this.data[this.position++], this.shift = 7;
            }
            const te = this.currentByte >> this.shift & 1;
            return this.shift--, te;
          }
          readBits(te) {
            let L = 0, X;
            for (X = te - 1; X >= 0; X--)
              L |= this.readBit() << X;
            return L;
          }
          byteAlign() {
            this.shift = -1;
          }
          next() {
            return this.position >= this.end ? -1 : this.data[this.position++];
          }
        }
        function M(Z, te, L) {
          let X = 0;
          for (let J = 0, Y = te.length; J < Y; J++) {
            const ae = L[te[J]];
            if (ae) {
              if (Z === X)
                return ae;
              X++;
            }
          }
          throw new t("can't find custom Huffman table");
        }
        function $(Z, te, L, X, J) {
          const Y = [];
          for (let W = 0; W <= 34; W++) {
            const oe = J.readBits(4);
            Y.push(new K([W, oe, 0, 0]));
          }
          const ae = new o(Y, !1);
          Y.length = 0;
          for (let W = 0; W < X; ) {
            const oe = ae.decode(J);
            if (oe >= 32) {
              let ue, pe, ve;
              switch (oe) {
                case 32:
                  if (W === 0)
                    throw new t("no previous value in symbol ID table");
                  pe = J.readBits(2) + 3, ue = Y[W - 1].prefixLength;
                  break;
                case 33:
                  pe = J.readBits(3) + 3, ue = 0;
                  break;
                case 34:
                  pe = J.readBits(7) + 11, ue = 0;
                  break;
                default:
                  throw new t("invalid code length in symbol ID table");
              }
              for (ve = 0; ve < pe; ve++)
                Y.push(new K([W, ue, 0, 0])), W++;
            } else
              Y.push(new K([W, oe, 0, 0])), W++;
          }
          J.byteAlign();
          const se = new o(Y, !1);
          let Q = 0, z, ie, ne;
          switch (Z.huffmanFS) {
            case 0:
            case 1:
              z = r(Z.huffmanFS + 6);
              break;
            case 3:
              z = M(Q, te, L), Q++;
              break;
            default:
              throw new t("invalid Huffman FS selector");
          }
          switch (Z.huffmanDS) {
            case 0:
            case 1:
            case 2:
              ie = r(Z.huffmanDS + 8);
              break;
            case 3:
              ie = M(Q, te, L), Q++;
              break;
            default:
              throw new t("invalid Huffman DS selector");
          }
          switch (Z.huffmanDT) {
            case 0:
            case 1:
            case 2:
              ne = r(Z.huffmanDT + 11);
              break;
            case 3:
              ne = M(Q, te, L), Q++;
              break;
            default:
              throw new t("invalid Huffman DT selector");
          }
          if (Z.refinement)
            throw new t("refinement with Huffman is not supported");
          return {
            symbolIDTable: se,
            tableFirstS: z,
            tableDeltaS: ie,
            tableDeltaT: ne
          };
        }
        function G(Z, te, L) {
          let X = 0, J, Y;
          switch (Z.huffmanDHSelector) {
            case 0:
            case 1:
              J = r(Z.huffmanDHSelector + 4);
              break;
            case 3:
              J = M(X, te, L), X++;
              break;
            default:
              throw new t("invalid Huffman DH selector");
          }
          switch (Z.huffmanDWSelector) {
            case 0:
            case 1:
              Y = r(Z.huffmanDWSelector + 2);
              break;
            case 3:
              Y = M(X, te, L), X++;
              break;
            default:
              throw new t("invalid Huffman DW selector");
          }
          let ae, se;
          return Z.bitmapSizeSelector ? (ae = M(X, te, L), X++) : ae = r(1), Z.aggregationInstancesSelector ? se = M(X, te, L) : se = r(1), {
            tableDeltaHeight: J,
            tableDeltaWidth: Y,
            tableBitmapSize: ae,
            tableAggregateInstances: se
          };
        }
        function ce(Z, te, L) {
          const X = [];
          for (let J = 0; J < L; J++) {
            const Y = new Uint8Array(te);
            X.push(Y);
            for (let ae = 0; ae < te; ae++)
              Y[ae] = Z.readBit();
            Z.byteAlign();
          }
          return X;
        }
        function q(Z, te, L, X) {
          const J = {
            K: -1,
            Columns: te,
            Rows: L,
            BlackIs1: !0,
            EndOfBlock: X
          }, Y = new e.CCITTFaxDecoder(Z, J), ae = [];
          let se, Q = !1;
          for (let z = 0; z < L; z++) {
            const ie = new Uint8Array(te);
            ae.push(ie);
            let ne = -1;
            for (let W = 0; W < te; W++)
              ne < 0 && (se = Y.readNextChar(), se === -1 && (se = 0, Q = !0), ne = 7), ie[W] = se >> ne & 1, ne--;
          }
          if (X && !Q)
            for (let ie = 0; ie < 5 && Y.readNextChar() !== -1; ie++)
              ;
          return ae;
        }
        class re {
          parseChunks(te) {
            return T(te);
          }
          parse(te) {
            throw new Error("Not implemented: Jbig2Image.parse");
          }
        }
        w.Jbig2Image = re;
      },
      /* 25 */
      /***/
      (fe, w) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.ArithmeticDecoder = void 0;
        const V = [{
          qe: 22017,
          nmps: 1,
          nlps: 1,
          switchFlag: 1
        }, {
          qe: 13313,
          nmps: 2,
          nlps: 6,
          switchFlag: 0
        }, {
          qe: 6145,
          nmps: 3,
          nlps: 9,
          switchFlag: 0
        }, {
          qe: 2753,
          nmps: 4,
          nlps: 12,
          switchFlag: 0
        }, {
          qe: 1313,
          nmps: 5,
          nlps: 29,
          switchFlag: 0
        }, {
          qe: 545,
          nmps: 38,
          nlps: 33,
          switchFlag: 0
        }, {
          qe: 22017,
          nmps: 7,
          nlps: 6,
          switchFlag: 1
        }, {
          qe: 21505,
          nmps: 8,
          nlps: 14,
          switchFlag: 0
        }, {
          qe: 18433,
          nmps: 9,
          nlps: 14,
          switchFlag: 0
        }, {
          qe: 14337,
          nmps: 10,
          nlps: 14,
          switchFlag: 0
        }, {
          qe: 12289,
          nmps: 11,
          nlps: 17,
          switchFlag: 0
        }, {
          qe: 9217,
          nmps: 12,
          nlps: 18,
          switchFlag: 0
        }, {
          qe: 7169,
          nmps: 13,
          nlps: 20,
          switchFlag: 0
        }, {
          qe: 5633,
          nmps: 29,
          nlps: 21,
          switchFlag: 0
        }, {
          qe: 22017,
          nmps: 15,
          nlps: 14,
          switchFlag: 1
        }, {
          qe: 21505,
          nmps: 16,
          nlps: 14,
          switchFlag: 0
        }, {
          qe: 20737,
          nmps: 17,
          nlps: 15,
          switchFlag: 0
        }, {
          qe: 18433,
          nmps: 18,
          nlps: 16,
          switchFlag: 0
        }, {
          qe: 14337,
          nmps: 19,
          nlps: 17,
          switchFlag: 0
        }, {
          qe: 13313,
          nmps: 20,
          nlps: 18,
          switchFlag: 0
        }, {
          qe: 12289,
          nmps: 21,
          nlps: 19,
          switchFlag: 0
        }, {
          qe: 10241,
          nmps: 22,
          nlps: 19,
          switchFlag: 0
        }, {
          qe: 9217,
          nmps: 23,
          nlps: 20,
          switchFlag: 0
        }, {
          qe: 8705,
          nmps: 24,
          nlps: 21,
          switchFlag: 0
        }, {
          qe: 7169,
          nmps: 25,
          nlps: 22,
          switchFlag: 0
        }, {
          qe: 6145,
          nmps: 26,
          nlps: 23,
          switchFlag: 0
        }, {
          qe: 5633,
          nmps: 27,
          nlps: 24,
          switchFlag: 0
        }, {
          qe: 5121,
          nmps: 28,
          nlps: 25,
          switchFlag: 0
        }, {
          qe: 4609,
          nmps: 29,
          nlps: 26,
          switchFlag: 0
        }, {
          qe: 4353,
          nmps: 30,
          nlps: 27,
          switchFlag: 0
        }, {
          qe: 2753,
          nmps: 31,
          nlps: 28,
          switchFlag: 0
        }, {
          qe: 2497,
          nmps: 32,
          nlps: 29,
          switchFlag: 0
        }, {
          qe: 2209,
          nmps: 33,
          nlps: 30,
          switchFlag: 0
        }, {
          qe: 1313,
          nmps: 34,
          nlps: 31,
          switchFlag: 0
        }, {
          qe: 1089,
          nmps: 35,
          nlps: 32,
          switchFlag: 0
        }, {
          qe: 673,
          nmps: 36,
          nlps: 33,
          switchFlag: 0
        }, {
          qe: 545,
          nmps: 37,
          nlps: 34,
          switchFlag: 0
        }, {
          qe: 321,
          nmps: 38,
          nlps: 35,
          switchFlag: 0
        }, {
          qe: 273,
          nmps: 39,
          nlps: 36,
          switchFlag: 0
        }, {
          qe: 133,
          nmps: 40,
          nlps: 37,
          switchFlag: 0
        }, {
          qe: 73,
          nmps: 41,
          nlps: 38,
          switchFlag: 0
        }, {
          qe: 37,
          nmps: 42,
          nlps: 39,
          switchFlag: 0
        }, {
          qe: 21,
          nmps: 43,
          nlps: 40,
          switchFlag: 0
        }, {
          qe: 9,
          nmps: 44,
          nlps: 41,
          switchFlag: 0
        }, {
          qe: 5,
          nmps: 45,
          nlps: 42,
          switchFlag: 0
        }, {
          qe: 1,
          nmps: 45,
          nlps: 43,
          switchFlag: 0
        }, {
          qe: 22017,
          nmps: 46,
          nlps: 46,
          switchFlag: 0
        }];
        class n {
          constructor(C, e, t) {
            this.data = C, this.bp = e, this.dataEnd = t, this.chigh = C[e], this.clow = 0, this.byteIn(), this.chigh = this.chigh << 7 & 65535 | this.clow >> 9 & 127, this.clow = this.clow << 7 & 65535, this.ct -= 7, this.a = 32768;
          }
          byteIn() {
            const C = this.data;
            let e = this.bp;
            C[e] === 255 ? C[e + 1] > 143 ? (this.clow += 65280, this.ct = 8) : (e++, this.clow += C[e] << 9, this.ct = 7, this.bp = e) : (e++, this.clow += e < this.dataEnd ? C[e] << 8 : 65280, this.ct = 8, this.bp = e), this.clow > 65535 && (this.chigh += this.clow >> 16, this.clow &= 65535);
          }
          readBit(C, e) {
            let t = C[e] >> 1, l = C[e] & 1;
            const j = V[t], U = j.qe;
            let O, v = this.a - U;
            if (this.chigh < U)
              v < U ? (v = U, O = l, t = j.nmps) : (v = U, O = 1 ^ l, j.switchFlag === 1 && (l = O), t = j.nlps);
            else {
              if (this.chigh -= U, v & 32768)
                return this.a = v, l;
              v < U ? (O = 1 ^ l, j.switchFlag === 1 && (l = O), t = j.nlps) : (O = l, t = j.nmps);
            }
            do
              this.ct === 0 && this.byteIn(), v <<= 1, this.chigh = this.chigh << 1 & 65535 | this.clow >> 15 & 1, this.clow = this.clow << 1 & 65535, this.ct--;
            while (!(v & 32768));
            return this.a = v, C[e] = t << 1 | l, O;
          }
        }
        w.ArithmeticDecoder = n;
      },
      /* 26 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.JpegStream = void 0;
        var n = V(18), F = V(4), C = V(27), e = V(2);
        class t extends n.DecodeStream {
          constructor(j, U, O) {
            let v;
            for (; (v = j.getByte()) !== -1; )
              if (v === 255) {
                j.skip(-1);
                break;
              }
            super(U), this.stream = j, this.dict = j.dict, this.maybeLength = U, this.params = O;
          }
          get bytes() {
            return (0, e.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
          }
          ensureBuffer(j) {
          }
          readBlock() {
            if (this.eof)
              return;
            const j = {
              decodeTransform: void 0,
              colorTransform: void 0
            }, U = this.dict.getArray("D", "Decode");
            if ((this.forceRGBA || this.forceRGB) && Array.isArray(U)) {
              const g = this.dict.get("BPC", "BitsPerComponent") || 8, b = U.length, i = new Int32Array(b);
              let P = !1;
              const d = (1 << g) - 1;
              for (let A = 0; A < b; A += 2)
                i[A] = (U[A + 1] - U[A]) * 256 | 0, i[A + 1] = U[A] * d | 0, (i[A] !== 256 || i[A + 1] !== 0) && (P = !0);
              P && (j.decodeTransform = i);
            }
            if (this.params instanceof F.Dict) {
              const g = this.params.get("ColorTransform");
              Number.isInteger(g) && (j.colorTransform = g);
            }
            const O = new C.JpegImage(j);
            O.parse(this.bytes);
            const v = O.getData({
              width: this.drawWidth,
              height: this.drawHeight,
              forceRGBA: this.forceRGBA,
              forceRGB: this.forceRGB,
              isSourcePDF: !0
            });
            this.buffer = v, this.bufferLength = v.length, this.eof = !0;
          }
        }
        w.JpegStream = t;
      },
      /* 27 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.JpegImage = void 0;
        var n = V(2), F = V(28), C = V(3);
        class e extends n.BaseException {
          constructor(c) {
            super(`JPEG error: ${c}`, "JpegError");
          }
        }
        class t extends n.BaseException {
          constructor(c, N) {
            super(c, "DNLMarkerError"), this.scanLines = N;
          }
        }
        class l extends n.BaseException {
          constructor(c) {
            super(c, "EOIMarkerError");
          }
        }
        const j = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), U = 4017, O = 799, v = 3406, g = 2276, b = 1567, i = 3784, P = 5793, d = 2896;
        function A(f, c) {
          let N = 0, u, p, S = 16;
          for (; S > 0 && !f[S - 1]; )
            S--;
          const B = [{
            children: [],
            index: 0
          }];
          let T = B[0], D;
          for (u = 0; u < S; u++) {
            for (p = 0; p < f[u]; p++) {
              for (T = B.pop(), T.children[T.index] = c[N]; T.index > 0; )
                T = B.pop();
              for (T.index++, B.push(T); B.length <= u; )
                B.push(D = {
                  children: [],
                  index: 0
                }), T.children[T.index] = D.children, T = D;
              N++;
            }
            u + 1 < S && (B.push(D = {
              children: [],
              index: 0
            }), T.children[T.index] = D.children, T = D);
          }
          return B[0].children;
        }
        function I(f, c, N) {
          return 64 * ((f.blocksPerLine + 1) * c + N);
        }
        function E(f, c, N, u, p, S, B, T, D, K = !1) {
          const _ = N.mcusPerLine, o = N.progressive, m = c;
          let s = 0, r = 0;
          function y() {
            if (r > 0)
              return r--, s >> r & 1;
            if (s = f[c++], s === 255) {
              const be = f[c++];
              if (be) {
                if (be === 220 && K) {
                  c += 2;
                  const me = (0, C.readUint16)(f, c);
                  if (c += 2, me > 0 && me !== N.scanLines)
                    throw new t("Found DNL marker (0xFFDC) while parsing scan data", me);
                } else if (be === 217) {
                  if (K) {
                    const me = Y * (N.precision === 8 ? 8 : 0);
                    if (me > 0 && Math.round(N.scanLines / me) >= 5)
                      throw new t("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter", me);
                  }
                  throw new l("Found EOI marker (0xFFD9) while parsing scan data");
                }
                throw new e(`unexpected marker ${(s << 8 | be).toString(16)}`);
              }
            }
            return r = 7, s >>> 7;
          }
          function M(be) {
            let me = be;
            for (; ; ) {
              switch (me = me[y()], typeof me) {
                case "number":
                  return me;
                case "object":
                  continue;
              }
              throw new e("invalid huffman sequence");
            }
          }
          function $(be) {
            let me = 0;
            for (; be > 0; )
              me = me << 1 | y(), be--;
            return me;
          }
          function G(be) {
            if (be === 1)
              return y() === 1 ? 1 : -1;
            const me = $(be);
            return me >= 1 << be - 1 ? me : me + (-1 << be) + 1;
          }
          function ce(be, me) {
            const we = M(be.huffmanTableDC), _e = we === 0 ? 0 : G(we);
            be.blockData[me] = be.pred += _e;
            let Se = 1;
            for (; Se < 64; ) {
              const Ae = M(be.huffmanTableAC), Te = Ae & 15, ke = Ae >> 4;
              if (Te === 0) {
                if (ke < 15)
                  break;
                Se += 16;
                continue;
              }
              Se += ke;
              const Ee = j[Se];
              be.blockData[me + Ee] = G(Te), Se++;
            }
          }
          function q(be, me) {
            const we = M(be.huffmanTableDC), _e = we === 0 ? 0 : G(we) << D;
            be.blockData[me] = be.pred += _e;
          }
          function re(be, me) {
            be.blockData[me] |= y() << D;
          }
          let Z = 0;
          function te(be, me) {
            if (Z > 0) {
              Z--;
              return;
            }
            let we = S;
            const _e = B;
            for (; we <= _e; ) {
              const Se = M(be.huffmanTableAC), Ae = Se & 15, Te = Se >> 4;
              if (Ae === 0) {
                if (Te < 15) {
                  Z = $(Te) + (1 << Te) - 1;
                  break;
                }
                we += 16;
                continue;
              }
              we += Te;
              const ke = j[we];
              be.blockData[me + ke] = G(Ae) * (1 << D), we++;
            }
          }
          let L = 0, X;
          function J(be, me) {
            let we = S;
            const _e = B;
            let Se = 0, Ae, Te;
            for (; we <= _e; ) {
              const ke = me + j[we], Ee = be.blockData[ke] < 0 ? -1 : 1;
              switch (L) {
                case 0:
                  if (Te = M(be.huffmanTableAC), Ae = Te & 15, Se = Te >> 4, Ae === 0)
                    Se < 15 ? (Z = $(Se) + (1 << Se), L = 4) : (Se = 16, L = 1);
                  else {
                    if (Ae !== 1)
                      throw new e("invalid ACn encoding");
                    X = G(Ae), L = Se ? 2 : 3;
                  }
                  continue;
                case 1:
                case 2:
                  be.blockData[ke] ? be.blockData[ke] += Ee * (y() << D) : (Se--, Se === 0 && (L = L === 2 ? 3 : 0));
                  break;
                case 3:
                  be.blockData[ke] ? be.blockData[ke] += Ee * (y() << D) : (be.blockData[ke] = X << D, L = 0);
                  break;
                case 4:
                  be.blockData[ke] && (be.blockData[ke] += Ee * (y() << D));
                  break;
              }
              we++;
            }
            L === 4 && (Z--, Z === 0 && (L = 0));
          }
          let Y = 0;
          function ae(be, me, we, _e, Se) {
            const Ae = we / _ | 0, Te = we % _;
            Y = Ae * be.v + _e;
            const ke = Te * be.h + Se, Ee = I(be, Y, ke);
            me(be, Ee);
          }
          function se(be, me, we) {
            Y = we / be.blocksPerLine | 0;
            const _e = we % be.blocksPerLine, Se = I(be, Y, _e);
            me(be, Se);
          }
          const Q = u.length;
          let z, ie, ne, W, oe, ue;
          o ? S === 0 ? ue = T === 0 ? q : re : ue = T === 0 ? te : J : ue = ce;
          let pe = 0, ve;
          const Ce = Q === 1 ? u[0].blocksPerLine * u[0].blocksPerColumn : _ * N.mcusPerColumn;
          let Fe, Pe;
          for (; pe <= Ce; ) {
            const be = p ? Math.min(Ce - pe, p) : Ce;
            if (be > 0) {
              for (ie = 0; ie < Q; ie++)
                u[ie].pred = 0;
              if (Z = 0, Q === 1)
                for (z = u[0], oe = 0; oe < be; oe++)
                  se(z, ue, pe), pe++;
              else
                for (oe = 0; oe < be; oe++) {
                  for (ie = 0; ie < Q; ie++)
                    for (z = u[ie], Fe = z.h, Pe = z.v, ne = 0; ne < Pe; ne++)
                      for (W = 0; W < Fe; W++)
                        ae(z, ue, pe, ne, W);
                  pe++;
                }
            }
            if (r = 0, ve = x(f, c), !ve)
              break;
            if (ve.invalid) {
              const me = be > 0 ? "unexpected" : "excessive";
              (0, n.warn)(`decodeScan - ${me} MCU data, current marker is: ${ve.invalid}`), c = ve.offset;
            }
            if (ve.marker >= 65488 && ve.marker <= 65495)
              c += 2;
            else
              break;
          }
          return c - m;
        }
        function k(f, c, N) {
          const u = f.quantizationTable, p = f.blockData;
          let S, B, T, D, K, _, o, m, s, r, y, M, $, G, ce, q, re;
          if (!u)
            throw new e("missing required Quantization Table.");
          for (let Z = 0; Z < 64; Z += 8) {
            if (s = p[c + Z], r = p[c + Z + 1], y = p[c + Z + 2], M = p[c + Z + 3], $ = p[c + Z + 4], G = p[c + Z + 5], ce = p[c + Z + 6], q = p[c + Z + 7], s *= u[Z], !(r | y | M | $ | G | ce | q)) {
              re = P * s + 512 >> 10, N[Z] = re, N[Z + 1] = re, N[Z + 2] = re, N[Z + 3] = re, N[Z + 4] = re, N[Z + 5] = re, N[Z + 6] = re, N[Z + 7] = re;
              continue;
            }
            r *= u[Z + 1], y *= u[Z + 2], M *= u[Z + 3], $ *= u[Z + 4], G *= u[Z + 5], ce *= u[Z + 6], q *= u[Z + 7], S = P * s + 128 >> 8, B = P * $ + 128 >> 8, T = y, D = ce, K = d * (r - q) + 128 >> 8, m = d * (r + q) + 128 >> 8, _ = M << 4, o = G << 4, S = S + B + 1 >> 1, B = S - B, re = T * i + D * b + 128 >> 8, T = T * b - D * i + 128 >> 8, D = re, K = K + o + 1 >> 1, o = K - o, m = m + _ + 1 >> 1, _ = m - _, S = S + D + 1 >> 1, D = S - D, B = B + T + 1 >> 1, T = B - T, re = K * g + m * v + 2048 >> 12, K = K * v - m * g + 2048 >> 12, m = re, re = _ * O + o * U + 2048 >> 12, _ = _ * U - o * O + 2048 >> 12, o = re, N[Z] = S + m, N[Z + 7] = S - m, N[Z + 1] = B + o, N[Z + 6] = B - o, N[Z + 2] = T + _, N[Z + 5] = T - _, N[Z + 3] = D + K, N[Z + 4] = D - K;
          }
          for (let Z = 0; Z < 8; ++Z) {
            if (s = N[Z], r = N[Z + 8], y = N[Z + 16], M = N[Z + 24], $ = N[Z + 32], G = N[Z + 40], ce = N[Z + 48], q = N[Z + 56], !(r | y | M | $ | G | ce | q)) {
              re = P * s + 8192 >> 14, re < -2040 ? re = 0 : re >= 2024 ? re = 255 : re = re + 2056 >> 4, p[c + Z] = re, p[c + Z + 8] = re, p[c + Z + 16] = re, p[c + Z + 24] = re, p[c + Z + 32] = re, p[c + Z + 40] = re, p[c + Z + 48] = re, p[c + Z + 56] = re;
              continue;
            }
            S = P * s + 2048 >> 12, B = P * $ + 2048 >> 12, T = y, D = ce, K = d * (r - q) + 2048 >> 12, m = d * (r + q) + 2048 >> 12, _ = M, o = G, S = (S + B + 1 >> 1) + 4112, B = S - B, re = T * i + D * b + 2048 >> 12, T = T * b - D * i + 2048 >> 12, D = re, K = K + o + 1 >> 1, o = K - o, m = m + _ + 1 >> 1, _ = m - _, S = S + D + 1 >> 1, D = S - D, B = B + T + 1 >> 1, T = B - T, re = K * g + m * v + 2048 >> 12, K = K * v - m * g + 2048 >> 12, m = re, re = _ * O + o * U + 2048 >> 12, _ = _ * U - o * O + 2048 >> 12, o = re, s = S + m, q = S - m, r = B + o, ce = B - o, y = T + _, G = T - _, M = D + K, $ = D - K, s < 16 ? s = 0 : s >= 4080 ? s = 255 : s >>= 4, r < 16 ? r = 0 : r >= 4080 ? r = 255 : r >>= 4, y < 16 ? y = 0 : y >= 4080 ? y = 255 : y >>= 4, M < 16 ? M = 0 : M >= 4080 ? M = 255 : M >>= 4, $ < 16 ? $ = 0 : $ >= 4080 ? $ = 255 : $ >>= 4, G < 16 ? G = 0 : G >= 4080 ? G = 255 : G >>= 4, ce < 16 ? ce = 0 : ce >= 4080 ? ce = 255 : ce >>= 4, q < 16 ? q = 0 : q >= 4080 ? q = 255 : q >>= 4, p[c + Z] = s, p[c + Z + 8] = r, p[c + Z + 16] = y, p[c + Z + 24] = M, p[c + Z + 32] = $, p[c + Z + 40] = G, p[c + Z + 48] = ce, p[c + Z + 56] = q;
          }
        }
        function H(f, c) {
          const N = c.blocksPerLine, u = c.blocksPerColumn, p = new Int16Array(64);
          for (let S = 0; S < u; S++)
            for (let B = 0; B < N; B++) {
              const T = I(c, S, B);
              k(c, T, p);
            }
          return c.blockData;
        }
        function x(f, c, N = c) {
          const u = f.length - 1;
          let p = N < c ? N : c;
          if (c >= u)
            return null;
          const S = (0, C.readUint16)(f, c);
          if (S >= 65472 && S <= 65534)
            return {
              invalid: null,
              marker: S,
              offset: c
            };
          let B = (0, C.readUint16)(f, p);
          for (; !(B >= 65472 && B <= 65534); ) {
            if (++p >= u)
              return null;
            B = (0, C.readUint16)(f, p);
          }
          return {
            invalid: S.toString(16),
            marker: B,
            offset: p
          };
        }
        class R {
          constructor({
            decodeTransform: c = null,
            colorTransform: N = -1
          } = {}) {
            this._decodeTransform = c, this._colorTransform = N;
          }
          parse(c, {
            dnlScanLines: N = null
          } = {}) {
            function u() {
              const y = (0, C.readUint16)(c, S);
              S += 2;
              let M = S + y - 2;
              const $ = x(c, M, S);
              $ != null && $.invalid && ((0, n.warn)("readDataBlock - incorrect length, current marker is: " + $.invalid), M = $.offset);
              const G = c.subarray(S, M);
              return S += G.length, G;
            }
            function p(y) {
              const M = Math.ceil(y.samplesPerLine / 8 / y.maxH), $ = Math.ceil(y.scanLines / 8 / y.maxV);
              for (const G of y.components) {
                const ce = Math.ceil(Math.ceil(y.samplesPerLine / 8) * G.h / y.maxH), q = Math.ceil(Math.ceil(y.scanLines / 8) * G.v / y.maxV), re = M * G.h, te = 64 * ($ * G.v) * (re + 1);
                G.blockData = new Int16Array(te), G.blocksPerLine = ce, G.blocksPerColumn = q;
              }
              y.mcusPerLine = M, y.mcusPerColumn = $;
            }
            let S = 0, B = null, T = null, D, K, _ = 0;
            const o = [], m = [], s = [];
            let r = (0, C.readUint16)(c, S);
            if (S += 2, r !== 65496)
              throw new e("SOI not found");
            r = (0, C.readUint16)(c, S), S += 2;
            e:
              for (; r !== 65497; ) {
                let y, M, $;
                switch (r) {
                  case 65504:
                  case 65505:
                  case 65506:
                  case 65507:
                  case 65508:
                  case 65509:
                  case 65510:
                  case 65511:
                  case 65512:
                  case 65513:
                  case 65514:
                  case 65515:
                  case 65516:
                  case 65517:
                  case 65518:
                  case 65519:
                  case 65534:
                    const G = u();
                    r === 65504 && G[0] === 74 && G[1] === 70 && G[2] === 73 && G[3] === 70 && G[4] === 0 && (B = {
                      version: {
                        major: G[5],
                        minor: G[6]
                      },
                      densityUnits: G[7],
                      xDensity: G[8] << 8 | G[9],
                      yDensity: G[10] << 8 | G[11],
                      thumbWidth: G[12],
                      thumbHeight: G[13],
                      thumbData: G.subarray(14, 14 + 3 * G[12] * G[13])
                    }), r === 65518 && G[0] === 65 && G[1] === 100 && G[2] === 111 && G[3] === 98 && G[4] === 101 && (T = {
                      version: G[5] << 8 | G[6],
                      flags0: G[7] << 8 | G[8],
                      flags1: G[9] << 8 | G[10],
                      transformCode: G[11]
                    });
                    break;
                  case 65499:
                    const ce = (0, C.readUint16)(c, S);
                    S += 2;
                    const q = ce + S - 2;
                    let re;
                    for (; S < q; ) {
                      const W = c[S++], oe = new Uint16Array(64);
                      if (W >> 4)
                        if (W >> 4 === 1)
                          for (M = 0; M < 64; M++)
                            re = j[M], oe[re] = (0, C.readUint16)(c, S), S += 2;
                        else
                          throw new e("DQT - invalid table spec");
                      else
                        for (M = 0; M < 64; M++)
                          re = j[M], oe[re] = c[S++];
                      o[W & 15] = oe;
                    }
                    break;
                  case 65472:
                  case 65473:
                  case 65474:
                    if (D)
                      throw new e("Only single frame JPEGs supported");
                    S += 2, D = {}, D.extended = r === 65473, D.progressive = r === 65474, D.precision = c[S++];
                    const Z = (0, C.readUint16)(c, S);
                    S += 2, D.scanLines = N || Z, D.samplesPerLine = (0, C.readUint16)(c, S), S += 2, D.components = [], D.componentIds = {};
                    const te = c[S++];
                    let L = 0, X = 0;
                    for (y = 0; y < te; y++) {
                      const W = c[S], oe = c[S + 1] >> 4, ue = c[S + 1] & 15;
                      L < oe && (L = oe), X < ue && (X = ue);
                      const pe = c[S + 2];
                      $ = D.components.push({
                        h: oe,
                        v: ue,
                        quantizationId: pe,
                        quantizationTable: null
                      }), D.componentIds[W] = $ - 1, S += 3;
                    }
                    D.maxH = L, D.maxV = X, p(D);
                    break;
                  case 65476:
                    const J = (0, C.readUint16)(c, S);
                    for (S += 2, y = 2; y < J; ) {
                      const W = c[S++], oe = new Uint8Array(16);
                      let ue = 0;
                      for (M = 0; M < 16; M++, S++)
                        ue += oe[M] = c[S];
                      const pe = new Uint8Array(ue);
                      for (M = 0; M < ue; M++, S++)
                        pe[M] = c[S];
                      y += 17 + ue, (W >> 4 ? m : s)[W & 15] = A(oe, pe);
                    }
                    break;
                  case 65501:
                    S += 2, K = (0, C.readUint16)(c, S), S += 2;
                    break;
                  case 65498:
                    const Y = ++_ === 1 && !N;
                    S += 2;
                    const ae = c[S++], se = [];
                    for (y = 0; y < ae; y++) {
                      const W = c[S++], oe = D.componentIds[W], ue = D.components[oe];
                      ue.index = W;
                      const pe = c[S++];
                      ue.huffmanTableDC = s[pe >> 4], ue.huffmanTableAC = m[pe & 15], se.push(ue);
                    }
                    const Q = c[S++], z = c[S++], ie = c[S++];
                    try {
                      const W = E(c, S, D, se, K, Q, z, ie >> 4, ie & 15, Y);
                      S += W;
                    } catch (W) {
                      if (W instanceof t)
                        return (0, n.warn)(`${W.message} -- attempting to re-parse the JPEG image.`), this.parse(c, {
                          dnlScanLines: W.scanLines
                        });
                      if (W instanceof l) {
                        (0, n.warn)(`${W.message} -- ignoring the rest of the image data.`);
                        break e;
                      }
                      throw W;
                    }
                    break;
                  case 65500:
                    S += 4;
                    break;
                  case 65535:
                    c[S] !== 255 && S--;
                    break;
                  default:
                    const ne = x(c, S - 2, S - 3);
                    if (ne != null && ne.invalid) {
                      (0, n.warn)("JpegImage.parse - unexpected data, current marker is: " + ne.invalid), S = ne.offset;
                      break;
                    }
                    if (!ne || S >= c.length - 1) {
                      (0, n.warn)("JpegImage.parse - reached the end of the image data without finding an EOI marker (0xFFD9).");
                      break e;
                    }
                    throw new e("JpegImage.parse - unknown marker: " + r.toString(16));
                }
                r = (0, C.readUint16)(c, S), S += 2;
              }
            this.width = D.samplesPerLine, this.height = D.scanLines, this.jfif = B, this.adobe = T, this.components = [];
            for (const y of D.components) {
              const M = o[y.quantizationId];
              M && (y.quantizationTable = M), this.components.push({
                index: y.index,
                output: H(D, y),
                scaleX: y.h / D.maxH,
                scaleY: y.v / D.maxV,
                blocksPerLine: y.blocksPerLine,
                blocksPerColumn: y.blocksPerColumn
              });
            }
            this.numComponents = this.components.length;
          }
          _getLinearizedBlockData(c, N, u = !1) {
            const p = this.width / c, S = this.height / N;
            let B, T, D, K, _, o, m, s, r, y, M = 0, $;
            const G = this.components.length, ce = c * N * G, q = new Uint8ClampedArray(ce), re = new Uint32Array(c), Z = 4294967288;
            let te;
            for (m = 0; m < G; m++) {
              if (B = this.components[m], T = B.scaleX * p, D = B.scaleY * S, M = m, $ = B.output, K = B.blocksPerLine + 1 << 3, T !== te) {
                for (_ = 0; _ < c; _++)
                  s = 0 | _ * T, re[_] = (s & Z) << 3 | s & 7;
                te = T;
              }
              for (o = 0; o < N; o++)
                for (s = 0 | o * D, y = K * (s & Z) | (s & 7) << 3, _ = 0; _ < c; _++)
                  q[M] = $[y + re[_]], M += G;
            }
            let L = this._decodeTransform;
            if (!u && G === 4 && !L && (L = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255])), L)
              for (m = 0; m < ce; )
                for (s = 0, r = 0; s < G; s++, m++, r += 2)
                  q[m] = (q[m] * L[r] >> 8) + L[r + 1];
            return q;
          }
          get _isColorConversionNeeded() {
            return this.adobe ? !!this.adobe.transformCode : this.numComponents === 3 ? this._colorTransform === 0 ? !1 : !(this.components[0].index === 82 && this.components[1].index === 71 && this.components[2].index === 66) : this._colorTransform === 1;
          }
          _convertYccToRgb(c) {
            let N, u, p;
            for (let S = 0, B = c.length; S < B; S += 3)
              N = c[S], u = c[S + 1], p = c[S + 2], c[S] = N - 179.456 + 1.402 * p, c[S + 1] = N + 135.459 - 0.344 * u - 0.714 * p, c[S + 2] = N - 226.816 + 1.772 * u;
            return c;
          }
          _convertYccToRgba(c, N) {
            for (let u = 0, p = 0, S = c.length; u < S; u += 3, p += 4) {
              const B = c[u], T = c[u + 1], D = c[u + 2];
              N[p] = B - 179.456 + 1.402 * D, N[p + 1] = B + 135.459 - 0.344 * T - 0.714 * D, N[p + 2] = B - 226.816 + 1.772 * T, N[p + 3] = 255;
            }
            return N;
          }
          _convertYcckToRgb(c) {
            let N, u, p, S, B = 0;
            for (let T = 0, D = c.length; T < D; T += 4)
              N = c[T], u = c[T + 1], p = c[T + 2], S = c[T + 3], c[B++] = -122.67195406894 + u * (-660635669420364e-19 * u + 437130475926232e-18 * p - 54080610064599e-18 * N + 48449797120281e-17 * S - 0.154362151871126) + p * (-957964378445773e-18 * p + 817076911346625e-18 * N - 0.00477271405408747 * S + 1.53380253221734) + N * (961250184130688e-18 * N - 0.00266257332283933 * S + 0.48357088451265) + S * (-336197177618394e-18 * S + 0.484791561490776), c[B++] = 107.268039397724 + u * (219927104525741e-19 * u - 640992018297945e-18 * p + 659397001245577e-18 * N + 426105652938837e-18 * S - 0.176491792462875) + p * (-778269941513683e-18 * p + 0.00130872261408275 * N + 770482631801132e-18 * S - 0.151051492775562) + N * (0.00126935368114843 * N - 0.00265090189010898 * S + 0.25802910206845) + S * (-318913117588328e-18 * S - 0.213742400323665), c[B++] = -20.810012546947 + u * (-570115196973677e-18 * u - 263409051004589e-19 * p + 0.0020741088115012 * N - 0.00288260236853442 * S + 0.814272968359295) + p * (-153496057440975e-19 * p - 132689043961446e-18 * N + 560833691242812e-18 * S - 0.195152027534049) + N * (0.00174418132927582 * N - 0.00255243321439347 * S + 0.116935020465145) + S * (-343531996510555e-18 * S + 0.24165260232407);
            return c.subarray(0, B);
          }
          _convertYcckToRgba(c) {
            for (let N = 0, u = c.length; N < u; N += 4) {
              const p = c[N], S = c[N + 1], B = c[N + 2], T = c[N + 3];
              c[N] = -122.67195406894 + S * (-660635669420364e-19 * S + 437130475926232e-18 * B - 54080610064599e-18 * p + 48449797120281e-17 * T - 0.154362151871126) + B * (-957964378445773e-18 * B + 817076911346625e-18 * p - 0.00477271405408747 * T + 1.53380253221734) + p * (961250184130688e-18 * p - 0.00266257332283933 * T + 0.48357088451265) + T * (-336197177618394e-18 * T + 0.484791561490776), c[N + 1] = 107.268039397724 + S * (219927104525741e-19 * S - 640992018297945e-18 * B + 659397001245577e-18 * p + 426105652938837e-18 * T - 0.176491792462875) + B * (-778269941513683e-18 * B + 0.00130872261408275 * p + 770482631801132e-18 * T - 0.151051492775562) + p * (0.00126935368114843 * p - 0.00265090189010898 * T + 0.25802910206845) + T * (-318913117588328e-18 * T - 0.213742400323665), c[N + 2] = -20.810012546947 + S * (-570115196973677e-18 * S - 263409051004589e-19 * B + 0.0020741088115012 * p - 0.00288260236853442 * T + 0.814272968359295) + B * (-153496057440975e-19 * B - 132689043961446e-18 * p + 560833691242812e-18 * T - 0.195152027534049) + p * (0.00174418132927582 * p - 0.00255243321439347 * T + 0.116935020465145) + T * (-343531996510555e-18 * T + 0.24165260232407), c[N + 3] = 255;
            }
            return c;
          }
          _convertYcckToCmyk(c) {
            let N, u, p;
            for (let S = 0, B = c.length; S < B; S += 4)
              N = c[S], u = c[S + 1], p = c[S + 2], c[S] = 434.456 - N - 1.402 * p, c[S + 1] = 119.541 - N + 0.344 * u + 0.714 * p, c[S + 2] = 481.816 - N - 1.772 * u;
            return c;
          }
          _convertCmykToRgb(c) {
            let N, u, p, S, B = 0;
            for (let T = 0, D = c.length; T < D; T += 4)
              N = c[T], u = c[T + 1], p = c[T + 2], S = c[T + 3], c[B++] = 255 + N * (-6747147073602441e-20 * N + 8379262121013727e-19 * u + 2894718188643294e-19 * p + 0.003264231057537806 * S - 1.1185611867203937) + u * (26374107616089405e-21 * u - 8626949158638572e-20 * p - 2748769067499491e-19 * S - 0.02155688794978967) + p * (-3878099212869363e-20 * p - 3267808279485286e-19 * S + 0.0686742238595345) - S * (3361971776183937e-19 * S + 0.7430659151342254), c[B++] = 255 + N * (13596372813588848e-20 * N + 924537132573585e-18 * u + 10567359618683593e-20 * p + 4791864687436512e-19 * S - 0.3109689587515875) + u * (-23545346108370344e-20 * u + 2702845253534714e-19 * p + 0.0020200308977307156 * S - 0.7488052167015494) + p * (6834815998235662e-20 * p + 15168452363460973e-20 * S - 0.09751927774728933) - S * (3189131175883281e-19 * S + 0.7364883807733168), c[B++] = 255 + N * (13598650411385307e-21 * N + 12423956175490851e-20 * u + 4751985097583589e-19 * p - 36729317476630422e-22 * S - 0.05562186980264034) + u * (16141380598724676e-20 * u + 9692239130725186e-19 * p + 7782692450036253e-19 * S - 0.44015232367526463) + p * (5068882914068769e-22 * p + 0.0017778369011375071 * S - 0.7591454649749609) - S * (3435319965105553e-19 * S + 0.7063770186160144);
            return c.subarray(0, B);
          }
          _convertCmykToRgba(c) {
            for (let N = 0, u = c.length; N < u; N += 4) {
              const p = c[N], S = c[N + 1], B = c[N + 2], T = c[N + 3];
              c[N] = 255 + p * (-6747147073602441e-20 * p + 8379262121013727e-19 * S + 2894718188643294e-19 * B + 0.003264231057537806 * T - 1.1185611867203937) + S * (26374107616089405e-21 * S - 8626949158638572e-20 * B - 2748769067499491e-19 * T - 0.02155688794978967) + B * (-3878099212869363e-20 * B - 3267808279485286e-19 * T + 0.0686742238595345) - T * (3361971776183937e-19 * T + 0.7430659151342254), c[N + 1] = 255 + p * (13596372813588848e-20 * p + 924537132573585e-18 * S + 10567359618683593e-20 * B + 4791864687436512e-19 * T - 0.3109689587515875) + S * (-23545346108370344e-20 * S + 2702845253534714e-19 * B + 0.0020200308977307156 * T - 0.7488052167015494) + B * (6834815998235662e-20 * B + 15168452363460973e-20 * T - 0.09751927774728933) - T * (3189131175883281e-19 * T + 0.7364883807733168), c[N + 2] = 255 + p * (13598650411385307e-21 * p + 12423956175490851e-20 * S + 4751985097583589e-19 * B - 36729317476630422e-22 * T - 0.05562186980264034) + S * (16141380598724676e-20 * S + 9692239130725186e-19 * B + 7782692450036253e-19 * T - 0.44015232367526463) + B * (5068882914068769e-22 * B + 0.0017778369011375071 * T - 0.7591454649749609) - T * (3435319965105553e-19 * T + 0.7063770186160144), c[N + 3] = 255;
            }
            return c;
          }
          getData({
            width: c,
            height: N,
            forceRGBA: u = !1,
            forceRGB: p = !1,
            isSourcePDF: S = !1
          }) {
            if (this.numComponents > 4)
              throw new e("Unsupported color mode");
            const B = this._getLinearizedBlockData(c, N, S);
            if (this.numComponents === 1 && (u || p)) {
              const T = B.length * (u ? 4 : 3), D = new Uint8ClampedArray(T);
              let K = 0;
              if (u)
                (0, F.grayToRGBA)(B, new Uint32Array(D.buffer));
              else
                for (const _ of B)
                  D[K++] = _, D[K++] = _, D[K++] = _;
              return D;
            } else if (this.numComponents === 3 && this._isColorConversionNeeded) {
              if (u) {
                const T = new Uint8ClampedArray(B.length / 3 * 4);
                return this._convertYccToRgba(B, T);
              }
              return this._convertYccToRgb(B);
            } else if (this.numComponents === 4) {
              if (this._isColorConversionNeeded)
                return u ? this._convertYcckToRgba(B) : p ? this._convertYcckToRgb(B) : this._convertYcckToCmyk(B);
              if (u)
                return this._convertCmykToRgba(B);
              if (p)
                return this._convertCmykToRgb(B);
            }
            return B;
          }
        }
        w.JpegImage = R;
      },
      /* 28 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.convertBlackAndWhiteToRGBA = C, w.convertToRGBA = F, w.grayToRGBA = t;
        var n = V(2);
        function F(l) {
          switch (l.kind) {
            case n.ImageKind.GRAYSCALE_1BPP:
              return C(l);
            case n.ImageKind.RGB_24BPP:
              return e(l);
          }
          return null;
        }
        function C({
          src: l,
          srcPos: j = 0,
          dest: U,
          width: O,
          height: v,
          nonBlackColor: g = 4294967295,
          inverseDecode: b = !1
        }) {
          const i = n.FeatureTest.isLittleEndian ? 4278190080 : 255, [P, d] = b ? [g, i] : [i, g], A = O >> 3, I = O & 7, E = l.length;
          U = new Uint32Array(U.buffer);
          let k = 0;
          for (let H = 0; H < v; H++) {
            for (const R = j + A; j < R; j++) {
              const f = j < E ? l[j] : 255;
              U[k++] = f & 128 ? d : P, U[k++] = f & 64 ? d : P, U[k++] = f & 32 ? d : P, U[k++] = f & 16 ? d : P, U[k++] = f & 8 ? d : P, U[k++] = f & 4 ? d : P, U[k++] = f & 2 ? d : P, U[k++] = f & 1 ? d : P;
            }
            if (I === 0)
              continue;
            const x = j < E ? l[j++] : 255;
            for (let R = 0; R < I; R++)
              U[k++] = x & 1 << 7 - R ? d : P;
          }
          return {
            srcPos: j,
            destPos: k
          };
        }
        function e({
          src: l,
          srcPos: j = 0,
          dest: U,
          destPos: O = 0,
          width: v,
          height: g
        }) {
          let b = 0;
          const i = l.length >> 2, P = new Uint32Array(l.buffer, j, i);
          if (n.FeatureTest.isLittleEndian) {
            for (; b < i - 2; b += 3, O += 4) {
              const d = P[b], A = P[b + 1], I = P[b + 2];
              U[O] = d | 4278190080, U[O + 1] = d >>> 24 | A << 8 | 4278190080, U[O + 2] = A >>> 16 | I << 16 | 4278190080, U[O + 3] = I >>> 8 | 4278190080;
            }
            for (let d = b * 4, A = l.length; d < A; d += 3)
              U[O++] = l[d] | l[d + 1] << 8 | l[d + 2] << 16 | 4278190080;
          } else {
            for (; b < i - 2; b += 3, O += 4) {
              const d = P[b], A = P[b + 1], I = P[b + 2];
              U[O] = d | 255, U[O + 1] = d << 24 | A >>> 8 | 255, U[O + 2] = A << 16 | I >>> 16 | 255, U[O + 3] = I << 8 | 255;
            }
            for (let d = b * 4, A = l.length; d < A; d += 3)
              U[O++] = l[d] << 24 | l[d + 1] << 16 | l[d + 2] << 8 | 255;
          }
          return {
            srcPos: j,
            destPos: O
          };
        }
        function t(l, j) {
          if (n.FeatureTest.isLittleEndian)
            for (let U = 0, O = l.length; U < O; U++)
              j[U] = l[U] * 65793 | 4278190080;
          else
            for (let U = 0, O = l.length; U < O; U++)
              j[U] = l[U] * 16843008 | 255;
        }
      },
      /* 29 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.JpxStream = void 0;
        var n = V(18), F = V(30), C = V(2);
        class e extends n.DecodeStream {
          constructor(l, j, U) {
            super(j), this.stream = l, this.dict = l.dict, this.maybeLength = j, this.params = U;
          }
          get bytes() {
            return (0, C.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
          }
          ensureBuffer(l) {
          }
          readBlock() {
            if (this.eof)
              return;
            const l = new F.JpxImage();
            l.parse(this.bytes);
            const j = l.width, U = l.height, O = l.componentsCount, v = l.tiles.length;
            if (v === 1)
              this.buffer = l.tiles[0].items;
            else {
              const g = new Uint8ClampedArray(j * U * O);
              for (let b = 0; b < v; b++) {
                const i = l.tiles[b], P = i.width, d = i.height, A = i.left, I = i.top, E = i.items;
                let k = 0, H = (j * I + A) * O;
                const x = j * O, R = P * O;
                for (let f = 0; f < d; f++) {
                  const c = E.subarray(k, k + R);
                  g.set(c, H), k += R, H += x;
                }
              }
              this.buffer = g;
            }
            this.bufferLength = this.buffer.length, this.eof = !0;
          }
        }
        w.JpxStream = e;
      },
      /* 30 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.JpxImage = void 0;
        var n = V(2), F = V(3), C = V(25);
        class e extends n.BaseException {
          constructor(o) {
            super(`JPX error: ${o}`, "JpxError");
          }
        }
        const t = {
          LL: 0,
          LH: 1,
          HL: 1,
          HH: 2
        };
        class l {
          constructor() {
            this.failOnCorruptedImage = !1;
          }
          parse(o) {
            if ((0, F.readUint16)(o, 0) === 65359) {
              this.parseCodestream(o, 0, o.length);
              return;
            }
            const s = o.length;
            let r = 0;
            for (; r < s; ) {
              let y = 8, M = (0, F.readUint32)(o, r);
              const $ = (0, F.readUint32)(o, r + 4);
              if (r += y, M === 1 && (M = (0, F.readUint32)(o, r) * 4294967296 + (0, F.readUint32)(o, r + 4), r += 8, y += 8), M === 0 && (M = s - r + y), M < y)
                throw new e("Invalid box field size");
              const G = M - y;
              let ce = !0;
              switch ($) {
                case 1785737832:
                  ce = !1;
                  break;
                case 1668246642:
                  const q = o[r];
                  if (q === 1) {
                    const Z = (0, F.readUint32)(o, r + 3);
                    switch (Z) {
                      case 16:
                      case 17:
                      case 18:
                        break;
                      default:
                        (0, n.warn)("Unknown colorspace " + Z);
                        break;
                    }
                  } else
                    q === 2 && (0, n.info)("ICC profile not supported");
                  break;
                case 1785737827:
                  this.parseCodestream(o, r, r + G);
                  break;
                case 1783636e3:
                  (0, F.readUint32)(o, r) !== 218793738 && (0, n.warn)("Invalid JP2 signature");
                  break;
                case 1783634458:
                case 1718909296:
                case 1920099697:
                case 1919251232:
                case 1768449138:
                  break;
                default:
                  const re = String.fromCharCode($ >> 24 & 255, $ >> 16 & 255, $ >> 8 & 255, $ & 255);
                  (0, n.warn)(`Unsupported header type ${$} (${re}).`);
                  break;
              }
              ce && (r += G);
            }
          }
          parseImageProperties(o) {
            let m = o.getByte();
            for (; m >= 0; ) {
              const s = m;
              if (m = o.getByte(), (s << 8 | m) === 65361) {
                o.skip(4);
                const y = o.getInt32() >>> 0, M = o.getInt32() >>> 0, $ = o.getInt32() >>> 0, G = o.getInt32() >>> 0;
                o.skip(16);
                const ce = o.getUint16();
                this.width = y - $, this.height = M - G, this.componentsCount = ce, this.bitsPerComponent = 8;
                return;
              }
            }
            throw new e("No size marker found in JPX stream");
          }
          parseCodestream(o, m, s) {
            const r = {};
            let y = !1;
            try {
              let M = m;
              for (; M + 1 < s; ) {
                const $ = (0, F.readUint16)(o, M);
                M += 2;
                let G = 0, ce, q, re, Z, te, L;
                switch ($) {
                  case 65359:
                    r.mainHeader = !0;
                    break;
                  case 65497:
                    break;
                  case 65361:
                    G = (0, F.readUint16)(o, M);
                    const X = {};
                    X.Xsiz = (0, F.readUint32)(o, M + 4), X.Ysiz = (0, F.readUint32)(o, M + 8), X.XOsiz = (0, F.readUint32)(o, M + 12), X.YOsiz = (0, F.readUint32)(o, M + 16), X.XTsiz = (0, F.readUint32)(o, M + 20), X.YTsiz = (0, F.readUint32)(o, M + 24), X.XTOsiz = (0, F.readUint32)(o, M + 28), X.YTOsiz = (0, F.readUint32)(o, M + 32);
                    const J = (0, F.readUint16)(o, M + 36);
                    X.Csiz = J;
                    const Y = [];
                    ce = M + 38;
                    for (let oe = 0; oe < J; oe++) {
                      const ue = {
                        precision: (o[ce] & 127) + 1,
                        isSigned: !!(o[ce] & 128),
                        XRsiz: o[ce + 1],
                        YRsiz: o[ce + 2]
                      };
                      ce += 3, j(ue, X), Y.push(ue);
                    }
                    r.SIZ = X, r.components = Y, U(r, Y), r.QCC = [], r.COC = [];
                    break;
                  case 65372:
                    G = (0, F.readUint16)(o, M);
                    const ae = {};
                    switch (ce = M + 2, q = o[ce++], q & 31) {
                      case 0:
                        Z = 8, te = !0;
                        break;
                      case 1:
                        Z = 16, te = !1;
                        break;
                      case 2:
                        Z = 16, te = !0;
                        break;
                      default:
                        throw new Error("Invalid SQcd value " + q);
                    }
                    for (ae.noQuantization = Z === 8, ae.scalarExpounded = te, ae.guardBits = q >> 5, re = []; ce < G + M; ) {
                      const oe = {};
                      Z === 8 ? (oe.epsilon = o[ce++] >> 3, oe.mu = 0) : (oe.epsilon = o[ce] >> 3, oe.mu = (o[ce] & 7) << 8 | o[ce + 1], ce += 2), re.push(oe);
                    }
                    ae.SPqcds = re, r.mainHeader ? r.QCD = ae : (r.currentTile.QCD = ae, r.currentTile.QCC = []);
                    break;
                  case 65373:
                    G = (0, F.readUint16)(o, M);
                    const se = {};
                    ce = M + 2;
                    let Q;
                    switch (r.SIZ.Csiz < 257 ? Q = o[ce++] : (Q = (0, F.readUint16)(o, ce), ce += 2), q = o[ce++], q & 31) {
                      case 0:
                        Z = 8, te = !0;
                        break;
                      case 1:
                        Z = 16, te = !1;
                        break;
                      case 2:
                        Z = 16, te = !0;
                        break;
                      default:
                        throw new Error("Invalid SQcd value " + q);
                    }
                    for (se.noQuantization = Z === 8, se.scalarExpounded = te, se.guardBits = q >> 5, re = []; ce < G + M; ) {
                      const oe = {};
                      Z === 8 ? (oe.epsilon = o[ce++] >> 3, oe.mu = 0) : (oe.epsilon = o[ce] >> 3, oe.mu = (o[ce] & 7) << 8 | o[ce + 1], ce += 2), re.push(oe);
                    }
                    se.SPqcds = re, r.mainHeader ? r.QCC[Q] = se : r.currentTile.QCC[Q] = se;
                    break;
                  case 65362:
                    G = (0, F.readUint16)(o, M);
                    const z = {};
                    ce = M + 2;
                    const ie = o[ce++];
                    z.entropyCoderWithCustomPrecincts = !!(ie & 1), z.sopMarkerUsed = !!(ie & 2), z.ephMarkerUsed = !!(ie & 4), z.progressionOrder = o[ce++], z.layersCount = (0, F.readUint16)(o, ce), ce += 2, z.multipleComponentTransform = o[ce++], z.decompositionLevelsCount = o[ce++], z.xcb = (o[ce++] & 15) + 2, z.ycb = (o[ce++] & 15) + 2;
                    const ne = o[ce++];
                    if (z.selectiveArithmeticCodingBypass = !!(ne & 1), z.resetContextProbabilities = !!(ne & 2), z.terminationOnEachCodingPass = !!(ne & 4), z.verticallyStripe = !!(ne & 8), z.predictableTermination = !!(ne & 16), z.segmentationSymbolUsed = !!(ne & 32), z.reversibleTransformation = o[ce++], z.entropyCoderWithCustomPrecincts) {
                      const oe = [];
                      for (; ce < G + M; ) {
                        const ue = o[ce++];
                        oe.push({
                          PPx: ue & 15,
                          PPy: ue >> 4
                        });
                      }
                      z.precinctsSizes = oe;
                    }
                    const W = [];
                    z.selectiveArithmeticCodingBypass && W.push("selectiveArithmeticCodingBypass"), z.terminationOnEachCodingPass && W.push("terminationOnEachCodingPass"), z.verticallyStripe && W.push("verticallyStripe"), z.predictableTermination && W.push("predictableTermination"), W.length > 0 && (y = !0, (0, n.warn)(`JPX: Unsupported COD options (${W.join(", ")}).`)), r.mainHeader ? r.COD = z : (r.currentTile.COD = z, r.currentTile.COC = []);
                    break;
                  case 65424:
                    G = (0, F.readUint16)(o, M), L = {}, L.index = (0, F.readUint16)(o, M + 2), L.length = (0, F.readUint32)(o, M + 4), L.dataEnd = L.length + M - 2, L.partIndex = o[M + 8], L.partsCount = o[M + 9], r.mainHeader = !1, L.partIndex === 0 && (L.COD = r.COD, L.COC = r.COC.slice(0), L.QCD = r.QCD, L.QCC = r.QCC.slice(0)), r.currentTile = L;
                    break;
                  case 65427:
                    L = r.currentTile, L.partIndex === 0 && (N(r, L.index), H(r)), G = L.dataEnd - M, x(r, o, M, G);
                    break;
                  case 65363:
                    (0, n.warn)("JPX: Codestream code 0xFF53 (COC) is not implemented.");
                  case 65365:
                  case 65367:
                  case 65368:
                  case 65380:
                    G = (0, F.readUint16)(o, M);
                    break;
                  default:
                    throw new Error("Unknown codestream code: " + $.toString(16));
                }
                M += G;
              }
            } catch (M) {
              if (y || this.failOnCorruptedImage)
                throw new e(M.message);
              (0, n.warn)(`JPX: Trying to recover from: "${M.message}".`);
            }
            this.tiles = c(r), this.width = r.SIZ.Xsiz - r.SIZ.XOsiz, this.height = r.SIZ.Ysiz - r.SIZ.YOsiz, this.componentsCount = r.SIZ.Csiz;
          }
        }
        w.JpxImage = l;
        function j(_, o) {
          _.x0 = Math.ceil(o.XOsiz / _.XRsiz), _.x1 = Math.ceil(o.Xsiz / _.XRsiz), _.y0 = Math.ceil(o.YOsiz / _.YRsiz), _.y1 = Math.ceil(o.Ysiz / _.YRsiz), _.width = _.x1 - _.x0, _.height = _.y1 - _.y0;
        }
        function U(_, o) {
          const m = _.SIZ, s = [];
          let r;
          const y = Math.ceil((m.Xsiz - m.XTOsiz) / m.XTsiz), M = Math.ceil((m.Ysiz - m.YTOsiz) / m.YTsiz);
          for (let G = 0; G < M; G++)
            for (let ce = 0; ce < y; ce++)
              r = {}, r.tx0 = Math.max(m.XTOsiz + ce * m.XTsiz, m.XOsiz), r.ty0 = Math.max(m.YTOsiz + G * m.YTsiz, m.YOsiz), r.tx1 = Math.min(m.XTOsiz + (ce + 1) * m.XTsiz, m.Xsiz), r.ty1 = Math.min(m.YTOsiz + (G + 1) * m.YTsiz, m.Ysiz), r.width = r.tx1 - r.tx0, r.height = r.ty1 - r.ty0, r.components = [], s.push(r);
          _.tiles = s;
          const $ = m.Csiz;
          for (let G = 0, ce = $; G < ce; G++) {
            const q = o[G];
            for (let re = 0, Z = s.length; re < Z; re++) {
              const te = {};
              r = s[re], te.tcx0 = Math.ceil(r.tx0 / q.XRsiz), te.tcy0 = Math.ceil(r.ty0 / q.YRsiz), te.tcx1 = Math.ceil(r.tx1 / q.XRsiz), te.tcy1 = Math.ceil(r.ty1 / q.YRsiz), te.width = te.tcx1 - te.tcx0, te.height = te.tcy1 - te.tcy0, r.components[G] = te;
            }
          }
        }
        function O(_, o, m) {
          const s = o.codingStyleParameters, r = {};
          return s.entropyCoderWithCustomPrecincts ? (r.PPx = s.precinctsSizes[m].PPx, r.PPy = s.precinctsSizes[m].PPy) : (r.PPx = 15, r.PPy = 15), r.xcb_ = m > 0 ? Math.min(s.xcb, r.PPx - 1) : Math.min(s.xcb, r.PPx), r.ycb_ = m > 0 ? Math.min(s.ycb, r.PPy - 1) : Math.min(s.ycb, r.PPy), r;
        }
        function v(_, o, m) {
          const s = 1 << m.PPx, r = 1 << m.PPy, y = o.resLevel === 0, M = 1 << m.PPx + (y ? 0 : -1), $ = 1 << m.PPy + (y ? 0 : -1), G = o.trx1 > o.trx0 ? Math.ceil(o.trx1 / s) - Math.floor(o.trx0 / s) : 0, ce = o.try1 > o.try0 ? Math.ceil(o.try1 / r) - Math.floor(o.try0 / r) : 0, q = G * ce;
          o.precinctParameters = {
            precinctWidth: s,
            precinctHeight: r,
            numprecinctswide: G,
            numprecinctshigh: ce,
            numprecincts: q,
            precinctWidthInSubband: M,
            precinctHeightInSubband: $
          };
        }
        function g(_, o, m) {
          const s = m.xcb_, r = m.ycb_, y = 1 << s, M = 1 << r, $ = o.tbx0 >> s, G = o.tby0 >> r, ce = o.tbx1 + y - 1 >> s, q = o.tby1 + M - 1 >> r, re = o.resolution.precinctParameters, Z = [], te = [];
          let L, X, J, Y;
          for (X = G; X < q; X++)
            for (L = $; L < ce; L++) {
              J = {
                cbx: L,
                cby: X,
                tbx0: y * L,
                tby0: M * X,
                tbx1: y * (L + 1),
                tby1: M * (X + 1)
              }, J.tbx0_ = Math.max(o.tbx0, J.tbx0), J.tby0_ = Math.max(o.tby0, J.tby0), J.tbx1_ = Math.min(o.tbx1, J.tbx1), J.tby1_ = Math.min(o.tby1, J.tby1);
              const ae = Math.floor((J.tbx0_ - o.tbx0) / re.precinctWidthInSubband), se = Math.floor((J.tby0_ - o.tby0) / re.precinctHeightInSubband);
              if (Y = ae + se * re.numprecinctswide, J.precinctNumber = Y, J.subbandType = o.type, J.Lblock = 3, J.tbx1_ <= J.tbx0_ || J.tby1_ <= J.tby0_)
                continue;
              Z.push(J);
              let Q = te[Y];
              Q !== void 0 ? (L < Q.cbxMin ? Q.cbxMin = L : L > Q.cbxMax && (Q.cbxMax = L), X < Q.cbyMin ? Q.cbxMin = X : X > Q.cbyMax && (Q.cbyMax = X)) : te[Y] = Q = {
                cbxMin: L,
                cbyMin: X,
                cbxMax: L,
                cbyMax: X
              }, J.precinct = Q;
            }
          o.codeblockParameters = {
            codeblockWidth: s,
            codeblockHeight: r,
            numcodeblockwide: ce - $ + 1,
            numcodeblockhigh: q - G + 1
          }, o.codeblocks = Z, o.precincts = te;
        }
        function b(_, o, m) {
          const s = [], r = _.subbands;
          for (let y = 0, M = r.length; y < M; y++) {
            const G = r[y].codeblocks;
            for (let ce = 0, q = G.length; ce < q; ce++) {
              const re = G[ce];
              re.precinctNumber === o && s.push(re);
            }
          }
          return {
            layerNumber: m,
            codeblocks: s
          };
        }
        function i(_) {
          const o = _.SIZ, m = _.currentTile.index, s = _.tiles[m], r = s.codingStyleDefaultParameters.layersCount, y = o.Csiz;
          let M = 0;
          for (let re = 0; re < y; re++)
            M = Math.max(M, s.components[re].codingStyleParameters.decompositionLevelsCount);
          let $ = 0, G = 0, ce = 0, q = 0;
          this.nextPacket = function() {
            for (; $ < r; $++) {
              for (; G <= M; G++) {
                for (; ce < y; ce++) {
                  const Z = s.components[ce];
                  if (G > Z.codingStyleParameters.decompositionLevelsCount)
                    continue;
                  const te = Z.resolutions[G], L = te.precinctParameters.numprecincts;
                  for (; q < L; ) {
                    const X = b(te, q, $);
                    return q++, X;
                  }
                  q = 0;
                }
                ce = 0;
              }
              G = 0;
            }
            throw new e("Out of packets");
          };
        }
        function P(_) {
          const o = _.SIZ, m = _.currentTile.index, s = _.tiles[m], r = s.codingStyleDefaultParameters.layersCount, y = o.Csiz;
          let M = 0;
          for (let re = 0; re < y; re++)
            M = Math.max(M, s.components[re].codingStyleParameters.decompositionLevelsCount);
          let $ = 0, G = 0, ce = 0, q = 0;
          this.nextPacket = function() {
            for (; $ <= M; $++) {
              for (; G < r; G++) {
                for (; ce < y; ce++) {
                  const Z = s.components[ce];
                  if ($ > Z.codingStyleParameters.decompositionLevelsCount)
                    continue;
                  const te = Z.resolutions[$], L = te.precinctParameters.numprecincts;
                  for (; q < L; ) {
                    const X = b(te, q, G);
                    return q++, X;
                  }
                  q = 0;
                }
                ce = 0;
              }
              G = 0;
            }
            throw new e("Out of packets");
          };
        }
        function d(_) {
          const o = _.SIZ, m = _.currentTile.index, s = _.tiles[m], r = s.codingStyleDefaultParameters.layersCount, y = o.Csiz;
          let M, $, G, ce, q = 0;
          for (G = 0; G < y; G++) {
            const Z = s.components[G];
            q = Math.max(q, Z.codingStyleParameters.decompositionLevelsCount);
          }
          const re = new Int32Array(q + 1);
          for ($ = 0; $ <= q; ++$) {
            let Z = 0;
            for (G = 0; G < y; ++G) {
              const te = s.components[G].resolutions;
              $ < te.length && (Z = Math.max(Z, te[$].precinctParameters.numprecincts));
            }
            re[$] = Z;
          }
          M = 0, $ = 0, G = 0, ce = 0, this.nextPacket = function() {
            for (; $ <= q; $++) {
              for (; ce < re[$]; ce++) {
                for (; G < y; G++) {
                  const te = s.components[G];
                  if ($ > te.codingStyleParameters.decompositionLevelsCount)
                    continue;
                  const L = te.resolutions[$], X = L.precinctParameters.numprecincts;
                  if (!(ce >= X)) {
                    for (; M < r; ) {
                      const J = b(L, ce, M);
                      return M++, J;
                    }
                    M = 0;
                  }
                }
                G = 0;
              }
              ce = 0;
            }
            throw new e("Out of packets");
          };
        }
        function A(_) {
          const o = _.SIZ, m = _.currentTile.index, s = _.tiles[m], r = s.codingStyleDefaultParameters.layersCount, y = o.Csiz, M = k(s), $ = M;
          let G = 0, ce = 0, q = 0, re = 0, Z = 0;
          this.nextPacket = function() {
            for (; Z < $.maxNumHigh; Z++) {
              for (; re < $.maxNumWide; re++) {
                for (; q < y; q++) {
                  const L = s.components[q], X = L.codingStyleParameters.decompositionLevelsCount;
                  for (; ce <= X; ce++) {
                    const J = L.resolutions[ce], Y = M.components[q].resolutions[ce], ae = E(re, Z, Y, $, J);
                    if (ae !== null) {
                      for (; G < r; ) {
                        const se = b(J, ae, G);
                        return G++, se;
                      }
                      G = 0;
                    }
                  }
                  ce = 0;
                }
                q = 0;
              }
              re = 0;
            }
            throw new e("Out of packets");
          };
        }
        function I(_) {
          const o = _.SIZ, m = _.currentTile.index, s = _.tiles[m], r = s.codingStyleDefaultParameters.layersCount, y = o.Csiz, M = k(s);
          let $ = 0, G = 0, ce = 0, q = 0, re = 0;
          this.nextPacket = function() {
            for (; ce < y; ++ce) {
              const te = s.components[ce], L = M.components[ce], X = te.codingStyleParameters.decompositionLevelsCount;
              for (; re < L.maxNumHigh; re++) {
                for (; q < L.maxNumWide; q++) {
                  for (; G <= X; G++) {
                    const J = te.resolutions[G], Y = L.resolutions[G], ae = E(q, re, Y, L, J);
                    if (ae !== null) {
                      for (; $ < r; ) {
                        const se = b(J, ae, $);
                        return $++, se;
                      }
                      $ = 0;
                    }
                  }
                  G = 0;
                }
                q = 0;
              }
              re = 0;
            }
            throw new e("Out of packets");
          };
        }
        function E(_, o, m, s, r) {
          const y = _ * s.minWidth, M = o * s.minHeight;
          if (y % m.width !== 0 || M % m.height !== 0)
            return null;
          const $ = M / m.width * r.precinctParameters.numprecinctswide;
          return y / m.height + $;
        }
        function k(_) {
          const o = _.components.length;
          let m = Number.MAX_VALUE, s = Number.MAX_VALUE, r = 0, y = 0;
          const M = new Array(o);
          for (let $ = 0; $ < o; $++) {
            const G = _.components[$], ce = G.codingStyleParameters.decompositionLevelsCount, q = new Array(ce + 1);
            let re = Number.MAX_VALUE, Z = Number.MAX_VALUE, te = 0, L = 0, X = 1;
            for (let J = ce; J >= 0; --J) {
              const Y = G.resolutions[J], ae = X * Y.precinctParameters.precinctWidth, se = X * Y.precinctParameters.precinctHeight;
              re = Math.min(re, ae), Z = Math.min(Z, se), te = Math.max(te, Y.precinctParameters.numprecinctswide), L = Math.max(L, Y.precinctParameters.numprecinctshigh), q[J] = {
                width: ae,
                height: se
              }, X <<= 1;
            }
            m = Math.min(m, re), s = Math.min(s, Z), r = Math.max(r, te), y = Math.max(y, L), M[$] = {
              resolutions: q,
              minWidth: re,
              minHeight: Z,
              maxNumWide: te,
              maxNumHigh: L
            };
          }
          return {
            components: M,
            minWidth: m,
            minHeight: s,
            maxNumWide: r,
            maxNumHigh: y
          };
        }
        function H(_) {
          const o = _.SIZ, m = _.currentTile.index, s = _.tiles[m], r = o.Csiz;
          for (let M = 0; M < r; M++) {
            const $ = s.components[M], G = $.codingStyleParameters.decompositionLevelsCount, ce = [], q = [];
            for (let re = 0; re <= G; re++) {
              const Z = O(_, $, re), te = {}, L = 1 << G - re;
              te.trx0 = Math.ceil($.tcx0 / L), te.try0 = Math.ceil($.tcy0 / L), te.trx1 = Math.ceil($.tcx1 / L), te.try1 = Math.ceil($.tcy1 / L), te.resLevel = re, v(_, te, Z), ce.push(te);
              let X;
              if (re === 0)
                X = {}, X.type = "LL", X.tbx0 = Math.ceil($.tcx0 / L), X.tby0 = Math.ceil($.tcy0 / L), X.tbx1 = Math.ceil($.tcx1 / L), X.tby1 = Math.ceil($.tcy1 / L), X.resolution = te, g(_, X, Z), q.push(X), te.subbands = [X];
              else {
                const J = 1 << G - re + 1, Y = [];
                X = {}, X.type = "HL", X.tbx0 = Math.ceil($.tcx0 / J - 0.5), X.tby0 = Math.ceil($.tcy0 / J), X.tbx1 = Math.ceil($.tcx1 / J - 0.5), X.tby1 = Math.ceil($.tcy1 / J), X.resolution = te, g(_, X, Z), q.push(X), Y.push(X), X = {}, X.type = "LH", X.tbx0 = Math.ceil($.tcx0 / J), X.tby0 = Math.ceil($.tcy0 / J - 0.5), X.tbx1 = Math.ceil($.tcx1 / J), X.tby1 = Math.ceil($.tcy1 / J - 0.5), X.resolution = te, g(_, X, Z), q.push(X), Y.push(X), X = {}, X.type = "HH", X.tbx0 = Math.ceil($.tcx0 / J - 0.5), X.tby0 = Math.ceil($.tcy0 / J - 0.5), X.tbx1 = Math.ceil($.tcx1 / J - 0.5), X.tby1 = Math.ceil($.tcy1 / J - 0.5), X.resolution = te, g(_, X, Z), q.push(X), Y.push(X), te.subbands = Y;
              }
            }
            $.resolutions = ce, $.subbands = q;
          }
          const y = s.codingStyleDefaultParameters.progressionOrder;
          switch (y) {
            case 0:
              s.packetsIterator = new i(_);
              break;
            case 1:
              s.packetsIterator = new P(_);
              break;
            case 2:
              s.packetsIterator = new d(_);
              break;
            case 3:
              s.packetsIterator = new A(_);
              break;
            case 4:
              s.packetsIterator = new I(_);
              break;
            default:
              throw new e(`Unsupported progression order ${y}`);
          }
        }
        function x(_, o, m, s) {
          let r = 0, y, M = 0, $ = !1;
          function G(ae) {
            for (; M < ae; ) {
              const se = o[m + r];
              r++, $ ? (y = y << 7 | se, M += 7, $ = !1) : (y = y << 8 | se, M += 8), se === 255 && ($ = !0);
            }
            return M -= ae, y >>> M & (1 << ae) - 1;
          }
          function ce(ae) {
            return o[m + r - 1] === 255 && o[m + r] === ae ? (q(1), !0) : o[m + r] === 255 && o[m + r + 1] === ae ? (q(2), !0) : !1;
          }
          function q(ae) {
            r += ae;
          }
          function re() {
            M = 0, $ && (r++, $ = !1);
          }
          function Z() {
            if (G(1) === 0)
              return 1;
            if (G(1) === 0)
              return 2;
            let ae = G(2);
            return ae < 3 ? ae + 3 : (ae = G(5), ae < 31 ? ae + 6 : (ae = G(7), ae + 37));
          }
          const te = _.currentTile.index, L = _.tiles[te], X = _.COD.sopMarkerUsed, J = _.COD.ephMarkerUsed, Y = L.packetsIterator;
          for (; r < s; ) {
            re(), X && ce(145) && q(4);
            const ae = Y.nextPacket();
            if (!G(1))
              continue;
            const se = ae.layerNumber, Q = [];
            let z;
            for (let ie = 0, ne = ae.codeblocks.length; ie < ne; ie++) {
              z = ae.codeblocks[ie];
              let W = z.precinct;
              const oe = z.cbx - W.cbxMin, ue = z.cby - W.cbyMin;
              let pe = !1, ve = !1, Ce, Fe;
              if (z.included !== void 0)
                pe = !!G(1);
              else {
                W = z.precinct;
                let _e;
                if (W.inclusionTree !== void 0)
                  _e = W.inclusionTree;
                else {
                  const Se = W.cbxMax - W.cbxMin + 1, Ae = W.cbyMax - W.cbyMin + 1;
                  _e = new p(Se, Ae, se), Fe = new u(Se, Ae), W.inclusionTree = _e, W.zeroBitPlanesTree = Fe;
                  for (let Te = 0; Te < se; Te++)
                    if (G(1) !== 0)
                      throw new e("Invalid tag tree");
                }
                if (_e.reset(oe, ue, se))
                  for (; ; )
                    if (G(1)) {
                      if (Ce = !_e.nextLevel(), Ce) {
                        z.included = !0, pe = ve = !0;
                        break;
                      }
                    } else {
                      _e.incrementValue(se);
                      break;
                    }
              }
              if (!pe)
                continue;
              if (ve) {
                for (Fe = W.zeroBitPlanesTree, Fe.reset(oe, ue); ; )
                  if (G(1)) {
                    if (Ce = !Fe.nextLevel(), Ce)
                      break;
                  } else
                    Fe.incrementValue();
                z.zeroBitPlanes = Fe.value;
              }
              const Pe = Z();
              for (; G(1); )
                z.Lblock++;
              const be = (0, F.log2)(Pe), me = (Pe < 1 << be ? be - 1 : be) + z.Lblock, we = G(me);
              Q.push({
                codeblock: z,
                codingpasses: Pe,
                dataLength: we
              });
            }
            for (re(), J && ce(146); Q.length > 0; ) {
              const ie = Q.shift();
              z = ie.codeblock, z.data === void 0 && (z.data = []), z.data.push({
                data: o,
                start: m + r,
                end: m + r + ie.dataLength,
                codingpasses: ie.codingpasses
              }), r += ie.dataLength;
            }
          }
          return r;
        }
        function R(_, o, m, s, r, y, M, $, G) {
          const ce = s.tbx0, q = s.tby0, re = s.tbx1 - s.tbx0, Z = s.codeblocks, te = s.type.charAt(0) === "H" ? 1 : 0, L = s.type.charAt(1) === "H" ? o : 0;
          for (let X = 0, J = Z.length; X < J; ++X) {
            const Y = Z[X], ae = Y.tbx1_ - Y.tbx0_, se = Y.tby1_ - Y.tby0_;
            if (ae === 0 || se === 0 || Y.data === void 0)
              continue;
            const Q = new S(ae, se, Y.subbandType, Y.zeroBitPlanes, y);
            let z = 2;
            const ie = Y.data;
            let ne = 0, W = 0, oe, ue, pe;
            for (oe = 0, ue = ie.length; oe < ue; oe++)
              pe = ie[oe], ne += pe.end - pe.start, W += pe.codingpasses;
            const ve = new Uint8Array(ne);
            let Ce = 0;
            for (oe = 0, ue = ie.length; oe < ue; oe++) {
              pe = ie[oe];
              const Ee = pe.data.subarray(pe.start, pe.end);
              ve.set(Ee, Ce), Ce += Ee.length;
            }
            const Fe = new C.ArithmeticDecoder(ve, 0, ne);
            for (Q.setDecoder(Fe), oe = 0; oe < W; oe++) {
              switch (z) {
                case 0:
                  Q.runSignificancePropagationPass();
                  break;
                case 1:
                  Q.runMagnitudeRefinementPass();
                  break;
                case 2:
                  Q.runCleanupPass(), $ && Q.checkSegmentationSymbol();
                  break;
              }
              G && Q.reset(), z = (z + 1) % 3;
            }
            let Pe = Y.tbx0_ - ce + (Y.tby0_ - q) * re;
            const be = Q.coefficentsSign, me = Q.coefficentsMagnitude, we = Q.bitsDecoded, _e = M ? 0 : 0.5;
            let Se, Ae, Te;
            Ce = 0;
            const ke = s.type !== "LL";
            for (oe = 0; oe < se; oe++) {
              const Ve = 2 * (Pe / re | 0) * (o - re) + te + L;
              for (Se = 0; Se < ae; Se++) {
                if (Ae = me[Ce], Ae !== 0) {
                  Ae = (Ae + _e) * r, be[Ce] !== 0 && (Ae = -Ae), Te = we[Ce];
                  const je = ke ? Ve + (Pe << 1) : Pe;
                  _[je] = M && Te >= y ? Ae : Ae * (1 << y - Te);
                }
                Pe++, Ce++;
              }
              Pe += re - ae;
            }
          }
        }
        function f(_, o, m) {
          const s = o.components[m], r = s.codingStyleParameters, y = s.quantizationParameters, M = r.decompositionLevelsCount, $ = y.SPqcds, G = y.scalarExpounded, ce = y.guardBits, q = r.segmentationSymbolUsed, re = r.resetContextProbabilities, Z = _.components[m].precision, te = r.reversibleTransformation, L = te ? new D() : new T(), X = [];
          let J = 0;
          for (let ae = 0; ae <= M; ae++) {
            const se = s.resolutions[ae], Q = se.trx1 - se.trx0, z = se.try1 - se.try0, ie = new Float32Array(Q * z);
            for (let ne = 0, W = se.subbands.length; ne < W; ne++) {
              let oe, ue;
              G ? (oe = $[J].mu, ue = $[J].epsilon, J++) : (oe = $[0].mu, ue = $[0].epsilon + (ae > 0 ? 1 - ae : 0));
              const pe = se.subbands[ne], ve = t[pe.type], Ce = te ? 1 : 2 ** (Z + ve - ue) * (1 + oe / 2048), Fe = ce + ue - 1;
              R(ie, Q, z, pe, Ce, Fe, te, q, re);
            }
            X.push({
              width: Q,
              height: z,
              items: ie
            });
          }
          const Y = L.calculate(X, s.tcx0, s.tcy0);
          return {
            left: s.tcx0,
            top: s.tcy0,
            width: Y.width,
            height: Y.height,
            items: Y.items
          };
        }
        function c(_) {
          const o = _.SIZ, m = _.components, s = o.Csiz, r = [];
          for (let y = 0, M = _.tiles.length; y < M; y++) {
            const $ = _.tiles[y], G = [];
            for (let Q = 0; Q < s; Q++)
              G[Q] = f(_, $, Q);
            const ce = G[0], q = new Uint8ClampedArray(ce.items.length * s), re = {
              left: ce.left,
              top: ce.top,
              width: ce.width,
              height: ce.height,
              items: q
            };
            let Z, te, L = 0, X, J, Y, ae, se;
            if ($.codingStyleDefaultParameters.multipleComponentTransform) {
              const Q = s === 4, z = G[0].items, ie = G[1].items, ne = G[2].items, W = Q ? G[3].items : null;
              Z = m[0].precision - 8, te = (128 << Z) + 0.5;
              const oe = $.components[0], ue = s - 3;
              if (J = z.length, oe.codingStyleParameters.reversibleTransformation)
                for (X = 0; X < J; X++, L += ue) {
                  Y = z[X] + te, ae = ie[X], se = ne[X];
                  const pe = Y - (se + ae >> 2);
                  q[L++] = pe + se >> Z, q[L++] = pe >> Z, q[L++] = pe + ae >> Z;
                }
              else
                for (X = 0; X < J; X++, L += ue)
                  Y = z[X] + te, ae = ie[X], se = ne[X], q[L++] = Y + 1.402 * se >> Z, q[L++] = Y - 0.34413 * ae - 0.71414 * se >> Z, q[L++] = Y + 1.772 * ae >> Z;
              if (Q)
                for (X = 0, L = 3; X < J; X++, L += 4)
                  q[L] = W[X] + te >> Z;
            } else
              for (let Q = 0; Q < s; Q++) {
                const z = G[Q].items;
                for (Z = m[Q].precision - 8, te = (128 << Z) + 0.5, L = Q, X = 0, J = z.length; X < J; X++)
                  q[L] = z[X] + te >> Z, L += s;
              }
            r.push(re);
          }
          return r;
        }
        function N(_, o) {
          const s = _.SIZ.Csiz, r = _.tiles[o];
          for (let y = 0; y < s; y++) {
            const M = r.components[y], $ = _.currentTile.QCC[y] !== void 0 ? _.currentTile.QCC[y] : _.currentTile.QCD;
            M.quantizationParameters = $;
            const G = _.currentTile.COC[y] !== void 0 ? _.currentTile.COC[y] : _.currentTile.COD;
            M.codingStyleParameters = G;
          }
          r.codingStyleDefaultParameters = _.currentTile.COD;
        }
        class u {
          constructor(o, m) {
            const s = (0, F.log2)(Math.max(o, m)) + 1;
            this.levels = [];
            for (let r = 0; r < s; r++) {
              const y = {
                width: o,
                height: m,
                items: []
              };
              this.levels.push(y), o = Math.ceil(o / 2), m = Math.ceil(m / 2);
            }
          }
          reset(o, m) {
            let s = 0, r = 0, y;
            for (; s < this.levels.length; ) {
              y = this.levels[s];
              const M = o + m * y.width;
              if (y.items[M] !== void 0) {
                r = y.items[M];
                break;
              }
              y.index = M, o >>= 1, m >>= 1, s++;
            }
            s--, y = this.levels[s], y.items[y.index] = r, this.currentLevel = s, delete this.value;
          }
          incrementValue() {
            const o = this.levels[this.currentLevel];
            o.items[o.index]++;
          }
          nextLevel() {
            let o = this.currentLevel, m = this.levels[o];
            const s = m.items[m.index];
            return o--, o < 0 ? (this.value = s, !1) : (this.currentLevel = o, m = this.levels[o], m.items[m.index] = s, !0);
          }
        }
        class p {
          constructor(o, m, s) {
            const r = (0, F.log2)(Math.max(o, m)) + 1;
            this.levels = [];
            for (let y = 0; y < r; y++) {
              const M = new Uint8Array(o * m);
              for (let G = 0, ce = M.length; G < ce; G++)
                M[G] = s;
              const $ = {
                width: o,
                height: m,
                items: M
              };
              this.levels.push($), o = Math.ceil(o / 2), m = Math.ceil(m / 2);
            }
          }
          reset(o, m, s) {
            let r = 0;
            for (; r < this.levels.length; ) {
              const y = this.levels[r], M = o + m * y.width;
              y.index = M;
              const $ = y.items[M];
              if ($ === 255)
                break;
              if ($ > s)
                return this.currentLevel = r, this.propagateValues(), !1;
              o >>= 1, m >>= 1, r++;
            }
            return this.currentLevel = r - 1, !0;
          }
          incrementValue(o) {
            const m = this.levels[this.currentLevel];
            m.items[m.index] = o + 1, this.propagateValues();
          }
          propagateValues() {
            let o = this.currentLevel, m = this.levels[o];
            const s = m.items[m.index];
            for (; --o >= 0; )
              m = this.levels[o], m.items[m.index] = s;
          }
          nextLevel() {
            let o = this.currentLevel, m = this.levels[o];
            const s = m.items[m.index];
            return m.items[m.index] = 255, o--, o < 0 ? !1 : (this.currentLevel = o, m = this.levels[o], m.items[m.index] = s, !0);
          }
        }
        const K = class K {
          constructor(o, m, s, r, y) {
            this.width = o, this.height = m;
            let M;
            s === "HH" ? M = K.HHContextLabel : s === "HL" ? M = K.HLContextLabel : M = K.LLAndLHContextsLabel, this.contextLabelTable = M;
            const $ = o * m;
            this.neighborsSignificance = new Uint8Array($), this.coefficentsSign = new Uint8Array($);
            let G;
            y > 14 ? G = new Uint32Array($) : y > 6 ? G = new Uint16Array($) : G = new Uint8Array($), this.coefficentsMagnitude = G, this.processingFlags = new Uint8Array($);
            const ce = new Uint8Array($);
            if (r !== 0)
              for (let q = 0; q < $; q++)
                ce[q] = r;
            this.bitsDecoded = ce, this.reset();
          }
          setDecoder(o) {
            this.decoder = o;
          }
          reset() {
            this.contexts = new Int8Array(19), this.contexts[0] = 8, this.contexts[K.UNIFORM_CONTEXT] = 92, this.contexts[K.RUNLENGTH_CONTEXT] = 6;
          }
          setNeighborsSignificance(o, m, s) {
            const r = this.neighborsSignificance, y = this.width, M = this.height, $ = m > 0, G = m + 1 < y;
            let ce;
            o > 0 && (ce = s - y, $ && (r[ce - 1] += 16), G && (r[ce + 1] += 16), r[ce] += 4), o + 1 < M && (ce = s + y, $ && (r[ce - 1] += 16), G && (r[ce + 1] += 16), r[ce] += 4), $ && (r[s - 1] += 1), G && (r[s + 1] += 1), r[s] |= 128;
          }
          runSignificancePropagationPass() {
            const o = this.decoder, m = this.width, s = this.height, r = this.coefficentsMagnitude, y = this.coefficentsSign, M = this.neighborsSignificance, $ = this.processingFlags, G = this.contexts, ce = this.contextLabelTable, q = this.bitsDecoded, re = -2, Z = 1, te = 2;
            for (let L = 0; L < s; L += 4)
              for (let X = 0; X < m; X++) {
                let J = L * m + X;
                for (let Y = 0; Y < 4; Y++, J += m) {
                  const ae = L + Y;
                  if (ae >= s)
                    break;
                  if ($[J] &= re, r[J] || !M[J])
                    continue;
                  const se = ce[M[J]];
                  if (o.readBit(G, se)) {
                    const z = this.decodeSignBit(ae, X, J);
                    y[J] = z, r[J] = 1, this.setNeighborsSignificance(ae, X, J), $[J] |= te;
                  }
                  q[J]++, $[J] |= Z;
                }
              }
          }
          decodeSignBit(o, m, s) {
            const r = this.width, y = this.height, M = this.coefficentsMagnitude, $ = this.coefficentsSign;
            let G, ce, q, re, Z, te;
            re = m > 0 && M[s - 1] !== 0, m + 1 < r && M[s + 1] !== 0 ? (q = $[s + 1], re ? (ce = $[s - 1], G = 1 - q - ce) : G = 1 - q - q) : re ? (ce = $[s - 1], G = 1 - ce - ce) : G = 0;
            const L = 3 * G;
            return re = o > 0 && M[s - r] !== 0, o + 1 < y && M[s + r] !== 0 ? (q = $[s + r], re ? (ce = $[s - r], G = 1 - q - ce + L) : G = 1 - q - q + L) : re ? (ce = $[s - r], G = 1 - ce - ce + L) : G = L, G >= 0 ? (Z = 9 + G, te = this.decoder.readBit(this.contexts, Z)) : (Z = 9 - G, te = this.decoder.readBit(this.contexts, Z) ^ 1), te;
          }
          runMagnitudeRefinementPass() {
            const o = this.decoder, m = this.width, s = this.height, r = this.coefficentsMagnitude, y = this.neighborsSignificance, M = this.contexts, $ = this.bitsDecoded, G = this.processingFlags, ce = 1, q = 2, re = m * s, Z = m * 4;
            for (let te = 0, L; te < re; te = L) {
              L = Math.min(re, te + Z);
              for (let X = 0; X < m; X++)
                for (let J = te + X; J < L; J += m) {
                  if (!r[J] || G[J] & ce)
                    continue;
                  let Y = 16;
                  G[J] & q && (G[J] ^= q, Y = (y[J] & 127) === 0 ? 15 : 14);
                  const ae = o.readBit(M, Y);
                  r[J] = r[J] << 1 | ae, $[J]++, G[J] |= ce;
                }
            }
          }
          runCleanupPass() {
            const o = this.decoder, m = this.width, s = this.height, r = this.neighborsSignificance, y = this.coefficentsMagnitude, M = this.coefficentsSign, $ = this.contexts, G = this.contextLabelTable, ce = this.bitsDecoded, q = this.processingFlags, re = 1, Z = 2, te = m, L = m * 2, X = m * 3;
            let J;
            for (let Y = 0; Y < s; Y = J) {
              J = Math.min(Y + 4, s);
              const ae = Y * m, se = Y + 3 < s;
              for (let Q = 0; Q < m; Q++) {
                const z = ae + Q, ie = se && q[z] === 0 && q[z + te] === 0 && q[z + L] === 0 && q[z + X] === 0 && r[z] === 0 && r[z + te] === 0 && r[z + L] === 0 && r[z + X] === 0;
                let ne = 0, W = z, oe = Y, ue;
                if (ie) {
                  if (!o.readBit($, K.RUNLENGTH_CONTEXT)) {
                    ce[z]++, ce[z + te]++, ce[z + L]++, ce[z + X]++;
                    continue;
                  }
                  ne = o.readBit($, K.UNIFORM_CONTEXT) << 1 | o.readBit($, K.UNIFORM_CONTEXT), ne !== 0 && (oe = Y + ne, W += ne * m), ue = this.decodeSignBit(oe, Q, W), M[W] = ue, y[W] = 1, this.setNeighborsSignificance(oe, Q, W), q[W] |= Z, W = z;
                  for (let ve = Y; ve <= oe; ve++, W += m)
                    ce[W]++;
                  ne++;
                }
                for (oe = Y + ne; oe < J; oe++, W += m) {
                  if (y[W] || q[W] & re)
                    continue;
                  const pe = G[r[W]];
                  o.readBit($, pe) === 1 && (ue = this.decodeSignBit(oe, Q, W), M[W] = ue, y[W] = 1, this.setNeighborsSignificance(oe, Q, W), q[W] |= Z), ce[W]++;
                }
              }
            }
          }
          checkSegmentationSymbol() {
            const o = this.decoder, m = this.contexts;
            if ((o.readBit(m, K.UNIFORM_CONTEXT) << 3 | o.readBit(m, K.UNIFORM_CONTEXT) << 2 | o.readBit(m, K.UNIFORM_CONTEXT) << 1 | o.readBit(m, K.UNIFORM_CONTEXT)) !== 10)
              throw new e("Invalid segmentation symbol");
          }
        };
        Ot(K, "UNIFORM_CONTEXT", 17), Ot(K, "RUNLENGTH_CONTEXT", 18), Ot(K, "LLAndLHContextsLabel", new Uint8Array([0, 5, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 1, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8])), Ot(K, "HLContextLabel", new Uint8Array([0, 3, 4, 0, 5, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 1, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8])), Ot(K, "HHContextLabel", new Uint8Array([0, 1, 2, 0, 1, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 3, 4, 5, 0, 4, 5, 5, 0, 5, 5, 5, 0, 0, 0, 0, 0, 6, 7, 7, 0, 7, 7, 7, 0, 7, 7, 7, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8]));
        let S = K;
        class B {
          constructor() {
            this.constructor === B && (0, n.unreachable)("Cannot initialize Transform.");
          }
          calculate(o, m, s) {
            let r = o[0];
            for (let y = 1, M = o.length; y < M; y++)
              r = this.iterate(r, o[y], m, s);
            return r;
          }
          extend(o, m, s) {
            let r = m - 1, y = m + 1, M = m + s - 2, $ = m + s;
            o[r--] = o[y++], o[$++] = o[M--], o[r--] = o[y++], o[$++] = o[M--], o[r--] = o[y++], o[$++] = o[M--], o[r] = o[y], o[$] = o[M];
          }
          filter(o, m, s) {
            (0, n.unreachable)("Abstract method `filter` called");
          }
          iterate(o, m, s, r) {
            const y = o.width, M = o.height;
            let $ = o.items;
            const G = m.width, ce = m.height, q = m.items;
            let re, Z, te, L, X, J;
            for (te = 0, re = 0; re < M; re++)
              for (L = re * 2 * G, Z = 0; Z < y; Z++, te++, L += 2)
                q[L] = $[te];
            $ = o.items = null;
            const Y = 4, ae = new Float32Array(G + 2 * Y);
            if (G === 1) {
              if (s & 1)
                for (J = 0, te = 0; J < ce; J++, te += G)
                  q[te] *= 0.5;
            } else
              for (J = 0, te = 0; J < ce; J++, te += G)
                ae.set(q.subarray(te, te + G), Y), this.extend(ae, Y, G), this.filter(ae, Y, G), q.set(ae.subarray(Y, Y + G), te);
            let se = 16;
            const Q = [];
            for (re = 0; re < se; re++)
              Q.push(new Float32Array(ce + 2 * Y));
            let z, ie = 0;
            if (o = Y + ce, ce === 1) {
              if (r & 1)
                for (X = 0; X < G; X++)
                  q[X] *= 0.5;
            } else
              for (X = 0; X < G; X++) {
                if (ie === 0) {
                  for (se = Math.min(G - X, se), te = X, L = Y; L < o; te += G, L++)
                    for (z = 0; z < se; z++)
                      Q[z][L] = q[te + z];
                  ie = se;
                }
                ie--;
                const ne = Q[ie];
                if (this.extend(ne, Y, ce), this.filter(ne, Y, ce), ie === 0)
                  for (te = X - se + 1, L = Y; L < o; te += G, L++)
                    for (z = 0; z < se; z++)
                      q[te + z] = Q[z][L];
              }
            return {
              width: G,
              height: ce,
              items: q
            };
          }
        }
        class T extends B {
          filter(o, m, s) {
            const r = s >> 1;
            m |= 0;
            let y, M, $, G;
            const ce = -1.586134342059924, q = -0.052980118572961, re = 0.882911075530934, Z = 0.443506852043971, te = 1.230174104914001, L = 1 / te;
            for (y = m - 3, M = r + 4; M--; y += 2)
              o[y] *= L;
            for (y = m - 2, $ = Z * o[y - 1], M = r + 3; M-- && (G = Z * o[y + 1], o[y] = te * o[y] - $ - G, M--); y += 2)
              y += 2, $ = Z * o[y + 1], o[y] = te * o[y] - $ - G;
            for (y = m - 1, $ = re * o[y - 1], M = r + 2; M-- && (G = re * o[y + 1], o[y] -= $ + G, M--); y += 2)
              y += 2, $ = re * o[y + 1], o[y] -= $ + G;
            for (y = m, $ = q * o[y - 1], M = r + 1; M-- && (G = q * o[y + 1], o[y] -= $ + G, M--); y += 2)
              y += 2, $ = q * o[y + 1], o[y] -= $ + G;
            if (r !== 0)
              for (y = m + 1, $ = ce * o[y - 1], M = r; M-- && (G = ce * o[y + 1], o[y] -= $ + G, M--); y += 2)
                y += 2, $ = ce * o[y + 1], o[y] -= $ + G;
          }
        }
        class D extends B {
          filter(o, m, s) {
            const r = s >> 1;
            m |= 0;
            let y, M;
            for (y = m, M = r + 1; M--; y += 2)
              o[y] -= o[y - 1] + o[y + 1] + 2 >> 2;
            for (y = m + 1, M = r; M--; y += 2)
              o[y] += o[y - 1] + o[y + 1] >> 1;
          }
        }
      },
      /* 31 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.LZWStream = void 0;
        var n = V(18);
        class F extends n.DecodeStream {
          constructor(e, t, l) {
            super(t), this.str = e, this.dict = e.dict, this.cachedData = 0, this.bitsCached = 0;
            const j = 4096, U = {
              earlyChange: l,
              codeLength: 9,
              nextCode: 258,
              dictionaryValues: new Uint8Array(j),
              dictionaryLengths: new Uint16Array(j),
              dictionaryPrevCodes: new Uint16Array(j),
              currentSequence: new Uint8Array(j),
              currentSequenceLength: 0
            };
            for (let O = 0; O < 256; ++O)
              U.dictionaryValues[O] = O, U.dictionaryLengths[O] = 1;
            this.lzwState = U;
          }
          readBits(e) {
            let t = this.bitsCached, l = this.cachedData;
            for (; t < e; ) {
              const j = this.str.getByte();
              if (j === -1)
                return this.eof = !0, null;
              l = l << 8 | j, t += 8;
            }
            return this.bitsCached = t -= e, this.cachedData = l, this.lastCode = null, l >>> t & (1 << e) - 1;
          }
          readBlock() {
            let l = 1024, j, U, O;
            const v = this.lzwState;
            if (!v)
              return;
            const g = v.earlyChange;
            let b = v.nextCode;
            const i = v.dictionaryValues, P = v.dictionaryLengths, d = v.dictionaryPrevCodes;
            let A = v.codeLength, I = v.prevCode;
            const E = v.currentSequence;
            let k = v.currentSequenceLength, H = 0, x = this.bufferLength, R = this.ensureBuffer(this.bufferLength + l);
            for (j = 0; j < 512; j++) {
              const f = this.readBits(A), c = k > 0;
              if (f < 256)
                E[0] = f, k = 1;
              else if (f >= 258)
                if (f < b)
                  for (k = P[f], U = k - 1, O = f; U >= 0; U--)
                    E[U] = i[O], O = d[O];
                else
                  E[k++] = E[0];
              else if (f === 256) {
                A = 9, b = 258, k = 0;
                continue;
              } else {
                this.eof = !0, delete this.lzwState;
                break;
              }
              if (c && (d[b] = I, P[b] = P[I] + 1, i[b] = E[0], b++, A = b + g & b + g - 1 ? A : Math.min(Math.log(b + g) / 0.6931471805599453 + 1, 12) | 0), I = f, H += k, l < H) {
                do
                  l += 512;
                while (l < H);
                R = this.ensureBuffer(this.bufferLength + l);
              }
              for (U = 0; U < k; U++)
                R[x++] = E[U];
            }
            v.nextCode = b, v.codeLength = A, v.prevCode = I, v.currentSequenceLength = k, this.bufferLength = x;
          }
        }
        w.LZWStream = F;
      },
      /* 32 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.PredictorStream = void 0;
        var n = V(18), F = V(4), C = V(2);
        class e extends n.DecodeStream {
          constructor(l, j, U) {
            if (super(j), !(U instanceof F.Dict))
              return l;
            const O = this.predictor = U.get("Predictor") || 1;
            if (O <= 1)
              return l;
            if (O !== 2 && (O < 10 || O > 15))
              throw new C.FormatError(`Unsupported predictor: ${O}`);
            this.readBlock = O === 2 ? this.readBlockTiff : this.readBlockPng, this.str = l, this.dict = l.dict;
            const v = this.colors = U.get("Colors") || 1, g = this.bits = U.get("BPC", "BitsPerComponent") || 8, b = this.columns = U.get("Columns") || 1;
            return this.pixBytes = v * g + 7 >> 3, this.rowBytes = b * v * g + 7 >> 3, this;
          }
          readBlockTiff() {
            const l = this.rowBytes, j = this.bufferLength, U = this.ensureBuffer(j + l), O = this.bits, v = this.colors, g = this.str.getBytes(l);
            if (this.eof = !g.length, this.eof)
              return;
            let b = 0, i = 0, P = 0, d = 0, A = j, I;
            if (O === 1 && v === 1)
              for (I = 0; I < l; ++I) {
                let E = g[I] ^ b;
                E ^= E >> 1, E ^= E >> 2, E ^= E >> 4, b = (E & 1) << 7, U[A++] = E;
              }
            else if (O === 8) {
              for (I = 0; I < v; ++I)
                U[A++] = g[I];
              for (; I < l; ++I)
                U[A] = U[A - v] + g[I], A++;
            } else if (O === 16) {
              const E = v * 2;
              for (I = 0; I < E; ++I)
                U[A++] = g[I];
              for (; I < l; I += 2) {
                const k = ((g[I] & 255) << 8) + (g[I + 1] & 255) + ((U[A - E] & 255) << 8) + (U[A - E + 1] & 255);
                U[A++] = k >> 8 & 255, U[A++] = k & 255;
              }
            } else {
              const E = new Uint8Array(v + 1), k = (1 << O) - 1;
              let H = 0, x = j;
              const R = this.columns;
              for (I = 0; I < R; ++I)
                for (let f = 0; f < v; ++f)
                  P < O && (b = b << 8 | g[H++] & 255, P += 8), E[f] = E[f] + (b >> P - O) & k, P -= O, i = i << O | E[f], d += O, d >= 8 && (U[x++] = i >> d - 8 & 255, d -= 8);
              d > 0 && (U[x++] = (i << 8 - d) + (b & (1 << 8 - d) - 1));
            }
            this.bufferLength += l;
          }
          readBlockPng() {
            const l = this.rowBytes, j = this.pixBytes, U = this.str.getByte(), O = this.str.getBytes(l);
            if (this.eof = !O.length, this.eof)
              return;
            const v = this.bufferLength, g = this.ensureBuffer(v + l);
            let b = g.subarray(v - l, v);
            b.length === 0 && (b = new Uint8Array(l));
            let i, P = v, d, A;
            switch (U) {
              case 0:
                for (i = 0; i < l; ++i)
                  g[P++] = O[i];
                break;
              case 1:
                for (i = 0; i < j; ++i)
                  g[P++] = O[i];
                for (; i < l; ++i)
                  g[P] = g[P - j] + O[i] & 255, P++;
                break;
              case 2:
                for (i = 0; i < l; ++i)
                  g[P++] = b[i] + O[i] & 255;
                break;
              case 3:
                for (i = 0; i < j; ++i)
                  g[P++] = (b[i] >> 1) + O[i];
                for (; i < l; ++i)
                  g[P] = (b[i] + g[P - j] >> 1) + O[i] & 255, P++;
                break;
              case 4:
                for (i = 0; i < j; ++i)
                  d = b[i], A = O[i], g[P++] = d + A;
                for (; i < l; ++i) {
                  d = b[i];
                  const I = b[i - j], E = g[P - j], k = E + d - I;
                  let H = k - E;
                  H < 0 && (H = -H);
                  let x = k - d;
                  x < 0 && (x = -x);
                  let R = k - I;
                  R < 0 && (R = -R), A = O[i], H <= x && H <= R ? g[P++] = E + A : x <= R ? g[P++] = d + A : g[P++] = I + A;
                }
                break;
              default:
                throw new C.FormatError(`Unsupported predictor: ${U}`);
            }
            this.bufferLength += l;
          }
        }
        w.PredictorStream = e;
      },
      /* 33 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.RunLengthStream = void 0;
        var n = V(18);
        class F extends n.DecodeStream {
          constructor(e, t) {
            super(t), this.str = e, this.dict = e.dict;
          }
          readBlock() {
            const e = this.str.getBytes(2);
            if (!e || e.length < 2 || e[0] === 128) {
              this.eof = !0;
              return;
            }
            let t, l = this.bufferLength, j = e[0];
            if (j < 128) {
              if (t = this.ensureBuffer(l + j + 1), t[l++] = e[1], j > 0) {
                const U = this.str.getBytes(j);
                t.set(U, l), l += j;
              }
            } else {
              j = 257 - j;
              const U = e[1];
              t = this.ensureBuffer(l + j + 1);
              for (let O = 0; O < j; O++)
                t[l++] = U;
            }
            this.bufferLength = l;
          }
        }
        w.RunLengthStream = F;
      },
      /* 34 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.Font = w.ErrorFont = void 0;
        var n = V(2), F = V(35), C = V(38), e = V(40), t = V(39), l = V(37), j = V(41), U = V(42), O = V(43), v = V(44), g = V(45), b = V(46), i = V(14), P = V(47), d = V(3), A = V(8), I = V(48);
        const E = [[57344, 63743], [1048576, 1114109]], k = 1e3, H = ["ascent", "bbox", "black", "bold", "charProcOperatorList", "composite", "cssFontInfo", "data", "defaultVMetrics", "defaultWidth", "descent", "fallbackName", "fontMatrix", "isInvalidPDFjsFont", "isType3Font", "italic", "loadedName", "mimetype", "missingFile", "name", "remeasure", "subtype", "systemFontInfo", "type", "vertical"], x = ["cMap", "defaultEncoding", "differences", "isMonospace", "isSerifFont", "isSymbolicFont", "seacMap", "toFontChar", "toUnicode", "vmetrics", "widths"];
        function R(z) {
          if (!z.fontMatrix || z.fontMatrix[0] === n.FONT_IDENTITY_MATRIX[0])
            return;
          const ie = 1e-3 / z.fontMatrix[0], ne = z.widths;
          for (const W in ne)
            ne[W] *= ie;
          z.defaultWidth *= ie;
        }
        function f(z, ie, ne) {
          if (z.isInternalFont || z.hasIncludedToUnicodeMap || z.hasEncoding || z.toUnicode instanceof U.IdentityToUnicodeMap || !ie || ne.length === 0 || z.defaultEncoding === l.WinAnsiEncoding)
            return;
          for (const pe of ne)
            if (!ce(pe))
              return;
          const W = l.WinAnsiEncoding, oe = [], ue = (0, t.getGlyphsUnicode)();
          for (const pe in W) {
            const ve = W[pe];
            if (ve === "")
              continue;
            const Ce = ue[ve];
            Ce !== void 0 && (oe[pe] = String.fromCharCode(Ce));
          }
          oe.length > 0 && z.toUnicode.amend(oe);
        }
        function c(z, ie) {
          if (z.isInternalFont || z.hasIncludedToUnicodeMap || ie === z.defaultEncoding || z.toUnicode instanceof U.IdentityToUnicodeMap)
            return;
          const ne = [], W = (0, t.getGlyphsUnicode)();
          for (const oe in ie) {
            if (z.hasEncoding && (z.baseEncodingName || z.differences[oe] !== void 0))
              continue;
            const ue = ie[oe], pe = (0, e.getUnicodeForGlyph)(ue, W);
            pe !== -1 && (ne[oe] = String.fromCharCode(pe));
          }
          ne.length > 0 && z.toUnicode.amend(ne);
        }
        function N(z) {
          if (!z.fallbackToUnicode || z.toUnicode instanceof U.IdentityToUnicodeMap)
            return;
          const ie = [];
          for (const ne in z.fallbackToUnicode)
            z.toUnicode.has(ne) || (ie[ne] = z.fallbackToUnicode[ne]);
          ie.length > 0 && z.toUnicode.amend(ie);
        }
        class u {
          constructor(ie, ne, W, oe, ue, pe, ve, Ce, Fe) {
            this.originalCharCode = ie, this.fontChar = ne, this.unicode = W, this.accent = oe, this.width = ue, this.vmetric = pe, this.operatorListId = ve, this.isSpace = Ce, this.isInFont = Fe;
          }
          get category() {
            return (0, n.shadow)(this, "category", (0, e.getCharUnicodeCategory)(this.unicode), !0);
          }
        }
        function p(z, ie) {
          return (z << 8) + ie;
        }
        function S(z, ie, ne) {
          z[ie + 1] = ne, z[ie] = ne >>> 8;
        }
        function B(z, ie) {
          const ne = (z << 8) + ie;
          return ne & 32768 ? ne - 65536 : ne;
        }
        function T(z, ie, ne, W) {
          return (z << 24) + (ie << 16) + (ne << 8) + W;
        }
        function D(z) {
          return String.fromCharCode(z >> 8 & 255, z & 255);
        }
        function K(z) {
          return z > 32767 ? z = 32767 : z < -32768 && (z = -32768), String.fromCharCode(z >> 8 & 255, z & 255);
        }
        function _(z) {
          const ie = z.peekBytes(4);
          return (0, d.readUint32)(ie, 0) === 65536 || (0, n.bytesToString)(ie) === "true";
        }
        function o(z) {
          const ie = z.peekBytes(4);
          return (0, n.bytesToString)(ie) === "ttcf";
        }
        function m(z) {
          const ie = z.peekBytes(4);
          return (0, n.bytesToString)(ie) === "OTTO";
        }
        function s(z) {
          const ie = z.peekBytes(2);
          return ie[0] === 37 && ie[1] === 33 || ie[0] === 128 && ie[1] === 1;
        }
        function r(z) {
          const ie = z.peekBytes(4);
          return ie[0] >= 1 && ie[3] >= 1 && ie[3] <= 4;
        }
        function y(z, {
          type: ie,
          subtype: ne,
          composite: W
        }) {
          let oe, ue;
          return _(z) || o(z) ? oe = W ? "CIDFontType2" : "TrueType" : m(z) ? oe = W ? "CIDFontType2" : "OpenType" : s(z) ? W ? oe = "CIDFontType0" : oe = ie === "MMType1" ? "MMType1" : "Type1" : r(z) ? W ? (oe = "CIDFontType0", ue = "CIDFontType0C") : (oe = ie === "MMType1" ? "MMType1" : "Type1", ue = "Type1C") : ((0, n.warn)("getFontFileType: Unable to detect correct font file Type/Subtype."), oe = ie, ue = ne), [oe, ue];
        }
        function M(z, ie) {
          for (const ne in ie)
            z[+ne] = ie[ne];
        }
        function $(z, ie, ne) {
          const W = [];
          let oe;
          for (let ue = 0, pe = z.length; ue < pe; ue++)
            oe = (0, e.getUnicodeForGlyph)(z[ue], ie), oe !== -1 && (W[ue] = oe);
          for (const ue in ne)
            oe = (0, e.getUnicodeForGlyph)(ne[ue], ie), oe !== -1 && (W[+ue] = oe);
          return W;
        }
        function G(z) {
          return z.platform === 1 && z.encoding === 0 && z.language === 0;
        }
        function ce(z) {
          return z.platform === 3 && z.encoding === 1 && z.language === 1033;
        }
        function q(z, ie, ne = !1) {
          switch (ie.length) {
            case 1:
              return ie.charCodeAt(0);
            case 2:
              return ie.charCodeAt(0) << 8 | ie.charCodeAt(1);
          }
          const W = `Unsupported CID string (charCode ${z}): "${ie}".`;
          if (ne)
            throw new n.FormatError(W);
          return (0, n.warn)(W), ie;
        }
        function re(z, ie, ne, W) {
          const oe = /* @__PURE__ */ Object.create(null), ue = /* @__PURE__ */ new Map(), pe = [], ve = /* @__PURE__ */ new Set();
          let Ce = 0, Pe = E[Ce][0], be = E[Ce][1];
          const me = (we) => E[0][0] <= we && we <= E[0][1] || E[1][0] <= we && we <= E[1][1];
          for (let we in z) {
            we |= 0;
            let _e = z[we];
            if (!ie(_e))
              continue;
            if (Pe > be) {
              if (Ce++, Ce >= E.length) {
                (0, n.warn)("Ran out of space in font private use area.");
                break;
              }
              Pe = E[Ce][0], be = E[Ce][1];
            }
            const Se = Pe++;
            _e === 0 && (_e = ne);
            let Ae = W.get(we);
            typeof Ae == "string" && (Ae = Ae.codePointAt(0)), Ae && !me(Ae) && !ve.has(_e) && (ue.set(Ae, _e), ve.add(_e)), oe[Se] = _e, pe[we] = Se;
          }
          return {
            toFontChar: pe,
            charCodeToGlyphId: oe,
            toUnicodeExtraMap: ue,
            nextAvailableFontCharCode: Pe
          };
        }
        function Z(z, ie, ne) {
          const W = [];
          for (const pe in z)
            z[pe] >= ne || W.push({
              fontCharCode: pe | 0,
              glyphId: z[pe]
            });
          if (ie)
            for (const [pe, ve] of ie)
              ve >= ne || W.push({
                fontCharCode: pe,
                glyphId: ve
              });
          W.length === 0 && W.push({
            fontCharCode: 0,
            glyphId: 0
          }), W.sort(function(ve, Ce) {
            return ve.fontCharCode - Ce.fontCharCode;
          });
          const oe = [], ue = W.length;
          for (let pe = 0; pe < ue; ) {
            const ve = W[pe].fontCharCode, Ce = [W[pe].glyphId];
            ++pe;
            let Fe = ve;
            for (; pe < ue && Fe + 1 === W[pe].fontCharCode && (Ce.push(W[pe].glyphId), ++Fe, ++pe, Fe !== 65535); )
              ;
            oe.push([ve, Fe, Ce]);
          }
          return oe;
        }
        function te(z, ie, ne) {
          const W = Z(z, ie, ne), oe = W.at(-1)[1] > 65535 ? 2 : 1;
          let ue = "\0\0" + D(oe) + "\0\0" + (0, n.string32)(4 + oe * 8), pe, ve, Ce, Fe;
          for (pe = W.length - 1; pe >= 0 && !(W[pe][0] <= 65535); --pe)
            ;
          const Pe = pe + 1;
          W[pe][0] < 65535 && W[pe][1] === 65535 && (W[pe][1] = 65534);
          const be = W[pe][1] < 65535 ? 1 : 0, me = Pe + be, we = P.OpenTypeFileBuilder.getSearchParams(me, 2);
          let _e = "", Se = "", Ae = "", Te = "", ke = "", Ee = 0, Ve, je, at, $e;
          for (pe = 0, ve = Pe; pe < ve; pe++) {
            Ve = W[pe], je = Ve[0], at = Ve[1], _e += D(je), Se += D(at), $e = Ve[2];
            let Qe = !0;
            for (Ce = 1, Fe = $e.length; Ce < Fe; ++Ce)
              if ($e[Ce] !== $e[Ce - 1] + 1) {
                Qe = !1;
                break;
              }
            if (Qe) {
              const Oe = $e[0];
              Ae += D(Oe - je & 65535), Te += D(0);
            } else {
              const Oe = (me - pe) * 2 + Ee * 2;
              for (Ee += at - je + 1, Ae += D(0), Te += D(Oe), Ce = 0, Fe = $e.length; Ce < Fe; ++Ce)
                ke += D($e[Ce]);
            }
          }
          be > 0 && (Se += "ÿÿ", _e += "ÿÿ", Ae += "\0", Te += "\0\0");
          const ct = "\0\0" + D(2 * me) + D(we.range) + D(we.entry) + D(we.rangeShift) + Se + "\0\0" + _e + Ae + Te + ke;
          let ze = "", Ye = "";
          if (oe > 1) {
            for (ue += `\0\0
` + (0, n.string32)(4 + oe * 8 + 4 + ct.length), ze = "", pe = 0, ve = W.length; pe < ve; pe++) {
              Ve = W[pe], je = Ve[0], $e = Ve[2];
              let Qe = $e[0];
              for (Ce = 1, Fe = $e.length; Ce < Fe; ++Ce)
                $e[Ce] !== $e[Ce - 1] + 1 && (at = Ve[0] + Ce - 1, ze += (0, n.string32)(je) + (0, n.string32)(at) + (0, n.string32)(Qe), je = at + 1, Qe = $e[Ce]);
              ze += (0, n.string32)(je) + (0, n.string32)(Ve[1]) + (0, n.string32)(Qe);
            }
            Ye = "\0\f\0\0" + (0, n.string32)(ze.length + 16) + "\0\0\0\0" + (0, n.string32)(ze.length / 12);
          }
          return ue + "\0" + D(ct.length + 4) + ct + Ye + ze;
        }
        function L(z, ie) {
          ie.pos = (ie.start || 0) + z.offset;
          const ne = ie.getUint16();
          ie.skip(60);
          const W = ie.getUint16();
          if (ne < 4 && W & 768)
            return !1;
          const oe = ie.getUint16(), ue = ie.getUint16();
          return oe > ue || (ie.skip(6), ie.getUint16() === 0) ? !1 : (z.data[8] = z.data[9] = 0, !0);
        }
        function X(z, ie, ne) {
          ne || (ne = {
            unitsPerEm: 0,
            yMax: 0,
            yMin: 0,
            ascent: 0,
            descent: 0
          });
          let W = 0, oe = 0, ue = 0, pe = 0, ve = null, Ce = 0, Fe = -1;
          if (ie) {
            for (let Te in ie)
              if (Te |= 0, (ve > Te || !ve) && (ve = Te), Ce < Te && (Ce = Te), Fe = (0, e.getUnicodeRangeFor)(Te, Fe), Fe < 32)
                W |= 1 << Fe;
              else if (Fe < 64)
                oe |= 1 << Fe - 32;
              else if (Fe < 96)
                ue |= 1 << Fe - 64;
              else if (Fe < 123)
                pe |= 1 << Fe - 96;
              else
                throw new n.FormatError("Unicode ranges Bits > 123 are reserved for internal usage");
            Ce > 65535 && (Ce = 65535);
          } else
            ve = 0, Ce = 255;
          const Pe = z.bbox || [0, 0, 0, 0], be = ne.unitsPerEm || 1 / (z.fontMatrix || n.FONT_IDENTITY_MATRIX)[0], me = z.ascentScaled ? 1 : be / k, we = ne.ascent || Math.round(me * (z.ascent || Pe[3]));
          let _e = ne.descent || Math.round(me * (z.descent || Pe[1]));
          _e > 0 && z.descent > 0 && Pe[1] < 0 && (_e = -_e);
          const Se = ne.yMax || we, Ae = -ne.yMin || -_e;
          return "\0$ô\0\0\0»\0\0\0»\0\0ß\x001\0\0\0\0" + String.fromCharCode(z.fixedPitch ? 9 : 0) + "\0\0\0\0\0\0" + (0, n.string32)(W) + (0, n.string32)(oe) + (0, n.string32)(ue) + (0, n.string32)(pe) + "*21*" + D(z.italicAngle ? 1 : 0) + D(ve || z.firstChar) + D(Ce || z.lastChar) + D(we) + D(_e) + "\0d" + D(Se) + D(Ae) + "\0\0\0\0\0\0\0\0" + D(z.xHeight) + D(z.capHeight) + D(0) + D(ve || z.firstChar) + "\0";
        }
        function J(z) {
          const ie = Math.floor(z.italicAngle * 65536);
          return "\0\0\0" + (0, n.string32)(ie) + "\0\0\0\0" + (0, n.string32)(z.fixedPitch ? 1 : 0) + "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
        }
        function Y(z) {
          return z.replaceAll(/[^\x21-\x7E]|[[\](){}<>/%]/g, "").slice(0, 63);
        }
        function ae(z, ie) {
          ie || (ie = [[], []]);
          const ne = [ie[0][0] || "Original licence", ie[0][1] || z, ie[0][2] || "Unknown", ie[0][3] || "uniqueID", ie[0][4] || z, ie[0][5] || "Version 0.11", ie[0][6] || Y(z), ie[0][7] || "Unknown", ie[0][8] || "Unknown", ie[0][9] || "Unknown"], W = [];
          let oe, ue, pe, ve, Ce;
          for (oe = 0, ue = ne.length; oe < ue; oe++) {
            Ce = ie[1][oe] || ne[oe];
            const Ae = [];
            for (pe = 0, ve = Ce.length; pe < ve; pe++)
              Ae.push(D(Ce.charCodeAt(pe)));
            W.push(Ae.join(""));
          }
          const Fe = [ne, W], Pe = ["\0", "\0"], be = ["\0\0", "\0"], me = ["\0\0", "	"], we = ne.length * Pe.length;
          let _e = "\0\0" + D(we) + D(we * 12 + 6), Se = 0;
          for (oe = 0, ue = Pe.length; oe < ue; oe++) {
            const Ae = Fe[oe];
            for (pe = 0, ve = Ae.length; pe < ve; pe++) {
              Ce = Ae[pe];
              const Te = Pe[oe] + be[oe] + me[oe] + D(pe) + D(Ce.length) + D(Se);
              _e += Te, Se += Ce.length;
            }
          }
          return _e += ne.join("") + W.join(""), _e;
        }
        class se {
          constructor(ie, ne, W) {
            var Fe;
            this.name = ie, this.psName = null, this.mimetype = null, this.disableFontFace = !1, this.loadedName = W.loadedName, this.isType3Font = W.isType3Font, this.missingFile = !1, this.cssFontInfo = W.cssFontInfo, this._charsCache = /* @__PURE__ */ Object.create(null), this._glyphCache = /* @__PURE__ */ Object.create(null);
            let oe = !!(W.flags & C.FontFlags.Serif);
            if (!oe && !W.isSimulatedFlags) {
              const Pe = ie.replaceAll(/[,_]/g, "-").split("-")[0], be = (0, j.getSerifFonts)();
              for (const me of Pe.split("+"))
                if (be[me]) {
                  oe = !0;
                  break;
                }
            }
            this.isSerifFont = oe, this.isSymbolicFont = !!(W.flags & C.FontFlags.Symbolic), this.isMonospace = !!(W.flags & C.FontFlags.FixedPitch);
            let {
              type: ue,
              subtype: pe
            } = W;
            this.type = ue, this.subtype = pe, this.systemFontInfo = W.systemFontInfo;
            const ve = ie.match(/^InvalidPDFjsFont_(.*)_\d+$/);
            if (this.isInvalidPDFjsFont = !!ve, this.isInvalidPDFjsFont ? this.fallbackName = ve[1] : this.isMonospace ? this.fallbackName = "monospace" : this.isSerifFont ? this.fallbackName = "serif" : this.fallbackName = "sans-serif", (Fe = this.systemFontInfo) != null && Fe.guessFallback && (this.systemFontInfo.guessFallback = !1, this.systemFontInfo.css += `,${this.fallbackName}`), this.differences = W.differences, this.widths = W.widths, this.defaultWidth = W.defaultWidth, this.composite = W.composite, this.cMap = W.cMap, this.capHeight = W.capHeight / k, this.ascent = W.ascent / k, this.descent = W.descent / k, this.lineHeight = this.ascent - this.descent, this.fontMatrix = W.fontMatrix, this.bbox = W.bbox, this.defaultEncoding = W.defaultEncoding, this.toUnicode = W.toUnicode, this.toFontChar = [], W.type === "Type3") {
              for (let Pe = 0; Pe < 256; Pe++)
                this.toFontChar[Pe] = this.differences[Pe] || W.defaultEncoding[Pe];
              return;
            }
            if (this.cidEncoding = W.cidEncoding || "", this.vertical = !!W.vertical, this.vertical && (this.vmetrics = W.vmetrics, this.defaultVMetrics = W.defaultVMetrics), !ne || ne.isEmpty) {
              ne && (0, n.warn)('Font file is empty in "' + ie + '" (' + this.loadedName + ")"), this.fallbackToSystemFont(W);
              return;
            }
            [ue, pe] = y(ne, W), (ue !== this.type || pe !== this.subtype) && (0, n.info)(`Inconsistent font file Type/SubType, expected: ${this.type}/${this.subtype} but found: ${ue}/${pe}.`);
            let Ce;
            try {
              switch (ue) {
                case "MMType1":
                  (0, n.info)("MMType1 font (" + ie + "), falling back to Type1.");
                case "Type1":
                case "CIDFontType0":
                  this.mimetype = "font/opentype";
                  const Pe = pe === "Type1C" || pe === "CIDFontType0C" ? new O.CFFFont(ne, W) : new I.Type1Font(ie, ne, W);
                  R(W), Ce = this.convert(ie, Pe, W);
                  break;
                case "OpenType":
                case "TrueType":
                case "CIDFontType2":
                  this.mimetype = "font/opentype", Ce = this.checkAndRepair(ie, ne, W), this.isOpenType && (R(W), ue = "OpenType");
                  break;
                default:
                  throw new n.FormatError(`Font ${ue} is not supported`);
              }
            } catch (Pe) {
              (0, n.warn)(Pe), this.fallbackToSystemFont(W);
              return;
            }
            N(W), this.data = Ce, this.type = ue, this.subtype = pe, this.fontMatrix = W.fontMatrix, this.widths = W.widths, this.defaultWidth = W.defaultWidth, this.toUnicode = W.toUnicode, this.seacMap = W.seacMap;
          }
          get renderer() {
            const ie = v.FontRendererFactory.create(this, C.SEAC_ANALYSIS_ENABLED);
            return (0, n.shadow)(this, "renderer", ie);
          }
          exportData(ie = !1) {
            const ne = ie ? [...H, ...x] : H, W = /* @__PURE__ */ Object.create(null);
            let oe, ue;
            for (oe of ne)
              ue = this[oe], ue !== void 0 && (W[oe] = ue);
            return W;
          }
          fallbackToSystemFont(ie) {
            this.missingFile = !0;
            const {
              name: ne,
              type: W
            } = this;
            let oe = (0, C.normalizeFontName)(ne);
            const ue = (0, j.getStdFontMap)(), pe = (0, j.getNonStdFontMap)(), ve = !!ue[oe], Ce = !!(pe[oe] && ue[pe[oe]]);
            oe = ue[oe] || pe[oe] || oe;
            const Pe = (0, g.getFontBasicMetrics)()[oe];
            Pe && (isNaN(this.ascent) && (this.ascent = Pe.ascent / k), isNaN(this.descent) && (this.descent = Pe.descent / k), isNaN(this.capHeight) && (this.capHeight = Pe.capHeight / k)), this.bold = /bold/gi.test(oe), this.italic = /oblique|italic/gi.test(oe), this.black = /Black/g.test(ne);
            const be = /Narrow/g.test(ne);
            if (this.remeasure = (!ve || be) && Object.keys(this.widths).length > 0, (ve || Ce) && W === "CIDFontType2" && this.cidEncoding.startsWith("Identity-")) {
              const me = ie.cidToGidMap, we = [];
              if (M(we, (0, j.getGlyphMapForStandardFonts)()), /Arial-?Black/i.test(ne) ? M(we, (0, j.getSupplementalGlyphMapForArialBlack)()) : /Calibri/i.test(ne) && M(we, (0, j.getSupplementalGlyphMapForCalibri)()), me) {
                for (const _e in we) {
                  const Se = we[_e];
                  me[Se] !== void 0 && (we[+_e] = me[Se]);
                }
                me.length !== this.toUnicode.length && ie.hasIncludedToUnicodeMap && this.toUnicode instanceof U.IdentityToUnicodeMap && this.toUnicode.forEach(function(_e, Se) {
                  const Ae = we[_e];
                  me[Ae] === void 0 && (we[+_e] = Se);
                });
              }
              this.toUnicode instanceof U.IdentityToUnicodeMap || this.toUnicode.forEach(function(_e, Se) {
                we[+_e] = Se;
              }), this.toFontChar = we, this.toUnicode = new U.ToUnicodeMap(we);
            } else if (/Symbol/i.test(oe))
              this.toFontChar = $(l.SymbolSetEncoding, (0, t.getGlyphsUnicode)(), this.differences);
            else if (/Dingbats/i.test(oe))
              this.toFontChar = $(l.ZapfDingbatsEncoding, (0, t.getDingbatsGlyphsUnicode)(), this.differences);
            else if (ve) {
              const me = $(this.defaultEncoding, (0, t.getGlyphsUnicode)(), this.differences);
              W === "CIDFontType2" && !this.cidEncoding.startsWith("Identity-") && !(this.toUnicode instanceof U.IdentityToUnicodeMap) && this.toUnicode.forEach(function(we, _e) {
                me[+we] = _e;
              }), this.toFontChar = me;
            } else {
              const me = (0, t.getGlyphsUnicode)(), we = [];
              this.toUnicode.forEach((_e, Se) => {
                if (!this.composite) {
                  const Ae = this.differences[_e] || this.defaultEncoding[_e], Te = (0, e.getUnicodeForGlyph)(Ae, me);
                  Te !== -1 && (Se = Te);
                }
                we[+_e] = Se;
              }), this.composite && this.toUnicode instanceof U.IdentityToUnicodeMap && /Tahoma|Verdana/i.test(ne) && M(we, (0, j.getGlyphMapForStandardFonts)()), this.toFontChar = we;
            }
            N(ie), this.loadedName = oe.split("-")[0];
          }
          checkAndRepair(ie, ne, W) {
            var nt, ut, bt;
            const oe = ["OS/2", "cmap", "head", "hhea", "hmtx", "maxp", "name", "post", "loca", "glyf", "fpgm", "prep", "cvt ", "CFF "];
            function ue(Ge, We) {
              const Je = /* @__PURE__ */ Object.create(null);
              Je["OS/2"] = null, Je.cmap = null, Je.head = null, Je.hhea = null, Je.hmtx = null, Je.maxp = null, Je.name = null, Je.post = null;
              for (let et = 0; et < We; et++) {
                const lt = pe(Ge);
                oe.includes(lt.tag) && lt.length !== 0 && (Je[lt.tag] = lt);
              }
              return Je;
            }
            function pe(Ge) {
              const We = Ge.getString(4), Je = Ge.getInt32() >>> 0, et = Ge.getInt32() >>> 0, lt = Ge.getInt32() >>> 0, pt = Ge.pos;
              Ge.pos = Ge.start || 0, Ge.skip(et);
              const ot = Ge.getBytes(lt);
              return Ge.pos = pt, We === "head" && (ot[8] = ot[9] = ot[10] = ot[11] = 0, ot[17] |= 32), {
                tag: We,
                checksum: Je,
                length: lt,
                offset: et,
                data: ot
              };
            }
            function ve(Ge) {
              return {
                version: Ge.getString(4),
                numTables: Ge.getUint16(),
                searchRange: Ge.getUint16(),
                entrySelector: Ge.getUint16(),
                rangeShift: Ge.getUint16()
              };
            }
            function Ce(Ge) {
              const We = Ge.getString(4);
              (0, n.assert)(We === "ttcf", "Must be a TrueType Collection font.");
              const Je = Ge.getUint16(), et = Ge.getUint16(), lt = Ge.getInt32() >>> 0, pt = [];
              for (let st = 0; st < lt; st++)
                pt.push(Ge.getInt32() >>> 0);
              const ot = {
                ttcTag: We,
                majorVersion: Je,
                minorVersion: et,
                numFonts: lt,
                offsetTable: pt
              };
              switch (Je) {
                case 1:
                  return ot;
                case 2:
                  return ot.dsigTag = Ge.getInt32() >>> 0, ot.dsigLength = Ge.getInt32() >>> 0, ot.dsigOffset = Ge.getInt32() >>> 0, ot;
              }
              throw new n.FormatError(`Invalid TrueType Collection majorVersion: ${Je}.`);
            }
            function Fe(Ge, We) {
              var ot;
              const {
                numFonts: Je,
                offsetTable: et
              } = Ce(Ge), lt = We.split("+");
              let pt;
              for (let st = 0; st < Je; st++) {
                Ge.pos = (Ge.start || 0) + et[st];
                const gt = ve(Ge), vt = ue(Ge, gt.numTables);
                if (!vt.name)
                  throw new n.FormatError('TrueType Collection font must contain a "name" table.');
                const [Mt] = Ae(vt.name);
                for (let At = 0, St = Mt.length; At < St; At++)
                  for (let Et = 0, mt = Mt[At].length; Et < mt; Et++) {
                    const Ct = (ot = Mt[At][Et]) == null ? void 0 : ot.replaceAll(/\s/g, "");
                    if (Ct) {
                      if (Ct === We)
                        return {
                          header: gt,
                          tables: vt
                        };
                      if (!(lt.length < 2))
                        for (const ft of lt)
                          Ct === ft && (pt = {
                            name: ft,
                            header: gt,
                            tables: vt
                          });
                    }
                  }
              }
              if (pt)
                return (0, n.warn)(`TrueType Collection does not contain "${We}" font, falling back to "${pt.name}" font instead.`), {
                  header: pt.header,
                  tables: pt.tables
                };
              throw new n.FormatError(`TrueType Collection does not contain "${We}" font.`);
            }
            function Pe(Ge, We, Je, et) {
              if (!Ge)
                return (0, n.warn)("No cmap table available."), {
                  platformId: -1,
                  encodingId: -1,
                  mappings: [],
                  hasShortCmap: !1
                };
              let lt, pt = (We.start || 0) + Ge.offset;
              We.pos = pt, We.skip(2);
              const ot = We.getUint16();
              let st, gt = !1;
              for (let mt = 0; mt < ot; mt++) {
                const Ct = We.getUint16(), ft = We.getUint16(), Tt = We.getInt32() >>> 0;
                let _t = !1;
                if (!((st == null ? void 0 : st.platformId) === Ct && (st == null ? void 0 : st.encodingId) === ft)) {
                  if (Ct === 0 && (ft === 0 || ft === 1 || ft === 3))
                    _t = !0;
                  else if (Ct === 1 && ft === 0)
                    _t = !0;
                  else if (Ct === 3 && ft === 1 && (et || !st))
                    _t = !0, Je || (gt = !0);
                  else if (Je && Ct === 3 && ft === 0) {
                    _t = !0;
                    let Xt = !0;
                    if (mt < ot - 1) {
                      const kt = We.peekBytes(2);
                      p(kt[0], kt[1]) < Ct && (Xt = !1);
                    }
                    Xt && (gt = !0);
                  }
                  if (_t && (st = {
                    platformId: Ct,
                    encodingId: ft,
                    offset: Tt
                  }), gt)
                    break;
                }
              }
              if (st && (We.pos = pt + st.offset), !st || We.peekByte() === -1)
                return (0, n.warn)("Could not find a preferred cmap table."), {
                  platformId: -1,
                  encodingId: -1,
                  mappings: [],
                  hasShortCmap: !1
                };
              const vt = We.getUint16();
              let Mt = !1;
              const At = [];
              let St, Et;
              if (vt === 0) {
                for (We.skip(4), St = 0; St < 256; St++) {
                  const mt = We.getByte();
                  mt && At.push({
                    charCode: St,
                    glyphId: mt
                  });
                }
                Mt = !0;
              } else if (vt === 2) {
                We.skip(4);
                const mt = [];
                let Ct = 0;
                for (let Tt = 0; Tt < 256; Tt++) {
                  const _t = We.getUint16() >> 3;
                  mt.push(_t), Ct = Math.max(_t, Ct);
                }
                const ft = [];
                for (let Tt = 0; Tt <= Ct; Tt++)
                  ft.push({
                    firstCode: We.getUint16(),
                    entryCount: We.getUint16(),
                    idDelta: B(We.getByte(), We.getByte()),
                    idRangePos: We.pos + We.getUint16()
                  });
                for (let Tt = 0; Tt < 256; Tt++)
                  if (mt[Tt] === 0)
                    We.pos = ft[0].idRangePos + 2 * Tt, Et = We.getUint16(), At.push({
                      charCode: Tt,
                      glyphId: Et
                    });
                  else {
                    const _t = ft[mt[Tt]];
                    for (St = 0; St < _t.entryCount; St++) {
                      const Xt = (Tt << 8) + St + _t.firstCode;
                      We.pos = _t.idRangePos + 2 * St, Et = We.getUint16(), Et !== 0 && (Et = (Et + _t.idDelta) % 65536), At.push({
                        charCode: Xt,
                        glyphId: Et
                      });
                    }
                  }
              } else if (vt === 4) {
                We.skip(4);
                const mt = We.getUint16() >> 1;
                We.skip(6);
                const Ct = [];
                let ft;
                for (ft = 0; ft < mt; ft++)
                  Ct.push({
                    end: We.getUint16()
                  });
                for (We.skip(2), ft = 0; ft < mt; ft++)
                  Ct[ft].start = We.getUint16();
                for (ft = 0; ft < mt; ft++)
                  Ct[ft].delta = We.getUint16();
                let Tt = 0, _t;
                for (ft = 0; ft < mt; ft++) {
                  lt = Ct[ft];
                  const kt = We.getUint16();
                  if (!kt) {
                    lt.offsetIndex = -1;
                    continue;
                  }
                  _t = (kt >> 1) - (mt - ft), lt.offsetIndex = _t, Tt = Math.max(Tt, _t + lt.end - lt.start + 1);
                }
                const Xt = [];
                for (St = 0; St < Tt; St++)
                  Xt.push(We.getUint16());
                for (ft = 0; ft < mt; ft++) {
                  lt = Ct[ft], pt = lt.start;
                  const kt = lt.end, Ft = lt.delta;
                  for (_t = lt.offsetIndex, St = pt; St <= kt; St++)
                    St !== 65535 && (Et = _t < 0 ? St : Xt[_t + St - pt], Et = Et + Ft & 65535, At.push({
                      charCode: St,
                      glyphId: Et
                    }));
                }
              } else if (vt === 6) {
                We.skip(4);
                const mt = We.getUint16(), Ct = We.getUint16();
                for (St = 0; St < Ct; St++) {
                  Et = We.getUint16();
                  const ft = mt + St;
                  At.push({
                    charCode: ft,
                    glyphId: Et
                  });
                }
              } else if (vt === 12) {
                We.skip(10);
                const mt = We.getInt32() >>> 0;
                for (St = 0; St < mt; St++) {
                  const Ct = We.getInt32() >>> 0, ft = We.getInt32() >>> 0;
                  let Tt = We.getInt32() >>> 0;
                  for (let _t = Ct; _t <= ft; _t++)
                    At.push({
                      charCode: _t,
                      glyphId: Tt++
                    });
                }
              } else
                return (0, n.warn)("cmap table has unsupported format: " + vt), {
                  platformId: -1,
                  encodingId: -1,
                  mappings: [],
                  hasShortCmap: !1
                };
              At.sort(function(mt, Ct) {
                return mt.charCode - Ct.charCode;
              });
              for (let mt = 1; mt < At.length; mt++)
                At[mt - 1].charCode === At[mt].charCode && (At.splice(mt, 1), mt--);
              return {
                platformId: st.platformId,
                encodingId: st.encodingId,
                mappings: At,
                hasShortCmap: Mt
              };
            }
            function be(Ge, We, Je, et, lt, pt) {
              if (!We) {
                Je && (Je.data = null);
                return;
              }
              Ge.pos = (Ge.start || 0) + We.offset, Ge.pos += 4, Ge.pos += 2, Ge.pos += 2, Ge.pos += 2, Ge.pos += 2, Ge.pos += 2, Ge.pos += 2, Ge.pos += 2, Ge.pos += 2, Ge.pos += 2;
              const ot = Ge.getUint16();
              Ge.pos += 8, Ge.pos += 2;
              let st = Ge.getUint16();
              ot !== 0 && (p(et.data[44], et.data[45]) & 2 || (We.data[22] = 0, We.data[23] = 0)), st > lt && ((0, n.info)(`The numOfMetrics (${st}) should not be greater than the numGlyphs (${lt}).`), st = lt, We.data[34] = (st & 65280) >> 8, We.data[35] = st & 255);
              const vt = lt - st - (Je.length - st * 4 >> 1);
              if (vt > 0) {
                const Mt = new Uint8Array(Je.length + vt * 2);
                Mt.set(Je.data), pt && (Mt[Je.length] = Je.data[2], Mt[Je.length + 1] = Je.data[3]), Je.data = Mt;
              }
            }
            function me(Ge, We, Je, et, lt, pt) {
              const ot = {
                length: 0,
                sizeOfInstructions: 0
              };
              if (We < 0 || We >= Ge.length || Je > Ge.length || Je - We <= 12)
                return ot;
              const st = Ge.subarray(We, Je), gt = B(st[2], st[3]), vt = B(st[4], st[5]), Mt = B(st[6], st[7]), At = B(st[8], st[9]);
              gt > Mt && (S(st, 2, Mt), S(st, 6, gt)), vt > At && (S(st, 4, At), S(st, 8, vt));
              const St = B(st[0], st[1]);
              if (St < 0)
                return St < -1 || (et.set(st, lt), ot.length = st.length), ot;
              let Et, mt = 10, Ct = 0;
              for (Et = 0; Et < St; Et++)
                Ct = (st[mt] << 8 | st[mt + 1]) + 1, mt += 2;
              const ft = mt, Tt = st[mt] << 8 | st[mt + 1];
              ot.sizeOfInstructions = Tt, mt += 2 + Tt;
              const _t = mt;
              let Xt = 0;
              for (Et = 0; Et < Ct; Et++) {
                const Ft = st[mt++];
                Ft & 192 && (st[mt - 1] = Ft & 63);
                let Lt = 2;
                Ft & 2 ? Lt = 1 : Ft & 16 && (Lt = 0);
                let jt = 2;
                Ft & 4 ? jt = 1 : Ft & 32 && (jt = 0);
                const qt = Lt + jt;
                if (Xt += qt, Ft & 8) {
                  const dn = st[mt++];
                  dn === 0 && (st[mt - 1] ^= 8), Et += dn, Xt += dn * qt;
                }
              }
              if (Xt === 0)
                return ot;
              let kt = mt + Xt;
              return kt > st.length ? ot : !pt && Tt > 0 ? (et.set(st.subarray(0, ft), lt), et.set([0, 0], lt + ft), et.set(st.subarray(_t, kt), lt + ft + 2), kt -= Tt, st.length - kt > 3 && (kt = kt + 3 & -4), ot.length = kt, ot) : st.length - kt > 3 ? (kt = kt + 3 & -4, et.set(st.subarray(0, kt), lt), ot.length = kt, ot) : (et.set(st, lt), ot.length = st.length, ot);
            }
            function we(Ge, We, Je) {
              const et = Ge.data, lt = T(et[0], et[1], et[2], et[3]);
              lt >> 16 !== 1 && ((0, n.info)("Attempting to fix invalid version in head table: " + lt), et[0] = 0, et[1] = 1, et[2] = 0, et[3] = 0);
              const pt = p(et[50], et[51]);
              if (pt < 0 || pt > 1) {
                (0, n.info)("Attempting to fix invalid indexToLocFormat in head table: " + pt);
                const ot = We + 1;
                if (Je === ot << 1)
                  et[50] = 0, et[51] = 0;
                else if (Je === ot << 2)
                  et[50] = 0, et[51] = 1;
                else
                  throw new n.FormatError("Could not fix indexToLocFormat: " + pt);
              }
            }
            function _e(Ge, We, Je, et, lt, pt, ot) {
              let st, gt, vt;
              et ? (st = 4, gt = function(Lt, jt) {
                return Lt[jt] << 24 | Lt[jt + 1] << 16 | Lt[jt + 2] << 8 | Lt[jt + 3];
              }, vt = function(Lt, jt, qt) {
                Lt[jt] = qt >>> 24 & 255, Lt[jt + 1] = qt >> 16 & 255, Lt[jt + 2] = qt >> 8 & 255, Lt[jt + 3] = qt & 255;
              }) : (st = 2, gt = function(Lt, jt) {
                return Lt[jt] << 9 | Lt[jt + 1] << 1;
              }, vt = function(Lt, jt, qt) {
                Lt[jt] = qt >> 9 & 255, Lt[jt + 1] = qt >> 1 & 255;
              });
              const Mt = pt ? Je + 1 : Je, At = st * (1 + Mt), St = new Uint8Array(At);
              St.set(Ge.data.subarray(0, At)), Ge.data = St;
              const Et = We.data, mt = Et.length, Ct = new Uint8Array(mt);
              let ft, Tt;
              const _t = [];
              for (ft = 0, Tt = 0; ft < Je + 1; ft++, Tt += st) {
                let Ft = gt(St, Tt);
                Ft > mt && (Ft = mt), _t.push({
                  index: ft,
                  offset: Ft,
                  endOffset: 0
                });
              }
              for (_t.sort((Ft, Lt) => Ft.offset - Lt.offset), ft = 0; ft < Je; ft++)
                _t[ft].endOffset = _t[ft + 1].offset;
              for (_t.sort((Ft, Lt) => Ft.index - Lt.index), ft = 0; ft < Je; ft++) {
                const {
                  offset: Ft,
                  endOffset: Lt
                } = _t[ft];
                if (Ft !== 0 || Lt !== 0)
                  break;
                const jt = _t[ft + 1].offset;
                if (jt !== 0) {
                  _t[ft].endOffset = jt;
                  break;
                }
              }
              const Xt = /* @__PURE__ */ Object.create(null);
              let kt = 0;
              for (vt(St, 0, kt), ft = 0, Tt = st; ft < Je; ft++, Tt += st) {
                const Ft = me(Et, _t[ft].offset, _t[ft].endOffset, Ct, kt, lt), Lt = Ft.length;
                Lt === 0 && (Xt[ft] = !0), Ft.sizeOfInstructions > ot && (ot = Ft.sizeOfInstructions), kt += Lt, vt(St, Tt, kt);
              }
              if (kt === 0) {
                const Ft = new Uint8Array([0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0]);
                for (ft = 0, Tt = st; ft < Mt; ft++, Tt += st)
                  vt(St, Tt, Ft.length);
                We.data = Ft;
              } else if (pt) {
                const Ft = gt(St, st);
                Ct.length > Ft + kt ? We.data = Ct.subarray(0, Ft + kt) : (We.data = new Uint8Array(Ft + kt), We.data.set(Ct.subarray(0, kt))), We.data.set(Ct.subarray(0, Ft), kt), vt(Ge.data, St.length - st, kt + Ft);
              } else
                We.data = Ct.subarray(0, kt);
              return {
                missingGlyphs: Xt,
                maxSizeOfInstructions: ot
              };
            }
            function Se(Ge, We, Je) {
              const et = (ne.start || 0) + Ge.offset;
              ne.pos = et;
              const lt = Ge.length, pt = et + lt, ot = ne.getInt32();
              ne.skip(28);
              let st, gt = !0, vt;
              switch (ot) {
                case 65536:
                  st = C.MacStandardGlyphOrdering;
                  break;
                case 131072:
                  const Mt = ne.getUint16();
                  if (Mt !== Je) {
                    gt = !1;
                    break;
                  }
                  const At = [];
                  for (vt = 0; vt < Mt; ++vt) {
                    const mt = ne.getUint16();
                    if (mt >= 32768) {
                      gt = !1;
                      break;
                    }
                    At.push(mt);
                  }
                  if (!gt)
                    break;
                  const St = [], Et = [];
                  for (; ne.pos < pt; ) {
                    const mt = ne.getByte();
                    for (Et.length = mt, vt = 0; vt < mt; ++vt)
                      Et[vt] = String.fromCharCode(ne.getByte());
                    St.push(Et.join(""));
                  }
                  for (st = [], vt = 0; vt < Mt; ++vt) {
                    const mt = At[vt];
                    if (mt < 258) {
                      st.push(C.MacStandardGlyphOrdering[mt]);
                      continue;
                    }
                    st.push(St[mt - 258]);
                  }
                  break;
                case 196608:
                  break;
                default:
                  (0, n.warn)("Unknown/unsupported post table version " + ot), gt = !1, We.defaultEncoding && (st = We.defaultEncoding);
                  break;
              }
              return We.glyphNames = st, gt;
            }
            function Ae(Ge) {
              const We = (ne.start || 0) + Ge.offset;
              ne.pos = We;
              const Je = [[], []], et = [], lt = Ge.length, pt = We + lt;
              if (ne.getUint16() !== 0 || lt < 6)
                return [Je, et];
              const gt = ne.getUint16(), vt = ne.getUint16(), Mt = 12;
              let At, St;
              for (At = 0; At < gt && ne.pos + Mt <= pt; At++) {
                const Et = {
                  platform: ne.getUint16(),
                  encoding: ne.getUint16(),
                  language: ne.getUint16(),
                  name: ne.getUint16(),
                  length: ne.getUint16(),
                  offset: ne.getUint16()
                };
                (G(Et) || ce(Et)) && et.push(Et);
              }
              for (At = 0, St = et.length; At < St; At++) {
                const Et = et[At];
                if (Et.length <= 0)
                  continue;
                const mt = We + vt + Et.offset;
                if (mt + Et.length > pt)
                  continue;
                ne.pos = mt;
                const Ct = Et.name;
                if (Et.encoding) {
                  let ft = "";
                  for (let Tt = 0, _t = Et.length; Tt < _t; Tt += 2)
                    ft += String.fromCharCode(ne.getUint16());
                  Je[1][Ct] = ft;
                } else
                  Je[0][Ct] = ne.getString(Et.length);
              }
              return [Je, et];
            }
            const Te = [0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1, 0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2, 0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1, -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];
            function ke(Ge, We) {
              let Je = Ge.data, et = 0, lt, pt, ot, st, gt, vt = 0, Mt = 0;
              const At = [], St = [], Et = [];
              let mt = We.tooComplexToFollowFunctions, Ct = !1, ft = 0, Tt = 0;
              for (let Xt = Je.length; et < Xt; ) {
                const kt = Je[et++];
                if (kt === 64)
                  if (pt = Je[et++], Ct || Tt)
                    et += pt;
                  else
                    for (lt = 0; lt < pt; lt++)
                      At.push(Je[et++]);
                else if (kt === 65)
                  if (pt = Je[et++], Ct || Tt)
                    et += pt * 2;
                  else
                    for (lt = 0; lt < pt; lt++)
                      ot = Je[et++], At.push(ot << 8 | Je[et++]);
                else if ((kt & 248) === 176)
                  if (pt = kt - 176 + 1, Ct || Tt)
                    et += pt;
                  else
                    for (lt = 0; lt < pt; lt++)
                      At.push(Je[et++]);
                else if ((kt & 248) === 184)
                  if (pt = kt - 184 + 1, Ct || Tt)
                    et += pt * 2;
                  else
                    for (lt = 0; lt < pt; lt++)
                      ot = Je[et++], At.push(ot << 8 | Je[et++]);
                else if (kt === 43 && !mt) {
                  if (!Ct && !Tt) {
                    if (st = At.at(-1), isNaN(st))
                      (0, n.info)("TT: CALL empty stack (or invalid entry).");
                    else if (We.functionsUsed[st] = !0, st in We.functionsStackDeltas) {
                      const Ft = At.length + We.functionsStackDeltas[st];
                      if (Ft < 0) {
                        (0, n.warn)("TT: CALL invalid functions stack delta."), We.hintsValid = !1;
                        return;
                      }
                      At.length = Ft;
                    } else if (st in We.functionsDefined && !Et.includes(st)) {
                      if (St.push({
                        data: Je,
                        i: et,
                        stackTop: At.length - 1
                      }), Et.push(st), gt = We.functionsDefined[st], !gt) {
                        (0, n.warn)("TT: CALL non-existent function"), We.hintsValid = !1;
                        return;
                      }
                      Je = gt.data, et = gt.i;
                    }
                  }
                } else if (kt === 44 && !mt)
                  (Ct || Tt) && ((0, n.warn)("TT: nested FDEFs not allowed"), mt = !0), Ct = !0, Mt = et, st = At.pop(), We.functionsDefined[st] = {
                    data: Je,
                    i: et
                  };
                else if (kt === 45)
                  if (Ct)
                    Ct = !1, vt = et;
                  else {
                    if (gt = St.pop(), !gt) {
                      (0, n.warn)("TT: ENDF bad stack"), We.hintsValid = !1;
                      return;
                    }
                    st = Et.pop(), Je = gt.data, et = gt.i, We.functionsStackDeltas[st] = At.length - gt.stackTop;
                  }
                else if (kt === 137)
                  (Ct || Tt) && ((0, n.warn)("TT: nested IDEFs not allowed"), mt = !0), Ct = !0, Mt = et;
                else if (kt === 88)
                  ++ft;
                else if (kt === 27)
                  Tt = ft;
                else if (kt === 89)
                  Tt === ft && (Tt = 0), --ft;
                else if (kt === 28 && !Ct && !Tt) {
                  const Ft = At.at(-1);
                  Ft > 0 && (et += Ft - 1);
                }
                if (!Ct && !Tt) {
                  let Ft = 0;
                  for (kt <= 142 ? Ft = Te[kt] : kt >= 192 && kt <= 223 ? Ft = -1 : kt >= 224 && (Ft = -2), kt >= 113 && kt <= 117 && (pt = At.pop(), isNaN(pt) || (Ft = -pt * 2)); Ft < 0 && At.length > 0; )
                    At.pop(), Ft++;
                  for (; Ft > 0; )
                    At.push(NaN), Ft--;
                }
              }
              We.tooComplexToFollowFunctions = mt;
              const _t = [Je];
              et > Je.length && _t.push(new Uint8Array(et - Je.length)), Mt > vt && ((0, n.warn)("TT: complementing a missing function tail"), _t.push(new Uint8Array([34, 45]))), Ve(Ge, _t);
            }
            function Ee(Ge, We) {
              if (!Ge.tooComplexToFollowFunctions) {
                if (Ge.functionsDefined.length > We) {
                  (0, n.warn)("TT: more functions defined than expected"), Ge.hintsValid = !1;
                  return;
                }
                for (let Je = 0, et = Ge.functionsUsed.length; Je < et; Je++) {
                  if (Je > We) {
                    (0, n.warn)("TT: invalid function id: " + Je), Ge.hintsValid = !1;
                    return;
                  }
                  if (Ge.functionsUsed[Je] && !Ge.functionsDefined[Je]) {
                    (0, n.warn)("TT: undefined function: " + Je), Ge.hintsValid = !1;
                    return;
                  }
                }
              }
            }
            function Ve(Ge, We) {
              if (We.length > 1) {
                let Je = 0, et, lt;
                for (et = 0, lt = We.length; et < lt; et++)
                  Je += We[et].length;
                Je = Je + 3 & -4;
                const pt = new Uint8Array(Je);
                let ot = 0;
                for (et = 0, lt = We.length; et < lt; et++)
                  pt.set(We[et], ot), ot += We[et].length;
                Ge.data = pt, Ge.length = Je;
              }
            }
            function je(Ge, We, Je, et) {
              const lt = {
                functionsDefined: [],
                functionsUsed: [],
                functionsStackDeltas: [],
                tooComplexToFollowFunctions: !1,
                hintsValid: !0
              };
              if (Ge && ke(Ge, lt), We && ke(We, lt), Ge && Ee(lt, et), Je && Je.length & 1) {
                const pt = new Uint8Array(Je.length + 1);
                pt.set(Je.data), Je.data = pt;
              }
              return lt.hintsValid;
            }
            ne = new A.Stream(new Uint8Array(ne.getBytes()));
            let at, $e;
            if (o(ne)) {
              const Ge = Fe(ne, this.name);
              at = Ge.header, $e = Ge.tables;
            } else
              at = ve(ne), $e = ue(ne, at.numTables);
            let ct, ze;
            const Ye = !$e["CFF "];
            if (Ye) {
              if (!$e.loca)
                throw new n.FormatError('Required "loca" table is not found');
              $e.glyf || ((0, n.warn)('Required "glyf" table is not found -- trying to recover.'), $e.glyf = {
                tag: "glyf",
                data: new Uint8Array(0)
              }), this.isOpenType = !1;
            } else {
              const Ge = W.composite && (((nt = W.cidToGidMap) == null ? void 0 : nt.length) > 0 || !(W.cMap instanceof i.IdentityCMap));
              if (at.version === "OTTO" && !Ge || !$e.head || !$e.hhea || !$e.maxp || !$e.post)
                return ze = new A.Stream($e["CFF "].data), ct = new O.CFFFont(ze, W), R(W), this.convert(ie, ct, W);
              delete $e.glyf, delete $e.loca, delete $e.fpgm, delete $e.prep, delete $e["cvt "], this.isOpenType = !0;
            }
            if (!$e.maxp)
              throw new n.FormatError('Required "maxp" table is not found');
            ne.pos = (ne.start || 0) + $e.maxp.offset;
            const Qe = ne.getInt32(), Oe = ne.getUint16();
            if (((ut = W.scaleFactors) == null ? void 0 : ut.length) === Oe && Ye) {
              const {
                scaleFactors: Ge
              } = W, We = p($e.head.data[50], $e.head.data[51]), Je = new b.GlyfTable({
                glyfTable: $e.glyf.data,
                isGlyphLocationsLong: We,
                locaTable: $e.loca.data,
                numGlyphs: Oe
              });
              Je.scale(Ge);
              const {
                glyf: et,
                loca: lt,
                isLocationLong: pt
              } = Je.write();
              $e.glyf.data = et, $e.loca.data = lt, pt !== !!We && ($e.head.data[50] = 0, $e.head.data[51] = pt ? 1 : 0);
              const ot = $e.hmtx.data;
              for (let st = 0; st < Oe; st++) {
                const gt = 4 * st, vt = Math.round(Ge[st] * p(ot[gt], ot[gt + 1]));
                ot[gt] = vt >> 8 & 255, ot[gt + 1] = vt & 255;
                const Mt = Math.round(Ge[st] * B(ot[gt + 2], ot[gt + 3]));
                S(ot, gt + 2, Mt);
              }
            }
            let he = Oe + 1, ye = !0;
            he > 65535 && (ye = !1, he = Oe, (0, n.warn)("Not enough space in glyfs to duplicate first glyph."));
            let Ie = 0, Le = 0;
            Qe >= 65536 && $e.maxp.length >= 22 && (ne.pos += 8, ne.getUint16() > 2 && ($e.maxp.data[14] = 0, $e.maxp.data[15] = 2), ne.pos += 4, Ie = ne.getUint16(), ne.pos += 4, Le = ne.getUint16()), $e.maxp.data[4] = he >> 8, $e.maxp.data[5] = he & 255;
            const Be = je($e.fpgm, $e.prep, $e["cvt "], Ie);
            if (Be || (delete $e.fpgm, delete $e.prep, delete $e["cvt "]), be(ne, $e.hhea, $e.hmtx, $e.head, he, ye), !$e.head)
              throw new n.FormatError('Required "head" table is not found');
            we($e.head, Oe, Ye ? $e.loca.length : 0);
            let Ne = /* @__PURE__ */ Object.create(null);
            if (Ye) {
              const Ge = p($e.head.data[50], $e.head.data[51]), We = _e($e.loca, $e.glyf, Oe, Ge, Be, ye, Le);
              Ne = We.missingGlyphs, Qe >= 65536 && $e.maxp.length >= 22 && ($e.maxp.data[26] = We.maxSizeOfInstructions >> 8, $e.maxp.data[27] = We.maxSizeOfInstructions & 255);
            }
            if (!$e.hhea)
              throw new n.FormatError('Required "hhea" table is not found');
            $e.hhea.data[10] === 0 && $e.hhea.data[11] === 0 && ($e.hhea.data[10] = 255, $e.hhea.data[11] = 255);
            const Ue = {
              unitsPerEm: p($e.head.data[18], $e.head.data[19]),
              yMax: B($e.head.data[42], $e.head.data[43]),
              yMin: B($e.head.data[38], $e.head.data[39]),
              ascent: B($e.hhea.data[4], $e.hhea.data[5]),
              descent: B($e.hhea.data[6], $e.hhea.data[7]),
              lineGap: B($e.hhea.data[8], $e.hhea.data[9])
            };
            this.ascent = Ue.ascent / Ue.unitsPerEm, this.descent = Ue.descent / Ue.unitsPerEm, this.lineGap = Ue.lineGap / Ue.unitsPerEm, (bt = this.cssFontInfo) != null && bt.lineHeight ? (this.lineHeight = this.cssFontInfo.metrics.lineHeight, this.lineGap = this.cssFontInfo.metrics.lineGap) : this.lineHeight = this.ascent - this.descent + this.lineGap, $e.post && Se($e.post, W, Oe), $e.post = {
              tag: "post",
              data: J(W)
            };
            const qe = [];
            function tt(Ge) {
              return !Ne[Ge];
            }
            if (W.composite) {
              const Ge = W.cidToGidMap || [], We = Ge.length === 0;
              W.cMap.forEach(function(Je, et) {
                if (typeof et == "string" && (et = q(Je, et, !0)), et > 65535)
                  throw new n.FormatError("Max size of CID is 65,535");
                let lt = -1;
                We ? lt = et : Ge[et] !== void 0 && (lt = Ge[et]), lt >= 0 && lt < Oe && tt(lt) && (qe[Je] = lt);
              });
            } else {
              const Ge = Pe($e.cmap, ne, this.isSymbolicFont, W.hasEncoding), We = Ge.platformId, Je = Ge.encodingId, et = Ge.mappings;
              let lt = [], pt = !1;
              if (W.hasEncoding && (W.baseEncodingName === "MacRomanEncoding" || W.baseEncodingName === "WinAnsiEncoding") && (lt = (0, l.getEncoding)(W.baseEncodingName)), W.hasEncoding && !this.isSymbolicFont && (We === 3 && Je === 1 || We === 1 && Je === 0)) {
                const ot = (0, t.getGlyphsUnicode)();
                for (let st = 0; st < 256; st++) {
                  let gt;
                  if (this.differences[st] !== void 0 ? gt = this.differences[st] : lt.length && lt[st] !== "" ? gt = lt[st] : gt = l.StandardEncoding[st], !gt)
                    continue;
                  const vt = (0, C.recoverGlyphName)(gt, ot);
                  let Mt;
                  if (We === 3 && Je === 1 ? Mt = ot[vt] : We === 1 && Je === 0 && (Mt = l.MacRomanEncoding.indexOf(vt)), Mt === void 0) {
                    if (!W.glyphNames && W.hasIncludedToUnicodeMap && !(this.toUnicode instanceof U.IdentityToUnicodeMap)) {
                      const At = this.toUnicode.get(st);
                      At && (Mt = At.codePointAt(0));
                    }
                    if (Mt === void 0)
                      continue;
                  }
                  for (const At of et)
                    if (At.charCode === Mt) {
                      qe[st] = At.glyphId;
                      break;
                    }
                }
              } else if (We === 0) {
                for (const ot of et)
                  qe[ot.charCode] = ot.glyphId;
                pt = !0;
              } else
                for (const ot of et) {
                  let st = ot.charCode;
                  We === 3 && st >= 61440 && st <= 61695 && (st &= 255), qe[st] = ot.glyphId;
                }
              if (W.glyphNames && (lt.length || this.differences.length))
                for (let ot = 0; ot < 256; ++ot) {
                  if (!pt && qe[ot] !== void 0)
                    continue;
                  const st = this.differences[ot] || lt[ot];
                  if (!st)
                    continue;
                  const gt = W.glyphNames.indexOf(st);
                  gt > 0 && tt(gt) && (qe[ot] = gt);
                }
            }
            qe.length === 0 && (qe[0] = 0);
            let ht = he - 1;
            if (ye || (ht = 0), !W.cssFontInfo) {
              const Ge = re(qe, tt, ht, this.toUnicode);
              this.toFontChar = Ge.toFontChar, $e.cmap = {
                tag: "cmap",
                data: te(Ge.charCodeToGlyphId, Ge.toUnicodeExtraMap, he)
              }, (!$e["OS/2"] || !L($e["OS/2"], ne)) && ($e["OS/2"] = {
                tag: "OS/2",
                data: X(W, Ge.charCodeToGlyphId, Ue)
              });
            }
            if (!Ye)
              try {
                ze = new A.Stream($e["CFF "].data), ct = new F.CFFParser(ze, W, C.SEAC_ANALYSIS_ENABLED).parse(), ct.duplicateFirstGlyph();
                const We = new F.CFFCompiler(ct);
                $e["CFF "].data = We.compile();
              } catch {
                (0, n.warn)("Failed to compile font " + W.loadedName);
              }
            if (!$e.name)
              $e.name = {
                tag: "name",
                data: ae(this.name)
              };
            else {
              const [Ge, We] = Ae($e.name);
              $e.name.data = ae(ie, Ge), this.psName = Ge[0][6] || null, W.composite || f(W, this.isSymbolicFont, We);
            }
            const rt = new P.OpenTypeFileBuilder(at.version);
            for (const Ge in $e)
              rt.addTable(Ge, $e[Ge].data);
            return rt.toArray();
          }
          convert(ie, ne, W) {
            W.fixedPitch = !1, W.builtInEncoding && c(W, W.builtInEncoding);
            let oe = 1;
            ne instanceof O.CFFFont && (oe = ne.numGlyphs - 1);
            const ue = ne.getGlyphMapping(W);
            let pe = null, ve = ue, Ce = null;
            W.cssFontInfo || (pe = re(ue, ne.hasGlyphId.bind(ne), oe, this.toUnicode), this.toFontChar = pe.toFontChar, ve = pe.charCodeToGlyphId, Ce = pe.toUnicodeExtraMap);
            const Fe = ne.numGlyphs;
            function Pe(Se, Ae) {
              let Te = null;
              for (const ke in Se)
                Ae === Se[ke] && (Te || (Te = [])).push(ke | 0);
              return Te;
            }
            function be(Se, Ae) {
              for (const Te in Se)
                if (Ae === Se[Te])
                  return Te | 0;
              return pe.charCodeToGlyphId[pe.nextAvailableFontCharCode] = Ae, pe.nextAvailableFontCharCode++;
            }
            const me = ne.seacs;
            if (pe && C.SEAC_ANALYSIS_ENABLED && (me != null && me.length)) {
              const Se = W.fontMatrix || n.FONT_IDENTITY_MATRIX, Ae = ne.getCharset(), Te = /* @__PURE__ */ Object.create(null);
              for (let ke in me) {
                ke |= 0;
                const Ee = me[ke], Ve = l.StandardEncoding[Ee[2]], je = l.StandardEncoding[Ee[3]], at = Ae.indexOf(Ve), $e = Ae.indexOf(je);
                if (at < 0 || $e < 0)
                  continue;
                const ct = {
                  x: Ee[0] * Se[0] + Ee[1] * Se[2] + Se[4],
                  y: Ee[0] * Se[1] + Ee[1] * Se[3] + Se[5]
                }, ze = Pe(ue, ke);
                if (ze)
                  for (const Ye of ze) {
                    const Qe = pe.charCodeToGlyphId, Oe = be(Qe, at), he = be(Qe, $e);
                    Te[Ye] = {
                      baseFontCharCode: Oe,
                      accentFontCharCode: he,
                      accentOffset: ct
                    };
                  }
              }
              W.seacMap = Te;
            }
            const we = 1 / (W.fontMatrix || n.FONT_IDENTITY_MATRIX)[0], _e = new P.OpenTypeFileBuilder("OTTO");
            return _e.addTable("CFF ", ne.data), _e.addTable("OS/2", X(W, ve)), _e.addTable("cmap", te(ve, Ce, Fe)), _e.addTable("head", "\0\0\0\0\0\0\0\0\0\0_<õ\0\0" + K(we) + "\0\0\0\0\v~'\0\0\0\0\v~'\0\0" + K(W.descent) + "ÿ" + K(W.ascent) + D(W.italicAngle ? 2 : 0) + "\0\0\0\0\0\0\0"), _e.addTable("hhea", "\0\0\0" + K(W.ascent) + K(W.descent) + "\0\0ÿÿ\0\0\0\0\0\0" + K(W.capHeight) + K(Math.tan(W.italicAngle) * W.xHeight) + "\0\0\0\0\0\0\0\0\0\0\0\0" + D(Fe)), _e.addTable("hmtx", function() {
              const Ae = ne.charstrings, Te = ne.cff ? ne.cff.widths : null;
              let ke = "\0\0\0\0";
              for (let Ee = 1, Ve = Fe; Ee < Ve; Ee++) {
                let je = 0;
                if (Ae) {
                  const at = Ae[Ee - 1];
                  je = "width" in at ? at.width : 0;
                } else
                  Te && (je = Math.ceil(Te[Ee] || 0));
                ke += D(je) + D(0);
              }
              return ke;
            }()), _e.addTable("maxp", "\0\0P\0" + D(Fe)), _e.addTable("name", ae(ie)), _e.addTable("post", J(W)), _e.toArray();
          }
          get spaceWidth() {
            const ie = ["space", "minus", "one", "i", "I"];
            let ne;
            for (const W of ie) {
              if (W in this.widths) {
                ne = this.widths[W];
                break;
              }
              const ue = (0, t.getGlyphsUnicode)()[W];
              let pe = 0;
              if (this.composite && this.cMap.contains(ue) && (pe = this.cMap.lookup(ue), typeof pe == "string" && (pe = q(ue, pe))), !pe && this.toUnicode && (pe = this.toUnicode.charCodeOf(ue)), pe <= 0 && (pe = ue), ne = this.widths[pe], ne)
                break;
            }
            return (0, n.shadow)(this, "spaceWidth", ne || this.defaultWidth);
          }
          _charToGlyph(ie, ne = !1) {
            var we, _e, Se;
            let W = this._glyphCache[ie];
            if ((W == null ? void 0 : W.isSpace) === ne)
              return W;
            let oe, ue, pe, ve = ie;
            (we = this.cMap) != null && we.contains(ie) && (ve = this.cMap.lookup(ie), typeof ve == "string" && (ve = q(ie, ve))), ue = this.widths[ve], typeof ue != "number" && (ue = this.defaultWidth);
            const Ce = (_e = this.vmetrics) == null ? void 0 : _e[ve];
            let Fe = this.toUnicode.get(ie) || ie;
            typeof Fe == "number" && (Fe = String.fromCharCode(Fe));
            let Pe = this.toFontChar[ie] !== void 0;
            if (oe = this.toFontChar[ie] || ie, this.missingFile) {
              const Ae = this.differences[ie] || this.defaultEncoding[ie];
              (Ae === ".notdef" || Ae === "") && this.type === "Type1" && (oe = 32), oe = (0, e.mapSpecialUnicodeValues)(oe);
            }
            this.isType3Font && (pe = oe);
            let be = null;
            if ((Se = this.seacMap) != null && Se[ie]) {
              Pe = !0;
              const Ae = this.seacMap[ie];
              oe = Ae.baseFontCharCode, be = {
                fontChar: String.fromCodePoint(Ae.accentFontCharCode),
                offset: Ae.accentOffset
              };
            }
            let me = "";
            return typeof oe == "number" && (oe <= 1114111 ? me = String.fromCodePoint(oe) : (0, n.warn)(`charToGlyph - invalid fontCharCode: ${oe}`)), W = new u(ie, me, Fe, be, ue, Ce, pe, ne, Pe), this._glyphCache[ie] = W;
          }
          charsToGlyphs(ie) {
            let ne = this._charsCache[ie];
            if (ne)
              return ne;
            if (ne = [], this.cMap) {
              const W = /* @__PURE__ */ Object.create(null), oe = ie.length;
              let ue = 0;
              for (; ue < oe; ) {
                this.cMap.readCharCode(ie, ue, W);
                const {
                  charcode: pe,
                  length: ve
                } = W;
                ue += ve;
                const Ce = this._charToGlyph(pe, ve === 1 && ie.charCodeAt(ue - 1) === 32);
                ne.push(Ce);
              }
            } else
              for (let W = 0, oe = ie.length; W < oe; ++W) {
                const ue = ie.charCodeAt(W), pe = this._charToGlyph(ue, ue === 32);
                ne.push(pe);
              }
            return this._charsCache[ie] = ne;
          }
          getCharPositions(ie) {
            const ne = [];
            if (this.cMap) {
              const W = /* @__PURE__ */ Object.create(null);
              let oe = 0;
              for (; oe < ie.length; ) {
                this.cMap.readCharCode(ie, oe, W);
                const ue = W.length;
                ne.push([oe, oe + ue]), oe += ue;
              }
            } else
              for (let W = 0, oe = ie.length; W < oe; ++W)
                ne.push([W, W + 1]);
            return ne;
          }
          get glyphCacheValues() {
            return Object.values(this._glyphCache);
          }
          encodeString(ie) {
            const ne = [], W = [], oe = () => ne.length % 2 === 1, ue = this.toUnicode instanceof U.IdentityToUnicodeMap ? (pe) => this.toUnicode.charCodeOf(pe) : (pe) => this.toUnicode.charCodeOf(String.fromCodePoint(pe));
            for (let pe = 0, ve = ie.length; pe < ve; pe++) {
              const Ce = ie.codePointAt(pe);
              if (Ce > 55295 && (Ce < 57344 || Ce > 65533) && pe++, this.toUnicode) {
                const Fe = ue(Ce);
                if (Fe !== -1) {
                  oe() && (ne.push(W.join("")), W.length = 0);
                  const Pe = this.cMap ? this.cMap.getCharCodeLength(Fe) : 1;
                  for (let be = Pe - 1; be >= 0; be--)
                    W.push(String.fromCharCode(Fe >> 8 * be & 255));
                  continue;
                }
              }
              oe() || (ne.push(W.join("")), W.length = 0), W.push(String.fromCodePoint(Ce));
            }
            return ne.push(W.join("")), ne;
          }
        }
        w.Font = se;
        class Q {
          constructor(ie) {
            this.error = ie, this.loadedName = "g_font_error", this.missingFile = !0;
          }
          charsToGlyphs() {
            return [];
          }
          encodeString(ie) {
            return [ie];
          }
          exportData(ie = !1) {
            return {
              error: this.error
            };
          }
        }
        w.ErrorFont = Q;
      },
      /* 35 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.CFFTopDict = w.CFFStrings = w.CFFStandardStrings = w.CFFPrivateDict = w.CFFParser = w.CFFIndex = w.CFFHeader = w.CFFFDSelect = w.CFFCompiler = w.CFFCharset = w.CFF = void 0;
        var n = V(2), F = V(36), C = V(37);
        const e = 10, t = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"];
        w.CFFStandardStrings = t;
        const l = 391, j = [null, {
          id: "hstem",
          min: 2,
          stackClearing: !0,
          stem: !0
        }, null, {
          id: "vstem",
          min: 2,
          stackClearing: !0,
          stem: !0
        }, {
          id: "vmoveto",
          min: 1,
          stackClearing: !0
        }, {
          id: "rlineto",
          min: 2,
          resetStack: !0
        }, {
          id: "hlineto",
          min: 1,
          resetStack: !0
        }, {
          id: "vlineto",
          min: 1,
          resetStack: !0
        }, {
          id: "rrcurveto",
          min: 6,
          resetStack: !0
        }, null, {
          id: "callsubr",
          min: 1,
          undefStack: !0
        }, {
          id: "return",
          min: 0,
          undefStack: !0
        }, null, null, {
          id: "endchar",
          min: 0,
          stackClearing: !0
        }, null, null, null, {
          id: "hstemhm",
          min: 2,
          stackClearing: !0,
          stem: !0
        }, {
          id: "hintmask",
          min: 0,
          stackClearing: !0
        }, {
          id: "cntrmask",
          min: 0,
          stackClearing: !0
        }, {
          id: "rmoveto",
          min: 2,
          stackClearing: !0
        }, {
          id: "hmoveto",
          min: 1,
          stackClearing: !0
        }, {
          id: "vstemhm",
          min: 2,
          stackClearing: !0,
          stem: !0
        }, {
          id: "rcurveline",
          min: 8,
          resetStack: !0
        }, {
          id: "rlinecurve",
          min: 8,
          resetStack: !0
        }, {
          id: "vvcurveto",
          min: 4,
          resetStack: !0
        }, {
          id: "hhcurveto",
          min: 4,
          resetStack: !0
        }, null, {
          id: "callgsubr",
          min: 1,
          undefStack: !0
        }, {
          id: "vhcurveto",
          min: 4,
          resetStack: !0
        }, {
          id: "hvcurveto",
          min: 4,
          resetStack: !0
        }], U = [null, null, null, {
          id: "and",
          min: 2,
          stackDelta: -1
        }, {
          id: "or",
          min: 2,
          stackDelta: -1
        }, {
          id: "not",
          min: 1,
          stackDelta: 0
        }, null, null, null, {
          id: "abs",
          min: 1,
          stackDelta: 0
        }, {
          id: "add",
          min: 2,
          stackDelta: -1,
          stackFn(N, u) {
            N[u - 2] = N[u - 2] + N[u - 1];
          }
        }, {
          id: "sub",
          min: 2,
          stackDelta: -1,
          stackFn(N, u) {
            N[u - 2] = N[u - 2] - N[u - 1];
          }
        }, {
          id: "div",
          min: 2,
          stackDelta: -1,
          stackFn(N, u) {
            N[u - 2] = N[u - 2] / N[u - 1];
          }
        }, null, {
          id: "neg",
          min: 1,
          stackDelta: 0,
          stackFn(N, u) {
            N[u - 1] = -N[u - 1];
          }
        }, {
          id: "eq",
          min: 2,
          stackDelta: -1
        }, null, null, {
          id: "drop",
          min: 1,
          stackDelta: -1
        }, null, {
          id: "put",
          min: 2,
          stackDelta: -2
        }, {
          id: "get",
          min: 1,
          stackDelta: 0
        }, {
          id: "ifelse",
          min: 4,
          stackDelta: -3
        }, {
          id: "random",
          min: 0,
          stackDelta: 1
        }, {
          id: "mul",
          min: 2,
          stackDelta: -1,
          stackFn(N, u) {
            N[u - 2] = N[u - 2] * N[u - 1];
          }
        }, null, {
          id: "sqrt",
          min: 1,
          stackDelta: 0
        }, {
          id: "dup",
          min: 1,
          stackDelta: 1
        }, {
          id: "exch",
          min: 2,
          stackDelta: 0
        }, {
          id: "index",
          min: 2,
          stackDelta: 0
        }, {
          id: "roll",
          min: 3,
          stackDelta: -2
        }, null, null, null, {
          id: "hflex",
          min: 7,
          resetStack: !0
        }, {
          id: "flex",
          min: 13,
          resetStack: !0
        }, {
          id: "hflex1",
          min: 9,
          resetStack: !0
        }, {
          id: "flex1",
          min: 11,
          resetStack: !0
        }];
        class O {
          constructor(u, p, S) {
            this.bytes = u.getBytes(), this.properties = p, this.seacAnalysisEnabled = !!S;
          }
          parse() {
            const u = this.properties, p = new v();
            this.cff = p;
            const S = this.parseHeader(), B = this.parseIndex(S.endPos), T = this.parseIndex(B.endPos), D = this.parseIndex(T.endPos), K = this.parseIndex(D.endPos), _ = this.parseDict(T.obj.get(0)), o = this.createDict(A, _, p.strings);
            p.header = S.obj, p.names = this.parseNameIndex(B.obj), p.strings = this.parseStringIndex(D.obj), p.topDict = o, p.globalSubrIndex = K.obj, this.parsePrivateDict(p.topDict), p.isCIDFont = o.hasName("ROS");
            const m = o.getByName("CharStrings"), s = this.parseIndex(m).obj, r = o.getByName("FontMatrix");
            r && (u.fontMatrix = r);
            const y = o.getByName("FontBBox");
            y && (u.ascent = Math.max(y[3], y[1]), u.descent = Math.min(y[1], y[3]), u.ascentScaled = !0);
            let M, $;
            if (p.isCIDFont) {
              const ce = this.parseIndex(o.getByName("FDArray")).obj;
              for (let q = 0, re = ce.count; q < re; ++q) {
                const Z = ce.get(q), te = this.createDict(A, this.parseDict(Z), p.strings);
                this.parsePrivateDict(te), p.fdArray.push(te);
              }
              $ = null, M = this.parseCharsets(o.getByName("charset"), s.count, p.strings, !0), p.fdSelect = this.parseFDSelect(o.getByName("FDSelect"), s.count);
            } else
              M = this.parseCharsets(o.getByName("charset"), s.count, p.strings, !1), $ = this.parseEncoding(o.getByName("Encoding"), u, p.strings, M.charset);
            p.charset = M, p.encoding = $;
            const G = this.parseCharStrings({
              charStrings: s,
              localSubrIndex: o.privateDict.subrsIndex,
              globalSubrIndex: K.obj,
              fdSelect: p.fdSelect,
              fdArray: p.fdArray,
              privateDict: o.privateDict
            });
            return p.charStrings = G.charStrings, p.seacs = G.seacs, p.widths = G.widths, p;
          }
          parseHeader() {
            let u = this.bytes;
            const p = u.length;
            let S = 0;
            for (; S < p && u[S] !== 1; )
              ++S;
            if (S >= p)
              throw new n.FormatError("Invalid CFF header");
            S !== 0 && ((0, n.info)("cff data is shifted"), u = u.subarray(S), this.bytes = u);
            const B = u[0], T = u[1], D = u[2], K = u[3];
            return {
              obj: new g(B, T, D, K),
              endPos: D
            };
          }
          parseDict(u) {
            let p = 0;
            function S() {
              let _ = u[p++];
              return _ === 30 ? B() : _ === 28 ? (_ = u[p++], _ = (_ << 24 | u[p++] << 16) >> 16, _) : _ === 29 ? (_ = u[p++], _ = _ << 8 | u[p++], _ = _ << 8 | u[p++], _ = _ << 8 | u[p++], _) : _ >= 32 && _ <= 246 ? _ - 139 : _ >= 247 && _ <= 250 ? (_ - 247) * 256 + u[p++] + 108 : _ >= 251 && _ <= 254 ? -((_ - 251) * 256) - u[p++] - 108 : ((0, n.warn)('CFFParser_parseDict: "' + _ + '" is a reserved command.'), NaN);
            }
            function B() {
              let _ = "";
              const m = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"], s = u.length;
              for (; p < s; ) {
                const r = u[p++], y = r >> 4, M = r & 15;
                if (y === 15 || (_ += m[y], M === 15))
                  break;
                _ += m[M];
              }
              return parseFloat(_);
            }
            let T = [];
            const D = [];
            p = 0;
            const K = u.length;
            for (; p < K; ) {
              let _ = u[p];
              _ <= 21 ? (_ === 12 && (_ = _ << 8 | u[++p]), D.push([_, T]), T = [], ++p) : T.push(S());
            }
            return D;
          }
          parseIndex(u) {
            const p = new i(), S = this.bytes, B = S[u++] << 8 | S[u++], T = [];
            let D = u, K, _;
            if (B !== 0) {
              const o = S[u++], m = u + (B + 1) * o - 1;
              for (K = 0, _ = B + 1; K < _; ++K) {
                let s = 0;
                for (let r = 0; r < o; ++r)
                  s <<= 8, s += S[u++];
                T.push(m + s);
              }
              D = T[B];
            }
            for (K = 0, _ = T.length - 1; K < _; ++K) {
              const o = T[K], m = T[K + 1];
              p.add(S.subarray(o, m));
            }
            return {
              obj: p,
              endPos: D
            };
          }
          parseNameIndex(u) {
            const p = [];
            for (let S = 0, B = u.count; S < B; ++S) {
              const T = u.get(S);
              p.push((0, n.bytesToString)(T));
            }
            return p;
          }
          parseStringIndex(u) {
            const p = new b();
            for (let S = 0, B = u.count; S < B; ++S) {
              const T = u.get(S);
              p.add((0, n.bytesToString)(T));
            }
            return p;
          }
          createDict(u, p, S) {
            const B = new u(S);
            for (const [T, D] of p)
              B.setByKey(T, D);
            return B;
          }
          parseCharString(u, p, S, B) {
            if (!p || u.callDepth > e)
              return !1;
            let T = u.stackSize;
            const D = u.stack;
            let K = p.length;
            for (let _ = 0; _ < K; ) {
              const o = p[_++];
              let m = null;
              if (o === 12) {
                const s = p[_++];
                s === 0 ? (p[_ - 2] = 139, p[_ - 1] = 22, T = 0) : m = U[s];
              } else if (o === 28)
                D[T] = (p[_] << 24 | p[_ + 1] << 16) >> 16, _ += 2, T++;
              else if (o === 14) {
                if (T >= 4 && (T -= 4, this.seacAnalysisEnabled))
                  return u.seac = D.slice(T, T + 4), !1;
                m = j[o];
              } else if (o >= 32 && o <= 246)
                D[T] = o - 139, T++;
              else if (o >= 247 && o <= 254)
                D[T] = o < 251 ? (o - 247 << 8) + p[_] + 108 : -(o - 251 << 8) - p[_] - 108, _++, T++;
              else if (o === 255)
                D[T] = (p[_] << 24 | p[_ + 1] << 16 | p[_ + 2] << 8 | p[_ + 3]) / 65536, _ += 4, T++;
              else if (o === 19 || o === 20) {
                if (u.hints += T >> 1, u.hints === 0) {
                  p.copyWithin(_ - 1, _, -1), _ -= 1, K -= 1;
                  continue;
                }
                _ += u.hints + 7 >> 3, T %= 2, m = j[o];
              } else if (o === 10 || o === 29) {
                const s = o === 10 ? S : B;
                if (!s)
                  return m = j[o], (0, n.warn)("Missing subrsIndex for " + m.id), !1;
                let r = 32768;
                s.count < 1240 ? r = 107 : s.count < 33900 && (r = 1131);
                const y = D[--T] + r;
                if (y < 0 || y >= s.count || isNaN(y))
                  return m = j[o], (0, n.warn)("Out of bounds subrIndex for " + m.id), !1;
                if (u.stackSize = T, u.callDepth++, !this.parseCharString(u, s.get(y), S, B))
                  return !1;
                u.callDepth--, T = u.stackSize;
                continue;
              } else {
                if (o === 11)
                  return u.stackSize = T, !0;
                if (o === 0 && _ === p.length)
                  p[_ - 1] = 14, m = j[14];
                else if (o === 9) {
                  p.copyWithin(_ - 1, _, -1), _ -= 1, K -= 1;
                  continue;
                } else
                  m = j[o];
              }
              if (m) {
                if (m.stem && (u.hints += T >> 1, o === 3 || o === 23 ? u.hasVStems = !0 : u.hasVStems && (o === 1 || o === 18) && ((0, n.warn)("CFF stem hints are in wrong order"), p[_ - 1] = o === 1 ? 3 : 23)), "min" in m && !u.undefStack && T < m.min)
                  return (0, n.warn)("Not enough parameters for " + m.id + "; actual: " + T + ", expected: " + m.min), T === 0 ? (p[_ - 1] = 14, !0) : !1;
                u.firstStackClearing && m.stackClearing && (u.firstStackClearing = !1, T -= m.min, T >= 2 && m.stem ? T %= 2 : T > 1 && (0, n.warn)("Found too many parameters for stack-clearing command"), T > 0 && (u.width = D[T - 1])), "stackDelta" in m ? ("stackFn" in m && m.stackFn(D, T), T += m.stackDelta) : m.stackClearing ? T = 0 : m.resetStack ? (T = 0, u.undefStack = !1) : m.undefStack && (T = 0, u.undefStack = !0, u.firstStackClearing = !1);
              }
            }
            return K < p.length && p.fill(14, K), u.stackSize = T, !0;
          }
          parseCharStrings({
            charStrings: u,
            localSubrIndex: p,
            globalSubrIndex: S,
            fdSelect: B,
            fdArray: T,
            privateDict: D
          }) {
            const K = [], _ = [], o = u.count;
            for (let m = 0; m < o; m++) {
              const s = u.get(m), r = {
                callDepth: 0,
                stackSize: 0,
                stack: [],
                undefStack: !0,
                hints: 0,
                firstStackClearing: !0,
                seac: null,
                width: null,
                hasVStems: !1
              };
              let y = !0, M = null, $ = D;
              if (B && T.length) {
                const G = B.getFDIndex(m);
                G === -1 && ((0, n.warn)("Glyph index is not in fd select."), y = !1), G >= T.length && ((0, n.warn)("Invalid fd index for glyph index."), y = !1), y && ($ = T[G].privateDict, M = $.subrsIndex);
              } else
                p && (M = p);
              if (y && (y = this.parseCharString(r, s, M, S)), r.width !== null) {
                const G = $.getByName("nominalWidthX");
                _[m] = G + r.width;
              } else {
                const G = $.getByName("defaultWidthX");
                _[m] = G;
              }
              r.seac !== null && (K[m] = r.seac), y || u.set(m, new Uint8Array([14]));
            }
            return {
              charStrings: u,
              seacs: K,
              widths: _
            };
          }
          emptyPrivateDictionary(u) {
            const p = this.createDict(E, [], u.strings);
            u.setByKey(18, [0, 0]), u.privateDict = p;
          }
          parsePrivateDict(u) {
            if (!u.hasName("Private")) {
              this.emptyPrivateDictionary(u);
              return;
            }
            const p = u.getByName("Private");
            if (!Array.isArray(p) || p.length !== 2) {
              u.removeByName("Private");
              return;
            }
            const S = p[0], B = p[1];
            if (S === 0 || B >= this.bytes.length) {
              this.emptyPrivateDictionary(u);
              return;
            }
            const T = B + S, D = this.bytes.subarray(B, T), K = this.parseDict(D), _ = this.createDict(E, K, u.strings);
            if (u.privateDict = _, _.getByName("ExpansionFactor") === 0 && _.setByName("ExpansionFactor", 0.06), !_.getByName("Subrs"))
              return;
            const o = _.getByName("Subrs"), m = B + o;
            if (o === 0 || m >= this.bytes.length) {
              this.emptyPrivateDictionary(u);
              return;
            }
            const s = this.parseIndex(m);
            _.subrsIndex = s.obj;
          }
          parseCharsets(u, p, S, B) {
            if (u === 0)
              return new H(!0, k.ISO_ADOBE, F.ISOAdobeCharset);
            if (u === 1)
              return new H(!0, k.EXPERT, F.ExpertCharset);
            if (u === 2)
              return new H(!0, k.EXPERT_SUBSET, F.ExpertSubsetCharset);
            const T = this.bytes, D = u, K = T[u++], _ = [B ? 0 : ".notdef"];
            let o, m, s;
            switch (p -= 1, K) {
              case 0:
                for (s = 0; s < p; s++)
                  o = T[u++] << 8 | T[u++], _.push(B ? o : S.get(o));
                break;
              case 1:
                for (; _.length <= p; )
                  for (o = T[u++] << 8 | T[u++], m = T[u++], s = 0; s <= m; s++)
                    _.push(B ? o++ : S.get(o++));
                break;
              case 2:
                for (; _.length <= p; )
                  for (o = T[u++] << 8 | T[u++], m = T[u++] << 8 | T[u++], s = 0; s <= m; s++)
                    _.push(B ? o++ : S.get(o++));
                break;
              default:
                throw new n.FormatError("Unknown charset format");
            }
            const r = u, y = T.subarray(D, r);
            return new H(!1, K, _, y);
          }
          parseEncoding(u, p, S, B) {
            const T = /* @__PURE__ */ Object.create(null), D = this.bytes;
            let K = !1, _, o, m, s = null;
            function r() {
              const y = D[u++];
              for (o = 0; o < y; o++) {
                const M = D[u++], $ = (D[u++] << 8) + (D[u++] & 255);
                T[M] = B.indexOf(S.get($));
              }
            }
            if (u === 0 || u === 1) {
              K = !0, _ = u;
              const y = u ? C.ExpertEncoding : C.StandardEncoding;
              for (o = 0, m = B.length; o < m; o++) {
                const M = y.indexOf(B[o]);
                M !== -1 && (T[M] = o);
              }
            } else {
              const y = u;
              switch (_ = D[u++], _ & 127) {
                case 0:
                  const $ = D[u++];
                  for (o = 1; o <= $; o++)
                    T[D[u++]] = o;
                  break;
                case 1:
                  const G = D[u++];
                  let ce = 1;
                  for (o = 0; o < G; o++) {
                    const q = D[u++], re = D[u++];
                    for (let Z = q; Z <= q + re; Z++)
                      T[Z] = ce++;
                  }
                  break;
                default:
                  throw new n.FormatError(`Unknown encoding format: ${_} in CFF`);
              }
              const M = u;
              _ & 128 && (D[y] &= 127, r()), s = D.subarray(y, M);
            }
            return _ &= 127, new x(K, _, T, s);
          }
          parseFDSelect(u, p) {
            const S = this.bytes, B = S[u++], T = [];
            let D;
            switch (B) {
              case 0:
                for (D = 0; D < p; ++D) {
                  const _ = S[u++];
                  T.push(_);
                }
                break;
              case 3:
                const K = S[u++] << 8 | S[u++];
                for (D = 0; D < K; ++D) {
                  let _ = S[u++] << 8 | S[u++];
                  D === 0 && _ !== 0 && ((0, n.warn)("parseFDSelect: The first range must have a first GID of 0 -- trying to recover."), _ = 0);
                  const o = S[u++], m = S[u] << 8 | S[u + 1];
                  for (let s = _; s < m; ++s)
                    T.push(o);
                }
                u += 2;
                break;
              default:
                throw new n.FormatError(`parseFDSelect: Unknown format "${B}".`);
            }
            if (T.length !== p)
              throw new n.FormatError("parseFDSelect: Invalid font data.");
            return new R(B, T);
          }
        }
        w.CFFParser = O;
        class v {
          constructor() {
            this.header = null, this.names = [], this.topDict = null, this.strings = new b(), this.globalSubrIndex = null, this.encoding = null, this.charset = null, this.charStrings = null, this.fdArray = [], this.fdSelect = null, this.isCIDFont = !1;
          }
          duplicateFirstGlyph() {
            if (this.charStrings.count >= 65535) {
              (0, n.warn)("Not enough space in charstrings to duplicate first glyph.");
              return;
            }
            const u = this.charStrings.get(0);
            this.charStrings.add(u), this.isCIDFont && this.fdSelect.fdSelect.push(this.fdSelect.fdSelect[0]);
          }
          hasGlyphId(u) {
            return u < 0 || u >= this.charStrings.count ? !1 : this.charStrings.get(u).length > 0;
          }
        }
        w.CFF = v;
        class g {
          constructor(u, p, S, B) {
            this.major = u, this.minor = p, this.hdrSize = S, this.offSize = B;
          }
        }
        w.CFFHeader = g;
        class b {
          constructor() {
            this.strings = [];
          }
          get(u) {
            return u >= 0 && u <= l - 1 ? t[u] : u - l <= this.strings.length ? this.strings[u - l] : t[0];
          }
          getSID(u) {
            let p = t.indexOf(u);
            return p !== -1 ? p : (p = this.strings.indexOf(u), p !== -1 ? p + l : -1);
          }
          add(u) {
            this.strings.push(u);
          }
          get count() {
            return this.strings.length;
          }
        }
        w.CFFStrings = b;
        class i {
          constructor() {
            this.objects = [], this.length = 0;
          }
          add(u) {
            this.length += u.length, this.objects.push(u);
          }
          set(u, p) {
            this.length += p.length - this.objects[u].length, this.objects[u] = p;
          }
          get(u) {
            return this.objects[u];
          }
          get count() {
            return this.objects.length;
          }
        }
        w.CFFIndex = i;
        class P {
          constructor(u, p) {
            this.keyToNameMap = u.keyToNameMap, this.nameToKeyMap = u.nameToKeyMap, this.defaults = u.defaults, this.types = u.types, this.opcodes = u.opcodes, this.order = u.order, this.strings = p, this.values = /* @__PURE__ */ Object.create(null);
          }
          setByKey(u, p) {
            if (!(u in this.keyToNameMap))
              return !1;
            if (p.length === 0)
              return !0;
            for (const B of p)
              if (isNaN(B))
                return (0, n.warn)(`Invalid CFFDict value: "${p}" for key "${u}".`), !0;
            const S = this.types[u];
            return (S === "num" || S === "sid" || S === "offset") && (p = p[0]), this.values[u] = p, !0;
          }
          setByName(u, p) {
            if (!(u in this.nameToKeyMap))
              throw new n.FormatError(`Invalid dictionary name "${u}"`);
            this.values[this.nameToKeyMap[u]] = p;
          }
          hasName(u) {
            return this.nameToKeyMap[u] in this.values;
          }
          getByName(u) {
            if (!(u in this.nameToKeyMap))
              throw new n.FormatError(`Invalid dictionary name ${u}"`);
            const p = this.nameToKeyMap[u];
            return p in this.values ? this.values[p] : this.defaults[p];
          }
          removeByName(u) {
            delete this.values[this.nameToKeyMap[u]];
          }
          static createTables(u) {
            const p = {
              keyToNameMap: {},
              nameToKeyMap: {},
              defaults: {},
              types: {},
              opcodes: {},
              order: []
            };
            for (const S of u) {
              const B = Array.isArray(S[0]) ? (S[0][0] << 8) + S[0][1] : S[0];
              p.keyToNameMap[B] = S[1], p.nameToKeyMap[S[1]] = B, p.types[B] = S[2], p.defaults[B] = S[3], p.opcodes[B] = Array.isArray(S[0]) ? S[0] : [S[0]], p.order.push(B);
            }
            return p;
          }
        }
        const d = [[[12, 30], "ROS", ["sid", "sid", "num"], null], [[12, 20], "SyntheticBase", "num", null], [0, "version", "sid", null], [1, "Notice", "sid", null], [[12, 0], "Copyright", "sid", null], [2, "FullName", "sid", null], [3, "FamilyName", "sid", null], [4, "Weight", "sid", null], [[12, 1], "isFixedPitch", "num", 0], [[12, 2], "ItalicAngle", "num", 0], [[12, 3], "UnderlinePosition", "num", -100], [[12, 4], "UnderlineThickness", "num", 50], [[12, 5], "PaintType", "num", 0], [[12, 6], "CharstringType", "num", 2], [[12, 7], "FontMatrix", ["num", "num", "num", "num", "num", "num"], [1e-3, 0, 0, 1e-3, 0, 0]], [13, "UniqueID", "num", null], [5, "FontBBox", ["num", "num", "num", "num"], [0, 0, 0, 0]], [[12, 8], "StrokeWidth", "num", 0], [14, "XUID", "array", null], [15, "charset", "offset", 0], [16, "Encoding", "offset", 0], [17, "CharStrings", "offset", 0], [18, "Private", ["offset", "offset"], null], [[12, 21], "PostScript", "sid", null], [[12, 22], "BaseFontName", "sid", null], [[12, 23], "BaseFontBlend", "delta", null], [[12, 31], "CIDFontVersion", "num", 0], [[12, 32], "CIDFontRevision", "num", 0], [[12, 33], "CIDFontType", "num", 0], [[12, 34], "CIDCount", "num", 8720], [[12, 35], "UIDBase", "num", null], [[12, 37], "FDSelect", "offset", null], [[12, 36], "FDArray", "offset", null], [[12, 38], "FontName", "sid", null]];
        class A extends P {
          static get tables() {
            return (0, n.shadow)(this, "tables", this.createTables(d));
          }
          constructor(u) {
            super(A.tables, u), this.privateDict = null;
          }
        }
        w.CFFTopDict = A;
        const I = [[6, "BlueValues", "delta", null], [7, "OtherBlues", "delta", null], [8, "FamilyBlues", "delta", null], [9, "FamilyOtherBlues", "delta", null], [[12, 9], "BlueScale", "num", 0.039625], [[12, 10], "BlueShift", "num", 7], [[12, 11], "BlueFuzz", "num", 1], [10, "StdHW", "num", null], [11, "StdVW", "num", null], [[12, 12], "StemSnapH", "delta", null], [[12, 13], "StemSnapV", "delta", null], [[12, 14], "ForceBold", "num", 0], [[12, 17], "LanguageGroup", "num", 0], [[12, 18], "ExpansionFactor", "num", 0.06], [[12, 19], "initialRandomSeed", "num", 0], [20, "defaultWidthX", "num", 0], [21, "nominalWidthX", "num", 0], [19, "Subrs", "offset", null]];
        class E extends P {
          static get tables() {
            return (0, n.shadow)(this, "tables", this.createTables(I));
          }
          constructor(u) {
            super(E.tables, u), this.subrsIndex = null;
          }
        }
        w.CFFPrivateDict = E;
        const k = {
          ISO_ADOBE: 0,
          EXPERT: 1,
          EXPERT_SUBSET: 2
        };
        class H {
          constructor(u, p, S, B) {
            this.predefined = u, this.format = p, this.charset = S, this.raw = B;
          }
        }
        w.CFFCharset = H;
        class x {
          constructor(u, p, S, B) {
            this.predefined = u, this.format = p, this.encoding = S, this.raw = B;
          }
        }
        class R {
          constructor(u, p) {
            this.format = u, this.fdSelect = p;
          }
          getFDIndex(u) {
            return u < 0 || u >= this.fdSelect.length ? -1 : this.fdSelect[u];
          }
        }
        w.CFFFDSelect = R;
        class f {
          constructor() {
            this.offsets = /* @__PURE__ */ Object.create(null);
          }
          isTracking(u) {
            return u in this.offsets;
          }
          track(u, p) {
            if (u in this.offsets)
              throw new n.FormatError(`Already tracking location of ${u}`);
            this.offsets[u] = p;
          }
          offset(u) {
            for (const p in this.offsets)
              this.offsets[p] += u;
          }
          setEntryLocation(u, p, S) {
            if (!(u in this.offsets))
              throw new n.FormatError(`Not tracking location of ${u}`);
            const B = S.data, T = this.offsets[u], D = 5;
            for (let K = 0, _ = p.length; K < _; ++K) {
              const o = K * D + T, m = o + 1, s = o + 2, r = o + 3, y = o + 4;
              if (B[o] !== 29 || B[m] !== 0 || B[s] !== 0 || B[r] !== 0 || B[y] !== 0)
                throw new n.FormatError("writing to an offset that is not empty");
              const M = p[K];
              B[o] = 29, B[m] = M >> 24 & 255, B[s] = M >> 16 & 255, B[r] = M >> 8 & 255, B[y] = M & 255;
            }
          }
        }
        class c {
          constructor(u) {
            this.cff = u;
          }
          compile() {
            const u = this.cff, p = {
              data: [],
              length: 0,
              add(r) {
                try {
                  this.data.push(...r);
                } catch {
                  this.data = this.data.concat(r);
                }
                this.length = this.data.length;
              }
            }, S = this.compileHeader(u.header);
            p.add(S);
            const B = this.compileNameIndex(u.names);
            if (p.add(B), u.isCIDFont && u.topDict.hasName("FontMatrix")) {
              const r = u.topDict.getByName("FontMatrix");
              u.topDict.removeByName("FontMatrix");
              for (const y of u.fdArray) {
                let M = r.slice(0);
                y.hasName("FontMatrix") && (M = n.Util.transform(M, y.getByName("FontMatrix"))), y.setByName("FontMatrix", M);
              }
            }
            const T = u.topDict.getByName("XUID");
            (T == null ? void 0 : T.length) > 16 && u.topDict.removeByName("XUID"), u.topDict.setByName("charset", 0);
            let D = this.compileTopDicts([u.topDict], p.length, u.isCIDFont);
            p.add(D.output);
            const K = D.trackers[0], _ = this.compileStringIndex(u.strings.strings);
            p.add(_);
            const o = this.compileIndex(u.globalSubrIndex);
            if (p.add(o), u.encoding && u.topDict.hasName("Encoding"))
              if (u.encoding.predefined)
                K.setEntryLocation("Encoding", [u.encoding.format], p);
              else {
                const r = this.compileEncoding(u.encoding);
                K.setEntryLocation("Encoding", [p.length], p), p.add(r);
              }
            const m = this.compileCharset(u.charset, u.charStrings.count, u.strings, u.isCIDFont);
            K.setEntryLocation("charset", [p.length], p), p.add(m);
            const s = this.compileCharStrings(u.charStrings);
            if (K.setEntryLocation("CharStrings", [p.length], p), p.add(s), u.isCIDFont) {
              K.setEntryLocation("FDSelect", [p.length], p);
              const r = this.compileFDSelect(u.fdSelect);
              p.add(r), D = this.compileTopDicts(u.fdArray, p.length, !0), K.setEntryLocation("FDArray", [p.length], p), p.add(D.output);
              const y = D.trackers;
              this.compilePrivateDicts(u.fdArray, y, p);
            }
            return this.compilePrivateDicts([u.topDict], [K], p), p.add([0]), p.data;
          }
          encodeNumber(u) {
            return Number.isInteger(u) ? this.encodeInteger(u) : this.encodeFloat(u);
          }
          static get EncodeFloatRegExp() {
            return (0, n.shadow)(this, "EncodeFloatRegExp", /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/);
          }
          encodeFloat(u) {
            let p = u.toString();
            const S = c.EncodeFloatRegExp.exec(p);
            if (S) {
              const _ = parseFloat("1e" + ((S[2] ? +S[2] : 0) + S[1].length));
              p = (Math.round(u * _) / _).toString();
            }
            let B = "", T, D;
            for (T = 0, D = p.length; T < D; ++T) {
              const _ = p[T];
              _ === "e" ? B += p[++T] === "-" ? "c" : "b" : _ === "." ? B += "a" : _ === "-" ? B += "e" : B += _;
            }
            B += B.length & 1 ? "f" : "ff";
            const K = [30];
            for (T = 0, D = B.length; T < D; T += 2)
              K.push(parseInt(B.substring(T, T + 2), 16));
            return K;
          }
          encodeInteger(u) {
            let p;
            return u >= -107 && u <= 107 ? p = [u + 139] : u >= 108 && u <= 1131 ? (u -= 108, p = [(u >> 8) + 247, u & 255]) : u >= -1131 && u <= -108 ? (u = -u - 108, p = [(u >> 8) + 251, u & 255]) : u >= -32768 && u <= 32767 ? p = [28, u >> 8 & 255, u & 255] : p = [29, u >> 24 & 255, u >> 16 & 255, u >> 8 & 255, u & 255], p;
          }
          compileHeader(u) {
            return [u.major, u.minor, 4, u.offSize];
          }
          compileNameIndex(u) {
            const p = new i();
            for (const S of u) {
              const B = Math.min(S.length, 127);
              let T = new Array(B);
              for (let D = 0; D < B; D++) {
                let K = S[D];
                (K < "!" || K > "~" || K === "[" || K === "]" || K === "(" || K === ")" || K === "{" || K === "}" || K === "<" || K === ">" || K === "/" || K === "%") && (K = "_"), T[D] = K;
              }
              T = T.join(""), T === "" && (T = "Bad_Font_Name"), p.add((0, n.stringToBytes)(T));
            }
            return this.compileIndex(p);
          }
          compileTopDicts(u, p, S) {
            const B = [];
            let T = new i();
            for (const D of u) {
              S && (D.removeByName("CIDFontVersion"), D.removeByName("CIDFontRevision"), D.removeByName("CIDFontType"), D.removeByName("CIDCount"), D.removeByName("UIDBase"));
              const K = new f(), _ = this.compileDict(D, K);
              B.push(K), T.add(_), K.offset(p);
            }
            return T = this.compileIndex(T, B), {
              trackers: B,
              output: T
            };
          }
          compilePrivateDicts(u, p, S) {
            for (let B = 0, T = u.length; B < T; ++B) {
              const D = u[B], K = D.privateDict;
              if (!K || !D.hasName("Private"))
                throw new n.FormatError("There must be a private dictionary.");
              const _ = new f(), o = this.compileDict(K, _);
              let m = S.length;
              if (_.offset(m), o.length || (m = 0), p[B].setEntryLocation("Private", [o.length, m], S), S.add(o), K.subrsIndex && K.hasName("Subrs")) {
                const s = this.compileIndex(K.subrsIndex);
                _.setEntryLocation("Subrs", [o.length], S), S.add(s);
              }
            }
          }
          compileDict(u, p) {
            const S = [];
            for (const B of u.order) {
              if (!(B in u.values))
                continue;
              let T = u.values[B], D = u.types[B];
              if (Array.isArray(D) || (D = [D]), Array.isArray(T) || (T = [T]), T.length !== 0) {
                for (let K = 0, _ = D.length; K < _; ++K) {
                  const o = D[K], m = T[K];
                  switch (o) {
                    case "num":
                    case "sid":
                      S.push(...this.encodeNumber(m));
                      break;
                    case "offset":
                      const s = u.keyToNameMap[B];
                      p.isTracking(s) || p.track(s, S.length), S.push(29, 0, 0, 0, 0);
                      break;
                    case "array":
                    case "delta":
                      S.push(...this.encodeNumber(m));
                      for (let r = 1, y = T.length; r < y; ++r)
                        S.push(...this.encodeNumber(T[r]));
                      break;
                    default:
                      throw new n.FormatError(`Unknown data type of ${o}`);
                  }
                }
                S.push(...u.opcodes[B]);
              }
            }
            return S;
          }
          compileStringIndex(u) {
            const p = new i();
            for (const S of u)
              p.add((0, n.stringToBytes)(S));
            return this.compileIndex(p);
          }
          compileCharStrings(u) {
            const p = new i();
            for (let S = 0; S < u.count; S++) {
              const B = u.get(S);
              if (B.length === 0) {
                p.add(new Uint8Array([139, 14]));
                continue;
              }
              p.add(B);
            }
            return this.compileIndex(p);
          }
          compileCharset(u, p, S, B) {
            let T;
            const D = p - 1;
            if (B)
              T = new Uint8Array([2, 0, 0, D >> 8 & 255, D & 255]);
            else {
              const K = 1 + D * 2;
              T = new Uint8Array(K), T[0] = 0;
              let _ = 0;
              const o = u.charset.length;
              let m = !1;
              for (let s = 1; s < T.length; s += 2) {
                let r = 0;
                if (_ < o) {
                  const y = u.charset[_++];
                  r = S.getSID(y), r === -1 && (r = 0, m || (m = !0, (0, n.warn)(`Couldn't find ${y} in CFF strings`)));
                }
                T[s] = r >> 8 & 255, T[s + 1] = r & 255;
              }
            }
            return this.compileTypedArray(T);
          }
          compileEncoding(u) {
            return this.compileTypedArray(u.raw);
          }
          compileFDSelect(u) {
            const p = u.format;
            let S, B;
            switch (p) {
              case 0:
                for (S = new Uint8Array(1 + u.fdSelect.length), S[0] = p, B = 0; B < u.fdSelect.length; B++)
                  S[B + 1] = u.fdSelect[B];
                break;
              case 3:
                const T = 0;
                let D = u.fdSelect[0];
                const K = [p, 0, 0, T >> 8 & 255, T & 255, D];
                for (B = 1; B < u.fdSelect.length; B++) {
                  const o = u.fdSelect[B];
                  o !== D && (K.push(B >> 8 & 255, B & 255, o), D = o);
                }
                const _ = (K.length - 3) / 3;
                K[1] = _ >> 8 & 255, K[2] = _ & 255, K.push(B >> 8 & 255, B & 255), S = new Uint8Array(K);
                break;
            }
            return this.compileTypedArray(S);
          }
          compileTypedArray(u) {
            return Array.from(u);
          }
          compileIndex(u, p = []) {
            const S = u.objects, B = S.length;
            if (B === 0)
              return [0, 0];
            const T = [B >> 8 & 255, B & 255];
            let D = 1, K;
            for (K = 0; K < B; ++K)
              D += S[K].length;
            let _;
            D < 256 ? _ = 1 : D < 65536 ? _ = 2 : D < 16777216 ? _ = 3 : _ = 4, T.push(_);
            let o = 1;
            for (K = 0; K < B + 1; K++)
              _ === 1 ? T.push(o & 255) : _ === 2 ? T.push(o >> 8 & 255, o & 255) : _ === 3 ? T.push(o >> 16 & 255, o >> 8 & 255, o & 255) : T.push(o >>> 24 & 255, o >> 16 & 255, o >> 8 & 255, o & 255), S[K] && (o += S[K].length);
            for (K = 0; K < B; K++)
              p[K] && p[K].offset(T.length), T.push(...S[K]);
            return T;
          }
        }
        w.CFFCompiler = c;
      },
      /* 36 */
      /***/
      (fe, w) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.ISOAdobeCharset = w.ExpertSubsetCharset = w.ExpertCharset = void 0;
        const V = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron"];
        w.ISOAdobeCharset = V;
        const n = [".notdef", "space", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
        w.ExpertCharset = n;
        const F = [".notdef", "space", "dollaroldstyle", "dollarsuperior", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "hyphensuperior", "colonmonetary", "onefitted", "rupiah", "centoldstyle", "figuredash", "hypheninferior", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior"];
        w.ExpertSubsetCharset = F;
      },
      /* 37 */
      /***/
      (fe, w) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.ZapfDingbatsEncoding = w.WinAnsiEncoding = w.SymbolSetEncoding = w.StandardEncoding = w.MacRomanEncoding = w.ExpertEncoding = void 0, w.getEncoding = j;
        const V = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
        w.ExpertEncoding = V;
        const n = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "centoldstyle", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "", "threequartersemdash", "", "questionsmall", "", "", "", "", "Ethsmall", "", "", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "", "", "", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hypheninferior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "asuperior", "centsuperior", "", "", "", "", "Aacutesmall", "Agravesmall", "Acircumflexsmall", "Adieresissmall", "Atildesmall", "Aringsmall", "Ccedillasmall", "Eacutesmall", "Egravesmall", "Ecircumflexsmall", "Edieresissmall", "Iacutesmall", "Igravesmall", "Icircumflexsmall", "Idieresissmall", "Ntildesmall", "Oacutesmall", "Ogravesmall", "Ocircumflexsmall", "Odieresissmall", "Otildesmall", "Uacutesmall", "Ugravesmall", "Ucircumflexsmall", "Udieresissmall", "", "eightsuperior", "fourinferior", "threeinferior", "sixinferior", "eightinferior", "seveninferior", "Scaronsmall", "", "centinferior", "twoinferior", "", "Dieresissmall", "", "Caronsmall", "osuperior", "fiveinferior", "", "commainferior", "periodinferior", "Yacutesmall", "", "dollarinferior", "", "", "Thornsmall", "", "nineinferior", "zeroinferior", "Zcaronsmall", "AEsmall", "Oslashsmall", "questiondownsmall", "oneinferior", "Lslashsmall", "", "", "", "", "", "", "Cedillasmall", "", "", "", "", "", "OEsmall", "figuredash", "hyphensuperior", "", "", "", "", "exclamdownsmall", "", "Ydieresissmall", "", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "ninesuperior", "zerosuperior", "", "esuperior", "rsuperior", "tsuperior", "", "", "isuperior", "ssuperior", "dsuperior", "", "", "", "", "", "lsuperior", "Ogoneksmall", "Brevesmall", "Macronsmall", "bsuperior", "nsuperior", "msuperior", "commasuperior", "periodsuperior", "Dotaccentsmall", "Ringsmall", "", "", "", ""], F = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "space", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron"];
        w.MacRomanEncoding = F;
        const C = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls", "", "", "", ""];
        w.StandardEncoding = C;
        const e = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "bullet", "Euro", "bullet", "quotesinglbase", "florin", "quotedblbase", "ellipsis", "dagger", "daggerdbl", "circumflex", "perthousand", "Scaron", "guilsinglleft", "OE", "bullet", "Zcaron", "bullet", "bullet", "quoteleft", "quoteright", "quotedblleft", "quotedblright", "bullet", "endash", "emdash", "tilde", "trademark", "scaron", "guilsinglright", "oe", "bullet", "zcaron", "Ydieresis", "space", "exclamdown", "cent", "sterling", "currency", "yen", "brokenbar", "section", "dieresis", "copyright", "ordfeminine", "guillemotleft", "logicalnot", "hyphen", "registered", "macron", "degree", "plusminus", "twosuperior", "threesuperior", "acute", "mu", "paragraph", "periodcentered", "cedilla", "onesuperior", "ordmasculine", "guillemotright", "onequarter", "onehalf", "threequarters", "questiondown", "Agrave", "Aacute", "Acircumflex", "Atilde", "Adieresis", "Aring", "AE", "Ccedilla", "Egrave", "Eacute", "Ecircumflex", "Edieresis", "Igrave", "Iacute", "Icircumflex", "Idieresis", "Eth", "Ntilde", "Ograve", "Oacute", "Ocircumflex", "Otilde", "Odieresis", "multiply", "Oslash", "Ugrave", "Uacute", "Ucircumflex", "Udieresis", "Yacute", "Thorn", "germandbls", "agrave", "aacute", "acircumflex", "atilde", "adieresis", "aring", "ae", "ccedilla", "egrave", "eacute", "ecircumflex", "edieresis", "igrave", "iacute", "icircumflex", "idieresis", "eth", "ntilde", "ograve", "oacute", "ocircumflex", "otilde", "odieresis", "divide", "oslash", "ugrave", "uacute", "ucircumflex", "udieresis", "yacute", "thorn", "ydieresis"];
        w.WinAnsiEncoding = e;
        const t = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "universal", "numbersign", "existential", "percent", "ampersand", "suchthat", "parenleft", "parenright", "asteriskmath", "plus", "comma", "minus", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "congruent", "Alpha", "Beta", "Chi", "Delta", "Epsilon", "Phi", "Gamma", "Eta", "Iota", "theta1", "Kappa", "Lambda", "Mu", "Nu", "Omicron", "Pi", "Theta", "Rho", "Sigma", "Tau", "Upsilon", "sigma1", "Omega", "Xi", "Psi", "Zeta", "bracketleft", "therefore", "bracketright", "perpendicular", "underscore", "radicalex", "alpha", "beta", "chi", "delta", "epsilon", "phi", "gamma", "eta", "iota", "phi1", "kappa", "lambda", "mu", "nu", "omicron", "pi", "theta", "rho", "sigma", "tau", "upsilon", "omega1", "omega", "xi", "psi", "zeta", "braceleft", "bar", "braceright", "similar", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Euro", "Upsilon1", "minute", "lessequal", "fraction", "infinity", "florin", "club", "diamond", "heart", "spade", "arrowboth", "arrowleft", "arrowup", "arrowright", "arrowdown", "degree", "plusminus", "second", "greaterequal", "multiply", "proportional", "partialdiff", "bullet", "divide", "notequal", "equivalence", "approxequal", "ellipsis", "arrowvertex", "arrowhorizex", "carriagereturn", "aleph", "Ifraktur", "Rfraktur", "weierstrass", "circlemultiply", "circleplus", "emptyset", "intersection", "union", "propersuperset", "reflexsuperset", "notsubset", "propersubset", "reflexsubset", "element", "notelement", "angle", "gradient", "registerserif", "copyrightserif", "trademarkserif", "product", "radical", "dotmath", "logicalnot", "logicaland", "logicalor", "arrowdblboth", "arrowdblleft", "arrowdblup", "arrowdblright", "arrowdbldown", "lozenge", "angleleft", "registersans", "copyrightsans", "trademarksans", "summation", "parenlefttp", "parenleftex", "parenleftbt", "bracketlefttp", "bracketleftex", "bracketleftbt", "bracelefttp", "braceleftmid", "braceleftbt", "braceex", "", "angleright", "integral", "integraltp", "integralex", "integralbt", "parenrighttp", "parenrightex", "parenrightbt", "bracketrighttp", "bracketrightex", "bracketrightbt", "bracerighttp", "bracerightmid", "bracerightbt", ""];
        w.SymbolSetEncoding = t;
        const l = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "a1", "a2", "a202", "a3", "a4", "a5", "a119", "a118", "a117", "a11", "a12", "a13", "a14", "a15", "a16", "a105", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24", "a25", "a26", "a27", "a28", "a6", "a7", "a8", "a9", "a10", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36", "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48", "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60", "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72", "a73", "a74", "a203", "a75", "a204", "a76", "a77", "a78", "a79", "a81", "a82", "a83", "a84", "a97", "a98", "a99", "a100", "", "a89", "a90", "a93", "a94", "a91", "a92", "a205", "a85", "a206", "a86", "a87", "a88", "a95", "a96", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "a101", "a102", "a103", "a104", "a106", "a107", "a108", "a112", "a111", "a110", "a109", "a120", "a121", "a122", "a123", "a124", "a125", "a126", "a127", "a128", "a129", "a130", "a131", "a132", "a133", "a134", "a135", "a136", "a137", "a138", "a139", "a140", "a141", "a142", "a143", "a144", "a145", "a146", "a147", "a148", "a149", "a150", "a151", "a152", "a153", "a154", "a155", "a156", "a157", "a158", "a159", "a160", "a161", "a163", "a164", "a196", "a165", "a192", "a166", "a167", "a168", "a169", "a170", "a171", "a172", "a173", "a162", "a174", "a175", "a176", "a177", "a178", "a179", "a193", "a180", "a199", "a181", "a200", "a182", "", "a201", "a183", "a184", "a197", "a185", "a194", "a198", "a186", "a195", "a187", "a188", "a189", "a190", "a191", ""];
        w.ZapfDingbatsEncoding = l;
        function j(U) {
          switch (U) {
            case "WinAnsiEncoding":
              return e;
            case "StandardEncoding":
              return C;
            case "MacRomanEncoding":
              return F;
            case "SymbolSetEncoding":
              return t;
            case "ZapfDingbatsEncoding":
              return l;
            case "ExpertEncoding":
              return V;
            case "MacExpertEncoding":
              return n;
            default:
              return null;
          }
        }
      },
      /* 38 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.SEAC_ANALYSIS_ENABLED = w.MacStandardGlyphOrdering = w.FontFlags = void 0, w.normalizeFontName = v, w.recoverGlyphName = U, w.type1FontGlyphMapping = O;
        var n = V(37), F = V(39), C = V(40), e = V(2);
        const t = !0;
        w.SEAC_ANALYSIS_ENABLED = t;
        const l = {
          FixedPitch: 1,
          Serif: 2,
          Symbolic: 4,
          Script: 8,
          Nonsymbolic: 32,
          Italic: 64,
          AllCap: 65536,
          SmallCap: 131072,
          ForceBold: 262144
        };
        w.FontFlags = l;
        const j = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];
        w.MacStandardGlyphOrdering = j;
        function U(g, b) {
          if (b[g] !== void 0)
            return g;
          const i = (0, C.getUnicodeForGlyph)(g, b);
          if (i !== -1) {
            for (const P in b)
              if (b[P] === i)
                return P;
          }
          return (0, e.info)("Unable to recover a standard glyph name for: " + g), g;
        }
        function O(g, b, i) {
          const P = /* @__PURE__ */ Object.create(null);
          let d, A, I;
          const E = !!(g.flags & l.Symbolic);
          if (g.isInternalFont)
            for (I = b, A = 0; A < I.length; A++)
              d = i.indexOf(I[A]), P[A] = d >= 0 ? d : 0;
          else if (g.baseEncodingName)
            for (I = (0, n.getEncoding)(g.baseEncodingName), A = 0; A < I.length; A++)
              d = i.indexOf(I[A]), P[A] = d >= 0 ? d : 0;
          else if (E)
            for (A in b)
              P[A] = b[A];
          else
            for (I = n.StandardEncoding, A = 0; A < I.length; A++)
              d = i.indexOf(I[A]), P[A] = d >= 0 ? d : 0;
          const k = g.differences;
          let H;
          if (k)
            for (A in k) {
              const x = k[A];
              if (d = i.indexOf(x), d === -1) {
                H || (H = (0, F.getGlyphsUnicode)());
                const R = U(x, H);
                R !== x && (d = i.indexOf(R));
              }
              P[A] = d >= 0 ? d : 0;
            }
          return P;
        }
        function v(g) {
          return g.replaceAll(/[,_]/g, "-").replaceAll(/\s/g, "");
        }
      },
      /* 39 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.getGlyphsUnicode = w.getDingbatsGlyphsUnicode = void 0;
        var n = V(3);
        const F = (0, n.getLookupTableFactory)(function(e) {
          e.A = 65, e.AE = 198, e.AEacute = 508, e.AEmacron = 482, e.AEsmall = 63462, e.Aacute = 193, e.Aacutesmall = 63457, e.Abreve = 258, e.Abreveacute = 7854, e.Abrevecyrillic = 1232, e.Abrevedotbelow = 7862, e.Abrevegrave = 7856, e.Abrevehookabove = 7858, e.Abrevetilde = 7860, e.Acaron = 461, e.Acircle = 9398, e.Acircumflex = 194, e.Acircumflexacute = 7844, e.Acircumflexdotbelow = 7852, e.Acircumflexgrave = 7846, e.Acircumflexhookabove = 7848, e.Acircumflexsmall = 63458, e.Acircumflextilde = 7850, e.Acute = 63177, e.Acutesmall = 63412, e.Acyrillic = 1040, e.Adblgrave = 512, e.Adieresis = 196, e.Adieresiscyrillic = 1234, e.Adieresismacron = 478, e.Adieresissmall = 63460, e.Adotbelow = 7840, e.Adotmacron = 480, e.Agrave = 192, e.Agravesmall = 63456, e.Ahookabove = 7842, e.Aiecyrillic = 1236, e.Ainvertedbreve = 514, e.Alpha = 913, e.Alphatonos = 902, e.Amacron = 256, e.Amonospace = 65313, e.Aogonek = 260, e.Aring = 197, e.Aringacute = 506, e.Aringbelow = 7680, e.Aringsmall = 63461, e.Asmall = 63329, e.Atilde = 195, e.Atildesmall = 63459, e.Aybarmenian = 1329, e.B = 66, e.Bcircle = 9399, e.Bdotaccent = 7682, e.Bdotbelow = 7684, e.Becyrillic = 1041, e.Benarmenian = 1330, e.Beta = 914, e.Bhook = 385, e.Blinebelow = 7686, e.Bmonospace = 65314, e.Brevesmall = 63220, e.Bsmall = 63330, e.Btopbar = 386, e.C = 67, e.Caarmenian = 1342, e.Cacute = 262, e.Caron = 63178, e.Caronsmall = 63221, e.Ccaron = 268, e.Ccedilla = 199, e.Ccedillaacute = 7688, e.Ccedillasmall = 63463, e.Ccircle = 9400, e.Ccircumflex = 264, e.Cdot = 266, e.Cdotaccent = 266, e.Cedillasmall = 63416, e.Chaarmenian = 1353, e.Cheabkhasiancyrillic = 1212, e.Checyrillic = 1063, e.Chedescenderabkhasiancyrillic = 1214, e.Chedescendercyrillic = 1206, e.Chedieresiscyrillic = 1268, e.Cheharmenian = 1347, e.Chekhakassiancyrillic = 1227, e.Cheverticalstrokecyrillic = 1208, e.Chi = 935, e.Chook = 391, e.Circumflexsmall = 63222, e.Cmonospace = 65315, e.Coarmenian = 1361, e.Csmall = 63331, e.D = 68, e.DZ = 497, e.DZcaron = 452, e.Daarmenian = 1332, e.Dafrican = 393, e.Dcaron = 270, e.Dcedilla = 7696, e.Dcircle = 9401, e.Dcircumflexbelow = 7698, e.Dcroat = 272, e.Ddotaccent = 7690, e.Ddotbelow = 7692, e.Decyrillic = 1044, e.Deicoptic = 1006, e.Delta = 8710, e.Deltagreek = 916, e.Dhook = 394, e.Dieresis = 63179, e.DieresisAcute = 63180, e.DieresisGrave = 63181, e.Dieresissmall = 63400, e.Digammagreek = 988, e.Djecyrillic = 1026, e.Dlinebelow = 7694, e.Dmonospace = 65316, e.Dotaccentsmall = 63223, e.Dslash = 272, e.Dsmall = 63332, e.Dtopbar = 395, e.Dz = 498, e.Dzcaron = 453, e.Dzeabkhasiancyrillic = 1248, e.Dzecyrillic = 1029, e.Dzhecyrillic = 1039, e.E = 69, e.Eacute = 201, e.Eacutesmall = 63465, e.Ebreve = 276, e.Ecaron = 282, e.Ecedillabreve = 7708, e.Echarmenian = 1333, e.Ecircle = 9402, e.Ecircumflex = 202, e.Ecircumflexacute = 7870, e.Ecircumflexbelow = 7704, e.Ecircumflexdotbelow = 7878, e.Ecircumflexgrave = 7872, e.Ecircumflexhookabove = 7874, e.Ecircumflexsmall = 63466, e.Ecircumflextilde = 7876, e.Ecyrillic = 1028, e.Edblgrave = 516, e.Edieresis = 203, e.Edieresissmall = 63467, e.Edot = 278, e.Edotaccent = 278, e.Edotbelow = 7864, e.Efcyrillic = 1060, e.Egrave = 200, e.Egravesmall = 63464, e.Eharmenian = 1335, e.Ehookabove = 7866, e.Eightroman = 8551, e.Einvertedbreve = 518, e.Eiotifiedcyrillic = 1124, e.Elcyrillic = 1051, e.Elevenroman = 8554, e.Emacron = 274, e.Emacronacute = 7702, e.Emacrongrave = 7700, e.Emcyrillic = 1052, e.Emonospace = 65317, e.Encyrillic = 1053, e.Endescendercyrillic = 1186, e.Eng = 330, e.Enghecyrillic = 1188, e.Enhookcyrillic = 1223, e.Eogonek = 280, e.Eopen = 400, e.Epsilon = 917, e.Epsilontonos = 904, e.Ercyrillic = 1056, e.Ereversed = 398, e.Ereversedcyrillic = 1069, e.Escyrillic = 1057, e.Esdescendercyrillic = 1194, e.Esh = 425, e.Esmall = 63333, e.Eta = 919, e.Etarmenian = 1336, e.Etatonos = 905, e.Eth = 208, e.Ethsmall = 63472, e.Etilde = 7868, e.Etildebelow = 7706, e.Euro = 8364, e.Ezh = 439, e.Ezhcaron = 494, e.Ezhreversed = 440, e.F = 70, e.Fcircle = 9403, e.Fdotaccent = 7710, e.Feharmenian = 1366, e.Feicoptic = 996, e.Fhook = 401, e.Fitacyrillic = 1138, e.Fiveroman = 8548, e.Fmonospace = 65318, e.Fourroman = 8547, e.Fsmall = 63334, e.G = 71, e.GBsquare = 13191, e.Gacute = 500, e.Gamma = 915, e.Gammaafrican = 404, e.Gangiacoptic = 1002, e.Gbreve = 286, e.Gcaron = 486, e.Gcedilla = 290, e.Gcircle = 9404, e.Gcircumflex = 284, e.Gcommaaccent = 290, e.Gdot = 288, e.Gdotaccent = 288, e.Gecyrillic = 1043, e.Ghadarmenian = 1346, e.Ghemiddlehookcyrillic = 1172, e.Ghestrokecyrillic = 1170, e.Gheupturncyrillic = 1168, e.Ghook = 403, e.Gimarmenian = 1331, e.Gjecyrillic = 1027, e.Gmacron = 7712, e.Gmonospace = 65319, e.Grave = 63182, e.Gravesmall = 63328, e.Gsmall = 63335, e.Gsmallhook = 667, e.Gstroke = 484, e.H = 72, e.H18533 = 9679, e.H18543 = 9642, e.H18551 = 9643, e.H22073 = 9633, e.HPsquare = 13259, e.Haabkhasiancyrillic = 1192, e.Hadescendercyrillic = 1202, e.Hardsigncyrillic = 1066, e.Hbar = 294, e.Hbrevebelow = 7722, e.Hcedilla = 7720, e.Hcircle = 9405, e.Hcircumflex = 292, e.Hdieresis = 7718, e.Hdotaccent = 7714, e.Hdotbelow = 7716, e.Hmonospace = 65320, e.Hoarmenian = 1344, e.Horicoptic = 1e3, e.Hsmall = 63336, e.Hungarumlaut = 63183, e.Hungarumlautsmall = 63224, e.Hzsquare = 13200, e.I = 73, e.IAcyrillic = 1071, e.IJ = 306, e.IUcyrillic = 1070, e.Iacute = 205, e.Iacutesmall = 63469, e.Ibreve = 300, e.Icaron = 463, e.Icircle = 9406, e.Icircumflex = 206, e.Icircumflexsmall = 63470, e.Icyrillic = 1030, e.Idblgrave = 520, e.Idieresis = 207, e.Idieresisacute = 7726, e.Idieresiscyrillic = 1252, e.Idieresissmall = 63471, e.Idot = 304, e.Idotaccent = 304, e.Idotbelow = 7882, e.Iebrevecyrillic = 1238, e.Iecyrillic = 1045, e.Ifraktur = 8465, e.Igrave = 204, e.Igravesmall = 63468, e.Ihookabove = 7880, e.Iicyrillic = 1048, e.Iinvertedbreve = 522, e.Iishortcyrillic = 1049, e.Imacron = 298, e.Imacroncyrillic = 1250, e.Imonospace = 65321, e.Iniarmenian = 1339, e.Iocyrillic = 1025, e.Iogonek = 302, e.Iota = 921, e.Iotaafrican = 406, e.Iotadieresis = 938, e.Iotatonos = 906, e.Ismall = 63337, e.Istroke = 407, e.Itilde = 296, e.Itildebelow = 7724, e.Izhitsacyrillic = 1140, e.Izhitsadblgravecyrillic = 1142, e.J = 74, e.Jaarmenian = 1345, e.Jcircle = 9407, e.Jcircumflex = 308, e.Jecyrillic = 1032, e.Jheharmenian = 1355, e.Jmonospace = 65322, e.Jsmall = 63338, e.K = 75, e.KBsquare = 13189, e.KKsquare = 13261, e.Kabashkircyrillic = 1184, e.Kacute = 7728, e.Kacyrillic = 1050, e.Kadescendercyrillic = 1178, e.Kahookcyrillic = 1219, e.Kappa = 922, e.Kastrokecyrillic = 1182, e.Kaverticalstrokecyrillic = 1180, e.Kcaron = 488, e.Kcedilla = 310, e.Kcircle = 9408, e.Kcommaaccent = 310, e.Kdotbelow = 7730, e.Keharmenian = 1364, e.Kenarmenian = 1343, e.Khacyrillic = 1061, e.Kheicoptic = 998, e.Khook = 408, e.Kjecyrillic = 1036, e.Klinebelow = 7732, e.Kmonospace = 65323, e.Koppacyrillic = 1152, e.Koppagreek = 990, e.Ksicyrillic = 1134, e.Ksmall = 63339, e.L = 76, e.LJ = 455, e.LL = 63167, e.Lacute = 313, e.Lambda = 923, e.Lcaron = 317, e.Lcedilla = 315, e.Lcircle = 9409, e.Lcircumflexbelow = 7740, e.Lcommaaccent = 315, e.Ldot = 319, e.Ldotaccent = 319, e.Ldotbelow = 7734, e.Ldotbelowmacron = 7736, e.Liwnarmenian = 1340, e.Lj = 456, e.Ljecyrillic = 1033, e.Llinebelow = 7738, e.Lmonospace = 65324, e.Lslash = 321, e.Lslashsmall = 63225, e.Lsmall = 63340, e.M = 77, e.MBsquare = 13190, e.Macron = 63184, e.Macronsmall = 63407, e.Macute = 7742, e.Mcircle = 9410, e.Mdotaccent = 7744, e.Mdotbelow = 7746, e.Menarmenian = 1348, e.Mmonospace = 65325, e.Msmall = 63341, e.Mturned = 412, e.Mu = 924, e.N = 78, e.NJ = 458, e.Nacute = 323, e.Ncaron = 327, e.Ncedilla = 325, e.Ncircle = 9411, e.Ncircumflexbelow = 7754, e.Ncommaaccent = 325, e.Ndotaccent = 7748, e.Ndotbelow = 7750, e.Nhookleft = 413, e.Nineroman = 8552, e.Nj = 459, e.Njecyrillic = 1034, e.Nlinebelow = 7752, e.Nmonospace = 65326, e.Nowarmenian = 1350, e.Nsmall = 63342, e.Ntilde = 209, e.Ntildesmall = 63473, e.Nu = 925, e.O = 79, e.OE = 338, e.OEsmall = 63226, e.Oacute = 211, e.Oacutesmall = 63475, e.Obarredcyrillic = 1256, e.Obarreddieresiscyrillic = 1258, e.Obreve = 334, e.Ocaron = 465, e.Ocenteredtilde = 415, e.Ocircle = 9412, e.Ocircumflex = 212, e.Ocircumflexacute = 7888, e.Ocircumflexdotbelow = 7896, e.Ocircumflexgrave = 7890, e.Ocircumflexhookabove = 7892, e.Ocircumflexsmall = 63476, e.Ocircumflextilde = 7894, e.Ocyrillic = 1054, e.Odblacute = 336, e.Odblgrave = 524, e.Odieresis = 214, e.Odieresiscyrillic = 1254, e.Odieresissmall = 63478, e.Odotbelow = 7884, e.Ogoneksmall = 63227, e.Ograve = 210, e.Ogravesmall = 63474, e.Oharmenian = 1365, e.Ohm = 8486, e.Ohookabove = 7886, e.Ohorn = 416, e.Ohornacute = 7898, e.Ohorndotbelow = 7906, e.Ohorngrave = 7900, e.Ohornhookabove = 7902, e.Ohorntilde = 7904, e.Ohungarumlaut = 336, e.Oi = 418, e.Oinvertedbreve = 526, e.Omacron = 332, e.Omacronacute = 7762, e.Omacrongrave = 7760, e.Omega = 8486, e.Omegacyrillic = 1120, e.Omegagreek = 937, e.Omegaroundcyrillic = 1146, e.Omegatitlocyrillic = 1148, e.Omegatonos = 911, e.Omicron = 927, e.Omicrontonos = 908, e.Omonospace = 65327, e.Oneroman = 8544, e.Oogonek = 490, e.Oogonekmacron = 492, e.Oopen = 390, e.Oslash = 216, e.Oslashacute = 510, e.Oslashsmall = 63480, e.Osmall = 63343, e.Ostrokeacute = 510, e.Otcyrillic = 1150, e.Otilde = 213, e.Otildeacute = 7756, e.Otildedieresis = 7758, e.Otildesmall = 63477, e.P = 80, e.Pacute = 7764, e.Pcircle = 9413, e.Pdotaccent = 7766, e.Pecyrillic = 1055, e.Peharmenian = 1354, e.Pemiddlehookcyrillic = 1190, e.Phi = 934, e.Phook = 420, e.Pi = 928, e.Piwrarmenian = 1363, e.Pmonospace = 65328, e.Psi = 936, e.Psicyrillic = 1136, e.Psmall = 63344, e.Q = 81, e.Qcircle = 9414, e.Qmonospace = 65329, e.Qsmall = 63345, e.R = 82, e.Raarmenian = 1356, e.Racute = 340, e.Rcaron = 344, e.Rcedilla = 342, e.Rcircle = 9415, e.Rcommaaccent = 342, e.Rdblgrave = 528, e.Rdotaccent = 7768, e.Rdotbelow = 7770, e.Rdotbelowmacron = 7772, e.Reharmenian = 1360, e.Rfraktur = 8476, e.Rho = 929, e.Ringsmall = 63228, e.Rinvertedbreve = 530, e.Rlinebelow = 7774, e.Rmonospace = 65330, e.Rsmall = 63346, e.Rsmallinverted = 641, e.Rsmallinvertedsuperior = 694, e.S = 83, e.SF010000 = 9484, e.SF020000 = 9492, e.SF030000 = 9488, e.SF040000 = 9496, e.SF050000 = 9532, e.SF060000 = 9516, e.SF070000 = 9524, e.SF080000 = 9500, e.SF090000 = 9508, e.SF100000 = 9472, e.SF110000 = 9474, e.SF190000 = 9569, e.SF200000 = 9570, e.SF210000 = 9558, e.SF220000 = 9557, e.SF230000 = 9571, e.SF240000 = 9553, e.SF250000 = 9559, e.SF260000 = 9565, e.SF270000 = 9564, e.SF280000 = 9563, e.SF360000 = 9566, e.SF370000 = 9567, e.SF380000 = 9562, e.SF390000 = 9556, e.SF400000 = 9577, e.SF410000 = 9574, e.SF420000 = 9568, e.SF430000 = 9552, e.SF440000 = 9580, e.SF450000 = 9575, e.SF460000 = 9576, e.SF470000 = 9572, e.SF480000 = 9573, e.SF490000 = 9561, e.SF500000 = 9560, e.SF510000 = 9554, e.SF520000 = 9555, e.SF530000 = 9579, e.SF540000 = 9578, e.Sacute = 346, e.Sacutedotaccent = 7780, e.Sampigreek = 992, e.Scaron = 352, e.Scarondotaccent = 7782, e.Scaronsmall = 63229, e.Scedilla = 350, e.Schwa = 399, e.Schwacyrillic = 1240, e.Schwadieresiscyrillic = 1242, e.Scircle = 9416, e.Scircumflex = 348, e.Scommaaccent = 536, e.Sdotaccent = 7776, e.Sdotbelow = 7778, e.Sdotbelowdotaccent = 7784, e.Seharmenian = 1357, e.Sevenroman = 8550, e.Shaarmenian = 1351, e.Shacyrillic = 1064, e.Shchacyrillic = 1065, e.Sheicoptic = 994, e.Shhacyrillic = 1210, e.Shimacoptic = 1004, e.Sigma = 931, e.Sixroman = 8549, e.Smonospace = 65331, e.Softsigncyrillic = 1068, e.Ssmall = 63347, e.Stigmagreek = 986, e.T = 84, e.Tau = 932, e.Tbar = 358, e.Tcaron = 356, e.Tcedilla = 354, e.Tcircle = 9417, e.Tcircumflexbelow = 7792, e.Tcommaaccent = 354, e.Tdotaccent = 7786, e.Tdotbelow = 7788, e.Tecyrillic = 1058, e.Tedescendercyrillic = 1196, e.Tenroman = 8553, e.Tetsecyrillic = 1204, e.Theta = 920, e.Thook = 428, e.Thorn = 222, e.Thornsmall = 63486, e.Threeroman = 8546, e.Tildesmall = 63230, e.Tiwnarmenian = 1359, e.Tlinebelow = 7790, e.Tmonospace = 65332, e.Toarmenian = 1337, e.Tonefive = 444, e.Tonesix = 388, e.Tonetwo = 423, e.Tretroflexhook = 430, e.Tsecyrillic = 1062, e.Tshecyrillic = 1035, e.Tsmall = 63348, e.Twelveroman = 8555, e.Tworoman = 8545, e.U = 85, e.Uacute = 218, e.Uacutesmall = 63482, e.Ubreve = 364, e.Ucaron = 467, e.Ucircle = 9418, e.Ucircumflex = 219, e.Ucircumflexbelow = 7798, e.Ucircumflexsmall = 63483, e.Ucyrillic = 1059, e.Udblacute = 368, e.Udblgrave = 532, e.Udieresis = 220, e.Udieresisacute = 471, e.Udieresisbelow = 7794, e.Udieresiscaron = 473, e.Udieresiscyrillic = 1264, e.Udieresisgrave = 475, e.Udieresismacron = 469, e.Udieresissmall = 63484, e.Udotbelow = 7908, e.Ugrave = 217, e.Ugravesmall = 63481, e.Uhookabove = 7910, e.Uhorn = 431, e.Uhornacute = 7912, e.Uhorndotbelow = 7920, e.Uhorngrave = 7914, e.Uhornhookabove = 7916, e.Uhorntilde = 7918, e.Uhungarumlaut = 368, e.Uhungarumlautcyrillic = 1266, e.Uinvertedbreve = 534, e.Ukcyrillic = 1144, e.Umacron = 362, e.Umacroncyrillic = 1262, e.Umacrondieresis = 7802, e.Umonospace = 65333, e.Uogonek = 370, e.Upsilon = 933, e.Upsilon1 = 978, e.Upsilonacutehooksymbolgreek = 979, e.Upsilonafrican = 433, e.Upsilondieresis = 939, e.Upsilondieresishooksymbolgreek = 980, e.Upsilonhooksymbol = 978, e.Upsilontonos = 910, e.Uring = 366, e.Ushortcyrillic = 1038, e.Usmall = 63349, e.Ustraightcyrillic = 1198, e.Ustraightstrokecyrillic = 1200, e.Utilde = 360, e.Utildeacute = 7800, e.Utildebelow = 7796, e.V = 86, e.Vcircle = 9419, e.Vdotbelow = 7806, e.Vecyrillic = 1042, e.Vewarmenian = 1358, e.Vhook = 434, e.Vmonospace = 65334, e.Voarmenian = 1352, e.Vsmall = 63350, e.Vtilde = 7804, e.W = 87, e.Wacute = 7810, e.Wcircle = 9420, e.Wcircumflex = 372, e.Wdieresis = 7812, e.Wdotaccent = 7814, e.Wdotbelow = 7816, e.Wgrave = 7808, e.Wmonospace = 65335, e.Wsmall = 63351, e.X = 88, e.Xcircle = 9421, e.Xdieresis = 7820, e.Xdotaccent = 7818, e.Xeharmenian = 1341, e.Xi = 926, e.Xmonospace = 65336, e.Xsmall = 63352, e.Y = 89, e.Yacute = 221, e.Yacutesmall = 63485, e.Yatcyrillic = 1122, e.Ycircle = 9422, e.Ycircumflex = 374, e.Ydieresis = 376, e.Ydieresissmall = 63487, e.Ydotaccent = 7822, e.Ydotbelow = 7924, e.Yericyrillic = 1067, e.Yerudieresiscyrillic = 1272, e.Ygrave = 7922, e.Yhook = 435, e.Yhookabove = 7926, e.Yiarmenian = 1349, e.Yicyrillic = 1031, e.Yiwnarmenian = 1362, e.Ymonospace = 65337, e.Ysmall = 63353, e.Ytilde = 7928, e.Yusbigcyrillic = 1130, e.Yusbigiotifiedcyrillic = 1132, e.Yuslittlecyrillic = 1126, e.Yuslittleiotifiedcyrillic = 1128, e.Z = 90, e.Zaarmenian = 1334, e.Zacute = 377, e.Zcaron = 381, e.Zcaronsmall = 63231, e.Zcircle = 9423, e.Zcircumflex = 7824, e.Zdot = 379, e.Zdotaccent = 379, e.Zdotbelow = 7826, e.Zecyrillic = 1047, e.Zedescendercyrillic = 1176, e.Zedieresiscyrillic = 1246, e.Zeta = 918, e.Zhearmenian = 1338, e.Zhebrevecyrillic = 1217, e.Zhecyrillic = 1046, e.Zhedescendercyrillic = 1174, e.Zhedieresiscyrillic = 1244, e.Zlinebelow = 7828, e.Zmonospace = 65338, e.Zsmall = 63354, e.Zstroke = 437, e.a = 97, e.aabengali = 2438, e.aacute = 225, e.aadeva = 2310, e.aagujarati = 2694, e.aagurmukhi = 2566, e.aamatragurmukhi = 2622, e.aarusquare = 13059, e.aavowelsignbengali = 2494, e.aavowelsigndeva = 2366, e.aavowelsigngujarati = 2750, e.abbreviationmarkarmenian = 1375, e.abbreviationsigndeva = 2416, e.abengali = 2437, e.abopomofo = 12570, e.abreve = 259, e.abreveacute = 7855, e.abrevecyrillic = 1233, e.abrevedotbelow = 7863, e.abrevegrave = 7857, e.abrevehookabove = 7859, e.abrevetilde = 7861, e.acaron = 462, e.acircle = 9424, e.acircumflex = 226, e.acircumflexacute = 7845, e.acircumflexdotbelow = 7853, e.acircumflexgrave = 7847, e.acircumflexhookabove = 7849, e.acircumflextilde = 7851, e.acute = 180, e.acutebelowcmb = 791, e.acutecmb = 769, e.acutecomb = 769, e.acutedeva = 2388, e.acutelowmod = 719, e.acutetonecmb = 833, e.acyrillic = 1072, e.adblgrave = 513, e.addakgurmukhi = 2673, e.adeva = 2309, e.adieresis = 228, e.adieresiscyrillic = 1235, e.adieresismacron = 479, e.adotbelow = 7841, e.adotmacron = 481, e.ae = 230, e.aeacute = 509, e.aekorean = 12624, e.aemacron = 483, e.afii00208 = 8213, e.afii08941 = 8356, e.afii10017 = 1040, e.afii10018 = 1041, e.afii10019 = 1042, e.afii10020 = 1043, e.afii10021 = 1044, e.afii10022 = 1045, e.afii10023 = 1025, e.afii10024 = 1046, e.afii10025 = 1047, e.afii10026 = 1048, e.afii10027 = 1049, e.afii10028 = 1050, e.afii10029 = 1051, e.afii10030 = 1052, e.afii10031 = 1053, e.afii10032 = 1054, e.afii10033 = 1055, e.afii10034 = 1056, e.afii10035 = 1057, e.afii10036 = 1058, e.afii10037 = 1059, e.afii10038 = 1060, e.afii10039 = 1061, e.afii10040 = 1062, e.afii10041 = 1063, e.afii10042 = 1064, e.afii10043 = 1065, e.afii10044 = 1066, e.afii10045 = 1067, e.afii10046 = 1068, e.afii10047 = 1069, e.afii10048 = 1070, e.afii10049 = 1071, e.afii10050 = 1168, e.afii10051 = 1026, e.afii10052 = 1027, e.afii10053 = 1028, e.afii10054 = 1029, e.afii10055 = 1030, e.afii10056 = 1031, e.afii10057 = 1032, e.afii10058 = 1033, e.afii10059 = 1034, e.afii10060 = 1035, e.afii10061 = 1036, e.afii10062 = 1038, e.afii10063 = 63172, e.afii10064 = 63173, e.afii10065 = 1072, e.afii10066 = 1073, e.afii10067 = 1074, e.afii10068 = 1075, e.afii10069 = 1076, e.afii10070 = 1077, e.afii10071 = 1105, e.afii10072 = 1078, e.afii10073 = 1079, e.afii10074 = 1080, e.afii10075 = 1081, e.afii10076 = 1082, e.afii10077 = 1083, e.afii10078 = 1084, e.afii10079 = 1085, e.afii10080 = 1086, e.afii10081 = 1087, e.afii10082 = 1088, e.afii10083 = 1089, e.afii10084 = 1090, e.afii10085 = 1091, e.afii10086 = 1092, e.afii10087 = 1093, e.afii10088 = 1094, e.afii10089 = 1095, e.afii10090 = 1096, e.afii10091 = 1097, e.afii10092 = 1098, e.afii10093 = 1099, e.afii10094 = 1100, e.afii10095 = 1101, e.afii10096 = 1102, e.afii10097 = 1103, e.afii10098 = 1169, e.afii10099 = 1106, e.afii10100 = 1107, e.afii10101 = 1108, e.afii10102 = 1109, e.afii10103 = 1110, e.afii10104 = 1111, e.afii10105 = 1112, e.afii10106 = 1113, e.afii10107 = 1114, e.afii10108 = 1115, e.afii10109 = 1116, e.afii10110 = 1118, e.afii10145 = 1039, e.afii10146 = 1122, e.afii10147 = 1138, e.afii10148 = 1140, e.afii10192 = 63174, e.afii10193 = 1119, e.afii10194 = 1123, e.afii10195 = 1139, e.afii10196 = 1141, e.afii10831 = 63175, e.afii10832 = 63176, e.afii10846 = 1241, e.afii299 = 8206, e.afii300 = 8207, e.afii301 = 8205, e.afii57381 = 1642, e.afii57388 = 1548, e.afii57392 = 1632, e.afii57393 = 1633, e.afii57394 = 1634, e.afii57395 = 1635, e.afii57396 = 1636, e.afii57397 = 1637, e.afii57398 = 1638, e.afii57399 = 1639, e.afii57400 = 1640, e.afii57401 = 1641, e.afii57403 = 1563, e.afii57407 = 1567, e.afii57409 = 1569, e.afii57410 = 1570, e.afii57411 = 1571, e.afii57412 = 1572, e.afii57413 = 1573, e.afii57414 = 1574, e.afii57415 = 1575, e.afii57416 = 1576, e.afii57417 = 1577, e.afii57418 = 1578, e.afii57419 = 1579, e.afii57420 = 1580, e.afii57421 = 1581, e.afii57422 = 1582, e.afii57423 = 1583, e.afii57424 = 1584, e.afii57425 = 1585, e.afii57426 = 1586, e.afii57427 = 1587, e.afii57428 = 1588, e.afii57429 = 1589, e.afii57430 = 1590, e.afii57431 = 1591, e.afii57432 = 1592, e.afii57433 = 1593, e.afii57434 = 1594, e.afii57440 = 1600, e.afii57441 = 1601, e.afii57442 = 1602, e.afii57443 = 1603, e.afii57444 = 1604, e.afii57445 = 1605, e.afii57446 = 1606, e.afii57448 = 1608, e.afii57449 = 1609, e.afii57450 = 1610, e.afii57451 = 1611, e.afii57452 = 1612, e.afii57453 = 1613, e.afii57454 = 1614, e.afii57455 = 1615, e.afii57456 = 1616, e.afii57457 = 1617, e.afii57458 = 1618, e.afii57470 = 1607, e.afii57505 = 1700, e.afii57506 = 1662, e.afii57507 = 1670, e.afii57508 = 1688, e.afii57509 = 1711, e.afii57511 = 1657, e.afii57512 = 1672, e.afii57513 = 1681, e.afii57514 = 1722, e.afii57519 = 1746, e.afii57534 = 1749, e.afii57636 = 8362, e.afii57645 = 1470, e.afii57658 = 1475, e.afii57664 = 1488, e.afii57665 = 1489, e.afii57666 = 1490, e.afii57667 = 1491, e.afii57668 = 1492, e.afii57669 = 1493, e.afii57670 = 1494, e.afii57671 = 1495, e.afii57672 = 1496, e.afii57673 = 1497, e.afii57674 = 1498, e.afii57675 = 1499, e.afii57676 = 1500, e.afii57677 = 1501, e.afii57678 = 1502, e.afii57679 = 1503, e.afii57680 = 1504, e.afii57681 = 1505, e.afii57682 = 1506, e.afii57683 = 1507, e.afii57684 = 1508, e.afii57685 = 1509, e.afii57686 = 1510, e.afii57687 = 1511, e.afii57688 = 1512, e.afii57689 = 1513, e.afii57690 = 1514, e.afii57694 = 64298, e.afii57695 = 64299, e.afii57700 = 64331, e.afii57705 = 64287, e.afii57716 = 1520, e.afii57717 = 1521, e.afii57718 = 1522, e.afii57723 = 64309, e.afii57793 = 1460, e.afii57794 = 1461, e.afii57795 = 1462, e.afii57796 = 1467, e.afii57797 = 1464, e.afii57798 = 1463, e.afii57799 = 1456, e.afii57800 = 1458, e.afii57801 = 1457, e.afii57802 = 1459, e.afii57803 = 1474, e.afii57804 = 1473, e.afii57806 = 1465, e.afii57807 = 1468, e.afii57839 = 1469, e.afii57841 = 1471, e.afii57842 = 1472, e.afii57929 = 700, e.afii61248 = 8453, e.afii61289 = 8467, e.afii61352 = 8470, e.afii61573 = 8236, e.afii61574 = 8237, e.afii61575 = 8238, e.afii61664 = 8204, e.afii63167 = 1645, e.afii64937 = 701, e.agrave = 224, e.agujarati = 2693, e.agurmukhi = 2565, e.ahiragana = 12354, e.ahookabove = 7843, e.aibengali = 2448, e.aibopomofo = 12574, e.aideva = 2320, e.aiecyrillic = 1237, e.aigujarati = 2704, e.aigurmukhi = 2576, e.aimatragurmukhi = 2632, e.ainarabic = 1593, e.ainfinalarabic = 65226, e.aininitialarabic = 65227, e.ainmedialarabic = 65228, e.ainvertedbreve = 515, e.aivowelsignbengali = 2504, e.aivowelsigndeva = 2376, e.aivowelsigngujarati = 2760, e.akatakana = 12450, e.akatakanahalfwidth = 65393, e.akorean = 12623, e.alef = 1488, e.alefarabic = 1575, e.alefdageshhebrew = 64304, e.aleffinalarabic = 65166, e.alefhamzaabovearabic = 1571, e.alefhamzaabovefinalarabic = 65156, e.alefhamzabelowarabic = 1573, e.alefhamzabelowfinalarabic = 65160, e.alefhebrew = 1488, e.aleflamedhebrew = 64335, e.alefmaddaabovearabic = 1570, e.alefmaddaabovefinalarabic = 65154, e.alefmaksuraarabic = 1609, e.alefmaksurafinalarabic = 65264, e.alefmaksurainitialarabic = 65267, e.alefmaksuramedialarabic = 65268, e.alefpatahhebrew = 64302, e.alefqamatshebrew = 64303, e.aleph = 8501, e.allequal = 8780, e.alpha = 945, e.alphatonos = 940, e.amacron = 257, e.amonospace = 65345, e.ampersand = 38, e.ampersandmonospace = 65286, e.ampersandsmall = 63270, e.amsquare = 13250, e.anbopomofo = 12578, e.angbopomofo = 12580, e.angbracketleft = 12296, e.angbracketright = 12297, e.angkhankhuthai = 3674, e.angle = 8736, e.anglebracketleft = 12296, e.anglebracketleftvertical = 65087, e.anglebracketright = 12297, e.anglebracketrightvertical = 65088, e.angleleft = 9001, e.angleright = 9002, e.angstrom = 8491, e.anoteleia = 903, e.anudattadeva = 2386, e.anusvarabengali = 2434, e.anusvaradeva = 2306, e.anusvaragujarati = 2690, e.aogonek = 261, e.apaatosquare = 13056, e.aparen = 9372, e.apostrophearmenian = 1370, e.apostrophemod = 700, e.apple = 63743, e.approaches = 8784, e.approxequal = 8776, e.approxequalorimage = 8786, e.approximatelyequal = 8773, e.araeaekorean = 12686, e.araeakorean = 12685, e.arc = 8978, e.arighthalfring = 7834, e.aring = 229, e.aringacute = 507, e.aringbelow = 7681, e.arrowboth = 8596, e.arrowdashdown = 8675, e.arrowdashleft = 8672, e.arrowdashright = 8674, e.arrowdashup = 8673, e.arrowdblboth = 8660, e.arrowdbldown = 8659, e.arrowdblleft = 8656, e.arrowdblright = 8658, e.arrowdblup = 8657, e.arrowdown = 8595, e.arrowdownleft = 8601, e.arrowdownright = 8600, e.arrowdownwhite = 8681, e.arrowheaddownmod = 709, e.arrowheadleftmod = 706, e.arrowheadrightmod = 707, e.arrowheadupmod = 708, e.arrowhorizex = 63719, e.arrowleft = 8592, e.arrowleftdbl = 8656, e.arrowleftdblstroke = 8653, e.arrowleftoverright = 8646, e.arrowleftwhite = 8678, e.arrowright = 8594, e.arrowrightdblstroke = 8655, e.arrowrightheavy = 10142, e.arrowrightoverleft = 8644, e.arrowrightwhite = 8680, e.arrowtableft = 8676, e.arrowtabright = 8677, e.arrowup = 8593, e.arrowupdn = 8597, e.arrowupdnbse = 8616, e.arrowupdownbase = 8616, e.arrowupleft = 8598, e.arrowupleftofdown = 8645, e.arrowupright = 8599, e.arrowupwhite = 8679, e.arrowvertex = 63718, e.asciicircum = 94, e.asciicircummonospace = 65342, e.asciitilde = 126, e.asciitildemonospace = 65374, e.ascript = 593, e.ascriptturned = 594, e.asmallhiragana = 12353, e.asmallkatakana = 12449, e.asmallkatakanahalfwidth = 65383, e.asterisk = 42, e.asteriskaltonearabic = 1645, e.asteriskarabic = 1645, e.asteriskmath = 8727, e.asteriskmonospace = 65290, e.asterisksmall = 65121, e.asterism = 8258, e.asuperior = 63209, e.asymptoticallyequal = 8771, e.at = 64, e.atilde = 227, e.atmonospace = 65312, e.atsmall = 65131, e.aturned = 592, e.aubengali = 2452, e.aubopomofo = 12576, e.audeva = 2324, e.augujarati = 2708, e.augurmukhi = 2580, e.aulengthmarkbengali = 2519, e.aumatragurmukhi = 2636, e.auvowelsignbengali = 2508, e.auvowelsigndeva = 2380, e.auvowelsigngujarati = 2764, e.avagrahadeva = 2365, e.aybarmenian = 1377, e.ayin = 1506, e.ayinaltonehebrew = 64288, e.ayinhebrew = 1506, e.b = 98, e.babengali = 2476, e.backslash = 92, e.backslashmonospace = 65340, e.badeva = 2348, e.bagujarati = 2732, e.bagurmukhi = 2604, e.bahiragana = 12400, e.bahtthai = 3647, e.bakatakana = 12496, e.bar = 124, e.barmonospace = 65372, e.bbopomofo = 12549, e.bcircle = 9425, e.bdotaccent = 7683, e.bdotbelow = 7685, e.beamedsixteenthnotes = 9836, e.because = 8757, e.becyrillic = 1073, e.beharabic = 1576, e.behfinalarabic = 65168, e.behinitialarabic = 65169, e.behiragana = 12409, e.behmedialarabic = 65170, e.behmeeminitialarabic = 64671, e.behmeemisolatedarabic = 64520, e.behnoonfinalarabic = 64621, e.bekatakana = 12505, e.benarmenian = 1378, e.bet = 1489, e.beta = 946, e.betasymbolgreek = 976, e.betdagesh = 64305, e.betdageshhebrew = 64305, e.bethebrew = 1489, e.betrafehebrew = 64332, e.bhabengali = 2477, e.bhadeva = 2349, e.bhagujarati = 2733, e.bhagurmukhi = 2605, e.bhook = 595, e.bihiragana = 12403, e.bikatakana = 12499, e.bilabialclick = 664, e.bindigurmukhi = 2562, e.birusquare = 13105, e.blackcircle = 9679, e.blackdiamond = 9670, e.blackdownpointingtriangle = 9660, e.blackleftpointingpointer = 9668, e.blackleftpointingtriangle = 9664, e.blacklenticularbracketleft = 12304, e.blacklenticularbracketleftvertical = 65083, e.blacklenticularbracketright = 12305, e.blacklenticularbracketrightvertical = 65084, e.blacklowerlefttriangle = 9699, e.blacklowerrighttriangle = 9698, e.blackrectangle = 9644, e.blackrightpointingpointer = 9658, e.blackrightpointingtriangle = 9654, e.blacksmallsquare = 9642, e.blacksmilingface = 9787, e.blacksquare = 9632, e.blackstar = 9733, e.blackupperlefttriangle = 9700, e.blackupperrighttriangle = 9701, e.blackuppointingsmalltriangle = 9652, e.blackuppointingtriangle = 9650, e.blank = 9251, e.blinebelow = 7687, e.block = 9608, e.bmonospace = 65346, e.bobaimaithai = 3610, e.bohiragana = 12412, e.bokatakana = 12508, e.bparen = 9373, e.bqsquare = 13251, e.braceex = 63732, e.braceleft = 123, e.braceleftbt = 63731, e.braceleftmid = 63730, e.braceleftmonospace = 65371, e.braceleftsmall = 65115, e.bracelefttp = 63729, e.braceleftvertical = 65079, e.braceright = 125, e.bracerightbt = 63742, e.bracerightmid = 63741, e.bracerightmonospace = 65373, e.bracerightsmall = 65116, e.bracerighttp = 63740, e.bracerightvertical = 65080, e.bracketleft = 91, e.bracketleftbt = 63728, e.bracketleftex = 63727, e.bracketleftmonospace = 65339, e.bracketlefttp = 63726, e.bracketright = 93, e.bracketrightbt = 63739, e.bracketrightex = 63738, e.bracketrightmonospace = 65341, e.bracketrighttp = 63737, e.breve = 728, e.brevebelowcmb = 814, e.brevecmb = 774, e.breveinvertedbelowcmb = 815, e.breveinvertedcmb = 785, e.breveinverteddoublecmb = 865, e.bridgebelowcmb = 810, e.bridgeinvertedbelowcmb = 826, e.brokenbar = 166, e.bstroke = 384, e.bsuperior = 63210, e.btopbar = 387, e.buhiragana = 12406, e.bukatakana = 12502, e.bullet = 8226, e.bulletinverse = 9688, e.bulletoperator = 8729, e.bullseye = 9678, e.c = 99, e.caarmenian = 1390, e.cabengali = 2458, e.cacute = 263, e.cadeva = 2330, e.cagujarati = 2714, e.cagurmukhi = 2586, e.calsquare = 13192, e.candrabindubengali = 2433, e.candrabinducmb = 784, e.candrabindudeva = 2305, e.candrabindugujarati = 2689, e.capslock = 8682, e.careof = 8453, e.caron = 711, e.caronbelowcmb = 812, e.caroncmb = 780, e.carriagereturn = 8629, e.cbopomofo = 12568, e.ccaron = 269, e.ccedilla = 231, e.ccedillaacute = 7689, e.ccircle = 9426, e.ccircumflex = 265, e.ccurl = 597, e.cdot = 267, e.cdotaccent = 267, e.cdsquare = 13253, e.cedilla = 184, e.cedillacmb = 807, e.cent = 162, e.centigrade = 8451, e.centinferior = 63199, e.centmonospace = 65504, e.centoldstyle = 63394, e.centsuperior = 63200, e.chaarmenian = 1401, e.chabengali = 2459, e.chadeva = 2331, e.chagujarati = 2715, e.chagurmukhi = 2587, e.chbopomofo = 12564, e.cheabkhasiancyrillic = 1213, e.checkmark = 10003, e.checyrillic = 1095, e.chedescenderabkhasiancyrillic = 1215, e.chedescendercyrillic = 1207, e.chedieresiscyrillic = 1269, e.cheharmenian = 1395, e.chekhakassiancyrillic = 1228, e.cheverticalstrokecyrillic = 1209, e.chi = 967, e.chieuchacirclekorean = 12919, e.chieuchaparenkorean = 12823, e.chieuchcirclekorean = 12905, e.chieuchkorean = 12618, e.chieuchparenkorean = 12809, e.chochangthai = 3594, e.chochanthai = 3592, e.chochingthai = 3593, e.chochoethai = 3596, e.chook = 392, e.cieucacirclekorean = 12918, e.cieucaparenkorean = 12822, e.cieuccirclekorean = 12904, e.cieuckorean = 12616, e.cieucparenkorean = 12808, e.cieucuparenkorean = 12828, e.circle = 9675, e.circlecopyrt = 169, e.circlemultiply = 8855, e.circleot = 8857, e.circleplus = 8853, e.circlepostalmark = 12342, e.circlewithlefthalfblack = 9680, e.circlewithrighthalfblack = 9681, e.circumflex = 710, e.circumflexbelowcmb = 813, e.circumflexcmb = 770, e.clear = 8999, e.clickalveolar = 450, e.clickdental = 448, e.clicklateral = 449, e.clickretroflex = 451, e.club = 9827, e.clubsuitblack = 9827, e.clubsuitwhite = 9831, e.cmcubedsquare = 13220, e.cmonospace = 65347, e.cmsquaredsquare = 13216, e.coarmenian = 1409, e.colon = 58, e.colonmonetary = 8353, e.colonmonospace = 65306, e.colonsign = 8353, e.colonsmall = 65109, e.colontriangularhalfmod = 721, e.colontriangularmod = 720, e.comma = 44, e.commaabovecmb = 787, e.commaaboverightcmb = 789, e.commaaccent = 63171, e.commaarabic = 1548, e.commaarmenian = 1373, e.commainferior = 63201, e.commamonospace = 65292, e.commareversedabovecmb = 788, e.commareversedmod = 701, e.commasmall = 65104, e.commasuperior = 63202, e.commaturnedabovecmb = 786, e.commaturnedmod = 699, e.compass = 9788, e.congruent = 8773, e.contourintegral = 8750, e.control = 8963, e.controlACK = 6, e.controlBEL = 7, e.controlBS = 8, e.controlCAN = 24, e.controlCR = 13, e.controlDC1 = 17, e.controlDC2 = 18, e.controlDC3 = 19, e.controlDC4 = 20, e.controlDEL = 127, e.controlDLE = 16, e.controlEM = 25, e.controlENQ = 5, e.controlEOT = 4, e.controlESC = 27, e.controlETB = 23, e.controlETX = 3, e.controlFF = 12, e.controlFS = 28, e.controlGS = 29, e.controlHT = 9, e.controlLF = 10, e.controlNAK = 21, e.controlNULL = 0, e.controlRS = 30, e.controlSI = 15, e.controlSO = 14, e.controlSOT = 2, e.controlSTX = 1, e.controlSUB = 26, e.controlSYN = 22, e.controlUS = 31, e.controlVT = 11, e.copyright = 169, e.copyrightsans = 63721, e.copyrightserif = 63193, e.cornerbracketleft = 12300, e.cornerbracketlefthalfwidth = 65378, e.cornerbracketleftvertical = 65089, e.cornerbracketright = 12301, e.cornerbracketrighthalfwidth = 65379, e.cornerbracketrightvertical = 65090, e.corporationsquare = 13183, e.cosquare = 13255, e.coverkgsquare = 13254, e.cparen = 9374, e.cruzeiro = 8354, e.cstretched = 663, e.curlyand = 8911, e.curlyor = 8910, e.currency = 164, e.cyrBreve = 63185, e.cyrFlex = 63186, e.cyrbreve = 63188, e.cyrflex = 63189, e.d = 100, e.daarmenian = 1380, e.dabengali = 2470, e.dadarabic = 1590, e.dadeva = 2342, e.dadfinalarabic = 65214, e.dadinitialarabic = 65215, e.dadmedialarabic = 65216, e.dagesh = 1468, e.dageshhebrew = 1468, e.dagger = 8224, e.daggerdbl = 8225, e.dagujarati = 2726, e.dagurmukhi = 2598, e.dahiragana = 12384, e.dakatakana = 12480, e.dalarabic = 1583, e.dalet = 1491, e.daletdagesh = 64307, e.daletdageshhebrew = 64307, e.dalethebrew = 1491, e.dalfinalarabic = 65194, e.dammaarabic = 1615, e.dammalowarabic = 1615, e.dammatanaltonearabic = 1612, e.dammatanarabic = 1612, e.danda = 2404, e.dargahebrew = 1447, e.dargalefthebrew = 1447, e.dasiapneumatacyrilliccmb = 1157, e.dblGrave = 63187, e.dblanglebracketleft = 12298, e.dblanglebracketleftvertical = 65085, e.dblanglebracketright = 12299, e.dblanglebracketrightvertical = 65086, e.dblarchinvertedbelowcmb = 811, e.dblarrowleft = 8660, e.dblarrowright = 8658, e.dbldanda = 2405, e.dblgrave = 63190, e.dblgravecmb = 783, e.dblintegral = 8748, e.dbllowline = 8215, e.dbllowlinecmb = 819, e.dbloverlinecmb = 831, e.dblprimemod = 698, e.dblverticalbar = 8214, e.dblverticallineabovecmb = 782, e.dbopomofo = 12553, e.dbsquare = 13256, e.dcaron = 271, e.dcedilla = 7697, e.dcircle = 9427, e.dcircumflexbelow = 7699, e.dcroat = 273, e.ddabengali = 2465, e.ddadeva = 2337, e.ddagujarati = 2721, e.ddagurmukhi = 2593, e.ddalarabic = 1672, e.ddalfinalarabic = 64393, e.dddhadeva = 2396, e.ddhabengali = 2466, e.ddhadeva = 2338, e.ddhagujarati = 2722, e.ddhagurmukhi = 2594, e.ddotaccent = 7691, e.ddotbelow = 7693, e.decimalseparatorarabic = 1643, e.decimalseparatorpersian = 1643, e.decyrillic = 1076, e.degree = 176, e.dehihebrew = 1453, e.dehiragana = 12391, e.deicoptic = 1007, e.dekatakana = 12487, e.deleteleft = 9003, e.deleteright = 8998, e.delta = 948, e.deltaturned = 397, e.denominatorminusonenumeratorbengali = 2552, e.dezh = 676, e.dhabengali = 2471, e.dhadeva = 2343, e.dhagujarati = 2727, e.dhagurmukhi = 2599, e.dhook = 599, e.dialytikatonos = 901, e.dialytikatonoscmb = 836, e.diamond = 9830, e.diamondsuitwhite = 9826, e.dieresis = 168, e.dieresisacute = 63191, e.dieresisbelowcmb = 804, e.dieresiscmb = 776, e.dieresisgrave = 63192, e.dieresistonos = 901, e.dihiragana = 12386, e.dikatakana = 12482, e.dittomark = 12291, e.divide = 247, e.divides = 8739, e.divisionslash = 8725, e.djecyrillic = 1106, e.dkshade = 9619, e.dlinebelow = 7695, e.dlsquare = 13207, e.dmacron = 273, e.dmonospace = 65348, e.dnblock = 9604, e.dochadathai = 3598, e.dodekthai = 3604, e.dohiragana = 12393, e.dokatakana = 12489, e.dollar = 36, e.dollarinferior = 63203, e.dollarmonospace = 65284, e.dollaroldstyle = 63268, e.dollarsmall = 65129, e.dollarsuperior = 63204, e.dong = 8363, e.dorusquare = 13094, e.dotaccent = 729, e.dotaccentcmb = 775, e.dotbelowcmb = 803, e.dotbelowcomb = 803, e.dotkatakana = 12539, e.dotlessi = 305, e.dotlessj = 63166, e.dotlessjstrokehook = 644, e.dotmath = 8901, e.dottedcircle = 9676, e.doubleyodpatah = 64287, e.doubleyodpatahhebrew = 64287, e.downtackbelowcmb = 798, e.downtackmod = 725, e.dparen = 9375, e.dsuperior = 63211, e.dtail = 598, e.dtopbar = 396, e.duhiragana = 12389, e.dukatakana = 12485, e.dz = 499, e.dzaltone = 675, e.dzcaron = 454, e.dzcurl = 677, e.dzeabkhasiancyrillic = 1249, e.dzecyrillic = 1109, e.dzhecyrillic = 1119, e.e = 101, e.eacute = 233, e.earth = 9793, e.ebengali = 2447, e.ebopomofo = 12572, e.ebreve = 277, e.ecandradeva = 2317, e.ecandragujarati = 2701, e.ecandravowelsigndeva = 2373, e.ecandravowelsigngujarati = 2757, e.ecaron = 283, e.ecedillabreve = 7709, e.echarmenian = 1381, e.echyiwnarmenian = 1415, e.ecircle = 9428, e.ecircumflex = 234, e.ecircumflexacute = 7871, e.ecircumflexbelow = 7705, e.ecircumflexdotbelow = 7879, e.ecircumflexgrave = 7873, e.ecircumflexhookabove = 7875, e.ecircumflextilde = 7877, e.ecyrillic = 1108, e.edblgrave = 517, e.edeva = 2319, e.edieresis = 235, e.edot = 279, e.edotaccent = 279, e.edotbelow = 7865, e.eegurmukhi = 2575, e.eematragurmukhi = 2631, e.efcyrillic = 1092, e.egrave = 232, e.egujarati = 2703, e.eharmenian = 1383, e.ehbopomofo = 12573, e.ehiragana = 12360, e.ehookabove = 7867, e.eibopomofo = 12575, e.eight = 56, e.eightarabic = 1640, e.eightbengali = 2542, e.eightcircle = 9319, e.eightcircleinversesansserif = 10129, e.eightdeva = 2414, e.eighteencircle = 9329, e.eighteenparen = 9349, e.eighteenperiod = 9369, e.eightgujarati = 2798, e.eightgurmukhi = 2670, e.eighthackarabic = 1640, e.eighthangzhou = 12328, e.eighthnotebeamed = 9835, e.eightideographicparen = 12839, e.eightinferior = 8328, e.eightmonospace = 65304, e.eightoldstyle = 63288, e.eightparen = 9339, e.eightperiod = 9359, e.eightpersian = 1784, e.eightroman = 8567, e.eightsuperior = 8312, e.eightthai = 3672, e.einvertedbreve = 519, e.eiotifiedcyrillic = 1125, e.ekatakana = 12456, e.ekatakanahalfwidth = 65396, e.ekonkargurmukhi = 2676, e.ekorean = 12628, e.elcyrillic = 1083, e.element = 8712, e.elevencircle = 9322, e.elevenparen = 9342, e.elevenperiod = 9362, e.elevenroman = 8570, e.ellipsis = 8230, e.ellipsisvertical = 8942, e.emacron = 275, e.emacronacute = 7703, e.emacrongrave = 7701, e.emcyrillic = 1084, e.emdash = 8212, e.emdashvertical = 65073, e.emonospace = 65349, e.emphasismarkarmenian = 1371, e.emptyset = 8709, e.enbopomofo = 12579, e.encyrillic = 1085, e.endash = 8211, e.endashvertical = 65074, e.endescendercyrillic = 1187, e.eng = 331, e.engbopomofo = 12581, e.enghecyrillic = 1189, e.enhookcyrillic = 1224, e.enspace = 8194, e.eogonek = 281, e.eokorean = 12627, e.eopen = 603, e.eopenclosed = 666, e.eopenreversed = 604, e.eopenreversedclosed = 606, e.eopenreversedhook = 605, e.eparen = 9376, e.epsilon = 949, e.epsilontonos = 941, e.equal = 61, e.equalmonospace = 65309, e.equalsmall = 65126, e.equalsuperior = 8316, e.equivalence = 8801, e.erbopomofo = 12582, e.ercyrillic = 1088, e.ereversed = 600, e.ereversedcyrillic = 1101, e.escyrillic = 1089, e.esdescendercyrillic = 1195, e.esh = 643, e.eshcurl = 646, e.eshortdeva = 2318, e.eshortvowelsigndeva = 2374, e.eshreversedloop = 426, e.eshsquatreversed = 645, e.esmallhiragana = 12359, e.esmallkatakana = 12455, e.esmallkatakanahalfwidth = 65386, e.estimated = 8494, e.esuperior = 63212, e.eta = 951, e.etarmenian = 1384, e.etatonos = 942, e.eth = 240, e.etilde = 7869, e.etildebelow = 7707, e.etnahtafoukhhebrew = 1425, e.etnahtafoukhlefthebrew = 1425, e.etnahtahebrew = 1425, e.etnahtalefthebrew = 1425, e.eturned = 477, e.eukorean = 12641, e.euro = 8364, e.evowelsignbengali = 2503, e.evowelsigndeva = 2375, e.evowelsigngujarati = 2759, e.exclam = 33, e.exclamarmenian = 1372, e.exclamdbl = 8252, e.exclamdown = 161, e.exclamdownsmall = 63393, e.exclammonospace = 65281, e.exclamsmall = 63265, e.existential = 8707, e.ezh = 658, e.ezhcaron = 495, e.ezhcurl = 659, e.ezhreversed = 441, e.ezhtail = 442, e.f = 102, e.fadeva = 2398, e.fagurmukhi = 2654, e.fahrenheit = 8457, e.fathaarabic = 1614, e.fathalowarabic = 1614, e.fathatanarabic = 1611, e.fbopomofo = 12552, e.fcircle = 9429, e.fdotaccent = 7711, e.feharabic = 1601, e.feharmenian = 1414, e.fehfinalarabic = 65234, e.fehinitialarabic = 65235, e.fehmedialarabic = 65236, e.feicoptic = 997, e.female = 9792, e.ff = 64256, e.f_f = 64256, e.ffi = 64259, e.f_f_i = 64259, e.ffl = 64260, e.f_f_l = 64260, e.fi = 64257, e.f_i = 64257, e.fifteencircle = 9326, e.fifteenparen = 9346, e.fifteenperiod = 9366, e.figuredash = 8210, e.filledbox = 9632, e.filledrect = 9644, e.finalkaf = 1498, e.finalkafdagesh = 64314, e.finalkafdageshhebrew = 64314, e.finalkafhebrew = 1498, e.finalmem = 1501, e.finalmemhebrew = 1501, e.finalnun = 1503, e.finalnunhebrew = 1503, e.finalpe = 1507, e.finalpehebrew = 1507, e.finaltsadi = 1509, e.finaltsadihebrew = 1509, e.firsttonechinese = 713, e.fisheye = 9673, e.fitacyrillic = 1139, e.five = 53, e.fivearabic = 1637, e.fivebengali = 2539, e.fivecircle = 9316, e.fivecircleinversesansserif = 10126, e.fivedeva = 2411, e.fiveeighths = 8541, e.fivegujarati = 2795, e.fivegurmukhi = 2667, e.fivehackarabic = 1637, e.fivehangzhou = 12325, e.fiveideographicparen = 12836, e.fiveinferior = 8325, e.fivemonospace = 65301, e.fiveoldstyle = 63285, e.fiveparen = 9336, e.fiveperiod = 9356, e.fivepersian = 1781, e.fiveroman = 8564, e.fivesuperior = 8309, e.fivethai = 3669, e.fl = 64258, e.f_l = 64258, e.florin = 402, e.fmonospace = 65350, e.fmsquare = 13209, e.fofanthai = 3615, e.fofathai = 3613, e.fongmanthai = 3663, e.forall = 8704, e.four = 52, e.fourarabic = 1636, e.fourbengali = 2538, e.fourcircle = 9315, e.fourcircleinversesansserif = 10125, e.fourdeva = 2410, e.fourgujarati = 2794, e.fourgurmukhi = 2666, e.fourhackarabic = 1636, e.fourhangzhou = 12324, e.fourideographicparen = 12835, e.fourinferior = 8324, e.fourmonospace = 65300, e.fournumeratorbengali = 2551, e.fouroldstyle = 63284, e.fourparen = 9335, e.fourperiod = 9355, e.fourpersian = 1780, e.fourroman = 8563, e.foursuperior = 8308, e.fourteencircle = 9325, e.fourteenparen = 9345, e.fourteenperiod = 9365, e.fourthai = 3668, e.fourthtonechinese = 715, e.fparen = 9377, e.fraction = 8260, e.franc = 8355, e.g = 103, e.gabengali = 2455, e.gacute = 501, e.gadeva = 2327, e.gafarabic = 1711, e.gaffinalarabic = 64403, e.gafinitialarabic = 64404, e.gafmedialarabic = 64405, e.gagujarati = 2711, e.gagurmukhi = 2583, e.gahiragana = 12364, e.gakatakana = 12460, e.gamma = 947, e.gammalatinsmall = 611, e.gammasuperior = 736, e.gangiacoptic = 1003, e.gbopomofo = 12557, e.gbreve = 287, e.gcaron = 487, e.gcedilla = 291, e.gcircle = 9430, e.gcircumflex = 285, e.gcommaaccent = 291, e.gdot = 289, e.gdotaccent = 289, e.gecyrillic = 1075, e.gehiragana = 12370, e.gekatakana = 12466, e.geometricallyequal = 8785, e.gereshaccenthebrew = 1436, e.gereshhebrew = 1523, e.gereshmuqdamhebrew = 1437, e.germandbls = 223, e.gershayimaccenthebrew = 1438, e.gershayimhebrew = 1524, e.getamark = 12307, e.ghabengali = 2456, e.ghadarmenian = 1394, e.ghadeva = 2328, e.ghagujarati = 2712, e.ghagurmukhi = 2584, e.ghainarabic = 1594, e.ghainfinalarabic = 65230, e.ghaininitialarabic = 65231, e.ghainmedialarabic = 65232, e.ghemiddlehookcyrillic = 1173, e.ghestrokecyrillic = 1171, e.gheupturncyrillic = 1169, e.ghhadeva = 2394, e.ghhagurmukhi = 2650, e.ghook = 608, e.ghzsquare = 13203, e.gihiragana = 12366, e.gikatakana = 12462, e.gimarmenian = 1379, e.gimel = 1490, e.gimeldagesh = 64306, e.gimeldageshhebrew = 64306, e.gimelhebrew = 1490, e.gjecyrillic = 1107, e.glottalinvertedstroke = 446, e.glottalstop = 660, e.glottalstopinverted = 662, e.glottalstopmod = 704, e.glottalstopreversed = 661, e.glottalstopreversedmod = 705, e.glottalstopreversedsuperior = 740, e.glottalstopstroke = 673, e.glottalstopstrokereversed = 674, e.gmacron = 7713, e.gmonospace = 65351, e.gohiragana = 12372, e.gokatakana = 12468, e.gparen = 9378, e.gpasquare = 13228, e.gradient = 8711, e.grave = 96, e.gravebelowcmb = 790, e.gravecmb = 768, e.gravecomb = 768, e.gravedeva = 2387, e.gravelowmod = 718, e.gravemonospace = 65344, e.gravetonecmb = 832, e.greater = 62, e.greaterequal = 8805, e.greaterequalorless = 8923, e.greatermonospace = 65310, e.greaterorequivalent = 8819, e.greaterorless = 8823, e.greateroverequal = 8807, e.greatersmall = 65125, e.gscript = 609, e.gstroke = 485, e.guhiragana = 12368, e.guillemotleft = 171, e.guillemotright = 187, e.guilsinglleft = 8249, e.guilsinglright = 8250, e.gukatakana = 12464, e.guramusquare = 13080, e.gysquare = 13257, e.h = 104, e.haabkhasiancyrillic = 1193, e.haaltonearabic = 1729, e.habengali = 2489, e.hadescendercyrillic = 1203, e.hadeva = 2361, e.hagujarati = 2745, e.hagurmukhi = 2617, e.haharabic = 1581, e.hahfinalarabic = 65186, e.hahinitialarabic = 65187, e.hahiragana = 12399, e.hahmedialarabic = 65188, e.haitusquare = 13098, e.hakatakana = 12495, e.hakatakanahalfwidth = 65418, e.halantgurmukhi = 2637, e.hamzaarabic = 1569, e.hamzalowarabic = 1569, e.hangulfiller = 12644, e.hardsigncyrillic = 1098, e.harpoonleftbarbup = 8636, e.harpoonrightbarbup = 8640, e.hasquare = 13258, e.hatafpatah = 1458, e.hatafpatah16 = 1458, e.hatafpatah23 = 1458, e.hatafpatah2f = 1458, e.hatafpatahhebrew = 1458, e.hatafpatahnarrowhebrew = 1458, e.hatafpatahquarterhebrew = 1458, e.hatafpatahwidehebrew = 1458, e.hatafqamats = 1459, e.hatafqamats1b = 1459, e.hatafqamats28 = 1459, e.hatafqamats34 = 1459, e.hatafqamatshebrew = 1459, e.hatafqamatsnarrowhebrew = 1459, e.hatafqamatsquarterhebrew = 1459, e.hatafqamatswidehebrew = 1459, e.hatafsegol = 1457, e.hatafsegol17 = 1457, e.hatafsegol24 = 1457, e.hatafsegol30 = 1457, e.hatafsegolhebrew = 1457, e.hatafsegolnarrowhebrew = 1457, e.hatafsegolquarterhebrew = 1457, e.hatafsegolwidehebrew = 1457, e.hbar = 295, e.hbopomofo = 12559, e.hbrevebelow = 7723, e.hcedilla = 7721, e.hcircle = 9431, e.hcircumflex = 293, e.hdieresis = 7719, e.hdotaccent = 7715, e.hdotbelow = 7717, e.he = 1492, e.heart = 9829, e.heartsuitblack = 9829, e.heartsuitwhite = 9825, e.hedagesh = 64308, e.hedageshhebrew = 64308, e.hehaltonearabic = 1729, e.heharabic = 1607, e.hehebrew = 1492, e.hehfinalaltonearabic = 64423, e.hehfinalalttwoarabic = 65258, e.hehfinalarabic = 65258, e.hehhamzaabovefinalarabic = 64421, e.hehhamzaaboveisolatedarabic = 64420, e.hehinitialaltonearabic = 64424, e.hehinitialarabic = 65259, e.hehiragana = 12408, e.hehmedialaltonearabic = 64425, e.hehmedialarabic = 65260, e.heiseierasquare = 13179, e.hekatakana = 12504, e.hekatakanahalfwidth = 65421, e.hekutaarusquare = 13110, e.henghook = 615, e.herutusquare = 13113, e.het = 1495, e.hethebrew = 1495, e.hhook = 614, e.hhooksuperior = 689, e.hieuhacirclekorean = 12923, e.hieuhaparenkorean = 12827, e.hieuhcirclekorean = 12909, e.hieuhkorean = 12622, e.hieuhparenkorean = 12813, e.hihiragana = 12402, e.hikatakana = 12498, e.hikatakanahalfwidth = 65419, e.hiriq = 1460, e.hiriq14 = 1460, e.hiriq21 = 1460, e.hiriq2d = 1460, e.hiriqhebrew = 1460, e.hiriqnarrowhebrew = 1460, e.hiriqquarterhebrew = 1460, e.hiriqwidehebrew = 1460, e.hlinebelow = 7830, e.hmonospace = 65352, e.hoarmenian = 1392, e.hohipthai = 3627, e.hohiragana = 12411, e.hokatakana = 12507, e.hokatakanahalfwidth = 65422, e.holam = 1465, e.holam19 = 1465, e.holam26 = 1465, e.holam32 = 1465, e.holamhebrew = 1465, e.holamnarrowhebrew = 1465, e.holamquarterhebrew = 1465, e.holamwidehebrew = 1465, e.honokhukthai = 3630, e.hookabovecomb = 777, e.hookcmb = 777, e.hookpalatalizedbelowcmb = 801, e.hookretroflexbelowcmb = 802, e.hoonsquare = 13122, e.horicoptic = 1001, e.horizontalbar = 8213, e.horncmb = 795, e.hotsprings = 9832, e.house = 8962, e.hparen = 9379, e.hsuperior = 688, e.hturned = 613, e.huhiragana = 12405, e.huiitosquare = 13107, e.hukatakana = 12501, e.hukatakanahalfwidth = 65420, e.hungarumlaut = 733, e.hungarumlautcmb = 779, e.hv = 405, e.hyphen = 45, e.hypheninferior = 63205, e.hyphenmonospace = 65293, e.hyphensmall = 65123, e.hyphensuperior = 63206, e.hyphentwo = 8208, e.i = 105, e.iacute = 237, e.iacyrillic = 1103, e.ibengali = 2439, e.ibopomofo = 12583, e.ibreve = 301, e.icaron = 464, e.icircle = 9432, e.icircumflex = 238, e.icyrillic = 1110, e.idblgrave = 521, e.ideographearthcircle = 12943, e.ideographfirecircle = 12939, e.ideographicallianceparen = 12863, e.ideographiccallparen = 12858, e.ideographiccentrecircle = 12965, e.ideographicclose = 12294, e.ideographiccomma = 12289, e.ideographiccommaleft = 65380, e.ideographiccongratulationparen = 12855, e.ideographiccorrectcircle = 12963, e.ideographicearthparen = 12847, e.ideographicenterpriseparen = 12861, e.ideographicexcellentcircle = 12957, e.ideographicfestivalparen = 12864, e.ideographicfinancialcircle = 12950, e.ideographicfinancialparen = 12854, e.ideographicfireparen = 12843, e.ideographichaveparen = 12850, e.ideographichighcircle = 12964, e.ideographiciterationmark = 12293, e.ideographiclaborcircle = 12952, e.ideographiclaborparen = 12856, e.ideographicleftcircle = 12967, e.ideographiclowcircle = 12966, e.ideographicmedicinecircle = 12969, e.ideographicmetalparen = 12846, e.ideographicmoonparen = 12842, e.ideographicnameparen = 12852, e.ideographicperiod = 12290, e.ideographicprintcircle = 12958, e.ideographicreachparen = 12867, e.ideographicrepresentparen = 12857, e.ideographicresourceparen = 12862, e.ideographicrightcircle = 12968, e.ideographicsecretcircle = 12953, e.ideographicselfparen = 12866, e.ideographicsocietyparen = 12851, e.ideographicspace = 12288, e.ideographicspecialparen = 12853, e.ideographicstockparen = 12849, e.ideographicstudyparen = 12859, e.ideographicsunparen = 12848, e.ideographicsuperviseparen = 12860, e.ideographicwaterparen = 12844, e.ideographicwoodparen = 12845, e.ideographiczero = 12295, e.ideographmetalcircle = 12942, e.ideographmooncircle = 12938, e.ideographnamecircle = 12948, e.ideographsuncircle = 12944, e.ideographwatercircle = 12940, e.ideographwoodcircle = 12941, e.ideva = 2311, e.idieresis = 239, e.idieresisacute = 7727, e.idieresiscyrillic = 1253, e.idotbelow = 7883, e.iebrevecyrillic = 1239, e.iecyrillic = 1077, e.ieungacirclekorean = 12917, e.ieungaparenkorean = 12821, e.ieungcirclekorean = 12903, e.ieungkorean = 12615, e.ieungparenkorean = 12807, e.igrave = 236, e.igujarati = 2695, e.igurmukhi = 2567, e.ihiragana = 12356, e.ihookabove = 7881, e.iibengali = 2440, e.iicyrillic = 1080, e.iideva = 2312, e.iigujarati = 2696, e.iigurmukhi = 2568, e.iimatragurmukhi = 2624, e.iinvertedbreve = 523, e.iishortcyrillic = 1081, e.iivowelsignbengali = 2496, e.iivowelsigndeva = 2368, e.iivowelsigngujarati = 2752, e.ij = 307, e.ikatakana = 12452, e.ikatakanahalfwidth = 65394, e.ikorean = 12643, e.ilde = 732, e.iluyhebrew = 1452, e.imacron = 299, e.imacroncyrillic = 1251, e.imageorapproximatelyequal = 8787, e.imatragurmukhi = 2623, e.imonospace = 65353, e.increment = 8710, e.infinity = 8734, e.iniarmenian = 1387, e.integral = 8747, e.integralbottom = 8993, e.integralbt = 8993, e.integralex = 63733, e.integraltop = 8992, e.integraltp = 8992, e.intersection = 8745, e.intisquare = 13061, e.invbullet = 9688, e.invcircle = 9689, e.invsmileface = 9787, e.iocyrillic = 1105, e.iogonek = 303, e.iota = 953, e.iotadieresis = 970, e.iotadieresistonos = 912, e.iotalatin = 617, e.iotatonos = 943, e.iparen = 9380, e.irigurmukhi = 2674, e.ismallhiragana = 12355, e.ismallkatakana = 12451, e.ismallkatakanahalfwidth = 65384, e.issharbengali = 2554, e.istroke = 616, e.isuperior = 63213, e.iterationhiragana = 12445, e.iterationkatakana = 12541, e.itilde = 297, e.itildebelow = 7725, e.iubopomofo = 12585, e.iucyrillic = 1102, e.ivowelsignbengali = 2495, e.ivowelsigndeva = 2367, e.ivowelsigngujarati = 2751, e.izhitsacyrillic = 1141, e.izhitsadblgravecyrillic = 1143, e.j = 106, e.jaarmenian = 1393, e.jabengali = 2460, e.jadeva = 2332, e.jagujarati = 2716, e.jagurmukhi = 2588, e.jbopomofo = 12560, e.jcaron = 496, e.jcircle = 9433, e.jcircumflex = 309, e.jcrossedtail = 669, e.jdotlessstroke = 607, e.jecyrillic = 1112, e.jeemarabic = 1580, e.jeemfinalarabic = 65182, e.jeeminitialarabic = 65183, e.jeemmedialarabic = 65184, e.jeharabic = 1688, e.jehfinalarabic = 64395, e.jhabengali = 2461, e.jhadeva = 2333, e.jhagujarati = 2717, e.jhagurmukhi = 2589, e.jheharmenian = 1403, e.jis = 12292, e.jmonospace = 65354, e.jparen = 9381, e.jsuperior = 690, e.k = 107, e.kabashkircyrillic = 1185, e.kabengali = 2453, e.kacute = 7729, e.kacyrillic = 1082, e.kadescendercyrillic = 1179, e.kadeva = 2325, e.kaf = 1499, e.kafarabic = 1603, e.kafdagesh = 64315, e.kafdageshhebrew = 64315, e.kaffinalarabic = 65242, e.kafhebrew = 1499, e.kafinitialarabic = 65243, e.kafmedialarabic = 65244, e.kafrafehebrew = 64333, e.kagujarati = 2709, e.kagurmukhi = 2581, e.kahiragana = 12363, e.kahookcyrillic = 1220, e.kakatakana = 12459, e.kakatakanahalfwidth = 65398, e.kappa = 954, e.kappasymbolgreek = 1008, e.kapyeounmieumkorean = 12657, e.kapyeounphieuphkorean = 12676, e.kapyeounpieupkorean = 12664, e.kapyeounssangpieupkorean = 12665, e.karoriisquare = 13069, e.kashidaautoarabic = 1600, e.kashidaautonosidebearingarabic = 1600, e.kasmallkatakana = 12533, e.kasquare = 13188, e.kasraarabic = 1616, e.kasratanarabic = 1613, e.kastrokecyrillic = 1183, e.katahiraprolongmarkhalfwidth = 65392, e.kaverticalstrokecyrillic = 1181, e.kbopomofo = 12558, e.kcalsquare = 13193, e.kcaron = 489, e.kcedilla = 311, e.kcircle = 9434, e.kcommaaccent = 311, e.kdotbelow = 7731, e.keharmenian = 1412, e.kehiragana = 12369, e.kekatakana = 12465, e.kekatakanahalfwidth = 65401, e.kenarmenian = 1391, e.kesmallkatakana = 12534, e.kgreenlandic = 312, e.khabengali = 2454, e.khacyrillic = 1093, e.khadeva = 2326, e.khagujarati = 2710, e.khagurmukhi = 2582, e.khaharabic = 1582, e.khahfinalarabic = 65190, e.khahinitialarabic = 65191, e.khahmedialarabic = 65192, e.kheicoptic = 999, e.khhadeva = 2393, e.khhagurmukhi = 2649, e.khieukhacirclekorean = 12920, e.khieukhaparenkorean = 12824, e.khieukhcirclekorean = 12906, e.khieukhkorean = 12619, e.khieukhparenkorean = 12810, e.khokhaithai = 3586, e.khokhonthai = 3589, e.khokhuatthai = 3587, e.khokhwaithai = 3588, e.khomutthai = 3675, e.khook = 409, e.khorakhangthai = 3590, e.khzsquare = 13201, e.kihiragana = 12365, e.kikatakana = 12461, e.kikatakanahalfwidth = 65399, e.kiroguramusquare = 13077, e.kiromeetorusquare = 13078, e.kirosquare = 13076, e.kiyeokacirclekorean = 12910, e.kiyeokaparenkorean = 12814, e.kiyeokcirclekorean = 12896, e.kiyeokkorean = 12593, e.kiyeokparenkorean = 12800, e.kiyeoksioskorean = 12595, e.kjecyrillic = 1116, e.klinebelow = 7733, e.klsquare = 13208, e.kmcubedsquare = 13222, e.kmonospace = 65355, e.kmsquaredsquare = 13218, e.kohiragana = 12371, e.kohmsquare = 13248, e.kokaithai = 3585, e.kokatakana = 12467, e.kokatakanahalfwidth = 65402, e.kooposquare = 13086, e.koppacyrillic = 1153, e.koreanstandardsymbol = 12927, e.koroniscmb = 835, e.kparen = 9382, e.kpasquare = 13226, e.ksicyrillic = 1135, e.ktsquare = 13263, e.kturned = 670, e.kuhiragana = 12367, e.kukatakana = 12463, e.kukatakanahalfwidth = 65400, e.kvsquare = 13240, e.kwsquare = 13246, e.l = 108, e.labengali = 2482, e.lacute = 314, e.ladeva = 2354, e.lagujarati = 2738, e.lagurmukhi = 2610, e.lakkhangyaothai = 3653, e.lamaleffinalarabic = 65276, e.lamalefhamzaabovefinalarabic = 65272, e.lamalefhamzaaboveisolatedarabic = 65271, e.lamalefhamzabelowfinalarabic = 65274, e.lamalefhamzabelowisolatedarabic = 65273, e.lamalefisolatedarabic = 65275, e.lamalefmaddaabovefinalarabic = 65270, e.lamalefmaddaaboveisolatedarabic = 65269, e.lamarabic = 1604, e.lambda = 955, e.lambdastroke = 411, e.lamed = 1500, e.lameddagesh = 64316, e.lameddageshhebrew = 64316, e.lamedhebrew = 1500, e.lamfinalarabic = 65246, e.lamhahinitialarabic = 64714, e.laminitialarabic = 65247, e.lamjeeminitialarabic = 64713, e.lamkhahinitialarabic = 64715, e.lamlamhehisolatedarabic = 65010, e.lammedialarabic = 65248, e.lammeemhahinitialarabic = 64904, e.lammeeminitialarabic = 64716, e.largecircle = 9711, e.lbar = 410, e.lbelt = 620, e.lbopomofo = 12556, e.lcaron = 318, e.lcedilla = 316, e.lcircle = 9435, e.lcircumflexbelow = 7741, e.lcommaaccent = 316, e.ldot = 320, e.ldotaccent = 320, e.ldotbelow = 7735, e.ldotbelowmacron = 7737, e.leftangleabovecmb = 794, e.lefttackbelowcmb = 792, e.less = 60, e.lessequal = 8804, e.lessequalorgreater = 8922, e.lessmonospace = 65308, e.lessorequivalent = 8818, e.lessorgreater = 8822, e.lessoverequal = 8806, e.lesssmall = 65124, e.lezh = 622, e.lfblock = 9612, e.lhookretroflex = 621, e.lira = 8356, e.liwnarmenian = 1388, e.lj = 457, e.ljecyrillic = 1113, e.ll = 63168, e.lladeva = 2355, e.llagujarati = 2739, e.llinebelow = 7739, e.llladeva = 2356, e.llvocalicbengali = 2529, e.llvocalicdeva = 2401, e.llvocalicvowelsignbengali = 2531, e.llvocalicvowelsigndeva = 2403, e.lmiddletilde = 619, e.lmonospace = 65356, e.lmsquare = 13264, e.lochulathai = 3628, e.logicaland = 8743, e.logicalnot = 172, e.logicalnotreversed = 8976, e.logicalor = 8744, e.lolingthai = 3621, e.longs = 383, e.lowlinecenterline = 65102, e.lowlinecmb = 818, e.lowlinedashed = 65101, e.lozenge = 9674, e.lparen = 9383, e.lslash = 322, e.lsquare = 8467, e.lsuperior = 63214, e.ltshade = 9617, e.luthai = 3622, e.lvocalicbengali = 2444, e.lvocalicdeva = 2316, e.lvocalicvowelsignbengali = 2530, e.lvocalicvowelsigndeva = 2402, e.lxsquare = 13267, e.m = 109, e.mabengali = 2478, e.macron = 175, e.macronbelowcmb = 817, e.macroncmb = 772, e.macronlowmod = 717, e.macronmonospace = 65507, e.macute = 7743, e.madeva = 2350, e.magujarati = 2734, e.magurmukhi = 2606, e.mahapakhhebrew = 1444, e.mahapakhlefthebrew = 1444, e.mahiragana = 12414, e.maichattawalowleftthai = 63637, e.maichattawalowrightthai = 63636, e.maichattawathai = 3659, e.maichattawaupperleftthai = 63635, e.maieklowleftthai = 63628, e.maieklowrightthai = 63627, e.maiekthai = 3656, e.maiekupperleftthai = 63626, e.maihanakatleftthai = 63620, e.maihanakatthai = 3633, e.maitaikhuleftthai = 63625, e.maitaikhuthai = 3655, e.maitholowleftthai = 63631, e.maitholowrightthai = 63630, e.maithothai = 3657, e.maithoupperleftthai = 63629, e.maitrilowleftthai = 63634, e.maitrilowrightthai = 63633, e.maitrithai = 3658, e.maitriupperleftthai = 63632, e.maiyamokthai = 3654, e.makatakana = 12510, e.makatakanahalfwidth = 65423, e.male = 9794, e.mansyonsquare = 13127, e.maqafhebrew = 1470, e.mars = 9794, e.masoracirclehebrew = 1455, e.masquare = 13187, e.mbopomofo = 12551, e.mbsquare = 13268, e.mcircle = 9436, e.mcubedsquare = 13221, e.mdotaccent = 7745, e.mdotbelow = 7747, e.meemarabic = 1605, e.meemfinalarabic = 65250, e.meeminitialarabic = 65251, e.meemmedialarabic = 65252, e.meemmeeminitialarabic = 64721, e.meemmeemisolatedarabic = 64584, e.meetorusquare = 13133, e.mehiragana = 12417, e.meizierasquare = 13182, e.mekatakana = 12513, e.mekatakanahalfwidth = 65426, e.mem = 1502, e.memdagesh = 64318, e.memdageshhebrew = 64318, e.memhebrew = 1502, e.menarmenian = 1396, e.merkhahebrew = 1445, e.merkhakefulahebrew = 1446, e.merkhakefulalefthebrew = 1446, e.merkhalefthebrew = 1445, e.mhook = 625, e.mhzsquare = 13202, e.middledotkatakanahalfwidth = 65381, e.middot = 183, e.mieumacirclekorean = 12914, e.mieumaparenkorean = 12818, e.mieumcirclekorean = 12900, e.mieumkorean = 12609, e.mieumpansioskorean = 12656, e.mieumparenkorean = 12804, e.mieumpieupkorean = 12654, e.mieumsioskorean = 12655, e.mihiragana = 12415, e.mikatakana = 12511, e.mikatakanahalfwidth = 65424, e.minus = 8722, e.minusbelowcmb = 800, e.minuscircle = 8854, e.minusmod = 727, e.minusplus = 8723, e.minute = 8242, e.miribaarusquare = 13130, e.mirisquare = 13129, e.mlonglegturned = 624, e.mlsquare = 13206, e.mmcubedsquare = 13219, e.mmonospace = 65357, e.mmsquaredsquare = 13215, e.mohiragana = 12418, e.mohmsquare = 13249, e.mokatakana = 12514, e.mokatakanahalfwidth = 65427, e.molsquare = 13270, e.momathai = 3617, e.moverssquare = 13223, e.moverssquaredsquare = 13224, e.mparen = 9384, e.mpasquare = 13227, e.mssquare = 13235, e.msuperior = 63215, e.mturned = 623, e.mu = 181, e.mu1 = 181, e.muasquare = 13186, e.muchgreater = 8811, e.muchless = 8810, e.mufsquare = 13196, e.mugreek = 956, e.mugsquare = 13197, e.muhiragana = 12416, e.mukatakana = 12512, e.mukatakanahalfwidth = 65425, e.mulsquare = 13205, e.multiply = 215, e.mumsquare = 13211, e.munahhebrew = 1443, e.munahlefthebrew = 1443, e.musicalnote = 9834, e.musicalnotedbl = 9835, e.musicflatsign = 9837, e.musicsharpsign = 9839, e.mussquare = 13234, e.muvsquare = 13238, e.muwsquare = 13244, e.mvmegasquare = 13241, e.mvsquare = 13239, e.mwmegasquare = 13247, e.mwsquare = 13245, e.n = 110, e.nabengali = 2472, e.nabla = 8711, e.nacute = 324, e.nadeva = 2344, e.nagujarati = 2728, e.nagurmukhi = 2600, e.nahiragana = 12394, e.nakatakana = 12490, e.nakatakanahalfwidth = 65413, e.napostrophe = 329, e.nasquare = 13185, e.nbopomofo = 12555, e.nbspace = 160, e.ncaron = 328, e.ncedilla = 326, e.ncircle = 9437, e.ncircumflexbelow = 7755, e.ncommaaccent = 326, e.ndotaccent = 7749, e.ndotbelow = 7751, e.nehiragana = 12397, e.nekatakana = 12493, e.nekatakanahalfwidth = 65416, e.newsheqelsign = 8362, e.nfsquare = 13195, e.ngabengali = 2457, e.ngadeva = 2329, e.ngagujarati = 2713, e.ngagurmukhi = 2585, e.ngonguthai = 3591, e.nhiragana = 12435, e.nhookleft = 626, e.nhookretroflex = 627, e.nieunacirclekorean = 12911, e.nieunaparenkorean = 12815, e.nieuncieuckorean = 12597, e.nieuncirclekorean = 12897, e.nieunhieuhkorean = 12598, e.nieunkorean = 12596, e.nieunpansioskorean = 12648, e.nieunparenkorean = 12801, e.nieunsioskorean = 12647, e.nieuntikeutkorean = 12646, e.nihiragana = 12395, e.nikatakana = 12491, e.nikatakanahalfwidth = 65414, e.nikhahitleftthai = 63641, e.nikhahitthai = 3661, e.nine = 57, e.ninearabic = 1641, e.ninebengali = 2543, e.ninecircle = 9320, e.ninecircleinversesansserif = 10130, e.ninedeva = 2415, e.ninegujarati = 2799, e.ninegurmukhi = 2671, e.ninehackarabic = 1641, e.ninehangzhou = 12329, e.nineideographicparen = 12840, e.nineinferior = 8329, e.ninemonospace = 65305, e.nineoldstyle = 63289, e.nineparen = 9340, e.nineperiod = 9360, e.ninepersian = 1785, e.nineroman = 8568, e.ninesuperior = 8313, e.nineteencircle = 9330, e.nineteenparen = 9350, e.nineteenperiod = 9370, e.ninethai = 3673, e.nj = 460, e.njecyrillic = 1114, e.nkatakana = 12531, e.nkatakanahalfwidth = 65437, e.nlegrightlong = 414, e.nlinebelow = 7753, e.nmonospace = 65358, e.nmsquare = 13210, e.nnabengali = 2467, e.nnadeva = 2339, e.nnagujarati = 2723, e.nnagurmukhi = 2595, e.nnnadeva = 2345, e.nohiragana = 12398, e.nokatakana = 12494, e.nokatakanahalfwidth = 65417, e.nonbreakingspace = 160, e.nonenthai = 3603, e.nonuthai = 3609, e.noonarabic = 1606, e.noonfinalarabic = 65254, e.noonghunnaarabic = 1722, e.noonghunnafinalarabic = 64415, e.nooninitialarabic = 65255, e.noonjeeminitialarabic = 64722, e.noonjeemisolatedarabic = 64587, e.noonmedialarabic = 65256, e.noonmeeminitialarabic = 64725, e.noonmeemisolatedarabic = 64590, e.noonnoonfinalarabic = 64653, e.notcontains = 8716, e.notelement = 8713, e.notelementof = 8713, e.notequal = 8800, e.notgreater = 8815, e.notgreaternorequal = 8817, e.notgreaternorless = 8825, e.notidentical = 8802, e.notless = 8814, e.notlessnorequal = 8816, e.notparallel = 8742, e.notprecedes = 8832, e.notsubset = 8836, e.notsucceeds = 8833, e.notsuperset = 8837, e.nowarmenian = 1398, e.nparen = 9385, e.nssquare = 13233, e.nsuperior = 8319, e.ntilde = 241, e.nu = 957, e.nuhiragana = 12396, e.nukatakana = 12492, e.nukatakanahalfwidth = 65415, e.nuktabengali = 2492, e.nuktadeva = 2364, e.nuktagujarati = 2748, e.nuktagurmukhi = 2620, e.numbersign = 35, e.numbersignmonospace = 65283, e.numbersignsmall = 65119, e.numeralsigngreek = 884, e.numeralsignlowergreek = 885, e.numero = 8470, e.nun = 1504, e.nundagesh = 64320, e.nundageshhebrew = 64320, e.nunhebrew = 1504, e.nvsquare = 13237, e.nwsquare = 13243, e.nyabengali = 2462, e.nyadeva = 2334, e.nyagujarati = 2718, e.nyagurmukhi = 2590, e.o = 111, e.oacute = 243, e.oangthai = 3629, e.obarred = 629, e.obarredcyrillic = 1257, e.obarreddieresiscyrillic = 1259, e.obengali = 2451, e.obopomofo = 12571, e.obreve = 335, e.ocandradeva = 2321, e.ocandragujarati = 2705, e.ocandravowelsigndeva = 2377, e.ocandravowelsigngujarati = 2761, e.ocaron = 466, e.ocircle = 9438, e.ocircumflex = 244, e.ocircumflexacute = 7889, e.ocircumflexdotbelow = 7897, e.ocircumflexgrave = 7891, e.ocircumflexhookabove = 7893, e.ocircumflextilde = 7895, e.ocyrillic = 1086, e.odblacute = 337, e.odblgrave = 525, e.odeva = 2323, e.odieresis = 246, e.odieresiscyrillic = 1255, e.odotbelow = 7885, e.oe = 339, e.oekorean = 12634, e.ogonek = 731, e.ogonekcmb = 808, e.ograve = 242, e.ogujarati = 2707, e.oharmenian = 1413, e.ohiragana = 12362, e.ohookabove = 7887, e.ohorn = 417, e.ohornacute = 7899, e.ohorndotbelow = 7907, e.ohorngrave = 7901, e.ohornhookabove = 7903, e.ohorntilde = 7905, e.ohungarumlaut = 337, e.oi = 419, e.oinvertedbreve = 527, e.okatakana = 12458, e.okatakanahalfwidth = 65397, e.okorean = 12631, e.olehebrew = 1451, e.omacron = 333, e.omacronacute = 7763, e.omacrongrave = 7761, e.omdeva = 2384, e.omega = 969, e.omega1 = 982, e.omegacyrillic = 1121, e.omegalatinclosed = 631, e.omegaroundcyrillic = 1147, e.omegatitlocyrillic = 1149, e.omegatonos = 974, e.omgujarati = 2768, e.omicron = 959, e.omicrontonos = 972, e.omonospace = 65359, e.one = 49, e.onearabic = 1633, e.onebengali = 2535, e.onecircle = 9312, e.onecircleinversesansserif = 10122, e.onedeva = 2407, e.onedotenleader = 8228, e.oneeighth = 8539, e.onefitted = 63196, e.onegujarati = 2791, e.onegurmukhi = 2663, e.onehackarabic = 1633, e.onehalf = 189, e.onehangzhou = 12321, e.oneideographicparen = 12832, e.oneinferior = 8321, e.onemonospace = 65297, e.onenumeratorbengali = 2548, e.oneoldstyle = 63281, e.oneparen = 9332, e.oneperiod = 9352, e.onepersian = 1777, e.onequarter = 188, e.oneroman = 8560, e.onesuperior = 185, e.onethai = 3665, e.onethird = 8531, e.oogonek = 491, e.oogonekmacron = 493, e.oogurmukhi = 2579, e.oomatragurmukhi = 2635, e.oopen = 596, e.oparen = 9386, e.openbullet = 9702, e.option = 8997, e.ordfeminine = 170, e.ordmasculine = 186, e.orthogonal = 8735, e.oshortdeva = 2322, e.oshortvowelsigndeva = 2378, e.oslash = 248, e.oslashacute = 511, e.osmallhiragana = 12361, e.osmallkatakana = 12457, e.osmallkatakanahalfwidth = 65387, e.ostrokeacute = 511, e.osuperior = 63216, e.otcyrillic = 1151, e.otilde = 245, e.otildeacute = 7757, e.otildedieresis = 7759, e.oubopomofo = 12577, e.overline = 8254, e.overlinecenterline = 65098, e.overlinecmb = 773, e.overlinedashed = 65097, e.overlinedblwavy = 65100, e.overlinewavy = 65099, e.overscore = 175, e.ovowelsignbengali = 2507, e.ovowelsigndeva = 2379, e.ovowelsigngujarati = 2763, e.p = 112, e.paampssquare = 13184, e.paasentosquare = 13099, e.pabengali = 2474, e.pacute = 7765, e.padeva = 2346, e.pagedown = 8671, e.pageup = 8670, e.pagujarati = 2730, e.pagurmukhi = 2602, e.pahiragana = 12401, e.paiyannoithai = 3631, e.pakatakana = 12497, e.palatalizationcyrilliccmb = 1156, e.palochkacyrillic = 1216, e.pansioskorean = 12671, e.paragraph = 182, e.parallel = 8741, e.parenleft = 40, e.parenleftaltonearabic = 64830, e.parenleftbt = 63725, e.parenleftex = 63724, e.parenleftinferior = 8333, e.parenleftmonospace = 65288, e.parenleftsmall = 65113, e.parenleftsuperior = 8317, e.parenlefttp = 63723, e.parenleftvertical = 65077, e.parenright = 41, e.parenrightaltonearabic = 64831, e.parenrightbt = 63736, e.parenrightex = 63735, e.parenrightinferior = 8334, e.parenrightmonospace = 65289, e.parenrightsmall = 65114, e.parenrightsuperior = 8318, e.parenrighttp = 63734, e.parenrightvertical = 65078, e.partialdiff = 8706, e.paseqhebrew = 1472, e.pashtahebrew = 1433, e.pasquare = 13225, e.patah = 1463, e.patah11 = 1463, e.patah1d = 1463, e.patah2a = 1463, e.patahhebrew = 1463, e.patahnarrowhebrew = 1463, e.patahquarterhebrew = 1463, e.patahwidehebrew = 1463, e.pazerhebrew = 1441, e.pbopomofo = 12550, e.pcircle = 9439, e.pdotaccent = 7767, e.pe = 1508, e.pecyrillic = 1087, e.pedagesh = 64324, e.pedageshhebrew = 64324, e.peezisquare = 13115, e.pefinaldageshhebrew = 64323, e.peharabic = 1662, e.peharmenian = 1402, e.pehebrew = 1508, e.pehfinalarabic = 64343, e.pehinitialarabic = 64344, e.pehiragana = 12410, e.pehmedialarabic = 64345, e.pekatakana = 12506, e.pemiddlehookcyrillic = 1191, e.perafehebrew = 64334, e.percent = 37, e.percentarabic = 1642, e.percentmonospace = 65285, e.percentsmall = 65130, e.period = 46, e.periodarmenian = 1417, e.periodcentered = 183, e.periodhalfwidth = 65377, e.periodinferior = 63207, e.periodmonospace = 65294, e.periodsmall = 65106, e.periodsuperior = 63208, e.perispomenigreekcmb = 834, e.perpendicular = 8869, e.perthousand = 8240, e.peseta = 8359, e.pfsquare = 13194, e.phabengali = 2475, e.phadeva = 2347, e.phagujarati = 2731, e.phagurmukhi = 2603, e.phi = 966, e.phi1 = 981, e.phieuphacirclekorean = 12922, e.phieuphaparenkorean = 12826, e.phieuphcirclekorean = 12908, e.phieuphkorean = 12621, e.phieuphparenkorean = 12812, e.philatin = 632, e.phinthuthai = 3642, e.phisymbolgreek = 981, e.phook = 421, e.phophanthai = 3614, e.phophungthai = 3612, e.phosamphaothai = 3616, e.pi = 960, e.pieupacirclekorean = 12915, e.pieupaparenkorean = 12819, e.pieupcieuckorean = 12662, e.pieupcirclekorean = 12901, e.pieupkiyeokkorean = 12658, e.pieupkorean = 12610, e.pieupparenkorean = 12805, e.pieupsioskiyeokkorean = 12660, e.pieupsioskorean = 12612, e.pieupsiostikeutkorean = 12661, e.pieupthieuthkorean = 12663, e.pieuptikeutkorean = 12659, e.pihiragana = 12404, e.pikatakana = 12500, e.pisymbolgreek = 982, e.piwrarmenian = 1411, e.planckover2pi = 8463, e.planckover2pi1 = 8463, e.plus = 43, e.plusbelowcmb = 799, e.pluscircle = 8853, e.plusminus = 177, e.plusmod = 726, e.plusmonospace = 65291, e.plussmall = 65122, e.plussuperior = 8314, e.pmonospace = 65360, e.pmsquare = 13272, e.pohiragana = 12413, e.pointingindexdownwhite = 9759, e.pointingindexleftwhite = 9756, e.pointingindexrightwhite = 9758, e.pointingindexupwhite = 9757, e.pokatakana = 12509, e.poplathai = 3611, e.postalmark = 12306, e.postalmarkface = 12320, e.pparen = 9387, e.precedes = 8826, e.prescription = 8478, e.primemod = 697, e.primereversed = 8245, e.product = 8719, e.projective = 8965, e.prolongedkana = 12540, e.propellor = 8984, e.propersubset = 8834, e.propersuperset = 8835, e.proportion = 8759, e.proportional = 8733, e.psi = 968, e.psicyrillic = 1137, e.psilipneumatacyrilliccmb = 1158, e.pssquare = 13232, e.puhiragana = 12407, e.pukatakana = 12503, e.pvsquare = 13236, e.pwsquare = 13242, e.q = 113, e.qadeva = 2392, e.qadmahebrew = 1448, e.qafarabic = 1602, e.qaffinalarabic = 65238, e.qafinitialarabic = 65239, e.qafmedialarabic = 65240, e.qamats = 1464, e.qamats10 = 1464, e.qamats1a = 1464, e.qamats1c = 1464, e.qamats27 = 1464, e.qamats29 = 1464, e.qamats33 = 1464, e.qamatsde = 1464, e.qamatshebrew = 1464, e.qamatsnarrowhebrew = 1464, e.qamatsqatanhebrew = 1464, e.qamatsqatannarrowhebrew = 1464, e.qamatsqatanquarterhebrew = 1464, e.qamatsqatanwidehebrew = 1464, e.qamatsquarterhebrew = 1464, e.qamatswidehebrew = 1464, e.qarneyparahebrew = 1439, e.qbopomofo = 12561, e.qcircle = 9440, e.qhook = 672, e.qmonospace = 65361, e.qof = 1511, e.qofdagesh = 64327, e.qofdageshhebrew = 64327, e.qofhebrew = 1511, e.qparen = 9388, e.quarternote = 9833, e.qubuts = 1467, e.qubuts18 = 1467, e.qubuts25 = 1467, e.qubuts31 = 1467, e.qubutshebrew = 1467, e.qubutsnarrowhebrew = 1467, e.qubutsquarterhebrew = 1467, e.qubutswidehebrew = 1467, e.question = 63, e.questionarabic = 1567, e.questionarmenian = 1374, e.questiondown = 191, e.questiondownsmall = 63423, e.questiongreek = 894, e.questionmonospace = 65311, e.questionsmall = 63295, e.quotedbl = 34, e.quotedblbase = 8222, e.quotedblleft = 8220, e.quotedblmonospace = 65282, e.quotedblprime = 12318, e.quotedblprimereversed = 12317, e.quotedblright = 8221, e.quoteleft = 8216, e.quoteleftreversed = 8219, e.quotereversed = 8219, e.quoteright = 8217, e.quoterightn = 329, e.quotesinglbase = 8218, e.quotesingle = 39, e.quotesinglemonospace = 65287, e.r = 114, e.raarmenian = 1404, e.rabengali = 2480, e.racute = 341, e.radeva = 2352, e.radical = 8730, e.radicalex = 63717, e.radoverssquare = 13230, e.radoverssquaredsquare = 13231, e.radsquare = 13229, e.rafe = 1471, e.rafehebrew = 1471, e.ragujarati = 2736, e.ragurmukhi = 2608, e.rahiragana = 12425, e.rakatakana = 12521, e.rakatakanahalfwidth = 65431, e.ralowerdiagonalbengali = 2545, e.ramiddlediagonalbengali = 2544, e.ramshorn = 612, e.ratio = 8758, e.rbopomofo = 12566, e.rcaron = 345, e.rcedilla = 343, e.rcircle = 9441, e.rcommaaccent = 343, e.rdblgrave = 529, e.rdotaccent = 7769, e.rdotbelow = 7771, e.rdotbelowmacron = 7773, e.referencemark = 8251, e.reflexsubset = 8838, e.reflexsuperset = 8839, e.registered = 174, e.registersans = 63720, e.registerserif = 63194, e.reharabic = 1585, e.reharmenian = 1408, e.rehfinalarabic = 65198, e.rehiragana = 12428, e.rekatakana = 12524, e.rekatakanahalfwidth = 65434, e.resh = 1512, e.reshdageshhebrew = 64328, e.reshhebrew = 1512, e.reversedtilde = 8765, e.reviahebrew = 1431, e.reviamugrashhebrew = 1431, e.revlogicalnot = 8976, e.rfishhook = 638, e.rfishhookreversed = 639, e.rhabengali = 2525, e.rhadeva = 2397, e.rho = 961, e.rhook = 637, e.rhookturned = 635, e.rhookturnedsuperior = 693, e.rhosymbolgreek = 1009, e.rhotichookmod = 734, e.rieulacirclekorean = 12913, e.rieulaparenkorean = 12817, e.rieulcirclekorean = 12899, e.rieulhieuhkorean = 12608, e.rieulkiyeokkorean = 12602, e.rieulkiyeoksioskorean = 12649, e.rieulkorean = 12601, e.rieulmieumkorean = 12603, e.rieulpansioskorean = 12652, e.rieulparenkorean = 12803, e.rieulphieuphkorean = 12607, e.rieulpieupkorean = 12604, e.rieulpieupsioskorean = 12651, e.rieulsioskorean = 12605, e.rieulthieuthkorean = 12606, e.rieultikeutkorean = 12650, e.rieulyeorinhieuhkorean = 12653, e.rightangle = 8735, e.righttackbelowcmb = 793, e.righttriangle = 8895, e.rihiragana = 12426, e.rikatakana = 12522, e.rikatakanahalfwidth = 65432, e.ring = 730, e.ringbelowcmb = 805, e.ringcmb = 778, e.ringhalfleft = 703, e.ringhalfleftarmenian = 1369, e.ringhalfleftbelowcmb = 796, e.ringhalfleftcentered = 723, e.ringhalfright = 702, e.ringhalfrightbelowcmb = 825, e.ringhalfrightcentered = 722, e.rinvertedbreve = 531, e.rittorusquare = 13137, e.rlinebelow = 7775, e.rlongleg = 636, e.rlonglegturned = 634, e.rmonospace = 65362, e.rohiragana = 12429, e.rokatakana = 12525, e.rokatakanahalfwidth = 65435, e.roruathai = 3619, e.rparen = 9389, e.rrabengali = 2524, e.rradeva = 2353, e.rragurmukhi = 2652, e.rreharabic = 1681, e.rrehfinalarabic = 64397, e.rrvocalicbengali = 2528, e.rrvocalicdeva = 2400, e.rrvocalicgujarati = 2784, e.rrvocalicvowelsignbengali = 2500, e.rrvocalicvowelsigndeva = 2372, e.rrvocalicvowelsigngujarati = 2756, e.rsuperior = 63217, e.rtblock = 9616, e.rturned = 633, e.rturnedsuperior = 692, e.ruhiragana = 12427, e.rukatakana = 12523, e.rukatakanahalfwidth = 65433, e.rupeemarkbengali = 2546, e.rupeesignbengali = 2547, e.rupiah = 63197, e.ruthai = 3620, e.rvocalicbengali = 2443, e.rvocalicdeva = 2315, e.rvocalicgujarati = 2699, e.rvocalicvowelsignbengali = 2499, e.rvocalicvowelsigndeva = 2371, e.rvocalicvowelsigngujarati = 2755, e.s = 115, e.sabengali = 2488, e.sacute = 347, e.sacutedotaccent = 7781, e.sadarabic = 1589, e.sadeva = 2360, e.sadfinalarabic = 65210, e.sadinitialarabic = 65211, e.sadmedialarabic = 65212, e.sagujarati = 2744, e.sagurmukhi = 2616, e.sahiragana = 12373, e.sakatakana = 12469, e.sakatakanahalfwidth = 65403, e.sallallahoualayhewasallamarabic = 65018, e.samekh = 1505, e.samekhdagesh = 64321, e.samekhdageshhebrew = 64321, e.samekhhebrew = 1505, e.saraaathai = 3634, e.saraaethai = 3649, e.saraaimaimalaithai = 3652, e.saraaimaimuanthai = 3651, e.saraamthai = 3635, e.saraathai = 3632, e.saraethai = 3648, e.saraiileftthai = 63622, e.saraiithai = 3637, e.saraileftthai = 63621, e.saraithai = 3636, e.saraothai = 3650, e.saraueeleftthai = 63624, e.saraueethai = 3639, e.saraueleftthai = 63623, e.sarauethai = 3638, e.sarauthai = 3640, e.sarauuthai = 3641, e.sbopomofo = 12569, e.scaron = 353, e.scarondotaccent = 7783, e.scedilla = 351, e.schwa = 601, e.schwacyrillic = 1241, e.schwadieresiscyrillic = 1243, e.schwahook = 602, e.scircle = 9442, e.scircumflex = 349, e.scommaaccent = 537, e.sdotaccent = 7777, e.sdotbelow = 7779, e.sdotbelowdotaccent = 7785, e.seagullbelowcmb = 828, e.second = 8243, e.secondtonechinese = 714, e.section = 167, e.seenarabic = 1587, e.seenfinalarabic = 65202, e.seeninitialarabic = 65203, e.seenmedialarabic = 65204, e.segol = 1462, e.segol13 = 1462, e.segol1f = 1462, e.segol2c = 1462, e.segolhebrew = 1462, e.segolnarrowhebrew = 1462, e.segolquarterhebrew = 1462, e.segoltahebrew = 1426, e.segolwidehebrew = 1462, e.seharmenian = 1405, e.sehiragana = 12379, e.sekatakana = 12475, e.sekatakanahalfwidth = 65406, e.semicolon = 59, e.semicolonarabic = 1563, e.semicolonmonospace = 65307, e.semicolonsmall = 65108, e.semivoicedmarkkana = 12444, e.semivoicedmarkkanahalfwidth = 65439, e.sentisquare = 13090, e.sentosquare = 13091, e.seven = 55, e.sevenarabic = 1639, e.sevenbengali = 2541, e.sevencircle = 9318, e.sevencircleinversesansserif = 10128, e.sevendeva = 2413, e.seveneighths = 8542, e.sevengujarati = 2797, e.sevengurmukhi = 2669, e.sevenhackarabic = 1639, e.sevenhangzhou = 12327, e.sevenideographicparen = 12838, e.seveninferior = 8327, e.sevenmonospace = 65303, e.sevenoldstyle = 63287, e.sevenparen = 9338, e.sevenperiod = 9358, e.sevenpersian = 1783, e.sevenroman = 8566, e.sevensuperior = 8311, e.seventeencircle = 9328, e.seventeenparen = 9348, e.seventeenperiod = 9368, e.seventhai = 3671, e.sfthyphen = 173, e.shaarmenian = 1399, e.shabengali = 2486, e.shacyrillic = 1096, e.shaddaarabic = 1617, e.shaddadammaarabic = 64609, e.shaddadammatanarabic = 64606, e.shaddafathaarabic = 64608, e.shaddakasraarabic = 64610, e.shaddakasratanarabic = 64607, e.shade = 9618, e.shadedark = 9619, e.shadelight = 9617, e.shademedium = 9618, e.shadeva = 2358, e.shagujarati = 2742, e.shagurmukhi = 2614, e.shalshelethebrew = 1427, e.shbopomofo = 12565, e.shchacyrillic = 1097, e.sheenarabic = 1588, e.sheenfinalarabic = 65206, e.sheeninitialarabic = 65207, e.sheenmedialarabic = 65208, e.sheicoptic = 995, e.sheqel = 8362, e.sheqelhebrew = 8362, e.sheva = 1456, e.sheva115 = 1456, e.sheva15 = 1456, e.sheva22 = 1456, e.sheva2e = 1456, e.shevahebrew = 1456, e.shevanarrowhebrew = 1456, e.shevaquarterhebrew = 1456, e.shevawidehebrew = 1456, e.shhacyrillic = 1211, e.shimacoptic = 1005, e.shin = 1513, e.shindagesh = 64329, e.shindageshhebrew = 64329, e.shindageshshindot = 64300, e.shindageshshindothebrew = 64300, e.shindageshsindot = 64301, e.shindageshsindothebrew = 64301, e.shindothebrew = 1473, e.shinhebrew = 1513, e.shinshindot = 64298, e.shinshindothebrew = 64298, e.shinsindot = 64299, e.shinsindothebrew = 64299, e.shook = 642, e.sigma = 963, e.sigma1 = 962, e.sigmafinal = 962, e.sigmalunatesymbolgreek = 1010, e.sihiragana = 12375, e.sikatakana = 12471, e.sikatakanahalfwidth = 65404, e.siluqhebrew = 1469, e.siluqlefthebrew = 1469, e.similar = 8764, e.sindothebrew = 1474, e.siosacirclekorean = 12916, e.siosaparenkorean = 12820, e.sioscieuckorean = 12670, e.sioscirclekorean = 12902, e.sioskiyeokkorean = 12666, e.sioskorean = 12613, e.siosnieunkorean = 12667, e.siosparenkorean = 12806, e.siospieupkorean = 12669, e.siostikeutkorean = 12668, e.six = 54, e.sixarabic = 1638, e.sixbengali = 2540, e.sixcircle = 9317, e.sixcircleinversesansserif = 10127, e.sixdeva = 2412, e.sixgujarati = 2796, e.sixgurmukhi = 2668, e.sixhackarabic = 1638, e.sixhangzhou = 12326, e.sixideographicparen = 12837, e.sixinferior = 8326, e.sixmonospace = 65302, e.sixoldstyle = 63286, e.sixparen = 9337, e.sixperiod = 9357, e.sixpersian = 1782, e.sixroman = 8565, e.sixsuperior = 8310, e.sixteencircle = 9327, e.sixteencurrencydenominatorbengali = 2553, e.sixteenparen = 9347, e.sixteenperiod = 9367, e.sixthai = 3670, e.slash = 47, e.slashmonospace = 65295, e.slong = 383, e.slongdotaccent = 7835, e.smileface = 9786, e.smonospace = 65363, e.sofpasuqhebrew = 1475, e.softhyphen = 173, e.softsigncyrillic = 1100, e.sohiragana = 12381, e.sokatakana = 12477, e.sokatakanahalfwidth = 65407, e.soliduslongoverlaycmb = 824, e.solidusshortoverlaycmb = 823, e.sorusithai = 3625, e.sosalathai = 3624, e.sosothai = 3595, e.sosuathai = 3626, e.space = 32, e.spacehackarabic = 32, e.spade = 9824, e.spadesuitblack = 9824, e.spadesuitwhite = 9828, e.sparen = 9390, e.squarebelowcmb = 827, e.squarecc = 13252, e.squarecm = 13213, e.squarediagonalcrosshatchfill = 9641, e.squarehorizontalfill = 9636, e.squarekg = 13199, e.squarekm = 13214, e.squarekmcapital = 13262, e.squareln = 13265, e.squarelog = 13266, e.squaremg = 13198, e.squaremil = 13269, e.squaremm = 13212, e.squaremsquared = 13217, e.squareorthogonalcrosshatchfill = 9638, e.squareupperlefttolowerrightfill = 9639, e.squareupperrighttolowerleftfill = 9640, e.squareverticalfill = 9637, e.squarewhitewithsmallblack = 9635, e.srsquare = 13275, e.ssabengali = 2487, e.ssadeva = 2359, e.ssagujarati = 2743, e.ssangcieuckorean = 12617, e.ssanghieuhkorean = 12677, e.ssangieungkorean = 12672, e.ssangkiyeokkorean = 12594, e.ssangnieunkorean = 12645, e.ssangpieupkorean = 12611, e.ssangsioskorean = 12614, e.ssangtikeutkorean = 12600, e.ssuperior = 63218, e.sterling = 163, e.sterlingmonospace = 65505, e.strokelongoverlaycmb = 822, e.strokeshortoverlaycmb = 821, e.subset = 8834, e.subsetnotequal = 8842, e.subsetorequal = 8838, e.succeeds = 8827, e.suchthat = 8715, e.suhiragana = 12377, e.sukatakana = 12473, e.sukatakanahalfwidth = 65405, e.sukunarabic = 1618, e.summation = 8721, e.sun = 9788, e.superset = 8835, e.supersetnotequal = 8843, e.supersetorequal = 8839, e.svsquare = 13276, e.syouwaerasquare = 13180, e.t = 116, e.tabengali = 2468, e.tackdown = 8868, e.tackleft = 8867, e.tadeva = 2340, e.tagujarati = 2724, e.tagurmukhi = 2596, e.taharabic = 1591, e.tahfinalarabic = 65218, e.tahinitialarabic = 65219, e.tahiragana = 12383, e.tahmedialarabic = 65220, e.taisyouerasquare = 13181, e.takatakana = 12479, e.takatakanahalfwidth = 65408, e.tatweelarabic = 1600, e.tau = 964, e.tav = 1514, e.tavdages = 64330, e.tavdagesh = 64330, e.tavdageshhebrew = 64330, e.tavhebrew = 1514, e.tbar = 359, e.tbopomofo = 12554, e.tcaron = 357, e.tccurl = 680, e.tcedilla = 355, e.tcheharabic = 1670, e.tchehfinalarabic = 64379, e.tchehinitialarabic = 64380, e.tchehmedialarabic = 64381, e.tcircle = 9443, e.tcircumflexbelow = 7793, e.tcommaaccent = 355, e.tdieresis = 7831, e.tdotaccent = 7787, e.tdotbelow = 7789, e.tecyrillic = 1090, e.tedescendercyrillic = 1197, e.teharabic = 1578, e.tehfinalarabic = 65174, e.tehhahinitialarabic = 64674, e.tehhahisolatedarabic = 64524, e.tehinitialarabic = 65175, e.tehiragana = 12390, e.tehjeeminitialarabic = 64673, e.tehjeemisolatedarabic = 64523, e.tehmarbutaarabic = 1577, e.tehmarbutafinalarabic = 65172, e.tehmedialarabic = 65176, e.tehmeeminitialarabic = 64676, e.tehmeemisolatedarabic = 64526, e.tehnoonfinalarabic = 64627, e.tekatakana = 12486, e.tekatakanahalfwidth = 65411, e.telephone = 8481, e.telephoneblack = 9742, e.telishagedolahebrew = 1440, e.telishaqetanahebrew = 1449, e.tencircle = 9321, e.tenideographicparen = 12841, e.tenparen = 9341, e.tenperiod = 9361, e.tenroman = 8569, e.tesh = 679, e.tet = 1496, e.tetdagesh = 64312, e.tetdageshhebrew = 64312, e.tethebrew = 1496, e.tetsecyrillic = 1205, e.tevirhebrew = 1435, e.tevirlefthebrew = 1435, e.thabengali = 2469, e.thadeva = 2341, e.thagujarati = 2725, e.thagurmukhi = 2597, e.thalarabic = 1584, e.thalfinalarabic = 65196, e.thanthakhatlowleftthai = 63640, e.thanthakhatlowrightthai = 63639, e.thanthakhatthai = 3660, e.thanthakhatupperleftthai = 63638, e.theharabic = 1579, e.thehfinalarabic = 65178, e.thehinitialarabic = 65179, e.thehmedialarabic = 65180, e.thereexists = 8707, e.therefore = 8756, e.theta = 952, e.theta1 = 977, e.thetasymbolgreek = 977, e.thieuthacirclekorean = 12921, e.thieuthaparenkorean = 12825, e.thieuthcirclekorean = 12907, e.thieuthkorean = 12620, e.thieuthparenkorean = 12811, e.thirteencircle = 9324, e.thirteenparen = 9344, e.thirteenperiod = 9364, e.thonangmonthothai = 3601, e.thook = 429, e.thophuthaothai = 3602, e.thorn = 254, e.thothahanthai = 3607, e.thothanthai = 3600, e.thothongthai = 3608, e.thothungthai = 3606, e.thousandcyrillic = 1154, e.thousandsseparatorarabic = 1644, e.thousandsseparatorpersian = 1644, e.three = 51, e.threearabic = 1635, e.threebengali = 2537, e.threecircle = 9314, e.threecircleinversesansserif = 10124, e.threedeva = 2409, e.threeeighths = 8540, e.threegujarati = 2793, e.threegurmukhi = 2665, e.threehackarabic = 1635, e.threehangzhou = 12323, e.threeideographicparen = 12834, e.threeinferior = 8323, e.threemonospace = 65299, e.threenumeratorbengali = 2550, e.threeoldstyle = 63283, e.threeparen = 9334, e.threeperiod = 9354, e.threepersian = 1779, e.threequarters = 190, e.threequartersemdash = 63198, e.threeroman = 8562, e.threesuperior = 179, e.threethai = 3667, e.thzsquare = 13204, e.tihiragana = 12385, e.tikatakana = 12481, e.tikatakanahalfwidth = 65409, e.tikeutacirclekorean = 12912, e.tikeutaparenkorean = 12816, e.tikeutcirclekorean = 12898, e.tikeutkorean = 12599, e.tikeutparenkorean = 12802, e.tilde = 732, e.tildebelowcmb = 816, e.tildecmb = 771, e.tildecomb = 771, e.tildedoublecmb = 864, e.tildeoperator = 8764, e.tildeoverlaycmb = 820, e.tildeverticalcmb = 830, e.timescircle = 8855, e.tipehahebrew = 1430, e.tipehalefthebrew = 1430, e.tippigurmukhi = 2672, e.titlocyrilliccmb = 1155, e.tiwnarmenian = 1407, e.tlinebelow = 7791, e.tmonospace = 65364, e.toarmenian = 1385, e.tohiragana = 12392, e.tokatakana = 12488, e.tokatakanahalfwidth = 65412, e.tonebarextrahighmod = 741, e.tonebarextralowmod = 745, e.tonebarhighmod = 742, e.tonebarlowmod = 744, e.tonebarmidmod = 743, e.tonefive = 445, e.tonesix = 389, e.tonetwo = 424, e.tonos = 900, e.tonsquare = 13095, e.topatakthai = 3599, e.tortoiseshellbracketleft = 12308, e.tortoiseshellbracketleftsmall = 65117, e.tortoiseshellbracketleftvertical = 65081, e.tortoiseshellbracketright = 12309, e.tortoiseshellbracketrightsmall = 65118, e.tortoiseshellbracketrightvertical = 65082, e.totaothai = 3605, e.tpalatalhook = 427, e.tparen = 9391, e.trademark = 8482, e.trademarksans = 63722, e.trademarkserif = 63195, e.tretroflexhook = 648, e.triagdn = 9660, e.triaglf = 9668, e.triagrt = 9658, e.triagup = 9650, e.ts = 678, e.tsadi = 1510, e.tsadidagesh = 64326, e.tsadidageshhebrew = 64326, e.tsadihebrew = 1510, e.tsecyrillic = 1094, e.tsere = 1461, e.tsere12 = 1461, e.tsere1e = 1461, e.tsere2b = 1461, e.tserehebrew = 1461, e.tserenarrowhebrew = 1461, e.tserequarterhebrew = 1461, e.tserewidehebrew = 1461, e.tshecyrillic = 1115, e.tsuperior = 63219, e.ttabengali = 2463, e.ttadeva = 2335, e.ttagujarati = 2719, e.ttagurmukhi = 2591, e.tteharabic = 1657, e.ttehfinalarabic = 64359, e.ttehinitialarabic = 64360, e.ttehmedialarabic = 64361, e.tthabengali = 2464, e.tthadeva = 2336, e.tthagujarati = 2720, e.tthagurmukhi = 2592, e.tturned = 647, e.tuhiragana = 12388, e.tukatakana = 12484, e.tukatakanahalfwidth = 65410, e.tusmallhiragana = 12387, e.tusmallkatakana = 12483, e.tusmallkatakanahalfwidth = 65391, e.twelvecircle = 9323, e.twelveparen = 9343, e.twelveperiod = 9363, e.twelveroman = 8571, e.twentycircle = 9331, e.twentyhangzhou = 21316, e.twentyparen = 9351, e.twentyperiod = 9371, e.two = 50, e.twoarabic = 1634, e.twobengali = 2536, e.twocircle = 9313, e.twocircleinversesansserif = 10123, e.twodeva = 2408, e.twodotenleader = 8229, e.twodotleader = 8229, e.twodotleadervertical = 65072, e.twogujarati = 2792, e.twogurmukhi = 2664, e.twohackarabic = 1634, e.twohangzhou = 12322, e.twoideographicparen = 12833, e.twoinferior = 8322, e.twomonospace = 65298, e.twonumeratorbengali = 2549, e.twooldstyle = 63282, e.twoparen = 9333, e.twoperiod = 9353, e.twopersian = 1778, e.tworoman = 8561, e.twostroke = 443, e.twosuperior = 178, e.twothai = 3666, e.twothirds = 8532, e.u = 117, e.uacute = 250, e.ubar = 649, e.ubengali = 2441, e.ubopomofo = 12584, e.ubreve = 365, e.ucaron = 468, e.ucircle = 9444, e.ucircumflex = 251, e.ucircumflexbelow = 7799, e.ucyrillic = 1091, e.udattadeva = 2385, e.udblacute = 369, e.udblgrave = 533, e.udeva = 2313, e.udieresis = 252, e.udieresisacute = 472, e.udieresisbelow = 7795, e.udieresiscaron = 474, e.udieresiscyrillic = 1265, e.udieresisgrave = 476, e.udieresismacron = 470, e.udotbelow = 7909, e.ugrave = 249, e.ugujarati = 2697, e.ugurmukhi = 2569, e.uhiragana = 12358, e.uhookabove = 7911, e.uhorn = 432, e.uhornacute = 7913, e.uhorndotbelow = 7921, e.uhorngrave = 7915, e.uhornhookabove = 7917, e.uhorntilde = 7919, e.uhungarumlaut = 369, e.uhungarumlautcyrillic = 1267, e.uinvertedbreve = 535, e.ukatakana = 12454, e.ukatakanahalfwidth = 65395, e.ukcyrillic = 1145, e.ukorean = 12636, e.umacron = 363, e.umacroncyrillic = 1263, e.umacrondieresis = 7803, e.umatragurmukhi = 2625, e.umonospace = 65365, e.underscore = 95, e.underscoredbl = 8215, e.underscoremonospace = 65343, e.underscorevertical = 65075, e.underscorewavy = 65103, e.union = 8746, e.universal = 8704, e.uogonek = 371, e.uparen = 9392, e.upblock = 9600, e.upperdothebrew = 1476, e.upsilon = 965, e.upsilondieresis = 971, e.upsilondieresistonos = 944, e.upsilonlatin = 650, e.upsilontonos = 973, e.uptackbelowcmb = 797, e.uptackmod = 724, e.uragurmukhi = 2675, e.uring = 367, e.ushortcyrillic = 1118, e.usmallhiragana = 12357, e.usmallkatakana = 12453, e.usmallkatakanahalfwidth = 65385, e.ustraightcyrillic = 1199, e.ustraightstrokecyrillic = 1201, e.utilde = 361, e.utildeacute = 7801, e.utildebelow = 7797, e.uubengali = 2442, e.uudeva = 2314, e.uugujarati = 2698, e.uugurmukhi = 2570, e.uumatragurmukhi = 2626, e.uuvowelsignbengali = 2498, e.uuvowelsigndeva = 2370, e.uuvowelsigngujarati = 2754, e.uvowelsignbengali = 2497, e.uvowelsigndeva = 2369, e.uvowelsigngujarati = 2753, e.v = 118, e.vadeva = 2357, e.vagujarati = 2741, e.vagurmukhi = 2613, e.vakatakana = 12535, e.vav = 1493, e.vavdagesh = 64309, e.vavdagesh65 = 64309, e.vavdageshhebrew = 64309, e.vavhebrew = 1493, e.vavholam = 64331, e.vavholamhebrew = 64331, e.vavvavhebrew = 1520, e.vavyodhebrew = 1521, e.vcircle = 9445, e.vdotbelow = 7807, e.vecyrillic = 1074, e.veharabic = 1700, e.vehfinalarabic = 64363, e.vehinitialarabic = 64364, e.vehmedialarabic = 64365, e.vekatakana = 12537, e.venus = 9792, e.verticalbar = 124, e.verticallineabovecmb = 781, e.verticallinebelowcmb = 809, e.verticallinelowmod = 716, e.verticallinemod = 712, e.vewarmenian = 1406, e.vhook = 651, e.vikatakana = 12536, e.viramabengali = 2509, e.viramadeva = 2381, e.viramagujarati = 2765, e.visargabengali = 2435, e.visargadeva = 2307, e.visargagujarati = 2691, e.vmonospace = 65366, e.voarmenian = 1400, e.voicediterationhiragana = 12446, e.voicediterationkatakana = 12542, e.voicedmarkkana = 12443, e.voicedmarkkanahalfwidth = 65438, e.vokatakana = 12538, e.vparen = 9393, e.vtilde = 7805, e.vturned = 652, e.vuhiragana = 12436, e.vukatakana = 12532, e.w = 119, e.wacute = 7811, e.waekorean = 12633, e.wahiragana = 12431, e.wakatakana = 12527, e.wakatakanahalfwidth = 65436, e.wakorean = 12632, e.wasmallhiragana = 12430, e.wasmallkatakana = 12526, e.wattosquare = 13143, e.wavedash = 12316, e.wavyunderscorevertical = 65076, e.wawarabic = 1608, e.wawfinalarabic = 65262, e.wawhamzaabovearabic = 1572, e.wawhamzaabovefinalarabic = 65158, e.wbsquare = 13277, e.wcircle = 9446, e.wcircumflex = 373, e.wdieresis = 7813, e.wdotaccent = 7815, e.wdotbelow = 7817, e.wehiragana = 12433, e.weierstrass = 8472, e.wekatakana = 12529, e.wekorean = 12638, e.weokorean = 12637, e.wgrave = 7809, e.whitebullet = 9702, e.whitecircle = 9675, e.whitecircleinverse = 9689, e.whitecornerbracketleft = 12302, e.whitecornerbracketleftvertical = 65091, e.whitecornerbracketright = 12303, e.whitecornerbracketrightvertical = 65092, e.whitediamond = 9671, e.whitediamondcontainingblacksmalldiamond = 9672, e.whitedownpointingsmalltriangle = 9663, e.whitedownpointingtriangle = 9661, e.whiteleftpointingsmalltriangle = 9667, e.whiteleftpointingtriangle = 9665, e.whitelenticularbracketleft = 12310, e.whitelenticularbracketright = 12311, e.whiterightpointingsmalltriangle = 9657, e.whiterightpointingtriangle = 9655, e.whitesmallsquare = 9643, e.whitesmilingface = 9786, e.whitesquare = 9633, e.whitestar = 9734, e.whitetelephone = 9743, e.whitetortoiseshellbracketleft = 12312, e.whitetortoiseshellbracketright = 12313, e.whiteuppointingsmalltriangle = 9653, e.whiteuppointingtriangle = 9651, e.wihiragana = 12432, e.wikatakana = 12528, e.wikorean = 12639, e.wmonospace = 65367, e.wohiragana = 12434, e.wokatakana = 12530, e.wokatakanahalfwidth = 65382, e.won = 8361, e.wonmonospace = 65510, e.wowaenthai = 3623, e.wparen = 9394, e.wring = 7832, e.wsuperior = 695, e.wturned = 653, e.wynn = 447, e.x = 120, e.xabovecmb = 829, e.xbopomofo = 12562, e.xcircle = 9447, e.xdieresis = 7821, e.xdotaccent = 7819, e.xeharmenian = 1389, e.xi = 958, e.xmonospace = 65368, e.xparen = 9395, e.xsuperior = 739, e.y = 121, e.yaadosquare = 13134, e.yabengali = 2479, e.yacute = 253, e.yadeva = 2351, e.yaekorean = 12626, e.yagujarati = 2735, e.yagurmukhi = 2607, e.yahiragana = 12420, e.yakatakana = 12516, e.yakatakanahalfwidth = 65428, e.yakorean = 12625, e.yamakkanthai = 3662, e.yasmallhiragana = 12419, e.yasmallkatakana = 12515, e.yasmallkatakanahalfwidth = 65388, e.yatcyrillic = 1123, e.ycircle = 9448, e.ycircumflex = 375, e.ydieresis = 255, e.ydotaccent = 7823, e.ydotbelow = 7925, e.yeharabic = 1610, e.yehbarreearabic = 1746, e.yehbarreefinalarabic = 64431, e.yehfinalarabic = 65266, e.yehhamzaabovearabic = 1574, e.yehhamzaabovefinalarabic = 65162, e.yehhamzaaboveinitialarabic = 65163, e.yehhamzaabovemedialarabic = 65164, e.yehinitialarabic = 65267, e.yehmedialarabic = 65268, e.yehmeeminitialarabic = 64733, e.yehmeemisolatedarabic = 64600, e.yehnoonfinalarabic = 64660, e.yehthreedotsbelowarabic = 1745, e.yekorean = 12630, e.yen = 165, e.yenmonospace = 65509, e.yeokorean = 12629, e.yeorinhieuhkorean = 12678, e.yerahbenyomohebrew = 1450, e.yerahbenyomolefthebrew = 1450, e.yericyrillic = 1099, e.yerudieresiscyrillic = 1273, e.yesieungkorean = 12673, e.yesieungpansioskorean = 12675, e.yesieungsioskorean = 12674, e.yetivhebrew = 1434, e.ygrave = 7923, e.yhook = 436, e.yhookabove = 7927, e.yiarmenian = 1397, e.yicyrillic = 1111, e.yikorean = 12642, e.yinyang = 9775, e.yiwnarmenian = 1410, e.ymonospace = 65369, e.yod = 1497, e.yoddagesh = 64313, e.yoddageshhebrew = 64313, e.yodhebrew = 1497, e.yodyodhebrew = 1522, e.yodyodpatahhebrew = 64287, e.yohiragana = 12424, e.yoikorean = 12681, e.yokatakana = 12520, e.yokatakanahalfwidth = 65430, e.yokorean = 12635, e.yosmallhiragana = 12423, e.yosmallkatakana = 12519, e.yosmallkatakanahalfwidth = 65390, e.yotgreek = 1011, e.yoyaekorean = 12680, e.yoyakorean = 12679, e.yoyakthai = 3618, e.yoyingthai = 3597, e.yparen = 9396, e.ypogegrammeni = 890, e.ypogegrammenigreekcmb = 837, e.yr = 422, e.yring = 7833, e.ysuperior = 696, e.ytilde = 7929, e.yturned = 654, e.yuhiragana = 12422, e.yuikorean = 12684, e.yukatakana = 12518, e.yukatakanahalfwidth = 65429, e.yukorean = 12640, e.yusbigcyrillic = 1131, e.yusbigiotifiedcyrillic = 1133, e.yuslittlecyrillic = 1127, e.yuslittleiotifiedcyrillic = 1129, e.yusmallhiragana = 12421, e.yusmallkatakana = 12517, e.yusmallkatakanahalfwidth = 65389, e.yuyekorean = 12683, e.yuyeokorean = 12682, e.yyabengali = 2527, e.yyadeva = 2399, e.z = 122, e.zaarmenian = 1382, e.zacute = 378, e.zadeva = 2395, e.zagurmukhi = 2651, e.zaharabic = 1592, e.zahfinalarabic = 65222, e.zahinitialarabic = 65223, e.zahiragana = 12374, e.zahmedialarabic = 65224, e.zainarabic = 1586, e.zainfinalarabic = 65200, e.zakatakana = 12470, e.zaqefgadolhebrew = 1429, e.zaqefqatanhebrew = 1428, e.zarqahebrew = 1432, e.zayin = 1494, e.zayindagesh = 64310, e.zayindageshhebrew = 64310, e.zayinhebrew = 1494, e.zbopomofo = 12567, e.zcaron = 382, e.zcircle = 9449, e.zcircumflex = 7825, e.zcurl = 657, e.zdot = 380, e.zdotaccent = 380, e.zdotbelow = 7827, e.zecyrillic = 1079, e.zedescendercyrillic = 1177, e.zedieresiscyrillic = 1247, e.zehiragana = 12380, e.zekatakana = 12476, e.zero = 48, e.zeroarabic = 1632, e.zerobengali = 2534, e.zerodeva = 2406, e.zerogujarati = 2790, e.zerogurmukhi = 2662, e.zerohackarabic = 1632, e.zeroinferior = 8320, e.zeromonospace = 65296, e.zerooldstyle = 63280, e.zeropersian = 1776, e.zerosuperior = 8304, e.zerothai = 3664, e.zerowidthjoiner = 65279, e.zerowidthnonjoiner = 8204, e.zerowidthspace = 8203, e.zeta = 950, e.zhbopomofo = 12563, e.zhearmenian = 1386, e.zhebrevecyrillic = 1218, e.zhecyrillic = 1078, e.zhedescendercyrillic = 1175, e.zhedieresiscyrillic = 1245, e.zihiragana = 12376, e.zikatakana = 12472, e.zinorhebrew = 1454, e.zlinebelow = 7829, e.zmonospace = 65370, e.zohiragana = 12382, e.zokatakana = 12478, e.zparen = 9397, e.zretroflexhook = 656, e.zstroke = 438, e.zuhiragana = 12378, e.zukatakana = 12474, e[".notdef"] = 0, e.angbracketleftbig = 9001, e.angbracketleftBig = 9001, e.angbracketleftbigg = 9001, e.angbracketleftBigg = 9001, e.angbracketrightBig = 9002, e.angbracketrightbig = 9002, e.angbracketrightBigg = 9002, e.angbracketrightbigg = 9002, e.arrowhookleft = 8618, e.arrowhookright = 8617, e.arrowlefttophalf = 8636, e.arrowleftbothalf = 8637, e.arrownortheast = 8599, e.arrownorthwest = 8598, e.arrowrighttophalf = 8640, e.arrowrightbothalf = 8641, e.arrowsoutheast = 8600, e.arrowsouthwest = 8601, e.backslashbig = 8726, e.backslashBig = 8726, e.backslashBigg = 8726, e.backslashbigg = 8726, e.bardbl = 8214, e.bracehtipdownleft = 65079, e.bracehtipdownright = 65079, e.bracehtipupleft = 65080, e.bracehtipupright = 65080, e.braceleftBig = 123, e.braceleftbig = 123, e.braceleftbigg = 123, e.braceleftBigg = 123, e.bracerightBig = 125, e.bracerightbig = 125, e.bracerightbigg = 125, e.bracerightBigg = 125, e.bracketleftbig = 91, e.bracketleftBig = 91, e.bracketleftbigg = 91, e.bracketleftBigg = 91, e.bracketrightBig = 93, e.bracketrightbig = 93, e.bracketrightbigg = 93, e.bracketrightBigg = 93, e.ceilingleftbig = 8968, e.ceilingleftBig = 8968, e.ceilingleftBigg = 8968, e.ceilingleftbigg = 8968, e.ceilingrightbig = 8969, e.ceilingrightBig = 8969, e.ceilingrightbigg = 8969, e.ceilingrightBigg = 8969, e.circledotdisplay = 8857, e.circledottext = 8857, e.circlemultiplydisplay = 8855, e.circlemultiplytext = 8855, e.circleplusdisplay = 8853, e.circleplustext = 8853, e.contintegraldisplay = 8750, e.contintegraltext = 8750, e.coproductdisplay = 8720, e.coproducttext = 8720, e.floorleftBig = 8970, e.floorleftbig = 8970, e.floorleftbigg = 8970, e.floorleftBigg = 8970, e.floorrightbig = 8971, e.floorrightBig = 8971, e.floorrightBigg = 8971, e.floorrightbigg = 8971, e.hatwide = 770, e.hatwider = 770, e.hatwidest = 770, e.intercal = 7488, e.integraldisplay = 8747, e.integraltext = 8747, e.intersectiondisplay = 8898, e.intersectiontext = 8898, e.logicalanddisplay = 8743, e.logicalandtext = 8743, e.logicalordisplay = 8744, e.logicalortext = 8744, e.parenleftBig = 40, e.parenleftbig = 40, e.parenleftBigg = 40, e.parenleftbigg = 40, e.parenrightBig = 41, e.parenrightbig = 41, e.parenrightBigg = 41, e.parenrightbigg = 41, e.prime = 8242, e.productdisplay = 8719, e.producttext = 8719, e.radicalbig = 8730, e.radicalBig = 8730, e.radicalBigg = 8730, e.radicalbigg = 8730, e.radicalbt = 8730, e.radicaltp = 8730, e.radicalvertex = 8730, e.slashbig = 47, e.slashBig = 47, e.slashBigg = 47, e.slashbigg = 47, e.summationdisplay = 8721, e.summationtext = 8721, e.tildewide = 732, e.tildewider = 732, e.tildewidest = 732, e.uniondisplay = 8899, e.unionmultidisplay = 8846, e.unionmultitext = 8846, e.unionsqdisplay = 8852, e.unionsqtext = 8852, e.uniontext = 8899, e.vextenddouble = 8741, e.vextendsingle = 8739;
        });
        w.getGlyphsUnicode = F;
        const C = (0, n.getLookupTableFactory)(function(e) {
          e.space = 32, e.a1 = 9985, e.a2 = 9986, e.a202 = 9987, e.a3 = 9988, e.a4 = 9742, e.a5 = 9990, e.a119 = 9991, e.a118 = 9992, e.a117 = 9993, e.a11 = 9755, e.a12 = 9758, e.a13 = 9996, e.a14 = 9997, e.a15 = 9998, e.a16 = 9999, e.a105 = 1e4, e.a17 = 10001, e.a18 = 10002, e.a19 = 10003, e.a20 = 10004, e.a21 = 10005, e.a22 = 10006, e.a23 = 10007, e.a24 = 10008, e.a25 = 10009, e.a26 = 10010, e.a27 = 10011, e.a28 = 10012, e.a6 = 10013, e.a7 = 10014, e.a8 = 10015, e.a9 = 10016, e.a10 = 10017, e.a29 = 10018, e.a30 = 10019, e.a31 = 10020, e.a32 = 10021, e.a33 = 10022, e.a34 = 10023, e.a35 = 9733, e.a36 = 10025, e.a37 = 10026, e.a38 = 10027, e.a39 = 10028, e.a40 = 10029, e.a41 = 10030, e.a42 = 10031, e.a43 = 10032, e.a44 = 10033, e.a45 = 10034, e.a46 = 10035, e.a47 = 10036, e.a48 = 10037, e.a49 = 10038, e.a50 = 10039, e.a51 = 10040, e.a52 = 10041, e.a53 = 10042, e.a54 = 10043, e.a55 = 10044, e.a56 = 10045, e.a57 = 10046, e.a58 = 10047, e.a59 = 10048, e.a60 = 10049, e.a61 = 10050, e.a62 = 10051, e.a63 = 10052, e.a64 = 10053, e.a65 = 10054, e.a66 = 10055, e.a67 = 10056, e.a68 = 10057, e.a69 = 10058, e.a70 = 10059, e.a71 = 9679, e.a72 = 10061, e.a73 = 9632, e.a74 = 10063, e.a203 = 10064, e.a75 = 10065, e.a204 = 10066, e.a76 = 9650, e.a77 = 9660, e.a78 = 9670, e.a79 = 10070, e.a81 = 9687, e.a82 = 10072, e.a83 = 10073, e.a84 = 10074, e.a97 = 10075, e.a98 = 10076, e.a99 = 10077, e.a100 = 10078, e.a101 = 10081, e.a102 = 10082, e.a103 = 10083, e.a104 = 10084, e.a106 = 10085, e.a107 = 10086, e.a108 = 10087, e.a112 = 9827, e.a111 = 9830, e.a110 = 9829, e.a109 = 9824, e.a120 = 9312, e.a121 = 9313, e.a122 = 9314, e.a123 = 9315, e.a124 = 9316, e.a125 = 9317, e.a126 = 9318, e.a127 = 9319, e.a128 = 9320, e.a129 = 9321, e.a130 = 10102, e.a131 = 10103, e.a132 = 10104, e.a133 = 10105, e.a134 = 10106, e.a135 = 10107, e.a136 = 10108, e.a137 = 10109, e.a138 = 10110, e.a139 = 10111, e.a140 = 10112, e.a141 = 10113, e.a142 = 10114, e.a143 = 10115, e.a144 = 10116, e.a145 = 10117, e.a146 = 10118, e.a147 = 10119, e.a148 = 10120, e.a149 = 10121, e.a150 = 10122, e.a151 = 10123, e.a152 = 10124, e.a153 = 10125, e.a154 = 10126, e.a155 = 10127, e.a156 = 10128, e.a157 = 10129, e.a158 = 10130, e.a159 = 10131, e.a160 = 10132, e.a161 = 8594, e.a163 = 8596, e.a164 = 8597, e.a196 = 10136, e.a165 = 10137, e.a192 = 10138, e.a166 = 10139, e.a167 = 10140, e.a168 = 10141, e.a169 = 10142, e.a170 = 10143, e.a171 = 10144, e.a172 = 10145, e.a173 = 10146, e.a162 = 10147, e.a174 = 10148, e.a175 = 10149, e.a176 = 10150, e.a177 = 10151, e.a178 = 10152, e.a179 = 10153, e.a193 = 10154, e.a180 = 10155, e.a199 = 10156, e.a181 = 10157, e.a200 = 10158, e.a182 = 10159, e.a201 = 10161, e.a183 = 10162, e.a184 = 10163, e.a197 = 10164, e.a185 = 10165, e.a194 = 10166, e.a198 = 10167, e.a186 = 10168, e.a195 = 10169, e.a187 = 10170, e.a188 = 10171, e.a189 = 10172, e.a190 = 10173, e.a191 = 10174, e.a89 = 10088, e.a90 = 10089, e.a93 = 10090, e.a94 = 10091, e.a91 = 10092, e.a92 = 10093, e.a205 = 10094, e.a85 = 10095, e.a206 = 10096, e.a86 = 10097, e.a87 = 10098, e.a88 = 10099, e.a95 = 10100, e.a96 = 10101, e[".notdef"] = 0;
        });
        w.getDingbatsGlyphsUnicode = C;
      },
      /* 40 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.clearUnicodeCaches = v, w.getCharUnicodeCategory = O, w.getUnicodeForGlyph = e, w.getUnicodeRangeFor = l, w.mapSpecialUnicodeValues = C;
        var n = V(3);
        const F = (0, n.getLookupTableFactory)(function(g) {
          g[63721] = 169, g[63193] = 169, g[63720] = 174, g[63194] = 174, g[63722] = 8482, g[63195] = 8482, g[63729] = 9127, g[63730] = 9128, g[63731] = 9129, g[63740] = 9131, g[63741] = 9132, g[63742] = 9133, g[63726] = 9121, g[63727] = 9122, g[63728] = 9123, g[63737] = 9124, g[63738] = 9125, g[63739] = 9126, g[63723] = 9115, g[63724] = 9116, g[63725] = 9117, g[63734] = 9118, g[63735] = 9119, g[63736] = 9120;
        });
        function C(g) {
          return g >= 65520 && g <= 65535 ? 0 : g >= 62976 && g <= 63743 ? F()[g] || g : g === 173 ? 45 : g;
        }
        function e(g, b) {
          let i = b[g];
          if (i !== void 0)
            return i;
          if (!g)
            return -1;
          if (g[0] === "u") {
            const P = g.length;
            let d;
            if (P === 7 && g[1] === "n" && g[2] === "i")
              d = g.substring(3);
            else if (P >= 5 && P <= 7)
              d = g.substring(1);
            else
              return -1;
            if (d === d.toUpperCase() && (i = parseInt(d, 16), i >= 0))
              return i;
          }
          return -1;
        }
        const t = [[0, 127], [128, 255], [256, 383], [384, 591], [592, 687, 7424, 7551, 7552, 7615], [688, 767, 42752, 42783], [768, 879, 7616, 7679], [880, 1023], [11392, 11519], [1024, 1279, 1280, 1327, 11744, 11775, 42560, 42655], [1328, 1423], [1424, 1535], [42240, 42559], [1536, 1791, 1872, 1919], [1984, 2047], [2304, 2431], [2432, 2559], [2560, 2687], [2688, 2815], [2816, 2943], [2944, 3071], [3072, 3199], [3200, 3327], [3328, 3455], [3584, 3711], [3712, 3839], [4256, 4351, 11520, 11567], [6912, 7039], [4352, 4607], [7680, 7935, 11360, 11391, 42784, 43007], [7936, 8191], [8192, 8303, 11776, 11903], [8304, 8351], [8352, 8399], [8400, 8447], [8448, 8527], [8528, 8591], [8592, 8703, 10224, 10239, 10496, 10623, 11008, 11263], [8704, 8959, 10752, 11007, 10176, 10223, 10624, 10751], [8960, 9215], [9216, 9279], [9280, 9311], [9312, 9471], [9472, 9599], [9600, 9631], [9632, 9727], [9728, 9983], [9984, 10175], [12288, 12351], [12352, 12447], [12448, 12543, 12784, 12799], [12544, 12591, 12704, 12735], [12592, 12687], [43072, 43135], [12800, 13055], [13056, 13311], [44032, 55215], [55296, 57343], [67840, 67871], [19968, 40959, 11904, 12031, 12032, 12255, 12272, 12287, 13312, 19903, 131072, 173791, 12688, 12703], [57344, 63743], [12736, 12783, 63744, 64255, 194560, 195103], [64256, 64335], [64336, 65023], [65056, 65071], [65040, 65055], [65104, 65135], [65136, 65279], [65280, 65519], [65520, 65535], [3840, 4095], [1792, 1871], [1920, 1983], [3456, 3583], [4096, 4255], [4608, 4991, 4992, 5023, 11648, 11743], [5024, 5119], [5120, 5759], [5760, 5791], [5792, 5887], [6016, 6143], [6144, 6319], [10240, 10495], [40960, 42127], [5888, 5919, 5920, 5951, 5952, 5983, 5984, 6015], [66304, 66351], [66352, 66383], [66560, 66639], [118784, 119039, 119040, 119295, 119296, 119375], [119808, 120831], [1044480, 1048573], [65024, 65039, 917760, 917999], [917504, 917631], [6400, 6479], [6480, 6527], [6528, 6623], [6656, 6687], [11264, 11359], [11568, 11647], [19904, 19967], [43008, 43055], [65536, 65663, 65664, 65791, 65792, 65855], [65856, 65935], [66432, 66463], [66464, 66527], [66640, 66687], [66688, 66735], [67584, 67647], [68096, 68191], [119552, 119647], [73728, 74751, 74752, 74879], [119648, 119679], [7040, 7103], [7168, 7247], [7248, 7295], [43136, 43231], [43264, 43311], [43312, 43359], [43520, 43615], [65936, 65999], [66e3, 66047], [66208, 66271, 66176, 66207, 67872, 67903], [127024, 127135, 126976, 127023]];
        function l(g, b = -1) {
          if (b !== -1) {
            const i = t[b];
            for (let P = 0, d = i.length; P < d; P += 2)
              if (g >= i[P] && g <= i[P + 1])
                return b;
          }
          for (let i = 0, P = t.length; i < P; i++) {
            const d = t[i];
            for (let A = 0, I = d.length; A < I; A += 2)
              if (g >= d[A] && g <= d[A + 1])
                return i;
          }
          return -1;
        }
        const j = new RegExp("^(\\s)|(\\p{Mn})|(\\p{Cf})$", "u"), U = /* @__PURE__ */ new Map();
        function O(g) {
          const b = U.get(g);
          if (b)
            return b;
          const i = g.match(j), P = {
            isWhitespace: !!(i != null && i[1]),
            isZeroWidthDiacritic: !!(i != null && i[2]),
            isInvisibleFormatMark: !!(i != null && i[3])
          };
          return U.set(g, P), P;
        }
        function v() {
          U.clear();
        }
      },
      /* 41 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.getSerifFonts = w.getNonStdFontMap = w.getGlyphMapForStandardFonts = w.getFontNameToFileMap = void 0, w.getStandardFontName = g, w.getSymbolsFonts = w.getSupplementalGlyphMapForCalibri = w.getSupplementalGlyphMapForArialBlack = w.getStdFontMap = void 0, w.isKnownFontName = b;
        var n = V(3), F = V(38);
        const C = (0, n.getLookupTableFactory)(function(i) {
          i["Times-Roman"] = "Times-Roman", i.Helvetica = "Helvetica", i.Courier = "Courier", i.Symbol = "Symbol", i["Times-Bold"] = "Times-Bold", i["Helvetica-Bold"] = "Helvetica-Bold", i["Courier-Bold"] = "Courier-Bold", i.ZapfDingbats = "ZapfDingbats", i["Times-Italic"] = "Times-Italic", i["Helvetica-Oblique"] = "Helvetica-Oblique", i["Courier-Oblique"] = "Courier-Oblique", i["Times-BoldItalic"] = "Times-BoldItalic", i["Helvetica-BoldOblique"] = "Helvetica-BoldOblique", i["Courier-BoldOblique"] = "Courier-BoldOblique", i.ArialNarrow = "Helvetica", i["ArialNarrow-Bold"] = "Helvetica-Bold", i["ArialNarrow-BoldItalic"] = "Helvetica-BoldOblique", i["ArialNarrow-Italic"] = "Helvetica-Oblique", i.ArialBlack = "Helvetica", i["ArialBlack-Bold"] = "Helvetica-Bold", i["ArialBlack-BoldItalic"] = "Helvetica-BoldOblique", i["ArialBlack-Italic"] = "Helvetica-Oblique", i["Arial-Black"] = "Helvetica", i["Arial-Black-Bold"] = "Helvetica-Bold", i["Arial-Black-BoldItalic"] = "Helvetica-BoldOblique", i["Arial-Black-Italic"] = "Helvetica-Oblique", i.Arial = "Helvetica", i["Arial-Bold"] = "Helvetica-Bold", i["Arial-BoldItalic"] = "Helvetica-BoldOblique", i["Arial-Italic"] = "Helvetica-Oblique", i.ArialMT = "Helvetica", i["Arial-BoldItalicMT"] = "Helvetica-BoldOblique", i["Arial-BoldMT"] = "Helvetica-Bold", i["Arial-ItalicMT"] = "Helvetica-Oblique", i["Arial-BoldItalicMT-BoldItalic"] = "Helvetica-BoldOblique", i["Arial-BoldMT-Bold"] = "Helvetica-Bold", i["Arial-ItalicMT-Italic"] = "Helvetica-Oblique", i.ArialUnicodeMS = "Helvetica", i["ArialUnicodeMS-Bold"] = "Helvetica-Bold", i["ArialUnicodeMS-BoldItalic"] = "Helvetica-BoldOblique", i["ArialUnicodeMS-Italic"] = "Helvetica-Oblique", i["Courier-BoldItalic"] = "Courier-BoldOblique", i["Courier-Italic"] = "Courier-Oblique", i.CourierNew = "Courier", i["CourierNew-Bold"] = "Courier-Bold", i["CourierNew-BoldItalic"] = "Courier-BoldOblique", i["CourierNew-Italic"] = "Courier-Oblique", i["CourierNewPS-BoldItalicMT"] = "Courier-BoldOblique", i["CourierNewPS-BoldMT"] = "Courier-Bold", i["CourierNewPS-ItalicMT"] = "Courier-Oblique", i.CourierNewPSMT = "Courier", i["Helvetica-BoldItalic"] = "Helvetica-BoldOblique", i["Helvetica-Italic"] = "Helvetica-Oblique", i["Symbol-Bold"] = "Symbol", i["Symbol-BoldItalic"] = "Symbol", i["Symbol-Italic"] = "Symbol", i.TimesNewRoman = "Times-Roman", i["TimesNewRoman-Bold"] = "Times-Bold", i["TimesNewRoman-BoldItalic"] = "Times-BoldItalic", i["TimesNewRoman-Italic"] = "Times-Italic", i.TimesNewRomanPS = "Times-Roman", i["TimesNewRomanPS-Bold"] = "Times-Bold", i["TimesNewRomanPS-BoldItalic"] = "Times-BoldItalic", i["TimesNewRomanPS-BoldItalicMT"] = "Times-BoldItalic", i["TimesNewRomanPS-BoldMT"] = "Times-Bold", i["TimesNewRomanPS-Italic"] = "Times-Italic", i["TimesNewRomanPS-ItalicMT"] = "Times-Italic", i.TimesNewRomanPSMT = "Times-Roman", i["TimesNewRomanPSMT-Bold"] = "Times-Bold", i["TimesNewRomanPSMT-BoldItalic"] = "Times-BoldItalic", i["TimesNewRomanPSMT-Italic"] = "Times-Italic";
        });
        w.getStdFontMap = C;
        const e = (0, n.getLookupTableFactory)(function(i) {
          i.Courier = "FoxitFixed.pfb", i["Courier-Bold"] = "FoxitFixedBold.pfb", i["Courier-BoldOblique"] = "FoxitFixedBoldItalic.pfb", i["Courier-Oblique"] = "FoxitFixedItalic.pfb", i.Helvetica = "LiberationSans-Regular.ttf", i["Helvetica-Bold"] = "LiberationSans-Bold.ttf", i["Helvetica-BoldOblique"] = "LiberationSans-BoldItalic.ttf", i["Helvetica-Oblique"] = "LiberationSans-Italic.ttf", i["Times-Roman"] = "FoxitSerif.pfb", i["Times-Bold"] = "FoxitSerifBold.pfb", i["Times-BoldItalic"] = "FoxitSerifBoldItalic.pfb", i["Times-Italic"] = "FoxitSerifItalic.pfb", i.Symbol = "FoxitSymbol.pfb", i.ZapfDingbats = "FoxitDingbats.pfb", i["LiberationSans-Regular"] = "LiberationSans-Regular.ttf", i["LiberationSans-Bold"] = "LiberationSans-Bold.ttf", i["LiberationSans-Italic"] = "LiberationSans-Italic.ttf", i["LiberationSans-BoldItalic"] = "LiberationSans-BoldItalic.ttf";
        });
        w.getFontNameToFileMap = e;
        const t = (0, n.getLookupTableFactory)(function(i) {
          i.Calibri = "Helvetica", i["Calibri-Bold"] = "Helvetica-Bold", i["Calibri-BoldItalic"] = "Helvetica-BoldOblique", i["Calibri-Italic"] = "Helvetica-Oblique", i.CenturyGothic = "Helvetica", i["CenturyGothic-Bold"] = "Helvetica-Bold", i["CenturyGothic-BoldItalic"] = "Helvetica-BoldOblique", i["CenturyGothic-Italic"] = "Helvetica-Oblique", i.ComicSansMS = "Comic Sans MS", i["ComicSansMS-Bold"] = "Comic Sans MS-Bold", i["ComicSansMS-BoldItalic"] = "Comic Sans MS-BoldItalic", i["ComicSansMS-Italic"] = "Comic Sans MS-Italic", i.Impact = "Helvetica", i["ItcSymbol-Bold"] = "Helvetica-Bold", i["ItcSymbol-BoldItalic"] = "Helvetica-BoldOblique", i["ItcSymbol-Book"] = "Helvetica", i["ItcSymbol-BookItalic"] = "Helvetica-Oblique", i["ItcSymbol-Medium"] = "Helvetica", i["ItcSymbol-MediumItalic"] = "Helvetica-Oblique", i.LucidaConsole = "Courier", i["LucidaConsole-Bold"] = "Courier-Bold", i["LucidaConsole-BoldItalic"] = "Courier-BoldOblique", i["LucidaConsole-Italic"] = "Courier-Oblique", i["LucidaSans-Demi"] = "Helvetica-Bold", i["MS-Gothic"] = "MS Gothic", i["MS-Gothic-Bold"] = "MS Gothic-Bold", i["MS-Gothic-BoldItalic"] = "MS Gothic-BoldItalic", i["MS-Gothic-Italic"] = "MS Gothic-Italic", i["MS-Mincho"] = "MS Mincho", i["MS-Mincho-Bold"] = "MS Mincho-Bold", i["MS-Mincho-BoldItalic"] = "MS Mincho-BoldItalic", i["MS-Mincho-Italic"] = "MS Mincho-Italic", i["MS-PGothic"] = "MS PGothic", i["MS-PGothic-Bold"] = "MS PGothic-Bold", i["MS-PGothic-BoldItalic"] = "MS PGothic-BoldItalic", i["MS-PGothic-Italic"] = "MS PGothic-Italic", i["MS-PMincho"] = "MS PMincho", i["MS-PMincho-Bold"] = "MS PMincho-Bold", i["MS-PMincho-BoldItalic"] = "MS PMincho-BoldItalic", i["MS-PMincho-Italic"] = "MS PMincho-Italic", i.NuptialScript = "Times-Italic", i.SegoeUISymbol = "Helvetica";
        });
        w.getNonStdFontMap = t;
        const l = (0, n.getLookupTableFactory)(function(i) {
          i["Adobe Jenson"] = !0, i["Adobe Text"] = !0, i.Albertus = !0, i.Aldus = !0, i.Alexandria = !0, i.Algerian = !0, i["American Typewriter"] = !0, i.Antiqua = !0, i.Apex = !0, i.Arno = !0, i.Aster = !0, i.Aurora = !0, i.Baskerville = !0, i.Bell = !0, i.Bembo = !0, i["Bembo Schoolbook"] = !0, i.Benguiat = !0, i["Berkeley Old Style"] = !0, i["Bernhard Modern"] = !0, i["Berthold City"] = !0, i.Bodoni = !0, i["Bauer Bodoni"] = !0, i["Book Antiqua"] = !0, i.Bookman = !0, i["Bordeaux Roman"] = !0, i["Californian FB"] = !0, i.Calisto = !0, i.Calvert = !0, i.Capitals = !0, i.Cambria = !0, i.Cartier = !0, i.Caslon = !0, i.Catull = !0, i.Centaur = !0, i["Century Old Style"] = !0, i["Century Schoolbook"] = !0, i.Chaparral = !0, i["Charis SIL"] = !0, i.Cheltenham = !0, i["Cholla Slab"] = !0, i.Clarendon = !0, i.Clearface = !0, i.Cochin = !0, i.Colonna = !0, i["Computer Modern"] = !0, i["Concrete Roman"] = !0, i.Constantia = !0, i["Cooper Black"] = !0, i.Corona = !0, i.Ecotype = !0, i.Egyptienne = !0, i.Elephant = !0, i.Excelsior = !0, i.Fairfield = !0, i["FF Scala"] = !0, i.Folkard = !0, i.Footlight = !0, i.FreeSerif = !0, i["Friz Quadrata"] = !0, i.Garamond = !0, i.Gentium = !0, i.Georgia = !0, i.Gloucester = !0, i["Goudy Old Style"] = !0, i["Goudy Schoolbook"] = !0, i["Goudy Pro Font"] = !0, i.Granjon = !0, i["Guardian Egyptian"] = !0, i.Heather = !0, i.Hercules = !0, i["High Tower Text"] = !0, i.Hiroshige = !0, i["Hoefler Text"] = !0, i["Humana Serif"] = !0, i.Imprint = !0, i["Ionic No. 5"] = !0, i.Janson = !0, i.Joanna = !0, i.Korinna = !0, i.Lexicon = !0, i.LiberationSerif = !0, i["Liberation Serif"] = !0, i["Linux Libertine"] = !0, i.Literaturnaya = !0, i.Lucida = !0, i["Lucida Bright"] = !0, i.Melior = !0, i.Memphis = !0, i.Miller = !0, i.Minion = !0, i.Modern = !0, i["Mona Lisa"] = !0, i["Mrs Eaves"] = !0, i["MS Serif"] = !0, i["Museo Slab"] = !0, i["New York"] = !0, i["Nimbus Roman"] = !0, i["NPS Rawlinson Roadway"] = !0, i.NuptialScript = !0, i.Palatino = !0, i.Perpetua = !0, i.Plantin = !0, i["Plantin Schoolbook"] = !0, i.Playbill = !0, i["Poor Richard"] = !0, i["Rawlinson Roadway"] = !0, i.Renault = !0, i.Requiem = !0, i.Rockwell = !0, i.Roman = !0, i["Rotis Serif"] = !0, i.Sabon = !0, i.Scala = !0, i.Seagull = !0, i.Sistina = !0, i.Souvenir = !0, i.STIX = !0, i["Stone Informal"] = !0, i["Stone Serif"] = !0, i.Sylfaen = !0, i.Times = !0, i.Trajan = !0, i.Trinité = !0, i["Trump Mediaeval"] = !0, i.Utopia = !0, i["Vale Type"] = !0, i["Bitstream Vera"] = !0, i["Vera Serif"] = !0, i.Versailles = !0, i.Wanted = !0, i.Weiss = !0, i["Wide Latin"] = !0, i.Windsor = !0, i.XITS = !0;
        });
        w.getSerifFonts = l;
        const j = (0, n.getLookupTableFactory)(function(i) {
          i.Dingbats = !0, i.Symbol = !0, i.ZapfDingbats = !0, i.Wingdings = !0, i["Wingdings-Bold"] = !0, i["Wingdings-Regular"] = !0;
        });
        w.getSymbolsFonts = j;
        const U = (0, n.getLookupTableFactory)(function(i) {
          i[2] = 10, i[3] = 32, i[4] = 33, i[5] = 34, i[6] = 35, i[7] = 36, i[8] = 37, i[9] = 38, i[10] = 39, i[11] = 40, i[12] = 41, i[13] = 42, i[14] = 43, i[15] = 44, i[16] = 45, i[17] = 46, i[18] = 47, i[19] = 48, i[20] = 49, i[21] = 50, i[22] = 51, i[23] = 52, i[24] = 53, i[25] = 54, i[26] = 55, i[27] = 56, i[28] = 57, i[29] = 58, i[30] = 894, i[31] = 60, i[32] = 61, i[33] = 62, i[34] = 63, i[35] = 64, i[36] = 65, i[37] = 66, i[38] = 67, i[39] = 68, i[40] = 69, i[41] = 70, i[42] = 71, i[43] = 72, i[44] = 73, i[45] = 74, i[46] = 75, i[47] = 76, i[48] = 77, i[49] = 78, i[50] = 79, i[51] = 80, i[52] = 81, i[53] = 82, i[54] = 83, i[55] = 84, i[56] = 85, i[57] = 86, i[58] = 87, i[59] = 88, i[60] = 89, i[61] = 90, i[62] = 91, i[63] = 92, i[64] = 93, i[65] = 94, i[66] = 95, i[67] = 96, i[68] = 97, i[69] = 98, i[70] = 99, i[71] = 100, i[72] = 101, i[73] = 102, i[74] = 103, i[75] = 104, i[76] = 105, i[77] = 106, i[78] = 107, i[79] = 108, i[80] = 109, i[81] = 110, i[82] = 111, i[83] = 112, i[84] = 113, i[85] = 114, i[86] = 115, i[87] = 116, i[88] = 117, i[89] = 118, i[90] = 119, i[91] = 120, i[92] = 121, i[93] = 122, i[94] = 123, i[95] = 124, i[96] = 125, i[97] = 126, i[98] = 196, i[99] = 197, i[100] = 199, i[101] = 201, i[102] = 209, i[103] = 214, i[104] = 220, i[105] = 225, i[106] = 224, i[107] = 226, i[108] = 228, i[109] = 227, i[110] = 229, i[111] = 231, i[112] = 233, i[113] = 232, i[114] = 234, i[115] = 235, i[116] = 237, i[117] = 236, i[118] = 238, i[119] = 239, i[120] = 241, i[121] = 243, i[122] = 242, i[123] = 244, i[124] = 246, i[125] = 245, i[126] = 250, i[127] = 249, i[128] = 251, i[129] = 252, i[130] = 8224, i[131] = 176, i[132] = 162, i[133] = 163, i[134] = 167, i[135] = 8226, i[136] = 182, i[137] = 223, i[138] = 174, i[139] = 169, i[140] = 8482, i[141] = 180, i[142] = 168, i[143] = 8800, i[144] = 198, i[145] = 216, i[146] = 8734, i[147] = 177, i[148] = 8804, i[149] = 8805, i[150] = 165, i[151] = 181, i[152] = 8706, i[153] = 8721, i[154] = 8719, i[156] = 8747, i[157] = 170, i[158] = 186, i[159] = 8486, i[160] = 230, i[161] = 248, i[162] = 191, i[163] = 161, i[164] = 172, i[165] = 8730, i[166] = 402, i[167] = 8776, i[168] = 8710, i[169] = 171, i[170] = 187, i[171] = 8230, i[179] = 8220, i[180] = 8221, i[181] = 8216, i[182] = 8217, i[200] = 193, i[203] = 205, i[207] = 211, i[210] = 218, i[223] = 711, i[224] = 321, i[225] = 322, i[226] = 352, i[227] = 353, i[228] = 381, i[229] = 382, i[233] = 221, i[234] = 253, i[252] = 263, i[253] = 268, i[254] = 269, i[258] = 258, i[260] = 260, i[261] = 261, i[265] = 280, i[266] = 281, i[267] = 282, i[268] = 283, i[269] = 313, i[275] = 323, i[276] = 324, i[278] = 328, i[283] = 344, i[284] = 345, i[285] = 346, i[286] = 347, i[292] = 367, i[295] = 377, i[296] = 378, i[298] = 380, i[305] = 963, i[306] = 964, i[307] = 966, i[308] = 8215, i[309] = 8252, i[310] = 8319, i[311] = 8359, i[312] = 8592, i[313] = 8593, i[337] = 9552, i[493] = 1039, i[494] = 1040, i[672] = 1488, i[673] = 1489, i[674] = 1490, i[675] = 1491, i[676] = 1492, i[677] = 1493, i[678] = 1494, i[679] = 1495, i[680] = 1496, i[681] = 1497, i[682] = 1498, i[683] = 1499, i[684] = 1500, i[685] = 1501, i[686] = 1502, i[687] = 1503, i[688] = 1504, i[689] = 1505, i[690] = 1506, i[691] = 1507, i[692] = 1508, i[693] = 1509, i[694] = 1510, i[695] = 1511, i[696] = 1512, i[697] = 1513, i[698] = 1514, i[705] = 1524, i[706] = 8362, i[710] = 64288, i[711] = 64298, i[759] = 1617, i[761] = 1776, i[763] = 1778, i[775] = 1652, i[777] = 1764, i[778] = 1780, i[779] = 1781, i[780] = 1782, i[782] = 771, i[783] = 64726, i[786] = 8363, i[788] = 8532, i[790] = 768, i[791] = 769, i[792] = 768, i[795] = 803, i[797] = 64336, i[798] = 64337, i[799] = 64342, i[800] = 64343, i[801] = 64344, i[802] = 64345, i[803] = 64362, i[804] = 64363, i[805] = 64364, i[2424] = 7821, i[2425] = 7822, i[2426] = 7823, i[2427] = 7824, i[2428] = 7825, i[2429] = 7826, i[2430] = 7827, i[2433] = 7682, i[2678] = 8045, i[2679] = 8046, i[2830] = 1552, i[2838] = 686, i[2840] = 751, i[2842] = 753, i[2843] = 754, i[2844] = 755, i[2846] = 757, i[2856] = 767, i[2857] = 848, i[2858] = 849, i[2862] = 853, i[2863] = 854, i[2864] = 855, i[2865] = 861, i[2866] = 862, i[2906] = 7460, i[2908] = 7462, i[2909] = 7463, i[2910] = 7464, i[2912] = 7466, i[2913] = 7467, i[2914] = 7468, i[2916] = 7470, i[2917] = 7471, i[2918] = 7472, i[2920] = 7474, i[2921] = 7475, i[2922] = 7476, i[2924] = 7478, i[2925] = 7479, i[2926] = 7480, i[2928] = 7482, i[2929] = 7483, i[2930] = 7484, i[2932] = 7486, i[2933] = 7487, i[2934] = 7488, i[2936] = 7490, i[2937] = 7491, i[2938] = 7492, i[2940] = 7494, i[2941] = 7495, i[2942] = 7496, i[2944] = 7498, i[2946] = 7500, i[2948] = 7502, i[2950] = 7504, i[2951] = 7505, i[2952] = 7506, i[2954] = 7508, i[2955] = 7509, i[2956] = 7510, i[2958] = 7512, i[2959] = 7513, i[2960] = 7514, i[2962] = 7516, i[2963] = 7517, i[2964] = 7518, i[2966] = 7520, i[2967] = 7521, i[2968] = 7522, i[2970] = 7524, i[2971] = 7525, i[2972] = 7526, i[2974] = 7528, i[2975] = 7529, i[2976] = 7530, i[2978] = 1537, i[2979] = 1538, i[2980] = 1539, i[2982] = 1549, i[2983] = 1551, i[2984] = 1552, i[2986] = 1554, i[2987] = 1555, i[2988] = 1556, i[2990] = 1623, i[2991] = 1624, i[2995] = 1775, i[2999] = 1791, i[3002] = 64290, i[3003] = 64291, i[3004] = 64292, i[3006] = 64294, i[3007] = 64295, i[3008] = 64296, i[3011] = 1900, i[3014] = 8223, i[3015] = 8244, i[3017] = 7532, i[3018] = 7533, i[3019] = 7534, i[3075] = 7590, i[3076] = 7591, i[3079] = 7594, i[3080] = 7595, i[3083] = 7598, i[3084] = 7599, i[3087] = 7602, i[3088] = 7603, i[3091] = 7606, i[3092] = 7607, i[3095] = 7610, i[3096] = 7611, i[3099] = 7614, i[3100] = 7615, i[3103] = 7618, i[3104] = 7619, i[3107] = 8337, i[3108] = 8338, i[3116] = 1884, i[3119] = 1885, i[3120] = 1885, i[3123] = 1886, i[3124] = 1886, i[3127] = 1887, i[3128] = 1887, i[3131] = 1888, i[3132] = 1888, i[3135] = 1889, i[3136] = 1889, i[3139] = 1890, i[3140] = 1890, i[3143] = 1891, i[3144] = 1891, i[3147] = 1892, i[3148] = 1892, i[3153] = 580, i[3154] = 581, i[3157] = 584, i[3158] = 585, i[3161] = 588, i[3162] = 589, i[3165] = 891, i[3166] = 892, i[3169] = 1274, i[3170] = 1275, i[3173] = 1278, i[3174] = 1279, i[3181] = 7622, i[3182] = 7623, i[3282] = 11799, i[3316] = 578, i[3379] = 42785, i[3393] = 1159, i[3416] = 8377;
        });
        w.getGlyphMapForStandardFonts = U;
        const O = (0, n.getLookupTableFactory)(function(i) {
          i[227] = 322, i[264] = 261, i[291] = 346;
        });
        w.getSupplementalGlyphMapForArialBlack = O;
        const v = (0, n.getLookupTableFactory)(function(i) {
          i[1] = 32, i[4] = 65, i[5] = 192, i[6] = 193, i[9] = 196, i[17] = 66, i[18] = 67, i[21] = 268, i[24] = 68, i[28] = 69, i[29] = 200, i[30] = 201, i[32] = 282, i[38] = 70, i[39] = 71, i[44] = 72, i[47] = 73, i[48] = 204, i[49] = 205, i[58] = 74, i[60] = 75, i[62] = 76, i[68] = 77, i[69] = 78, i[75] = 79, i[76] = 210, i[80] = 214, i[87] = 80, i[89] = 81, i[90] = 82, i[92] = 344, i[94] = 83, i[97] = 352, i[100] = 84, i[104] = 85, i[109] = 220, i[115] = 86, i[116] = 87, i[121] = 88, i[122] = 89, i[124] = 221, i[127] = 90, i[129] = 381, i[258] = 97, i[259] = 224, i[260] = 225, i[263] = 228, i[268] = 261, i[271] = 98, i[272] = 99, i[273] = 263, i[275] = 269, i[282] = 100, i[286] = 101, i[287] = 232, i[288] = 233, i[290] = 283, i[295] = 281, i[296] = 102, i[336] = 103, i[346] = 104, i[349] = 105, i[350] = 236, i[351] = 237, i[361] = 106, i[364] = 107, i[367] = 108, i[371] = 322, i[373] = 109, i[374] = 110, i[381] = 111, i[382] = 242, i[383] = 243, i[386] = 246, i[393] = 112, i[395] = 113, i[396] = 114, i[398] = 345, i[400] = 115, i[401] = 347, i[403] = 353, i[410] = 116, i[437] = 117, i[442] = 252, i[448] = 118, i[449] = 119, i[454] = 120, i[455] = 121, i[457] = 253, i[460] = 122, i[462] = 382, i[463] = 380, i[853] = 44, i[855] = 58, i[856] = 46, i[876] = 47, i[878] = 45, i[882] = 45, i[894] = 40, i[895] = 41, i[896] = 91, i[897] = 93, i[923] = 64, i[1004] = 48, i[1005] = 49, i[1006] = 50, i[1007] = 51, i[1008] = 52, i[1009] = 53, i[1010] = 54, i[1011] = 55, i[1012] = 56, i[1013] = 57, i[1081] = 37, i[1085] = 43, i[1086] = 45;
        });
        w.getSupplementalGlyphMapForCalibri = v;
        function g(i) {
          const P = (0, F.normalizeFontName)(i);
          return C()[P];
        }
        function b(i) {
          const P = (0, F.normalizeFontName)(i);
          return !!(C()[P] || t()[P] || l()[P] || j()[P]);
        }
      },
      /* 42 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.ToUnicodeMap = w.IdentityToUnicodeMap = void 0;
        var n = V(2);
        class F {
          constructor(t = []) {
            this._map = t;
          }
          get length() {
            return this._map.length;
          }
          forEach(t) {
            for (const l in this._map)
              t(l, this._map[l].charCodeAt(0));
          }
          has(t) {
            return this._map[t] !== void 0;
          }
          get(t) {
            return this._map[t];
          }
          charCodeOf(t) {
            const l = this._map;
            if (l.length <= 65536)
              return l.indexOf(t);
            for (const j in l)
              if (l[j] === t)
                return j | 0;
            return -1;
          }
          amend(t) {
            for (const l in t)
              this._map[l] = t[l];
          }
        }
        w.ToUnicodeMap = F;
        class C {
          constructor(t, l) {
            this.firstChar = t, this.lastChar = l;
          }
          get length() {
            return this.lastChar + 1 - this.firstChar;
          }
          forEach(t) {
            for (let l = this.firstChar, j = this.lastChar; l <= j; l++)
              t(l, l);
          }
          has(t) {
            return this.firstChar <= t && t <= this.lastChar;
          }
          get(t) {
            if (this.firstChar <= t && t <= this.lastChar)
              return String.fromCharCode(t);
          }
          charCodeOf(t) {
            return Number.isInteger(t) && t >= this.firstChar && t <= this.lastChar ? t : -1;
          }
          amend(t) {
            (0, n.unreachable)("Should not call amend()");
          }
        }
        w.IdentityToUnicodeMap = C;
      },
      /* 43 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.CFFFont = void 0;
        var n = V(35), F = V(38), C = V(2);
        class e {
          constructor(l, j) {
            this.properties = j;
            const U = new n.CFFParser(l, j, F.SEAC_ANALYSIS_ENABLED);
            this.cff = U.parse(), this.cff.duplicateFirstGlyph();
            const O = new n.CFFCompiler(this.cff);
            this.seacs = this.cff.seacs;
            try {
              this.data = O.compile();
            } catch {
              (0, C.warn)("Failed to compile font " + j.loadedName), this.data = l;
            }
            this._createBuiltInEncoding();
          }
          get numGlyphs() {
            return this.cff.charStrings.count;
          }
          getCharset() {
            return this.cff.charset.charset;
          }
          getGlyphMapping() {
            const l = this.cff, j = this.properties, {
              cidToGidMap: U,
              cMap: O
            } = j, v = l.charset.charset;
            let g, b;
            if (j.composite) {
              let P;
              if ((U == null ? void 0 : U.length) > 0) {
                P = /* @__PURE__ */ Object.create(null);
                for (let A = 0, I = U.length; A < I; A++) {
                  const E = U[A];
                  E !== void 0 && (P[E] = A);
                }
              }
              g = /* @__PURE__ */ Object.create(null);
              let d;
              if (l.isCIDFont)
                for (b = 0; b < v.length; b++) {
                  const A = v[b];
                  d = O.charCodeOf(A), (P == null ? void 0 : P[d]) !== void 0 && (d = P[d]), g[d] = b;
                }
              else
                for (b = 0; b < l.charStrings.count; b++)
                  d = O.charCodeOf(b), g[d] = b;
              return g;
            }
            let i = l.encoding ? l.encoding.encoding : null;
            return j.isInternalFont && (i = j.defaultEncoding), g = (0, F.type1FontGlyphMapping)(j, i, v), g;
          }
          hasGlyphId(l) {
            return this.cff.hasGlyphId(l);
          }
          _createBuiltInEncoding() {
            const {
              charset: l,
              encoding: j
            } = this.cff;
            if (!l || !j)
              return;
            const U = l.charset, O = j.encoding, v = [];
            for (const g in O) {
              const b = O[g];
              if (b >= 0) {
                const i = U[b];
                i && (v[g] = i);
              }
            }
            v.length > 0 && (this.properties.builtInEncoding = v);
          }
        }
        w.CFFFont = e;
      },
      /* 44 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.FontRendererFactory = void 0;
        var n = V(2), F = V(35), C = V(39), e = V(37), t = V(8);
        function l(f, c) {
          return (f[c] << 24 | f[c + 1] << 16 | f[c + 2] << 8 | f[c + 3]) >>> 0;
        }
        function j(f, c) {
          return f[c] << 8 | f[c + 1];
        }
        function U(f, c) {
          return (f[c] << 24 | f[c + 1] << 16) >> 16;
        }
        function O(f, c) {
          return f[c] << 24 >> 24;
        }
        function v(f, c) {
          return U(f, c) / 16384;
        }
        function g(f) {
          const c = f.length;
          let N = 32768;
          return c < 1240 ? N = 107 : c < 33900 && (N = 1131), N;
        }
        function b(f, c, N) {
          const u = j(f, c + 2) === 1 ? l(f, c + 8) : l(f, c + 16), p = j(f, c + u);
          let S, B, T;
          if (p === 4) {
            j(f, c + u + 2);
            const D = j(f, c + u + 6) >> 1;
            for (B = c + u + 14, S = [], T = 0; T < D; T++, B += 2)
              S[T] = {
                end: j(f, B)
              };
            for (B += 2, T = 0; T < D; T++, B += 2)
              S[T].start = j(f, B);
            for (T = 0; T < D; T++, B += 2)
              S[T].idDelta = j(f, B);
            for (T = 0; T < D; T++, B += 2) {
              let K = j(f, B);
              if (K !== 0) {
                S[T].ids = [];
                for (let _ = 0, o = S[T].end - S[T].start + 1; _ < o; _++)
                  S[T].ids[_] = j(f, B + K), K += 2;
              }
            }
            return S;
          } else if (p === 12) {
            const D = l(f, c + u + 12);
            for (B = c + u + 16, S = [], T = 0; T < D; T++)
              c = l(f, B), S.push({
                start: c,
                end: l(f, B + 4),
                idDelta: l(f, B + 8) - c
              }), B += 12;
            return S;
          }
          throw new n.FormatError(`unsupported cmap: ${p}`);
        }
        function i(f, c, N, u) {
          var T, D, K;
          const p = {}, B = new F.CFFParser(new t.Stream(f, c, N - c), p, u).parse();
          return {
            glyphs: B.charStrings.objects,
            subrs: (D = (T = B.topDict.privateDict) == null ? void 0 : T.subrsIndex) == null ? void 0 : D.objects,
            gsubrs: (K = B.globalSubrIndex) == null ? void 0 : K.objects,
            isCFFCIDFont: B.isCIDFont,
            fdSelect: B.fdSelect,
            fdArray: B.fdArray
          };
        }
        function P(f, c, N) {
          let u, p;
          N ? (u = 4, p = l) : (u = 2, p = (T, D) => 2 * j(T, D));
          const S = [];
          let B = p(c, 0);
          for (let T = u; T < c.length; T += u) {
            const D = p(c, T);
            S.push(f.subarray(B, D)), B = D;
          }
          return S;
        }
        function d(f, c) {
          const N = c.codePointAt(0);
          let u = 0, p = 0, S = f.length - 1;
          for (; p < S; ) {
            const B = p + S + 1 >> 1;
            N < f[B].start ? S = B - 1 : p = B;
          }
          return f[p].start <= N && N <= f[p].end && (u = f[p].idDelta + (f[p].ids ? f[p].ids[N - f[p].start] : N) & 65535), {
            charCode: N,
            glyphId: u
          };
        }
        function A(f, c, N) {
          function u(o, m) {
            c.push({
              cmd: "moveTo",
              args: [o, m]
            });
          }
          function p(o, m) {
            c.push({
              cmd: "lineTo",
              args: [o, m]
            });
          }
          function S(o, m, s, r) {
            c.push({
              cmd: "quadraticCurveTo",
              args: [o, m, s, r]
            });
          }
          let B = 0;
          const T = U(f, B);
          let D, K = 0, _ = 0;
          if (B += 10, T < 0)
            do {
              D = j(f, B);
              const o = j(f, B + 2);
              B += 4;
              let m, s;
              D & 1 ? (D & 2 ? (m = U(f, B), s = U(f, B + 2)) : (m = j(f, B), s = j(f, B + 2)), B += 4) : D & 2 ? (m = O(f, B++), s = O(f, B++)) : (m = f[B++], s = f[B++]), D & 2 ? (K = m, _ = s) : (K = 0, _ = 0);
              let r = 1, y = 1, M = 0, $ = 0;
              D & 8 ? (r = y = v(f, B), B += 2) : D & 64 ? (r = v(f, B), y = v(f, B + 2), B += 4) : D & 128 && (r = v(f, B), M = v(f, B + 2), $ = v(f, B + 4), y = v(f, B + 6), B += 8);
              const G = N.glyphs[o];
              G && (c.push({
                cmd: "save"
              }, {
                cmd: "transform",
                args: [r, M, $, y, K, _]
              }), A(G, c, N), c.push({
                cmd: "restore"
              }));
            } while (D & 32);
          else {
            const o = [];
            let m, s;
            for (m = 0; m < T; m++)
              o.push(j(f, B)), B += 2;
            const r = j(f, B);
            B += 2 + r;
            const y = o.at(-1) + 1, M = [];
            for (; M.length < y; ) {
              D = f[B++];
              let G = 1;
              for (D & 8 && (G += f[B++]); G-- > 0; )
                M.push({
                  flags: D
                });
            }
            for (m = 0; m < y; m++) {
              switch (M[m].flags & 18) {
                case 0:
                  K += U(f, B), B += 2;
                  break;
                case 2:
                  K -= f[B++];
                  break;
                case 18:
                  K += f[B++];
                  break;
              }
              M[m].x = K;
            }
            for (m = 0; m < y; m++) {
              switch (M[m].flags & 36) {
                case 0:
                  _ += U(f, B), B += 2;
                  break;
                case 4:
                  _ -= f[B++];
                  break;
                case 36:
                  _ += f[B++];
                  break;
              }
              M[m].y = _;
            }
            let $ = 0;
            for (B = 0; B < T; B++) {
              const G = o[B], ce = M.slice($, G + 1);
              if (ce[0].flags & 1)
                ce.push(ce[0]);
              else if (ce.at(-1).flags & 1)
                ce.unshift(ce.at(-1));
              else {
                const q = {
                  flags: 1,
                  x: (ce[0].x + ce.at(-1).x) / 2,
                  y: (ce[0].y + ce.at(-1).y) / 2
                };
                ce.unshift(q), ce.push(q);
              }
              for (u(ce[0].x, ce[0].y), m = 1, s = ce.length; m < s; m++)
                ce[m].flags & 1 ? p(ce[m].x, ce[m].y) : ce[m + 1].flags & 1 ? (S(ce[m].x, ce[m].y, ce[m + 1].x, ce[m + 1].y), m++) : S(ce[m].x, ce[m].y, (ce[m].x + ce[m + 1].x) / 2, (ce[m].y + ce[m + 1].y) / 2);
              $ = G + 1;
            }
          }
        }
        function I(f, c, N, u) {
          function p(m, s) {
            c.push({
              cmd: "moveTo",
              args: [m, s]
            });
          }
          function S(m, s) {
            c.push({
              cmd: "lineTo",
              args: [m, s]
            });
          }
          function B(m, s, r, y, M, $) {
            c.push({
              cmd: "bezierCurveTo",
              args: [m, s, r, y, M, $]
            });
          }
          const T = [];
          let D = 0, K = 0, _ = 0;
          function o(m) {
            var r;
            let s = 0;
            for (; s < m.length; ) {
              let y = !1, M = m[s++], $, G, ce, q, re, Z, te, L, X;
              switch (M) {
                case 1:
                  _ += T.length >> 1, y = !0;
                  break;
                case 3:
                  _ += T.length >> 1, y = !0;
                  break;
                case 4:
                  K += T.pop(), p(D, K), y = !0;
                  break;
                case 5:
                  for (; T.length > 0; )
                    D += T.shift(), K += T.shift(), S(D, K);
                  break;
                case 6:
                  for (; T.length > 0 && (D += T.shift(), S(D, K), T.length !== 0); )
                    K += T.shift(), S(D, K);
                  break;
                case 7:
                  for (; T.length > 0 && (K += T.shift(), S(D, K), T.length !== 0); )
                    D += T.shift(), S(D, K);
                  break;
                case 8:
                  for (; T.length > 0; )
                    $ = D + T.shift(), ce = K + T.shift(), G = $ + T.shift(), q = ce + T.shift(), D = G + T.shift(), K = q + T.shift(), B($, ce, G, q, D, K);
                  break;
                case 10:
                  if (L = T.pop(), X = null, N.isCFFCIDFont) {
                    const J = N.fdSelect.getFDIndex(u);
                    if (J >= 0 && J < N.fdArray.length) {
                      const Y = N.fdArray[J];
                      let ae;
                      (r = Y.privateDict) != null && r.subrsIndex && (ae = Y.privateDict.subrsIndex.objects), ae && (L += g(ae), X = ae[L]);
                    } else
                      (0, n.warn)("Invalid fd index for glyph index.");
                  } else
                    X = N.subrs[L + N.subrsBias];
                  X && o(X);
                  break;
                case 11:
                  return;
                case 12:
                  switch (M = m[s++], M) {
                    case 34:
                      $ = D + T.shift(), G = $ + T.shift(), re = K + T.shift(), D = G + T.shift(), B($, K, G, re, D, re), $ = D + T.shift(), G = $ + T.shift(), D = G + T.shift(), B($, re, G, K, D, K);
                      break;
                    case 35:
                      $ = D + T.shift(), ce = K + T.shift(), G = $ + T.shift(), q = ce + T.shift(), D = G + T.shift(), K = q + T.shift(), B($, ce, G, q, D, K), $ = D + T.shift(), ce = K + T.shift(), G = $ + T.shift(), q = ce + T.shift(), D = G + T.shift(), K = q + T.shift(), B($, ce, G, q, D, K), T.pop();
                      break;
                    case 36:
                      $ = D + T.shift(), re = K + T.shift(), G = $ + T.shift(), Z = re + T.shift(), D = G + T.shift(), B($, re, G, Z, D, Z), $ = D + T.shift(), G = $ + T.shift(), te = Z + T.shift(), D = G + T.shift(), B($, Z, G, te, D, K);
                      break;
                    case 37:
                      const J = D, Y = K;
                      $ = D + T.shift(), ce = K + T.shift(), G = $ + T.shift(), q = ce + T.shift(), D = G + T.shift(), K = q + T.shift(), B($, ce, G, q, D, K), $ = D + T.shift(), ce = K + T.shift(), G = $ + T.shift(), q = ce + T.shift(), D = G, K = q, Math.abs(D - J) > Math.abs(K - Y) ? D += T.shift() : K += T.shift(), B($, ce, G, q, D, K);
                      break;
                    default:
                      throw new n.FormatError(`unknown operator: 12 ${M}`);
                  }
                  break;
                case 14:
                  if (T.length >= 4) {
                    const J = T.pop(), Y = T.pop();
                    K = T.pop(), D = T.pop(), c.push({
                      cmd: "save"
                    }, {
                      cmd: "translate",
                      args: [D, K]
                    });
                    let ae = d(N.cmap, String.fromCharCode(N.glyphNameMap[e.StandardEncoding[J]]));
                    I(N.glyphs[ae.glyphId], c, N, ae.glyphId), c.push({
                      cmd: "restore"
                    }), ae = d(N.cmap, String.fromCharCode(N.glyphNameMap[e.StandardEncoding[Y]])), I(N.glyphs[ae.glyphId], c, N, ae.glyphId);
                  }
                  return;
                case 18:
                  _ += T.length >> 1, y = !0;
                  break;
                case 19:
                  _ += T.length >> 1, s += _ + 7 >> 3, y = !0;
                  break;
                case 20:
                  _ += T.length >> 1, s += _ + 7 >> 3, y = !0;
                  break;
                case 21:
                  K += T.pop(), D += T.pop(), p(D, K), y = !0;
                  break;
                case 22:
                  D += T.pop(), p(D, K), y = !0;
                  break;
                case 23:
                  _ += T.length >> 1, y = !0;
                  break;
                case 24:
                  for (; T.length > 2; )
                    $ = D + T.shift(), ce = K + T.shift(), G = $ + T.shift(), q = ce + T.shift(), D = G + T.shift(), K = q + T.shift(), B($, ce, G, q, D, K);
                  D += T.shift(), K += T.shift(), S(D, K);
                  break;
                case 25:
                  for (; T.length > 6; )
                    D += T.shift(), K += T.shift(), S(D, K);
                  $ = D + T.shift(), ce = K + T.shift(), G = $ + T.shift(), q = ce + T.shift(), D = G + T.shift(), K = q + T.shift(), B($, ce, G, q, D, K);
                  break;
                case 26:
                  for (T.length % 2 && (D += T.shift()); T.length > 0; )
                    $ = D, ce = K + T.shift(), G = $ + T.shift(), q = ce + T.shift(), D = G, K = q + T.shift(), B($, ce, G, q, D, K);
                  break;
                case 27:
                  for (T.length % 2 && (K += T.shift()); T.length > 0; )
                    $ = D + T.shift(), ce = K, G = $ + T.shift(), q = ce + T.shift(), D = G + T.shift(), K = q, B($, ce, G, q, D, K);
                  break;
                case 28:
                  T.push((m[s] << 24 | m[s + 1] << 16) >> 16), s += 2;
                  break;
                case 29:
                  L = T.pop() + N.gsubrsBias, X = N.gsubrs[L], X && o(X);
                  break;
                case 30:
                  for (; T.length > 0 && ($ = D, ce = K + T.shift(), G = $ + T.shift(), q = ce + T.shift(), D = G + T.shift(), K = q + (T.length === 1 ? T.shift() : 0), B($, ce, G, q, D, K), T.length !== 0); )
                    $ = D + T.shift(), ce = K, G = $ + T.shift(), q = ce + T.shift(), K = q + T.shift(), D = G + (T.length === 1 ? T.shift() : 0), B($, ce, G, q, D, K);
                  break;
                case 31:
                  for (; T.length > 0 && ($ = D + T.shift(), ce = K, G = $ + T.shift(), q = ce + T.shift(), K = q + T.shift(), D = G + (T.length === 1 ? T.shift() : 0), B($, ce, G, q, D, K), T.length !== 0); )
                    $ = D, ce = K + T.shift(), G = $ + T.shift(), q = ce + T.shift(), D = G + T.shift(), K = q + (T.length === 1 ? T.shift() : 0), B($, ce, G, q, D, K);
                  break;
                default:
                  if (M < 32)
                    throw new n.FormatError(`unknown operator: ${M}`);
                  M < 247 ? T.push(M - 139) : M < 251 ? T.push((M - 247) * 256 + m[s++] + 108) : M < 255 ? T.push(-(M - 251) * 256 - m[s++] - 108) : (T.push((m[s] << 24 | m[s + 1] << 16 | m[s + 2] << 8 | m[s + 3]) / 65536), s += 4);
                  break;
              }
              y && (T.length = 0);
            }
          }
          o(f);
        }
        const E = [];
        class k {
          constructor(c) {
            this.constructor === k && (0, n.unreachable)("Cannot initialize CompiledFont."), this.fontMatrix = c, this.compiledGlyphs = /* @__PURE__ */ Object.create(null), this.compiledCharCodeToGlyphId = /* @__PURE__ */ Object.create(null);
          }
          getPathJs(c) {
            const {
              charCode: N,
              glyphId: u
            } = d(this.cmap, c);
            let p = this.compiledGlyphs[u];
            if (!p)
              try {
                p = this.compileGlyph(this.glyphs[u], u), this.compiledGlyphs[u] = p;
              } catch (S) {
                throw this.compiledGlyphs[u] = E, this.compiledCharCodeToGlyphId[N] === void 0 && (this.compiledCharCodeToGlyphId[N] = u), S;
              }
            return this.compiledCharCodeToGlyphId[N] === void 0 && (this.compiledCharCodeToGlyphId[N] = u), p;
          }
          compileGlyph(c, N) {
            if (!c || c.length === 0 || c[0] === 14)
              return E;
            let u = this.fontMatrix;
            if (this.isCFFCIDFont) {
              const S = this.fdSelect.getFDIndex(N);
              S >= 0 && S < this.fdArray.length ? u = this.fdArray[S].getByName("FontMatrix") || n.FONT_IDENTITY_MATRIX : (0, n.warn)("Invalid fd index for glyph index.");
            }
            const p = [{
              cmd: "save"
            }, {
              cmd: "transform",
              args: u.slice()
            }, {
              cmd: "scale",
              args: ["size", "-size"]
            }];
            return this.compileGlyphImpl(c, p, N), p.push({
              cmd: "restore"
            }), p;
          }
          compileGlyphImpl() {
            (0, n.unreachable)("Children classes should implement this.");
          }
          hasBuiltPath(c) {
            const {
              charCode: N,
              glyphId: u
            } = d(this.cmap, c);
            return this.compiledGlyphs[u] !== void 0 && this.compiledCharCodeToGlyphId[N] !== void 0;
          }
        }
        class H extends k {
          constructor(c, N, u) {
            super(u || [488e-6, 0, 0, 488e-6, 0, 0]), this.glyphs = c, this.cmap = N;
          }
          compileGlyphImpl(c, N) {
            A(c, N, this);
          }
        }
        class x extends k {
          constructor(c, N, u, p) {
            super(u || [1e-3, 0, 0, 1e-3, 0, 0]), this.glyphs = c.glyphs, this.gsubrs = c.gsubrs || [], this.subrs = c.subrs || [], this.cmap = N, this.glyphNameMap = p || (0, C.getGlyphsUnicode)(), this.gsubrsBias = g(this.gsubrs), this.subrsBias = g(this.subrs), this.isCFFCIDFont = c.isCFFCIDFont, this.fdSelect = c.fdSelect, this.fdArray = c.fdArray;
          }
          compileGlyphImpl(c, N, u) {
            I(c, N, this, u);
          }
        }
        class R {
          static create(c, N) {
            const u = new Uint8Array(c.data);
            let p, S, B, T, D, K;
            const _ = j(u, 4);
            for (let o = 0, m = 12; o < _; o++, m += 16) {
              const s = (0, n.bytesToString)(u.subarray(m, m + 4)), r = l(u, m + 8), y = l(u, m + 12);
              switch (s) {
                case "cmap":
                  p = b(u, r);
                  break;
                case "glyf":
                  S = u.subarray(r, r + y);
                  break;
                case "loca":
                  B = u.subarray(r, r + y);
                  break;
                case "head":
                  K = j(u, r + 18), D = j(u, r + 50);
                  break;
                case "CFF ":
                  T = i(u, r, r + y, N);
                  break;
              }
            }
            if (S) {
              const o = K ? [1 / K, 0, 0, 1 / K, 0, 0] : c.fontMatrix;
              return new H(P(S, B, D), p, o);
            }
            return new x(T, p, c.fontMatrix, c.glyphNameMap);
          }
        }
        w.FontRendererFactory = R;
      },
      /* 45 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.getMetrics = w.getFontBasicMetrics = void 0;
        var n = V(3);
        const F = (0, n.getLookupTableFactory)(function(e) {
          e.Courier = 600, e["Courier-Bold"] = 600, e["Courier-BoldOblique"] = 600, e["Courier-Oblique"] = 600, e.Helvetica = (0, n.getLookupTableFactory)(function(t) {
            t.space = 278, t.exclam = 278, t.quotedbl = 355, t.numbersign = 556, t.dollar = 556, t.percent = 889, t.ampersand = 667, t.quoteright = 222, t.parenleft = 333, t.parenright = 333, t.asterisk = 389, t.plus = 584, t.comma = 278, t.hyphen = 333, t.period = 278, t.slash = 278, t.zero = 556, t.one = 556, t.two = 556, t.three = 556, t.four = 556, t.five = 556, t.six = 556, t.seven = 556, t.eight = 556, t.nine = 556, t.colon = 278, t.semicolon = 278, t.less = 584, t.equal = 584, t.greater = 584, t.question = 556, t.at = 1015, t.A = 667, t.B = 667, t.C = 722, t.D = 722, t.E = 667, t.F = 611, t.G = 778, t.H = 722, t.I = 278, t.J = 500, t.K = 667, t.L = 556, t.M = 833, t.N = 722, t.O = 778, t.P = 667, t.Q = 778, t.R = 722, t.S = 667, t.T = 611, t.U = 722, t.V = 667, t.W = 944, t.X = 667, t.Y = 667, t.Z = 611, t.bracketleft = 278, t.backslash = 278, t.bracketright = 278, t.asciicircum = 469, t.underscore = 556, t.quoteleft = 222, t.a = 556, t.b = 556, t.c = 500, t.d = 556, t.e = 556, t.f = 278, t.g = 556, t.h = 556, t.i = 222, t.j = 222, t.k = 500, t.l = 222, t.m = 833, t.n = 556, t.o = 556, t.p = 556, t.q = 556, t.r = 333, t.s = 500, t.t = 278, t.u = 556, t.v = 500, t.w = 722, t.x = 500, t.y = 500, t.z = 500, t.braceleft = 334, t.bar = 260, t.braceright = 334, t.asciitilde = 584, t.exclamdown = 333, t.cent = 556, t.sterling = 556, t.fraction = 167, t.yen = 556, t.florin = 556, t.section = 556, t.currency = 556, t.quotesingle = 191, t.quotedblleft = 333, t.guillemotleft = 556, t.guilsinglleft = 333, t.guilsinglright = 333, t.fi = 500, t.fl = 500, t.endash = 556, t.dagger = 556, t.daggerdbl = 556, t.periodcentered = 278, t.paragraph = 537, t.bullet = 350, t.quotesinglbase = 222, t.quotedblbase = 333, t.quotedblright = 333, t.guillemotright = 556, t.ellipsis = 1e3, t.perthousand = 1e3, t.questiondown = 611, t.grave = 333, t.acute = 333, t.circumflex = 333, t.tilde = 333, t.macron = 333, t.breve = 333, t.dotaccent = 333, t.dieresis = 333, t.ring = 333, t.cedilla = 333, t.hungarumlaut = 333, t.ogonek = 333, t.caron = 333, t.emdash = 1e3, t.AE = 1e3, t.ordfeminine = 370, t.Lslash = 556, t.Oslash = 778, t.OE = 1e3, t.ordmasculine = 365, t.ae = 889, t.dotlessi = 278, t.lslash = 222, t.oslash = 611, t.oe = 944, t.germandbls = 611, t.Idieresis = 278, t.eacute = 556, t.abreve = 556, t.uhungarumlaut = 556, t.ecaron = 556, t.Ydieresis = 667, t.divide = 584, t.Yacute = 667, t.Acircumflex = 667, t.aacute = 556, t.Ucircumflex = 722, t.yacute = 500, t.scommaaccent = 500, t.ecircumflex = 556, t.Uring = 722, t.Udieresis = 722, t.aogonek = 556, t.Uacute = 722, t.uogonek = 556, t.Edieresis = 667, t.Dcroat = 722, t.commaaccent = 250, t.copyright = 737, t.Emacron = 667, t.ccaron = 500, t.aring = 556, t.Ncommaaccent = 722, t.lacute = 222, t.agrave = 556, t.Tcommaaccent = 611, t.Cacute = 722, t.atilde = 556, t.Edotaccent = 667, t.scaron = 500, t.scedilla = 500, t.iacute = 278, t.lozenge = 471, t.Rcaron = 722, t.Gcommaaccent = 778, t.ucircumflex = 556, t.acircumflex = 556, t.Amacron = 667, t.rcaron = 333, t.ccedilla = 500, t.Zdotaccent = 611, t.Thorn = 667, t.Omacron = 778, t.Racute = 722, t.Sacute = 667, t.dcaron = 643, t.Umacron = 722, t.uring = 556, t.threesuperior = 333, t.Ograve = 778, t.Agrave = 667, t.Abreve = 667, t.multiply = 584, t.uacute = 556, t.Tcaron = 611, t.partialdiff = 476, t.ydieresis = 500, t.Nacute = 722, t.icircumflex = 278, t.Ecircumflex = 667, t.adieresis = 556, t.edieresis = 556, t.cacute = 500, t.nacute = 556, t.umacron = 556, t.Ncaron = 722, t.Iacute = 278, t.plusminus = 584, t.brokenbar = 260, t.registered = 737, t.Gbreve = 778, t.Idotaccent = 278, t.summation = 600, t.Egrave = 667, t.racute = 333, t.omacron = 556, t.Zacute = 611, t.Zcaron = 611, t.greaterequal = 549, t.Eth = 722, t.Ccedilla = 722, t.lcommaaccent = 222, t.tcaron = 317, t.eogonek = 556, t.Uogonek = 722, t.Aacute = 667, t.Adieresis = 667, t.egrave = 556, t.zacute = 500, t.iogonek = 222, t.Oacute = 778, t.oacute = 556, t.amacron = 556, t.sacute = 500, t.idieresis = 278, t.Ocircumflex = 778, t.Ugrave = 722, t.Delta = 612, t.thorn = 556, t.twosuperior = 333, t.Odieresis = 778, t.mu = 556, t.igrave = 278, t.ohungarumlaut = 556, t.Eogonek = 667, t.dcroat = 556, t.threequarters = 834, t.Scedilla = 667, t.lcaron = 299, t.Kcommaaccent = 667, t.Lacute = 556, t.trademark = 1e3, t.edotaccent = 556, t.Igrave = 278, t.Imacron = 278, t.Lcaron = 556, t.onehalf = 834, t.lessequal = 549, t.ocircumflex = 556, t.ntilde = 556, t.Uhungarumlaut = 722, t.Eacute = 667, t.emacron = 556, t.gbreve = 556, t.onequarter = 834, t.Scaron = 667, t.Scommaaccent = 667, t.Ohungarumlaut = 778, t.degree = 400, t.ograve = 556, t.Ccaron = 722, t.ugrave = 556, t.radical = 453, t.Dcaron = 722, t.rcommaaccent = 333, t.Ntilde = 722, t.otilde = 556, t.Rcommaaccent = 722, t.Lcommaaccent = 556, t.Atilde = 667, t.Aogonek = 667, t.Aring = 667, t.Otilde = 778, t.zdotaccent = 500, t.Ecaron = 667, t.Iogonek = 278, t.kcommaaccent = 500, t.minus = 584, t.Icircumflex = 278, t.ncaron = 556, t.tcommaaccent = 278, t.logicalnot = 584, t.odieresis = 556, t.udieresis = 556, t.notequal = 549, t.gcommaaccent = 556, t.eth = 556, t.zcaron = 500, t.ncommaaccent = 556, t.onesuperior = 333, t.imacron = 278, t.Euro = 556;
          }), e["Helvetica-Bold"] = (0, n.getLookupTableFactory)(function(t) {
            t.space = 278, t.exclam = 333, t.quotedbl = 474, t.numbersign = 556, t.dollar = 556, t.percent = 889, t.ampersand = 722, t.quoteright = 278, t.parenleft = 333, t.parenright = 333, t.asterisk = 389, t.plus = 584, t.comma = 278, t.hyphen = 333, t.period = 278, t.slash = 278, t.zero = 556, t.one = 556, t.two = 556, t.three = 556, t.four = 556, t.five = 556, t.six = 556, t.seven = 556, t.eight = 556, t.nine = 556, t.colon = 333, t.semicolon = 333, t.less = 584, t.equal = 584, t.greater = 584, t.question = 611, t.at = 975, t.A = 722, t.B = 722, t.C = 722, t.D = 722, t.E = 667, t.F = 611, t.G = 778, t.H = 722, t.I = 278, t.J = 556, t.K = 722, t.L = 611, t.M = 833, t.N = 722, t.O = 778, t.P = 667, t.Q = 778, t.R = 722, t.S = 667, t.T = 611, t.U = 722, t.V = 667, t.W = 944, t.X = 667, t.Y = 667, t.Z = 611, t.bracketleft = 333, t.backslash = 278, t.bracketright = 333, t.asciicircum = 584, t.underscore = 556, t.quoteleft = 278, t.a = 556, t.b = 611, t.c = 556, t.d = 611, t.e = 556, t.f = 333, t.g = 611, t.h = 611, t.i = 278, t.j = 278, t.k = 556, t.l = 278, t.m = 889, t.n = 611, t.o = 611, t.p = 611, t.q = 611, t.r = 389, t.s = 556, t.t = 333, t.u = 611, t.v = 556, t.w = 778, t.x = 556, t.y = 556, t.z = 500, t.braceleft = 389, t.bar = 280, t.braceright = 389, t.asciitilde = 584, t.exclamdown = 333, t.cent = 556, t.sterling = 556, t.fraction = 167, t.yen = 556, t.florin = 556, t.section = 556, t.currency = 556, t.quotesingle = 238, t.quotedblleft = 500, t.guillemotleft = 556, t.guilsinglleft = 333, t.guilsinglright = 333, t.fi = 611, t.fl = 611, t.endash = 556, t.dagger = 556, t.daggerdbl = 556, t.periodcentered = 278, t.paragraph = 556, t.bullet = 350, t.quotesinglbase = 278, t.quotedblbase = 500, t.quotedblright = 500, t.guillemotright = 556, t.ellipsis = 1e3, t.perthousand = 1e3, t.questiondown = 611, t.grave = 333, t.acute = 333, t.circumflex = 333, t.tilde = 333, t.macron = 333, t.breve = 333, t.dotaccent = 333, t.dieresis = 333, t.ring = 333, t.cedilla = 333, t.hungarumlaut = 333, t.ogonek = 333, t.caron = 333, t.emdash = 1e3, t.AE = 1e3, t.ordfeminine = 370, t.Lslash = 611, t.Oslash = 778, t.OE = 1e3, t.ordmasculine = 365, t.ae = 889, t.dotlessi = 278, t.lslash = 278, t.oslash = 611, t.oe = 944, t.germandbls = 611, t.Idieresis = 278, t.eacute = 556, t.abreve = 556, t.uhungarumlaut = 611, t.ecaron = 556, t.Ydieresis = 667, t.divide = 584, t.Yacute = 667, t.Acircumflex = 722, t.aacute = 556, t.Ucircumflex = 722, t.yacute = 556, t.scommaaccent = 556, t.ecircumflex = 556, t.Uring = 722, t.Udieresis = 722, t.aogonek = 556, t.Uacute = 722, t.uogonek = 611, t.Edieresis = 667, t.Dcroat = 722, t.commaaccent = 250, t.copyright = 737, t.Emacron = 667, t.ccaron = 556, t.aring = 556, t.Ncommaaccent = 722, t.lacute = 278, t.agrave = 556, t.Tcommaaccent = 611, t.Cacute = 722, t.atilde = 556, t.Edotaccent = 667, t.scaron = 556, t.scedilla = 556, t.iacute = 278, t.lozenge = 494, t.Rcaron = 722, t.Gcommaaccent = 778, t.ucircumflex = 611, t.acircumflex = 556, t.Amacron = 722, t.rcaron = 389, t.ccedilla = 556, t.Zdotaccent = 611, t.Thorn = 667, t.Omacron = 778, t.Racute = 722, t.Sacute = 667, t.dcaron = 743, t.Umacron = 722, t.uring = 611, t.threesuperior = 333, t.Ograve = 778, t.Agrave = 722, t.Abreve = 722, t.multiply = 584, t.uacute = 611, t.Tcaron = 611, t.partialdiff = 494, t.ydieresis = 556, t.Nacute = 722, t.icircumflex = 278, t.Ecircumflex = 667, t.adieresis = 556, t.edieresis = 556, t.cacute = 556, t.nacute = 611, t.umacron = 611, t.Ncaron = 722, t.Iacute = 278, t.plusminus = 584, t.brokenbar = 280, t.registered = 737, t.Gbreve = 778, t.Idotaccent = 278, t.summation = 600, t.Egrave = 667, t.racute = 389, t.omacron = 611, t.Zacute = 611, t.Zcaron = 611, t.greaterequal = 549, t.Eth = 722, t.Ccedilla = 722, t.lcommaaccent = 278, t.tcaron = 389, t.eogonek = 556, t.Uogonek = 722, t.Aacute = 722, t.Adieresis = 722, t.egrave = 556, t.zacute = 500, t.iogonek = 278, t.Oacute = 778, t.oacute = 611, t.amacron = 556, t.sacute = 556, t.idieresis = 278, t.Ocircumflex = 778, t.Ugrave = 722, t.Delta = 612, t.thorn = 611, t.twosuperior = 333, t.Odieresis = 778, t.mu = 611, t.igrave = 278, t.ohungarumlaut = 611, t.Eogonek = 667, t.dcroat = 611, t.threequarters = 834, t.Scedilla = 667, t.lcaron = 400, t.Kcommaaccent = 722, t.Lacute = 611, t.trademark = 1e3, t.edotaccent = 556, t.Igrave = 278, t.Imacron = 278, t.Lcaron = 611, t.onehalf = 834, t.lessequal = 549, t.ocircumflex = 611, t.ntilde = 611, t.Uhungarumlaut = 722, t.Eacute = 667, t.emacron = 556, t.gbreve = 611, t.onequarter = 834, t.Scaron = 667, t.Scommaaccent = 667, t.Ohungarumlaut = 778, t.degree = 400, t.ograve = 611, t.Ccaron = 722, t.ugrave = 611, t.radical = 549, t.Dcaron = 722, t.rcommaaccent = 389, t.Ntilde = 722, t.otilde = 611, t.Rcommaaccent = 722, t.Lcommaaccent = 611, t.Atilde = 722, t.Aogonek = 722, t.Aring = 722, t.Otilde = 778, t.zdotaccent = 500, t.Ecaron = 667, t.Iogonek = 278, t.kcommaaccent = 556, t.minus = 584, t.Icircumflex = 278, t.ncaron = 611, t.tcommaaccent = 333, t.logicalnot = 584, t.odieresis = 611, t.udieresis = 611, t.notequal = 549, t.gcommaaccent = 611, t.eth = 611, t.zcaron = 500, t.ncommaaccent = 611, t.onesuperior = 333, t.imacron = 278, t.Euro = 556;
          }), e["Helvetica-BoldOblique"] = (0, n.getLookupTableFactory)(function(t) {
            t.space = 278, t.exclam = 333, t.quotedbl = 474, t.numbersign = 556, t.dollar = 556, t.percent = 889, t.ampersand = 722, t.quoteright = 278, t.parenleft = 333, t.parenright = 333, t.asterisk = 389, t.plus = 584, t.comma = 278, t.hyphen = 333, t.period = 278, t.slash = 278, t.zero = 556, t.one = 556, t.two = 556, t.three = 556, t.four = 556, t.five = 556, t.six = 556, t.seven = 556, t.eight = 556, t.nine = 556, t.colon = 333, t.semicolon = 333, t.less = 584, t.equal = 584, t.greater = 584, t.question = 611, t.at = 975, t.A = 722, t.B = 722, t.C = 722, t.D = 722, t.E = 667, t.F = 611, t.G = 778, t.H = 722, t.I = 278, t.J = 556, t.K = 722, t.L = 611, t.M = 833, t.N = 722, t.O = 778, t.P = 667, t.Q = 778, t.R = 722, t.S = 667, t.T = 611, t.U = 722, t.V = 667, t.W = 944, t.X = 667, t.Y = 667, t.Z = 611, t.bracketleft = 333, t.backslash = 278, t.bracketright = 333, t.asciicircum = 584, t.underscore = 556, t.quoteleft = 278, t.a = 556, t.b = 611, t.c = 556, t.d = 611, t.e = 556, t.f = 333, t.g = 611, t.h = 611, t.i = 278, t.j = 278, t.k = 556, t.l = 278, t.m = 889, t.n = 611, t.o = 611, t.p = 611, t.q = 611, t.r = 389, t.s = 556, t.t = 333, t.u = 611, t.v = 556, t.w = 778, t.x = 556, t.y = 556, t.z = 500, t.braceleft = 389, t.bar = 280, t.braceright = 389, t.asciitilde = 584, t.exclamdown = 333, t.cent = 556, t.sterling = 556, t.fraction = 167, t.yen = 556, t.florin = 556, t.section = 556, t.currency = 556, t.quotesingle = 238, t.quotedblleft = 500, t.guillemotleft = 556, t.guilsinglleft = 333, t.guilsinglright = 333, t.fi = 611, t.fl = 611, t.endash = 556, t.dagger = 556, t.daggerdbl = 556, t.periodcentered = 278, t.paragraph = 556, t.bullet = 350, t.quotesinglbase = 278, t.quotedblbase = 500, t.quotedblright = 500, t.guillemotright = 556, t.ellipsis = 1e3, t.perthousand = 1e3, t.questiondown = 611, t.grave = 333, t.acute = 333, t.circumflex = 333, t.tilde = 333, t.macron = 333, t.breve = 333, t.dotaccent = 333, t.dieresis = 333, t.ring = 333, t.cedilla = 333, t.hungarumlaut = 333, t.ogonek = 333, t.caron = 333, t.emdash = 1e3, t.AE = 1e3, t.ordfeminine = 370, t.Lslash = 611, t.Oslash = 778, t.OE = 1e3, t.ordmasculine = 365, t.ae = 889, t.dotlessi = 278, t.lslash = 278, t.oslash = 611, t.oe = 944, t.germandbls = 611, t.Idieresis = 278, t.eacute = 556, t.abreve = 556, t.uhungarumlaut = 611, t.ecaron = 556, t.Ydieresis = 667, t.divide = 584, t.Yacute = 667, t.Acircumflex = 722, t.aacute = 556, t.Ucircumflex = 722, t.yacute = 556, t.scommaaccent = 556, t.ecircumflex = 556, t.Uring = 722, t.Udieresis = 722, t.aogonek = 556, t.Uacute = 722, t.uogonek = 611, t.Edieresis = 667, t.Dcroat = 722, t.commaaccent = 250, t.copyright = 737, t.Emacron = 667, t.ccaron = 556, t.aring = 556, t.Ncommaaccent = 722, t.lacute = 278, t.agrave = 556, t.Tcommaaccent = 611, t.Cacute = 722, t.atilde = 556, t.Edotaccent = 667, t.scaron = 556, t.scedilla = 556, t.iacute = 278, t.lozenge = 494, t.Rcaron = 722, t.Gcommaaccent = 778, t.ucircumflex = 611, t.acircumflex = 556, t.Amacron = 722, t.rcaron = 389, t.ccedilla = 556, t.Zdotaccent = 611, t.Thorn = 667, t.Omacron = 778, t.Racute = 722, t.Sacute = 667, t.dcaron = 743, t.Umacron = 722, t.uring = 611, t.threesuperior = 333, t.Ograve = 778, t.Agrave = 722, t.Abreve = 722, t.multiply = 584, t.uacute = 611, t.Tcaron = 611, t.partialdiff = 494, t.ydieresis = 556, t.Nacute = 722, t.icircumflex = 278, t.Ecircumflex = 667, t.adieresis = 556, t.edieresis = 556, t.cacute = 556, t.nacute = 611, t.umacron = 611, t.Ncaron = 722, t.Iacute = 278, t.plusminus = 584, t.brokenbar = 280, t.registered = 737, t.Gbreve = 778, t.Idotaccent = 278, t.summation = 600, t.Egrave = 667, t.racute = 389, t.omacron = 611, t.Zacute = 611, t.Zcaron = 611, t.greaterequal = 549, t.Eth = 722, t.Ccedilla = 722, t.lcommaaccent = 278, t.tcaron = 389, t.eogonek = 556, t.Uogonek = 722, t.Aacute = 722, t.Adieresis = 722, t.egrave = 556, t.zacute = 500, t.iogonek = 278, t.Oacute = 778, t.oacute = 611, t.amacron = 556, t.sacute = 556, t.idieresis = 278, t.Ocircumflex = 778, t.Ugrave = 722, t.Delta = 612, t.thorn = 611, t.twosuperior = 333, t.Odieresis = 778, t.mu = 611, t.igrave = 278, t.ohungarumlaut = 611, t.Eogonek = 667, t.dcroat = 611, t.threequarters = 834, t.Scedilla = 667, t.lcaron = 400, t.Kcommaaccent = 722, t.Lacute = 611, t.trademark = 1e3, t.edotaccent = 556, t.Igrave = 278, t.Imacron = 278, t.Lcaron = 611, t.onehalf = 834, t.lessequal = 549, t.ocircumflex = 611, t.ntilde = 611, t.Uhungarumlaut = 722, t.Eacute = 667, t.emacron = 556, t.gbreve = 611, t.onequarter = 834, t.Scaron = 667, t.Scommaaccent = 667, t.Ohungarumlaut = 778, t.degree = 400, t.ograve = 611, t.Ccaron = 722, t.ugrave = 611, t.radical = 549, t.Dcaron = 722, t.rcommaaccent = 389, t.Ntilde = 722, t.otilde = 611, t.Rcommaaccent = 722, t.Lcommaaccent = 611, t.Atilde = 722, t.Aogonek = 722, t.Aring = 722, t.Otilde = 778, t.zdotaccent = 500, t.Ecaron = 667, t.Iogonek = 278, t.kcommaaccent = 556, t.minus = 584, t.Icircumflex = 278, t.ncaron = 611, t.tcommaaccent = 333, t.logicalnot = 584, t.odieresis = 611, t.udieresis = 611, t.notequal = 549, t.gcommaaccent = 611, t.eth = 611, t.zcaron = 500, t.ncommaaccent = 611, t.onesuperior = 333, t.imacron = 278, t.Euro = 556;
          }), e["Helvetica-Oblique"] = (0, n.getLookupTableFactory)(function(t) {
            t.space = 278, t.exclam = 278, t.quotedbl = 355, t.numbersign = 556, t.dollar = 556, t.percent = 889, t.ampersand = 667, t.quoteright = 222, t.parenleft = 333, t.parenright = 333, t.asterisk = 389, t.plus = 584, t.comma = 278, t.hyphen = 333, t.period = 278, t.slash = 278, t.zero = 556, t.one = 556, t.two = 556, t.three = 556, t.four = 556, t.five = 556, t.six = 556, t.seven = 556, t.eight = 556, t.nine = 556, t.colon = 278, t.semicolon = 278, t.less = 584, t.equal = 584, t.greater = 584, t.question = 556, t.at = 1015, t.A = 667, t.B = 667, t.C = 722, t.D = 722, t.E = 667, t.F = 611, t.G = 778, t.H = 722, t.I = 278, t.J = 500, t.K = 667, t.L = 556, t.M = 833, t.N = 722, t.O = 778, t.P = 667, t.Q = 778, t.R = 722, t.S = 667, t.T = 611, t.U = 722, t.V = 667, t.W = 944, t.X = 667, t.Y = 667, t.Z = 611, t.bracketleft = 278, t.backslash = 278, t.bracketright = 278, t.asciicircum = 469, t.underscore = 556, t.quoteleft = 222, t.a = 556, t.b = 556, t.c = 500, t.d = 556, t.e = 556, t.f = 278, t.g = 556, t.h = 556, t.i = 222, t.j = 222, t.k = 500, t.l = 222, t.m = 833, t.n = 556, t.o = 556, t.p = 556, t.q = 556, t.r = 333, t.s = 500, t.t = 278, t.u = 556, t.v = 500, t.w = 722, t.x = 500, t.y = 500, t.z = 500, t.braceleft = 334, t.bar = 260, t.braceright = 334, t.asciitilde = 584, t.exclamdown = 333, t.cent = 556, t.sterling = 556, t.fraction = 167, t.yen = 556, t.florin = 556, t.section = 556, t.currency = 556, t.quotesingle = 191, t.quotedblleft = 333, t.guillemotleft = 556, t.guilsinglleft = 333, t.guilsinglright = 333, t.fi = 500, t.fl = 500, t.endash = 556, t.dagger = 556, t.daggerdbl = 556, t.periodcentered = 278, t.paragraph = 537, t.bullet = 350, t.quotesinglbase = 222, t.quotedblbase = 333, t.quotedblright = 333, t.guillemotright = 556, t.ellipsis = 1e3, t.perthousand = 1e3, t.questiondown = 611, t.grave = 333, t.acute = 333, t.circumflex = 333, t.tilde = 333, t.macron = 333, t.breve = 333, t.dotaccent = 333, t.dieresis = 333, t.ring = 333, t.cedilla = 333, t.hungarumlaut = 333, t.ogonek = 333, t.caron = 333, t.emdash = 1e3, t.AE = 1e3, t.ordfeminine = 370, t.Lslash = 556, t.Oslash = 778, t.OE = 1e3, t.ordmasculine = 365, t.ae = 889, t.dotlessi = 278, t.lslash = 222, t.oslash = 611, t.oe = 944, t.germandbls = 611, t.Idieresis = 278, t.eacute = 556, t.abreve = 556, t.uhungarumlaut = 556, t.ecaron = 556, t.Ydieresis = 667, t.divide = 584, t.Yacute = 667, t.Acircumflex = 667, t.aacute = 556, t.Ucircumflex = 722, t.yacute = 500, t.scommaaccent = 500, t.ecircumflex = 556, t.Uring = 722, t.Udieresis = 722, t.aogonek = 556, t.Uacute = 722, t.uogonek = 556, t.Edieresis = 667, t.Dcroat = 722, t.commaaccent = 250, t.copyright = 737, t.Emacron = 667, t.ccaron = 500, t.aring = 556, t.Ncommaaccent = 722, t.lacute = 222, t.agrave = 556, t.Tcommaaccent = 611, t.Cacute = 722, t.atilde = 556, t.Edotaccent = 667, t.scaron = 500, t.scedilla = 500, t.iacute = 278, t.lozenge = 471, t.Rcaron = 722, t.Gcommaaccent = 778, t.ucircumflex = 556, t.acircumflex = 556, t.Amacron = 667, t.rcaron = 333, t.ccedilla = 500, t.Zdotaccent = 611, t.Thorn = 667, t.Omacron = 778, t.Racute = 722, t.Sacute = 667, t.dcaron = 643, t.Umacron = 722, t.uring = 556, t.threesuperior = 333, t.Ograve = 778, t.Agrave = 667, t.Abreve = 667, t.multiply = 584, t.uacute = 556, t.Tcaron = 611, t.partialdiff = 476, t.ydieresis = 500, t.Nacute = 722, t.icircumflex = 278, t.Ecircumflex = 667, t.adieresis = 556, t.edieresis = 556, t.cacute = 500, t.nacute = 556, t.umacron = 556, t.Ncaron = 722, t.Iacute = 278, t.plusminus = 584, t.brokenbar = 260, t.registered = 737, t.Gbreve = 778, t.Idotaccent = 278, t.summation = 600, t.Egrave = 667, t.racute = 333, t.omacron = 556, t.Zacute = 611, t.Zcaron = 611, t.greaterequal = 549, t.Eth = 722, t.Ccedilla = 722, t.lcommaaccent = 222, t.tcaron = 317, t.eogonek = 556, t.Uogonek = 722, t.Aacute = 667, t.Adieresis = 667, t.egrave = 556, t.zacute = 500, t.iogonek = 222, t.Oacute = 778, t.oacute = 556, t.amacron = 556, t.sacute = 500, t.idieresis = 278, t.Ocircumflex = 778, t.Ugrave = 722, t.Delta = 612, t.thorn = 556, t.twosuperior = 333, t.Odieresis = 778, t.mu = 556, t.igrave = 278, t.ohungarumlaut = 556, t.Eogonek = 667, t.dcroat = 556, t.threequarters = 834, t.Scedilla = 667, t.lcaron = 299, t.Kcommaaccent = 667, t.Lacute = 556, t.trademark = 1e3, t.edotaccent = 556, t.Igrave = 278, t.Imacron = 278, t.Lcaron = 556, t.onehalf = 834, t.lessequal = 549, t.ocircumflex = 556, t.ntilde = 556, t.Uhungarumlaut = 722, t.Eacute = 667, t.emacron = 556, t.gbreve = 556, t.onequarter = 834, t.Scaron = 667, t.Scommaaccent = 667, t.Ohungarumlaut = 778, t.degree = 400, t.ograve = 556, t.Ccaron = 722, t.ugrave = 556, t.radical = 453, t.Dcaron = 722, t.rcommaaccent = 333, t.Ntilde = 722, t.otilde = 556, t.Rcommaaccent = 722, t.Lcommaaccent = 556, t.Atilde = 667, t.Aogonek = 667, t.Aring = 667, t.Otilde = 778, t.zdotaccent = 500, t.Ecaron = 667, t.Iogonek = 278, t.kcommaaccent = 500, t.minus = 584, t.Icircumflex = 278, t.ncaron = 556, t.tcommaaccent = 278, t.logicalnot = 584, t.odieresis = 556, t.udieresis = 556, t.notequal = 549, t.gcommaaccent = 556, t.eth = 556, t.zcaron = 500, t.ncommaaccent = 556, t.onesuperior = 333, t.imacron = 278, t.Euro = 556;
          }), e.Symbol = (0, n.getLookupTableFactory)(function(t) {
            t.space = 250, t.exclam = 333, t.universal = 713, t.numbersign = 500, t.existential = 549, t.percent = 833, t.ampersand = 778, t.suchthat = 439, t.parenleft = 333, t.parenright = 333, t.asteriskmath = 500, t.plus = 549, t.comma = 250, t.minus = 549, t.period = 250, t.slash = 278, t.zero = 500, t.one = 500, t.two = 500, t.three = 500, t.four = 500, t.five = 500, t.six = 500, t.seven = 500, t.eight = 500, t.nine = 500, t.colon = 278, t.semicolon = 278, t.less = 549, t.equal = 549, t.greater = 549, t.question = 444, t.congruent = 549, t.Alpha = 722, t.Beta = 667, t.Chi = 722, t.Delta = 612, t.Epsilon = 611, t.Phi = 763, t.Gamma = 603, t.Eta = 722, t.Iota = 333, t.theta1 = 631, t.Kappa = 722, t.Lambda = 686, t.Mu = 889, t.Nu = 722, t.Omicron = 722, t.Pi = 768, t.Theta = 741, t.Rho = 556, t.Sigma = 592, t.Tau = 611, t.Upsilon = 690, t.sigma1 = 439, t.Omega = 768, t.Xi = 645, t.Psi = 795, t.Zeta = 611, t.bracketleft = 333, t.therefore = 863, t.bracketright = 333, t.perpendicular = 658, t.underscore = 500, t.radicalex = 500, t.alpha = 631, t.beta = 549, t.chi = 549, t.delta = 494, t.epsilon = 439, t.phi = 521, t.gamma = 411, t.eta = 603, t.iota = 329, t.phi1 = 603, t.kappa = 549, t.lambda = 549, t.mu = 576, t.nu = 521, t.omicron = 549, t.pi = 549, t.theta = 521, t.rho = 549, t.sigma = 603, t.tau = 439, t.upsilon = 576, t.omega1 = 713, t.omega = 686, t.xi = 493, t.psi = 686, t.zeta = 494, t.braceleft = 480, t.bar = 200, t.braceright = 480, t.similar = 549, t.Euro = 750, t.Upsilon1 = 620, t.minute = 247, t.lessequal = 549, t.fraction = 167, t.infinity = 713, t.florin = 500, t.club = 753, t.diamond = 753, t.heart = 753, t.spade = 753, t.arrowboth = 1042, t.arrowleft = 987, t.arrowup = 603, t.arrowright = 987, t.arrowdown = 603, t.degree = 400, t.plusminus = 549, t.second = 411, t.greaterequal = 549, t.multiply = 549, t.proportional = 713, t.partialdiff = 494, t.bullet = 460, t.divide = 549, t.notequal = 549, t.equivalence = 549, t.approxequal = 549, t.ellipsis = 1e3, t.arrowvertex = 603, t.arrowhorizex = 1e3, t.carriagereturn = 658, t.aleph = 823, t.Ifraktur = 686, t.Rfraktur = 795, t.weierstrass = 987, t.circlemultiply = 768, t.circleplus = 768, t.emptyset = 823, t.intersection = 768, t.union = 768, t.propersuperset = 713, t.reflexsuperset = 713, t.notsubset = 713, t.propersubset = 713, t.reflexsubset = 713, t.element = 713, t.notelement = 713, t.angle = 768, t.gradient = 713, t.registerserif = 790, t.copyrightserif = 790, t.trademarkserif = 890, t.product = 823, t.radical = 549, t.dotmath = 250, t.logicalnot = 713, t.logicaland = 603, t.logicalor = 603, t.arrowdblboth = 1042, t.arrowdblleft = 987, t.arrowdblup = 603, t.arrowdblright = 987, t.arrowdbldown = 603, t.lozenge = 494, t.angleleft = 329, t.registersans = 790, t.copyrightsans = 790, t.trademarksans = 786, t.summation = 713, t.parenlefttp = 384, t.parenleftex = 384, t.parenleftbt = 384, t.bracketlefttp = 384, t.bracketleftex = 384, t.bracketleftbt = 384, t.bracelefttp = 494, t.braceleftmid = 494, t.braceleftbt = 494, t.braceex = 494, t.angleright = 329, t.integral = 274, t.integraltp = 686, t.integralex = 686, t.integralbt = 686, t.parenrighttp = 384, t.parenrightex = 384, t.parenrightbt = 384, t.bracketrighttp = 384, t.bracketrightex = 384, t.bracketrightbt = 384, t.bracerighttp = 494, t.bracerightmid = 494, t.bracerightbt = 494, t.apple = 790;
          }), e["Times-Roman"] = (0, n.getLookupTableFactory)(function(t) {
            t.space = 250, t.exclam = 333, t.quotedbl = 408, t.numbersign = 500, t.dollar = 500, t.percent = 833, t.ampersand = 778, t.quoteright = 333, t.parenleft = 333, t.parenright = 333, t.asterisk = 500, t.plus = 564, t.comma = 250, t.hyphen = 333, t.period = 250, t.slash = 278, t.zero = 500, t.one = 500, t.two = 500, t.three = 500, t.four = 500, t.five = 500, t.six = 500, t.seven = 500, t.eight = 500, t.nine = 500, t.colon = 278, t.semicolon = 278, t.less = 564, t.equal = 564, t.greater = 564, t.question = 444, t.at = 921, t.A = 722, t.B = 667, t.C = 667, t.D = 722, t.E = 611, t.F = 556, t.G = 722, t.H = 722, t.I = 333, t.J = 389, t.K = 722, t.L = 611, t.M = 889, t.N = 722, t.O = 722, t.P = 556, t.Q = 722, t.R = 667, t.S = 556, t.T = 611, t.U = 722, t.V = 722, t.W = 944, t.X = 722, t.Y = 722, t.Z = 611, t.bracketleft = 333, t.backslash = 278, t.bracketright = 333, t.asciicircum = 469, t.underscore = 500, t.quoteleft = 333, t.a = 444, t.b = 500, t.c = 444, t.d = 500, t.e = 444, t.f = 333, t.g = 500, t.h = 500, t.i = 278, t.j = 278, t.k = 500, t.l = 278, t.m = 778, t.n = 500, t.o = 500, t.p = 500, t.q = 500, t.r = 333, t.s = 389, t.t = 278, t.u = 500, t.v = 500, t.w = 722, t.x = 500, t.y = 500, t.z = 444, t.braceleft = 480, t.bar = 200, t.braceright = 480, t.asciitilde = 541, t.exclamdown = 333, t.cent = 500, t.sterling = 500, t.fraction = 167, t.yen = 500, t.florin = 500, t.section = 500, t.currency = 500, t.quotesingle = 180, t.quotedblleft = 444, t.guillemotleft = 500, t.guilsinglleft = 333, t.guilsinglright = 333, t.fi = 556, t.fl = 556, t.endash = 500, t.dagger = 500, t.daggerdbl = 500, t.periodcentered = 250, t.paragraph = 453, t.bullet = 350, t.quotesinglbase = 333, t.quotedblbase = 444, t.quotedblright = 444, t.guillemotright = 500, t.ellipsis = 1e3, t.perthousand = 1e3, t.questiondown = 444, t.grave = 333, t.acute = 333, t.circumflex = 333, t.tilde = 333, t.macron = 333, t.breve = 333, t.dotaccent = 333, t.dieresis = 333, t.ring = 333, t.cedilla = 333, t.hungarumlaut = 333, t.ogonek = 333, t.caron = 333, t.emdash = 1e3, t.AE = 889, t.ordfeminine = 276, t.Lslash = 611, t.Oslash = 722, t.OE = 889, t.ordmasculine = 310, t.ae = 667, t.dotlessi = 278, t.lslash = 278, t.oslash = 500, t.oe = 722, t.germandbls = 500, t.Idieresis = 333, t.eacute = 444, t.abreve = 444, t.uhungarumlaut = 500, t.ecaron = 444, t.Ydieresis = 722, t.divide = 564, t.Yacute = 722, t.Acircumflex = 722, t.aacute = 444, t.Ucircumflex = 722, t.yacute = 500, t.scommaaccent = 389, t.ecircumflex = 444, t.Uring = 722, t.Udieresis = 722, t.aogonek = 444, t.Uacute = 722, t.uogonek = 500, t.Edieresis = 611, t.Dcroat = 722, t.commaaccent = 250, t.copyright = 760, t.Emacron = 611, t.ccaron = 444, t.aring = 444, t.Ncommaaccent = 722, t.lacute = 278, t.agrave = 444, t.Tcommaaccent = 611, t.Cacute = 667, t.atilde = 444, t.Edotaccent = 611, t.scaron = 389, t.scedilla = 389, t.iacute = 278, t.lozenge = 471, t.Rcaron = 667, t.Gcommaaccent = 722, t.ucircumflex = 500, t.acircumflex = 444, t.Amacron = 722, t.rcaron = 333, t.ccedilla = 444, t.Zdotaccent = 611, t.Thorn = 556, t.Omacron = 722, t.Racute = 667, t.Sacute = 556, t.dcaron = 588, t.Umacron = 722, t.uring = 500, t.threesuperior = 300, t.Ograve = 722, t.Agrave = 722, t.Abreve = 722, t.multiply = 564, t.uacute = 500, t.Tcaron = 611, t.partialdiff = 476, t.ydieresis = 500, t.Nacute = 722, t.icircumflex = 278, t.Ecircumflex = 611, t.adieresis = 444, t.edieresis = 444, t.cacute = 444, t.nacute = 500, t.umacron = 500, t.Ncaron = 722, t.Iacute = 333, t.plusminus = 564, t.brokenbar = 200, t.registered = 760, t.Gbreve = 722, t.Idotaccent = 333, t.summation = 600, t.Egrave = 611, t.racute = 333, t.omacron = 500, t.Zacute = 611, t.Zcaron = 611, t.greaterequal = 549, t.Eth = 722, t.Ccedilla = 667, t.lcommaaccent = 278, t.tcaron = 326, t.eogonek = 444, t.Uogonek = 722, t.Aacute = 722, t.Adieresis = 722, t.egrave = 444, t.zacute = 444, t.iogonek = 278, t.Oacute = 722, t.oacute = 500, t.amacron = 444, t.sacute = 389, t.idieresis = 278, t.Ocircumflex = 722, t.Ugrave = 722, t.Delta = 612, t.thorn = 500, t.twosuperior = 300, t.Odieresis = 722, t.mu = 500, t.igrave = 278, t.ohungarumlaut = 500, t.Eogonek = 611, t.dcroat = 500, t.threequarters = 750, t.Scedilla = 556, t.lcaron = 344, t.Kcommaaccent = 722, t.Lacute = 611, t.trademark = 980, t.edotaccent = 444, t.Igrave = 333, t.Imacron = 333, t.Lcaron = 611, t.onehalf = 750, t.lessequal = 549, t.ocircumflex = 500, t.ntilde = 500, t.Uhungarumlaut = 722, t.Eacute = 611, t.emacron = 444, t.gbreve = 500, t.onequarter = 750, t.Scaron = 556, t.Scommaaccent = 556, t.Ohungarumlaut = 722, t.degree = 400, t.ograve = 500, t.Ccaron = 667, t.ugrave = 500, t.radical = 453, t.Dcaron = 722, t.rcommaaccent = 333, t.Ntilde = 722, t.otilde = 500, t.Rcommaaccent = 667, t.Lcommaaccent = 611, t.Atilde = 722, t.Aogonek = 722, t.Aring = 722, t.Otilde = 722, t.zdotaccent = 444, t.Ecaron = 611, t.Iogonek = 333, t.kcommaaccent = 500, t.minus = 564, t.Icircumflex = 333, t.ncaron = 500, t.tcommaaccent = 278, t.logicalnot = 564, t.odieresis = 500, t.udieresis = 500, t.notequal = 549, t.gcommaaccent = 500, t.eth = 500, t.zcaron = 444, t.ncommaaccent = 500, t.onesuperior = 300, t.imacron = 278, t.Euro = 500;
          }), e["Times-Bold"] = (0, n.getLookupTableFactory)(function(t) {
            t.space = 250, t.exclam = 333, t.quotedbl = 555, t.numbersign = 500, t.dollar = 500, t.percent = 1e3, t.ampersand = 833, t.quoteright = 333, t.parenleft = 333, t.parenright = 333, t.asterisk = 500, t.plus = 570, t.comma = 250, t.hyphen = 333, t.period = 250, t.slash = 278, t.zero = 500, t.one = 500, t.two = 500, t.three = 500, t.four = 500, t.five = 500, t.six = 500, t.seven = 500, t.eight = 500, t.nine = 500, t.colon = 333, t.semicolon = 333, t.less = 570, t.equal = 570, t.greater = 570, t.question = 500, t.at = 930, t.A = 722, t.B = 667, t.C = 722, t.D = 722, t.E = 667, t.F = 611, t.G = 778, t.H = 778, t.I = 389, t.J = 500, t.K = 778, t.L = 667, t.M = 944, t.N = 722, t.O = 778, t.P = 611, t.Q = 778, t.R = 722, t.S = 556, t.T = 667, t.U = 722, t.V = 722, t.W = 1e3, t.X = 722, t.Y = 722, t.Z = 667, t.bracketleft = 333, t.backslash = 278, t.bracketright = 333, t.asciicircum = 581, t.underscore = 500, t.quoteleft = 333, t.a = 500, t.b = 556, t.c = 444, t.d = 556, t.e = 444, t.f = 333, t.g = 500, t.h = 556, t.i = 278, t.j = 333, t.k = 556, t.l = 278, t.m = 833, t.n = 556, t.o = 500, t.p = 556, t.q = 556, t.r = 444, t.s = 389, t.t = 333, t.u = 556, t.v = 500, t.w = 722, t.x = 500, t.y = 500, t.z = 444, t.braceleft = 394, t.bar = 220, t.braceright = 394, t.asciitilde = 520, t.exclamdown = 333, t.cent = 500, t.sterling = 500, t.fraction = 167, t.yen = 500, t.florin = 500, t.section = 500, t.currency = 500, t.quotesingle = 278, t.quotedblleft = 500, t.guillemotleft = 500, t.guilsinglleft = 333, t.guilsinglright = 333, t.fi = 556, t.fl = 556, t.endash = 500, t.dagger = 500, t.daggerdbl = 500, t.periodcentered = 250, t.paragraph = 540, t.bullet = 350, t.quotesinglbase = 333, t.quotedblbase = 500, t.quotedblright = 500, t.guillemotright = 500, t.ellipsis = 1e3, t.perthousand = 1e3, t.questiondown = 500, t.grave = 333, t.acute = 333, t.circumflex = 333, t.tilde = 333, t.macron = 333, t.breve = 333, t.dotaccent = 333, t.dieresis = 333, t.ring = 333, t.cedilla = 333, t.hungarumlaut = 333, t.ogonek = 333, t.caron = 333, t.emdash = 1e3, t.AE = 1e3, t.ordfeminine = 300, t.Lslash = 667, t.Oslash = 778, t.OE = 1e3, t.ordmasculine = 330, t.ae = 722, t.dotlessi = 278, t.lslash = 278, t.oslash = 500, t.oe = 722, t.germandbls = 556, t.Idieresis = 389, t.eacute = 444, t.abreve = 500, t.uhungarumlaut = 556, t.ecaron = 444, t.Ydieresis = 722, t.divide = 570, t.Yacute = 722, t.Acircumflex = 722, t.aacute = 500, t.Ucircumflex = 722, t.yacute = 500, t.scommaaccent = 389, t.ecircumflex = 444, t.Uring = 722, t.Udieresis = 722, t.aogonek = 500, t.Uacute = 722, t.uogonek = 556, t.Edieresis = 667, t.Dcroat = 722, t.commaaccent = 250, t.copyright = 747, t.Emacron = 667, t.ccaron = 444, t.aring = 500, t.Ncommaaccent = 722, t.lacute = 278, t.agrave = 500, t.Tcommaaccent = 667, t.Cacute = 722, t.atilde = 500, t.Edotaccent = 667, t.scaron = 389, t.scedilla = 389, t.iacute = 278, t.lozenge = 494, t.Rcaron = 722, t.Gcommaaccent = 778, t.ucircumflex = 556, t.acircumflex = 500, t.Amacron = 722, t.rcaron = 444, t.ccedilla = 444, t.Zdotaccent = 667, t.Thorn = 611, t.Omacron = 778, t.Racute = 722, t.Sacute = 556, t.dcaron = 672, t.Umacron = 722, t.uring = 556, t.threesuperior = 300, t.Ograve = 778, t.Agrave = 722, t.Abreve = 722, t.multiply = 570, t.uacute = 556, t.Tcaron = 667, t.partialdiff = 494, t.ydieresis = 500, t.Nacute = 722, t.icircumflex = 278, t.Ecircumflex = 667, t.adieresis = 500, t.edieresis = 444, t.cacute = 444, t.nacute = 556, t.umacron = 556, t.Ncaron = 722, t.Iacute = 389, t.plusminus = 570, t.brokenbar = 220, t.registered = 747, t.Gbreve = 778, t.Idotaccent = 389, t.summation = 600, t.Egrave = 667, t.racute = 444, t.omacron = 500, t.Zacute = 667, t.Zcaron = 667, t.greaterequal = 549, t.Eth = 722, t.Ccedilla = 722, t.lcommaaccent = 278, t.tcaron = 416, t.eogonek = 444, t.Uogonek = 722, t.Aacute = 722, t.Adieresis = 722, t.egrave = 444, t.zacute = 444, t.iogonek = 278, t.Oacute = 778, t.oacute = 500, t.amacron = 500, t.sacute = 389, t.idieresis = 278, t.Ocircumflex = 778, t.Ugrave = 722, t.Delta = 612, t.thorn = 556, t.twosuperior = 300, t.Odieresis = 778, t.mu = 556, t.igrave = 278, t.ohungarumlaut = 500, t.Eogonek = 667, t.dcroat = 556, t.threequarters = 750, t.Scedilla = 556, t.lcaron = 394, t.Kcommaaccent = 778, t.Lacute = 667, t.trademark = 1e3, t.edotaccent = 444, t.Igrave = 389, t.Imacron = 389, t.Lcaron = 667, t.onehalf = 750, t.lessequal = 549, t.ocircumflex = 500, t.ntilde = 556, t.Uhungarumlaut = 722, t.Eacute = 667, t.emacron = 444, t.gbreve = 500, t.onequarter = 750, t.Scaron = 556, t.Scommaaccent = 556, t.Ohungarumlaut = 778, t.degree = 400, t.ograve = 500, t.Ccaron = 722, t.ugrave = 556, t.radical = 549, t.Dcaron = 722, t.rcommaaccent = 444, t.Ntilde = 722, t.otilde = 500, t.Rcommaaccent = 722, t.Lcommaaccent = 667, t.Atilde = 722, t.Aogonek = 722, t.Aring = 722, t.Otilde = 778, t.zdotaccent = 444, t.Ecaron = 667, t.Iogonek = 389, t.kcommaaccent = 556, t.minus = 570, t.Icircumflex = 389, t.ncaron = 556, t.tcommaaccent = 333, t.logicalnot = 570, t.odieresis = 500, t.udieresis = 556, t.notequal = 549, t.gcommaaccent = 500, t.eth = 500, t.zcaron = 444, t.ncommaaccent = 556, t.onesuperior = 300, t.imacron = 278, t.Euro = 500;
          }), e["Times-BoldItalic"] = (0, n.getLookupTableFactory)(function(t) {
            t.space = 250, t.exclam = 389, t.quotedbl = 555, t.numbersign = 500, t.dollar = 500, t.percent = 833, t.ampersand = 778, t.quoteright = 333, t.parenleft = 333, t.parenright = 333, t.asterisk = 500, t.plus = 570, t.comma = 250, t.hyphen = 333, t.period = 250, t.slash = 278, t.zero = 500, t.one = 500, t.two = 500, t.three = 500, t.four = 500, t.five = 500, t.six = 500, t.seven = 500, t.eight = 500, t.nine = 500, t.colon = 333, t.semicolon = 333, t.less = 570, t.equal = 570, t.greater = 570, t.question = 500, t.at = 832, t.A = 667, t.B = 667, t.C = 667, t.D = 722, t.E = 667, t.F = 667, t.G = 722, t.H = 778, t.I = 389, t.J = 500, t.K = 667, t.L = 611, t.M = 889, t.N = 722, t.O = 722, t.P = 611, t.Q = 722, t.R = 667, t.S = 556, t.T = 611, t.U = 722, t.V = 667, t.W = 889, t.X = 667, t.Y = 611, t.Z = 611, t.bracketleft = 333, t.backslash = 278, t.bracketright = 333, t.asciicircum = 570, t.underscore = 500, t.quoteleft = 333, t.a = 500, t.b = 500, t.c = 444, t.d = 500, t.e = 444, t.f = 333, t.g = 500, t.h = 556, t.i = 278, t.j = 278, t.k = 500, t.l = 278, t.m = 778, t.n = 556, t.o = 500, t.p = 500, t.q = 500, t.r = 389, t.s = 389, t.t = 278, t.u = 556, t.v = 444, t.w = 667, t.x = 500, t.y = 444, t.z = 389, t.braceleft = 348, t.bar = 220, t.braceright = 348, t.asciitilde = 570, t.exclamdown = 389, t.cent = 500, t.sterling = 500, t.fraction = 167, t.yen = 500, t.florin = 500, t.section = 500, t.currency = 500, t.quotesingle = 278, t.quotedblleft = 500, t.guillemotleft = 500, t.guilsinglleft = 333, t.guilsinglright = 333, t.fi = 556, t.fl = 556, t.endash = 500, t.dagger = 500, t.daggerdbl = 500, t.periodcentered = 250, t.paragraph = 500, t.bullet = 350, t.quotesinglbase = 333, t.quotedblbase = 500, t.quotedblright = 500, t.guillemotright = 500, t.ellipsis = 1e3, t.perthousand = 1e3, t.questiondown = 500, t.grave = 333, t.acute = 333, t.circumflex = 333, t.tilde = 333, t.macron = 333, t.breve = 333, t.dotaccent = 333, t.dieresis = 333, t.ring = 333, t.cedilla = 333, t.hungarumlaut = 333, t.ogonek = 333, t.caron = 333, t.emdash = 1e3, t.AE = 944, t.ordfeminine = 266, t.Lslash = 611, t.Oslash = 722, t.OE = 944, t.ordmasculine = 300, t.ae = 722, t.dotlessi = 278, t.lslash = 278, t.oslash = 500, t.oe = 722, t.germandbls = 500, t.Idieresis = 389, t.eacute = 444, t.abreve = 500, t.uhungarumlaut = 556, t.ecaron = 444, t.Ydieresis = 611, t.divide = 570, t.Yacute = 611, t.Acircumflex = 667, t.aacute = 500, t.Ucircumflex = 722, t.yacute = 444, t.scommaaccent = 389, t.ecircumflex = 444, t.Uring = 722, t.Udieresis = 722, t.aogonek = 500, t.Uacute = 722, t.uogonek = 556, t.Edieresis = 667, t.Dcroat = 722, t.commaaccent = 250, t.copyright = 747, t.Emacron = 667, t.ccaron = 444, t.aring = 500, t.Ncommaaccent = 722, t.lacute = 278, t.agrave = 500, t.Tcommaaccent = 611, t.Cacute = 667, t.atilde = 500, t.Edotaccent = 667, t.scaron = 389, t.scedilla = 389, t.iacute = 278, t.lozenge = 494, t.Rcaron = 667, t.Gcommaaccent = 722, t.ucircumflex = 556, t.acircumflex = 500, t.Amacron = 667, t.rcaron = 389, t.ccedilla = 444, t.Zdotaccent = 611, t.Thorn = 611, t.Omacron = 722, t.Racute = 667, t.Sacute = 556, t.dcaron = 608, t.Umacron = 722, t.uring = 556, t.threesuperior = 300, t.Ograve = 722, t.Agrave = 667, t.Abreve = 667, t.multiply = 570, t.uacute = 556, t.Tcaron = 611, t.partialdiff = 494, t.ydieresis = 444, t.Nacute = 722, t.icircumflex = 278, t.Ecircumflex = 667, t.adieresis = 500, t.edieresis = 444, t.cacute = 444, t.nacute = 556, t.umacron = 556, t.Ncaron = 722, t.Iacute = 389, t.plusminus = 570, t.brokenbar = 220, t.registered = 747, t.Gbreve = 722, t.Idotaccent = 389, t.summation = 600, t.Egrave = 667, t.racute = 389, t.omacron = 500, t.Zacute = 611, t.Zcaron = 611, t.greaterequal = 549, t.Eth = 722, t.Ccedilla = 667, t.lcommaaccent = 278, t.tcaron = 366, t.eogonek = 444, t.Uogonek = 722, t.Aacute = 667, t.Adieresis = 667, t.egrave = 444, t.zacute = 389, t.iogonek = 278, t.Oacute = 722, t.oacute = 500, t.amacron = 500, t.sacute = 389, t.idieresis = 278, t.Ocircumflex = 722, t.Ugrave = 722, t.Delta = 612, t.thorn = 500, t.twosuperior = 300, t.Odieresis = 722, t.mu = 576, t.igrave = 278, t.ohungarumlaut = 500, t.Eogonek = 667, t.dcroat = 500, t.threequarters = 750, t.Scedilla = 556, t.lcaron = 382, t.Kcommaaccent = 667, t.Lacute = 611, t.trademark = 1e3, t.edotaccent = 444, t.Igrave = 389, t.Imacron = 389, t.Lcaron = 611, t.onehalf = 750, t.lessequal = 549, t.ocircumflex = 500, t.ntilde = 556, t.Uhungarumlaut = 722, t.Eacute = 667, t.emacron = 444, t.gbreve = 500, t.onequarter = 750, t.Scaron = 556, t.Scommaaccent = 556, t.Ohungarumlaut = 722, t.degree = 400, t.ograve = 500, t.Ccaron = 667, t.ugrave = 556, t.radical = 549, t.Dcaron = 722, t.rcommaaccent = 389, t.Ntilde = 722, t.otilde = 500, t.Rcommaaccent = 667, t.Lcommaaccent = 611, t.Atilde = 667, t.Aogonek = 667, t.Aring = 667, t.Otilde = 722, t.zdotaccent = 389, t.Ecaron = 667, t.Iogonek = 389, t.kcommaaccent = 500, t.minus = 606, t.Icircumflex = 389, t.ncaron = 556, t.tcommaaccent = 278, t.logicalnot = 606, t.odieresis = 500, t.udieresis = 556, t.notequal = 549, t.gcommaaccent = 500, t.eth = 500, t.zcaron = 389, t.ncommaaccent = 556, t.onesuperior = 300, t.imacron = 278, t.Euro = 500;
          }), e["Times-Italic"] = (0, n.getLookupTableFactory)(function(t) {
            t.space = 250, t.exclam = 333, t.quotedbl = 420, t.numbersign = 500, t.dollar = 500, t.percent = 833, t.ampersand = 778, t.quoteright = 333, t.parenleft = 333, t.parenright = 333, t.asterisk = 500, t.plus = 675, t.comma = 250, t.hyphen = 333, t.period = 250, t.slash = 278, t.zero = 500, t.one = 500, t.two = 500, t.three = 500, t.four = 500, t.five = 500, t.six = 500, t.seven = 500, t.eight = 500, t.nine = 500, t.colon = 333, t.semicolon = 333, t.less = 675, t.equal = 675, t.greater = 675, t.question = 500, t.at = 920, t.A = 611, t.B = 611, t.C = 667, t.D = 722, t.E = 611, t.F = 611, t.G = 722, t.H = 722, t.I = 333, t.J = 444, t.K = 667, t.L = 556, t.M = 833, t.N = 667, t.O = 722, t.P = 611, t.Q = 722, t.R = 611, t.S = 500, t.T = 556, t.U = 722, t.V = 611, t.W = 833, t.X = 611, t.Y = 556, t.Z = 556, t.bracketleft = 389, t.backslash = 278, t.bracketright = 389, t.asciicircum = 422, t.underscore = 500, t.quoteleft = 333, t.a = 500, t.b = 500, t.c = 444, t.d = 500, t.e = 444, t.f = 278, t.g = 500, t.h = 500, t.i = 278, t.j = 278, t.k = 444, t.l = 278, t.m = 722, t.n = 500, t.o = 500, t.p = 500, t.q = 500, t.r = 389, t.s = 389, t.t = 278, t.u = 500, t.v = 444, t.w = 667, t.x = 444, t.y = 444, t.z = 389, t.braceleft = 400, t.bar = 275, t.braceright = 400, t.asciitilde = 541, t.exclamdown = 389, t.cent = 500, t.sterling = 500, t.fraction = 167, t.yen = 500, t.florin = 500, t.section = 500, t.currency = 500, t.quotesingle = 214, t.quotedblleft = 556, t.guillemotleft = 500, t.guilsinglleft = 333, t.guilsinglright = 333, t.fi = 500, t.fl = 500, t.endash = 500, t.dagger = 500, t.daggerdbl = 500, t.periodcentered = 250, t.paragraph = 523, t.bullet = 350, t.quotesinglbase = 333, t.quotedblbase = 556, t.quotedblright = 556, t.guillemotright = 500, t.ellipsis = 889, t.perthousand = 1e3, t.questiondown = 500, t.grave = 333, t.acute = 333, t.circumflex = 333, t.tilde = 333, t.macron = 333, t.breve = 333, t.dotaccent = 333, t.dieresis = 333, t.ring = 333, t.cedilla = 333, t.hungarumlaut = 333, t.ogonek = 333, t.caron = 333, t.emdash = 889, t.AE = 889, t.ordfeminine = 276, t.Lslash = 556, t.Oslash = 722, t.OE = 944, t.ordmasculine = 310, t.ae = 667, t.dotlessi = 278, t.lslash = 278, t.oslash = 500, t.oe = 667, t.germandbls = 500, t.Idieresis = 333, t.eacute = 444, t.abreve = 500, t.uhungarumlaut = 500, t.ecaron = 444, t.Ydieresis = 556, t.divide = 675, t.Yacute = 556, t.Acircumflex = 611, t.aacute = 500, t.Ucircumflex = 722, t.yacute = 444, t.scommaaccent = 389, t.ecircumflex = 444, t.Uring = 722, t.Udieresis = 722, t.aogonek = 500, t.Uacute = 722, t.uogonek = 500, t.Edieresis = 611, t.Dcroat = 722, t.commaaccent = 250, t.copyright = 760, t.Emacron = 611, t.ccaron = 444, t.aring = 500, t.Ncommaaccent = 667, t.lacute = 278, t.agrave = 500, t.Tcommaaccent = 556, t.Cacute = 667, t.atilde = 500, t.Edotaccent = 611, t.scaron = 389, t.scedilla = 389, t.iacute = 278, t.lozenge = 471, t.Rcaron = 611, t.Gcommaaccent = 722, t.ucircumflex = 500, t.acircumflex = 500, t.Amacron = 611, t.rcaron = 389, t.ccedilla = 444, t.Zdotaccent = 556, t.Thorn = 611, t.Omacron = 722, t.Racute = 611, t.Sacute = 500, t.dcaron = 544, t.Umacron = 722, t.uring = 500, t.threesuperior = 300, t.Ograve = 722, t.Agrave = 611, t.Abreve = 611, t.multiply = 675, t.uacute = 500, t.Tcaron = 556, t.partialdiff = 476, t.ydieresis = 444, t.Nacute = 667, t.icircumflex = 278, t.Ecircumflex = 611, t.adieresis = 500, t.edieresis = 444, t.cacute = 444, t.nacute = 500, t.umacron = 500, t.Ncaron = 667, t.Iacute = 333, t.plusminus = 675, t.brokenbar = 275, t.registered = 760, t.Gbreve = 722, t.Idotaccent = 333, t.summation = 600, t.Egrave = 611, t.racute = 389, t.omacron = 500, t.Zacute = 556, t.Zcaron = 556, t.greaterequal = 549, t.Eth = 722, t.Ccedilla = 667, t.lcommaaccent = 278, t.tcaron = 300, t.eogonek = 444, t.Uogonek = 722, t.Aacute = 611, t.Adieresis = 611, t.egrave = 444, t.zacute = 389, t.iogonek = 278, t.Oacute = 722, t.oacute = 500, t.amacron = 500, t.sacute = 389, t.idieresis = 278, t.Ocircumflex = 722, t.Ugrave = 722, t.Delta = 612, t.thorn = 500, t.twosuperior = 300, t.Odieresis = 722, t.mu = 500, t.igrave = 278, t.ohungarumlaut = 500, t.Eogonek = 611, t.dcroat = 500, t.threequarters = 750, t.Scedilla = 500, t.lcaron = 300, t.Kcommaaccent = 667, t.Lacute = 556, t.trademark = 980, t.edotaccent = 444, t.Igrave = 333, t.Imacron = 333, t.Lcaron = 611, t.onehalf = 750, t.lessequal = 549, t.ocircumflex = 500, t.ntilde = 500, t.Uhungarumlaut = 722, t.Eacute = 611, t.emacron = 444, t.gbreve = 500, t.onequarter = 750, t.Scaron = 500, t.Scommaaccent = 500, t.Ohungarumlaut = 722, t.degree = 400, t.ograve = 500, t.Ccaron = 667, t.ugrave = 500, t.radical = 453, t.Dcaron = 722, t.rcommaaccent = 389, t.Ntilde = 667, t.otilde = 500, t.Rcommaaccent = 611, t.Lcommaaccent = 556, t.Atilde = 611, t.Aogonek = 611, t.Aring = 611, t.Otilde = 722, t.zdotaccent = 389, t.Ecaron = 611, t.Iogonek = 333, t.kcommaaccent = 444, t.minus = 675, t.Icircumflex = 333, t.ncaron = 500, t.tcommaaccent = 278, t.logicalnot = 675, t.odieresis = 500, t.udieresis = 500, t.notequal = 549, t.gcommaaccent = 500, t.eth = 500, t.zcaron = 389, t.ncommaaccent = 500, t.onesuperior = 300, t.imacron = 278, t.Euro = 500;
          }), e.ZapfDingbats = (0, n.getLookupTableFactory)(function(t) {
            t.space = 278, t.a1 = 974, t.a2 = 961, t.a202 = 974, t.a3 = 980, t.a4 = 719, t.a5 = 789, t.a119 = 790, t.a118 = 791, t.a117 = 690, t.a11 = 960, t.a12 = 939, t.a13 = 549, t.a14 = 855, t.a15 = 911, t.a16 = 933, t.a105 = 911, t.a17 = 945, t.a18 = 974, t.a19 = 755, t.a20 = 846, t.a21 = 762, t.a22 = 761, t.a23 = 571, t.a24 = 677, t.a25 = 763, t.a26 = 760, t.a27 = 759, t.a28 = 754, t.a6 = 494, t.a7 = 552, t.a8 = 537, t.a9 = 577, t.a10 = 692, t.a29 = 786, t.a30 = 788, t.a31 = 788, t.a32 = 790, t.a33 = 793, t.a34 = 794, t.a35 = 816, t.a36 = 823, t.a37 = 789, t.a38 = 841, t.a39 = 823, t.a40 = 833, t.a41 = 816, t.a42 = 831, t.a43 = 923, t.a44 = 744, t.a45 = 723, t.a46 = 749, t.a47 = 790, t.a48 = 792, t.a49 = 695, t.a50 = 776, t.a51 = 768, t.a52 = 792, t.a53 = 759, t.a54 = 707, t.a55 = 708, t.a56 = 682, t.a57 = 701, t.a58 = 826, t.a59 = 815, t.a60 = 789, t.a61 = 789, t.a62 = 707, t.a63 = 687, t.a64 = 696, t.a65 = 689, t.a66 = 786, t.a67 = 787, t.a68 = 713, t.a69 = 791, t.a70 = 785, t.a71 = 791, t.a72 = 873, t.a73 = 761, t.a74 = 762, t.a203 = 762, t.a75 = 759, t.a204 = 759, t.a76 = 892, t.a77 = 892, t.a78 = 788, t.a79 = 784, t.a81 = 438, t.a82 = 138, t.a83 = 277, t.a84 = 415, t.a97 = 392, t.a98 = 392, t.a99 = 668, t.a100 = 668, t.a89 = 390, t.a90 = 390, t.a93 = 317, t.a94 = 317, t.a91 = 276, t.a92 = 276, t.a205 = 509, t.a85 = 509, t.a206 = 410, t.a86 = 410, t.a87 = 234, t.a88 = 234, t.a95 = 334, t.a96 = 334, t.a101 = 732, t.a102 = 544, t.a103 = 544, t.a104 = 910, t.a106 = 667, t.a107 = 760, t.a108 = 760, t.a112 = 776, t.a111 = 595, t.a110 = 694, t.a109 = 626, t.a120 = 788, t.a121 = 788, t.a122 = 788, t.a123 = 788, t.a124 = 788, t.a125 = 788, t.a126 = 788, t.a127 = 788, t.a128 = 788, t.a129 = 788, t.a130 = 788, t.a131 = 788, t.a132 = 788, t.a133 = 788, t.a134 = 788, t.a135 = 788, t.a136 = 788, t.a137 = 788, t.a138 = 788, t.a139 = 788, t.a140 = 788, t.a141 = 788, t.a142 = 788, t.a143 = 788, t.a144 = 788, t.a145 = 788, t.a146 = 788, t.a147 = 788, t.a148 = 788, t.a149 = 788, t.a150 = 788, t.a151 = 788, t.a152 = 788, t.a153 = 788, t.a154 = 788, t.a155 = 788, t.a156 = 788, t.a157 = 788, t.a158 = 788, t.a159 = 788, t.a160 = 894, t.a161 = 838, t.a163 = 1016, t.a164 = 458, t.a196 = 748, t.a165 = 924, t.a192 = 748, t.a166 = 918, t.a167 = 927, t.a168 = 928, t.a169 = 928, t.a170 = 834, t.a171 = 873, t.a172 = 828, t.a173 = 924, t.a162 = 924, t.a174 = 917, t.a175 = 930, t.a176 = 931, t.a177 = 463, t.a178 = 883, t.a179 = 836, t.a193 = 836, t.a180 = 867, t.a199 = 867, t.a181 = 696, t.a200 = 696, t.a182 = 874, t.a201 = 874, t.a183 = 760, t.a184 = 946, t.a197 = 771, t.a185 = 865, t.a194 = 771, t.a198 = 888, t.a186 = 967, t.a195 = 888, t.a187 = 831, t.a188 = 873, t.a189 = 927, t.a190 = 970, t.a191 = 918;
          });
        });
        w.getMetrics = F;
        const C = (0, n.getLookupTableFactory)(function(e) {
          e.Courier = {
            ascent: 629,
            descent: -157,
            capHeight: 562,
            xHeight: -426
          }, e["Courier-Bold"] = {
            ascent: 629,
            descent: -157,
            capHeight: 562,
            xHeight: 439
          }, e["Courier-Oblique"] = {
            ascent: 629,
            descent: -157,
            capHeight: 562,
            xHeight: 426
          }, e["Courier-BoldOblique"] = {
            ascent: 629,
            descent: -157,
            capHeight: 562,
            xHeight: 426
          }, e.Helvetica = {
            ascent: 718,
            descent: -207,
            capHeight: 718,
            xHeight: 523
          }, e["Helvetica-Bold"] = {
            ascent: 718,
            descent: -207,
            capHeight: 718,
            xHeight: 532
          }, e["Helvetica-Oblique"] = {
            ascent: 718,
            descent: -207,
            capHeight: 718,
            xHeight: 523
          }, e["Helvetica-BoldOblique"] = {
            ascent: 718,
            descent: -207,
            capHeight: 718,
            xHeight: 532
          }, e["Times-Roman"] = {
            ascent: 683,
            descent: -217,
            capHeight: 662,
            xHeight: 450
          }, e["Times-Bold"] = {
            ascent: 683,
            descent: -217,
            capHeight: 676,
            xHeight: 461
          }, e["Times-Italic"] = {
            ascent: 683,
            descent: -217,
            capHeight: 653,
            xHeight: 441
          }, e["Times-BoldItalic"] = {
            ascent: 683,
            descent: -217,
            capHeight: 669,
            xHeight: 462
          }, e.Symbol = {
            ascent: Math.NaN,
            descent: Math.NaN,
            capHeight: Math.NaN,
            xHeight: Math.NaN
          }, e.ZapfDingbats = {
            ascent: Math.NaN,
            descent: Math.NaN,
            capHeight: Math.NaN,
            xHeight: Math.NaN
          };
        });
        w.getFontBasicMetrics = C;
      },
      /* 46 */
      /***/
      (fe, w) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.GlyfTable = void 0;
        const V = 1, n = 2, F = 4, C = 8, e = 16, t = 32, l = 64, j = 1, U = 2, O = 8, v = 32, g = 64, b = 128, i = 256;
        class P {
          constructor({
            glyfTable: x,
            isGlyphLocationsLong: R,
            locaTable: f,
            numGlyphs: c
          }) {
            this.glyphs = [];
            const N = new DataView(f.buffer, f.byteOffset, f.byteLength), u = new DataView(x.buffer, x.byteOffset, x.byteLength), p = R ? 4 : 2;
            let S = R ? N.getUint32(0) : 2 * N.getUint16(0), B = 0;
            for (let T = 0; T < c; T++) {
              B += p;
              const D = R ? N.getUint32(B) : 2 * N.getUint16(B);
              if (D === S) {
                this.glyphs.push(new d({}));
                continue;
              }
              const K = d.parse(S, u);
              this.glyphs.push(K), S = D;
            }
          }
          getSize() {
            return this.glyphs.reduce((x, R) => {
              const f = R.getSize();
              return x + (f + 3 & -4);
            }, 0);
          }
          write() {
            const x = this.getSize(), R = new DataView(new ArrayBuffer(x)), f = x > 131070, c = f ? 4 : 2, N = new DataView(new ArrayBuffer((this.glyphs.length + 1) * c));
            f ? N.setUint32(0, 0) : N.setUint16(0, 0);
            let u = 0, p = 0;
            for (const S of this.glyphs)
              u += S.write(u, R), u = u + 3 & -4, p += c, f ? N.setUint32(p, u) : N.setUint16(p, u >> 1);
            return {
              isLocationLong: f,
              loca: new Uint8Array(N.buffer),
              glyf: new Uint8Array(R.buffer)
            };
          }
          scale(x) {
            for (let R = 0, f = this.glyphs.length; R < f; R++)
              this.glyphs[R].scale(x[R]);
          }
        }
        w.GlyfTable = P;
        class d {
          constructor({
            header: x = null,
            simple: R = null,
            composites: f = null
          }) {
            this.header = x, this.simple = R, this.composites = f;
          }
          static parse(x, R) {
            const [f, c] = A.parse(x, R);
            if (x += f, c.numberOfContours < 0) {
              const u = [];
              for (; ; ) {
                const [p, S] = k.parse(x, R);
                if (x += p, u.push(S), !(S.flags & v))
                  break;
              }
              return new d({
                header: c,
                composites: u
              });
            }
            const N = E.parse(x, R, c.numberOfContours);
            return new d({
              header: c,
              simple: N
            });
          }
          getSize() {
            if (!this.header)
              return 0;
            const x = this.simple ? this.simple.getSize() : this.composites.reduce((R, f) => R + f.getSize(), 0);
            return this.header.getSize() + x;
          }
          write(x, R) {
            if (!this.header)
              return 0;
            const f = x;
            if (x += this.header.write(x, R), this.simple)
              x += this.simple.write(x, R);
            else
              for (const c of this.composites)
                x += c.write(x, R);
            return x - f;
          }
          scale(x) {
            if (!this.header)
              return;
            const R = (this.header.xMin + this.header.xMax) / 2;
            if (this.header.scale(R, x), this.simple)
              this.simple.scale(R, x);
            else
              for (const f of this.composites)
                f.scale(R, x);
          }
        }
        class A {
          constructor({
            numberOfContours: x,
            xMin: R,
            yMin: f,
            xMax: c,
            yMax: N
          }) {
            this.numberOfContours = x, this.xMin = R, this.yMin = f, this.xMax = c, this.yMax = N;
          }
          static parse(x, R) {
            return [10, new A({
              numberOfContours: R.getInt16(x),
              xMin: R.getInt16(x + 2),
              yMin: R.getInt16(x + 4),
              xMax: R.getInt16(x + 6),
              yMax: R.getInt16(x + 8)
            })];
          }
          getSize() {
            return 10;
          }
          write(x, R) {
            return R.setInt16(x, this.numberOfContours), R.setInt16(x + 2, this.xMin), R.setInt16(x + 4, this.yMin), R.setInt16(x + 6, this.xMax), R.setInt16(x + 8, this.yMax), 10;
          }
          scale(x, R) {
            this.xMin = Math.round(x + (this.xMin - x) * R), this.xMax = Math.round(x + (this.xMax - x) * R);
          }
        }
        class I {
          constructor({
            flags: x,
            xCoordinates: R,
            yCoordinates: f
          }) {
            this.xCoordinates = R, this.yCoordinates = f, this.flags = x;
          }
        }
        class E {
          constructor({
            contours: x,
            instructions: R
          }) {
            this.contours = x, this.instructions = R;
          }
          static parse(x, R, f) {
            const c = [];
            for (let s = 0; s < f; s++) {
              const r = R.getUint16(x);
              x += 2, c.push(r);
            }
            const N = c[f - 1] + 1, u = R.getUint16(x);
            x += 2;
            const p = new Uint8Array(R).slice(x, x + u);
            x += u;
            const S = [];
            for (let s = 0; s < N; x++, s++) {
              let r = R.getUint8(x);
              if (S.push(r), r & C) {
                const y = R.getUint8(++x);
                r ^= C;
                for (let M = 0; M < y; M++)
                  S.push(r);
                s += y;
              }
            }
            const B = [];
            let T = [], D = [], K = [];
            const _ = [];
            let o = 0, m = 0;
            for (let s = 0; s < N; s++) {
              const r = S[s];
              if (r & n) {
                const y = R.getUint8(x++);
                m += r & e ? y : -y, T.push(m);
              } else
                r & e || (m += R.getInt16(x), x += 2), T.push(m);
              c[o] === s && (o++, B.push(T), T = []);
            }
            m = 0, o = 0;
            for (let s = 0; s < N; s++) {
              const r = S[s];
              if (r & F) {
                const y = R.getUint8(x++);
                m += r & t ? y : -y, D.push(m);
              } else
                r & t || (m += R.getInt16(x), x += 2), D.push(m);
              K.push(r & V | r & l), c[o] === s && (T = B[o], o++, _.push(new I({
                flags: K,
                xCoordinates: T,
                yCoordinates: D
              })), D = [], K = []);
            }
            return new E({
              contours: _,
              instructions: p
            });
          }
          getSize() {
            let x = this.contours.length * 2 + 2 + this.instructions.length, R = 0, f = 0;
            for (const c of this.contours) {
              x += c.flags.length;
              for (let N = 0, u = c.xCoordinates.length; N < u; N++) {
                const p = c.xCoordinates[N], S = c.yCoordinates[N];
                let B = Math.abs(p - R);
                B > 255 ? x += 2 : B > 0 && (x += 1), R = p, B = Math.abs(S - f), B > 255 ? x += 2 : B > 0 && (x += 1), f = S;
              }
            }
            return x;
          }
          write(x, R) {
            const f = x, c = [], N = [], u = [];
            let p = 0, S = 0;
            for (const B of this.contours) {
              for (let T = 0, D = B.xCoordinates.length; T < D; T++) {
                let K = B.flags[T];
                const _ = B.xCoordinates[T];
                let o = _ - p;
                if (o === 0)
                  K |= e, c.push(0);
                else {
                  const s = Math.abs(o);
                  s <= 255 ? (K |= o >= 0 ? n | e : n, c.push(s)) : c.push(o);
                }
                p = _;
                const m = B.yCoordinates[T];
                if (o = m - S, o === 0)
                  K |= t, N.push(0);
                else {
                  const s = Math.abs(o);
                  s <= 255 ? (K |= o >= 0 ? F | t : F, N.push(s)) : N.push(o);
                }
                S = m, u.push(K);
              }
              R.setUint16(x, c.length - 1), x += 2;
            }
            R.setUint16(x, this.instructions.length), x += 2, this.instructions.length && (new Uint8Array(R.buffer, 0, R.buffer.byteLength).set(this.instructions, x), x += this.instructions.length);
            for (const B of u)
              R.setUint8(x++, B);
            for (let B = 0, T = c.length; B < T; B++) {
              const D = c[B], K = u[B];
              K & n ? R.setUint8(x++, D) : K & e || (R.setInt16(x, D), x += 2);
            }
            for (let B = 0, T = N.length; B < T; B++) {
              const D = N[B], K = u[B];
              K & F ? R.setUint8(x++, D) : K & t || (R.setInt16(x, D), x += 2);
            }
            return x - f;
          }
          scale(x, R) {
            for (const f of this.contours)
              if (f.xCoordinates.length !== 0)
                for (let c = 0, N = f.xCoordinates.length; c < N; c++)
                  f.xCoordinates[c] = Math.round(x + (f.xCoordinates[c] - x) * R);
          }
        }
        class k {
          constructor({
            flags: x,
            glyphIndex: R,
            argument1: f,
            argument2: c,
            transf: N,
            instructions: u
          }) {
            this.flags = x, this.glyphIndex = R, this.argument1 = f, this.argument2 = c, this.transf = N, this.instructions = u;
          }
          static parse(x, R) {
            const f = x, c = [];
            let N = R.getUint16(x);
            const u = R.getUint16(x + 2);
            x += 4;
            let p, S;
            N & j ? (N & U ? (p = R.getInt16(x), S = R.getInt16(x + 2)) : (p = R.getUint16(x), S = R.getUint16(x + 2)), x += 4, N ^= j) : (N & U ? (p = R.getInt8(x), S = R.getInt8(x + 1)) : (p = R.getUint8(x), S = R.getUint8(x + 1)), x += 2), N & O ? (c.push(R.getUint16(x)), x += 2) : N & g ? (c.push(R.getUint16(x), R.getUint16(x + 2)), x += 4) : N & b && (c.push(R.getUint16(x), R.getUint16(x + 2), R.getUint16(x + 4), R.getUint16(x + 6)), x += 8);
            let B = null;
            if (N & i) {
              const T = R.getUint16(x);
              x += 2, B = new Uint8Array(R).slice(x, x + T), x += T;
            }
            return [x - f, new k({
              flags: N,
              glyphIndex: u,
              argument1: p,
              argument2: S,
              transf: c,
              instructions: B
            })];
          }
          getSize() {
            let x = 4 + this.transf.length * 2;
            return this.flags & i && (x += 2 + this.instructions.length), x += 2, this.flags & 2 ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (x += 2) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (x += 2), x;
          }
          write(x, R) {
            const f = x;
            return this.flags & U ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (this.flags |= j) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (this.flags |= j), R.setUint16(x, this.flags), R.setUint16(x + 2, this.glyphIndex), x += 4, this.flags & j ? (this.flags & U ? (R.setInt16(x, this.argument1), R.setInt16(x + 2, this.argument2)) : (R.setUint16(x, this.argument1), R.setUint16(x + 2, this.argument2)), x += 4) : (R.setUint8(x, this.argument1), R.setUint8(x + 1, this.argument2), x += 2), this.flags & i && (R.setUint16(x, this.instructions.length), x += 2, this.instructions.length && (new Uint8Array(R.buffer, 0, R.buffer.byteLength).set(this.instructions, x), x += this.instructions.length)), x - f;
          }
          scale(x, R) {
          }
        }
      },
      /* 47 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.OpenTypeFileBuilder = void 0;
        var n = V(3), F = V(2);
        function C(O, v, g) {
          O[v] = g >> 8 & 255, O[v + 1] = g & 255;
        }
        function e(O, v, g) {
          O[v] = g >> 24 & 255, O[v + 1] = g >> 16 & 255, O[v + 2] = g >> 8 & 255, O[v + 3] = g & 255;
        }
        function t(O, v, g) {
          if (g instanceof Uint8Array)
            O.set(g, v);
          else if (typeof g == "string")
            for (let b = 0, i = g.length; b < i; b++)
              O[v++] = g.charCodeAt(b) & 255;
          else
            for (const b of g)
              O[v++] = b & 255;
        }
        const l = 12, j = 16;
        class U {
          constructor(v) {
            this.sfnt = v, this.tables = /* @__PURE__ */ Object.create(null);
          }
          static getSearchParams(v, g) {
            let b = 1, i = 0;
            for (; (b ^ v) > b; )
              b <<= 1, i++;
            const P = b * g;
            return {
              range: P,
              entry: i,
              rangeShift: g * v - P
            };
          }
          toArray() {
            let v = this.sfnt;
            const g = this.tables, b = Object.keys(g);
            b.sort();
            const i = b.length;
            let P, d, A, I, E, k = l + i * j;
            const H = [k];
            for (P = 0; P < i; P++) {
              I = g[b[P]];
              const f = (I.length + 3 & -4) >>> 0;
              k += f, H.push(k);
            }
            const x = new Uint8Array(k);
            for (P = 0; P < i; P++)
              I = g[b[P]], t(x, H[P], I);
            v === "true" && (v = (0, F.string32)(65536)), x[0] = v.charCodeAt(0) & 255, x[1] = v.charCodeAt(1) & 255, x[2] = v.charCodeAt(2) & 255, x[3] = v.charCodeAt(3) & 255, C(x, 4, i);
            const R = U.getSearchParams(i, 16);
            for (C(x, 6, R.range), C(x, 8, R.entry), C(x, 10, R.rangeShift), k = l, P = 0; P < i; P++) {
              E = b[P], x[k] = E.charCodeAt(0) & 255, x[k + 1] = E.charCodeAt(1) & 255, x[k + 2] = E.charCodeAt(2) & 255, x[k + 3] = E.charCodeAt(3) & 255;
              let f = 0;
              for (d = H[P], A = H[P + 1]; d < A; d += 4) {
                const c = (0, n.readUint32)(x, d);
                f = f + c >>> 0;
              }
              e(x, k + 4, f), e(x, k + 8, H[P]), e(x, k + 12, g[E].length), k += j;
            }
            return x;
          }
          addTable(v, g) {
            if (v in this.tables)
              throw new Error("Table " + v + " already exists");
            this.tables[v] = g;
          }
        }
        w.OpenTypeFileBuilder = U;
      },
      /* 48 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.Type1Font = void 0;
        var n = V(35), F = V(2), C = V(38), e = V(3), t = V(8), l = V(49);
        function j(g, b, i) {
          const P = g.length, d = b.length, A = P - d;
          let I = i, E = !1;
          for (; I < A; ) {
            let k = 0;
            for (; k < d && g[I + k] === b[k]; )
              k++;
            if (k >= d) {
              for (I += k; I < P && (0, e.isWhiteSpace)(g[I]); )
                I++;
              E = !0;
              break;
            }
            I++;
          }
          return {
            found: E,
            length: I
          };
        }
        function U(g, b) {
          const i = [101, 101, 120, 101, 99], P = g.pos;
          let d, A, I;
          try {
            d = g.getBytes(b), A = d.length;
          } catch {
          }
          if (A === b && (I = j(d, i, b - 2 * i.length), I.found && I.length === b))
            return {
              stream: new t.Stream(d),
              length: b
            };
          (0, F.warn)('Invalid "Length1" property in Type1 font -- trying to recover.'), g.pos = P;
          const E = 2048;
          let k;
          for (; ; ) {
            const H = g.peekBytes(E);
            if (I = j(H, i, 0), I.length === 0)
              break;
            if (g.pos += I.length, I.found) {
              k = g.pos - P;
              break;
            }
          }
          return g.pos = P, k ? {
            stream: new t.Stream(g.getBytes(k)),
            length: k
          } : ((0, F.warn)('Unable to recover "Length1" property in Type1 font -- using as is.'), {
            stream: new t.Stream(g.getBytes(b)),
            length: b
          });
        }
        function O(g, b) {
          const i = g.getBytes();
          if (i.length === 0)
            throw new F.FormatError("getEexecBlock - no font program found.");
          return {
            stream: new t.Stream(i),
            length: i.length
          };
        }
        class v {
          constructor(b, i, P) {
            let A = P.length1;
            P.length2;
            let I = i.peekBytes(6);
            const E = I[0] === 128 && I[1] === 1;
            E && (i.skip(6), A = I[5] << 24 | I[4] << 16 | I[3] << 8 | I[2]);
            const k = U(i, A);
            new l.Type1Parser(k.stream, !1, C.SEAC_ANALYSIS_ENABLED).extractFontHeader(P), E && (I = i.getBytes(6), I[5] << 24 | I[4] << 16 | I[3] << 8 | I[2]);
            const x = O(i), f = new l.Type1Parser(x.stream, !0, C.SEAC_ANALYSIS_ENABLED).extractFontProgram(P);
            for (const p in f.properties)
              P[p] = f.properties[p];
            const c = f.charstrings, N = this.getType2Charstrings(c), u = this.getType2Subrs(f.subrs);
            this.charstrings = c, this.data = this.wrap(b, N, this.charstrings, u, P), this.seacs = this.getSeacs(f.charstrings);
          }
          get numGlyphs() {
            return this.charstrings.length + 1;
          }
          getCharset() {
            const b = [".notdef"];
            for (const {
              glyphName: i
            } of this.charstrings)
              b.push(i);
            return b;
          }
          getGlyphMapping(b) {
            const i = this.charstrings;
            if (b.composite) {
              const E = /* @__PURE__ */ Object.create(null);
              for (let k = 0, H = i.length; k < H; k++) {
                const x = b.cMap.charCodeOf(k);
                E[x] = k + 1;
              }
              return E;
            }
            const P = [".notdef"];
            let d, A;
            for (A = 0; A < i.length; A++)
              P.push(i[A].glyphName);
            const I = b.builtInEncoding;
            if (I) {
              d = /* @__PURE__ */ Object.create(null);
              for (const E in I)
                A = P.indexOf(I[E]), A >= 0 && (d[E] = A);
            }
            return (0, C.type1FontGlyphMapping)(b, d, P);
          }
          hasGlyphId(b) {
            return b < 0 || b >= this.numGlyphs ? !1 : b === 0 ? !0 : this.charstrings[b - 1].charstring.length > 0;
          }
          getSeacs(b) {
            const i = [];
            for (let P = 0, d = b.length; P < d; P++) {
              const A = b[P];
              A.seac && (i[P + 1] = A.seac);
            }
            return i;
          }
          getType2Charstrings(b) {
            const i = [];
            for (const P of b)
              i.push(P.charstring);
            return i;
          }
          getType2Subrs(b) {
            let i = 0;
            const P = b.length;
            P < 1133 ? i = 107 : P < 33769 ? i = 1131 : i = 32768;
            const d = [];
            let A;
            for (A = 0; A < i; A++)
              d.push([11]);
            for (A = 0; A < P; A++)
              d.push(b[A]);
            return d;
          }
          wrap(b, i, P, d, A) {
            const I = new n.CFF();
            I.header = new n.CFFHeader(1, 0, 4, 4), I.names = [b];
            const E = new n.CFFTopDict();
            E.setByName("version", 391), E.setByName("Notice", 392), E.setByName("FullName", 393), E.setByName("FamilyName", 394), E.setByName("Weight", 395), E.setByName("Encoding", null), E.setByName("FontMatrix", A.fontMatrix), E.setByName("FontBBox", A.bbox), E.setByName("charset", null), E.setByName("CharStrings", null), E.setByName("Private", null), I.topDict = E;
            const k = new n.CFFStrings();
            k.add("Version 0.11"), k.add("See original notice"), k.add(b), k.add(b), k.add("Medium"), I.strings = k, I.globalSubrIndex = new n.CFFIndex();
            const H = i.length, x = [".notdef"];
            let R, f;
            for (R = 0; R < H; R++) {
              const B = P[R].glyphName;
              n.CFFStandardStrings.indexOf(B) === -1 && k.add(B), x.push(B);
            }
            I.charset = new n.CFFCharset(!1, 0, x);
            const c = new n.CFFIndex();
            for (c.add([139, 14]), R = 0; R < H; R++)
              c.add(i[R]);
            I.charStrings = c;
            const N = new n.CFFPrivateDict();
            N.setByName("Subrs", null);
            const u = ["BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StemSnapH", "StemSnapV", "BlueShift", "BlueFuzz", "BlueScale", "LanguageGroup", "ExpansionFactor", "ForceBold", "StdHW", "StdVW"];
            for (R = 0, f = u.length; R < f; R++) {
              const B = u[R];
              if (!(B in A.privateData))
                continue;
              const T = A.privateData[B];
              if (Array.isArray(T))
                for (let D = T.length - 1; D > 0; D--)
                  T[D] -= T[D - 1];
              N.setByName(B, T);
            }
            I.topDict.privateDict = N;
            const p = new n.CFFIndex();
            for (R = 0, f = d.length; R < f; R++)
              p.add(d[R]);
            return N.subrsIndex = p, new n.CFFCompiler(I).compile();
          }
        }
        w.Type1Font = v;
      },
      /* 49 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.Type1Parser = void 0;
        var n = V(37), F = V(3), C = V(8), e = V(2);
        const t = !1, l = {
          hstem: [1],
          vstem: [3],
          vmoveto: [4],
          rlineto: [5],
          hlineto: [6],
          vlineto: [7],
          rrcurveto: [8],
          callsubr: [10],
          flex: [12, 35],
          drop: [12, 18],
          endchar: [14],
          rmoveto: [21],
          hmoveto: [22],
          vhcurveto: [30],
          hvcurveto: [31]
        };
        class j {
          constructor() {
            this.width = 0, this.lsb = 0, this.flexing = !1, this.output = [], this.stack = [];
          }
          convert(A, I, E) {
            const k = A.length;
            let H = !1, x, R, f;
            for (let c = 0; c < k; c++) {
              let N = A[c];
              if (N < 32) {
                switch (N === 12 && (N = (N << 8) + A[++c]), N) {
                  case 1: {
                    this.stack = [];
                    break;
                  }
                  case 3: {
                    this.stack = [];
                    break;
                  }
                  case 4:
                    if (this.flexing) {
                      if (this.stack.length < 1) {
                        H = !0;
                        break;
                      }
                      const T = this.stack.pop();
                      this.stack.push(0, T);
                      break;
                    }
                    H = this.executeCommand(1, l.vmoveto);
                    break;
                  case 5:
                    H = this.executeCommand(2, l.rlineto);
                    break;
                  case 6:
                    H = this.executeCommand(1, l.hlineto);
                    break;
                  case 7:
                    H = this.executeCommand(1, l.vlineto);
                    break;
                  case 8:
                    H = this.executeCommand(6, l.rrcurveto);
                    break;
                  case 9:
                    this.stack = [];
                    break;
                  case 10:
                    if (this.stack.length < 1) {
                      H = !0;
                      break;
                    }
                    if (f = this.stack.pop(), !I[f]) {
                      H = !0;
                      break;
                    }
                    H = this.convert(I[f], I, E);
                    break;
                  case 11:
                    return H;
                  case 13:
                    if (this.stack.length < 2) {
                      H = !0;
                      break;
                    }
                    x = this.stack.pop(), R = this.stack.pop(), this.lsb = R, this.width = x, this.stack.push(x, R), H = this.executeCommand(2, l.hmoveto);
                    break;
                  case 14:
                    this.output.push(l.endchar[0]);
                    break;
                  case 21:
                    if (this.flexing)
                      break;
                    H = this.executeCommand(2, l.rmoveto);
                    break;
                  case 22:
                    if (this.flexing) {
                      this.stack.push(0);
                      break;
                    }
                    H = this.executeCommand(1, l.hmoveto);
                    break;
                  case 30:
                    H = this.executeCommand(4, l.vhcurveto);
                    break;
                  case 31:
                    H = this.executeCommand(4, l.hvcurveto);
                    break;
                  case 3072:
                    this.stack = [];
                    break;
                  case 3073: {
                    this.stack = [];
                    break;
                  }
                  case 3074: {
                    this.stack = [];
                    break;
                  }
                  case 3078:
                    if (E) {
                      const T = this.stack.at(-5);
                      this.seac = this.stack.splice(-4, 4), this.seac[0] += this.lsb - T, H = this.executeCommand(0, l.endchar);
                    } else
                      H = this.executeCommand(4, l.endchar);
                    break;
                  case 3079:
                    if (this.stack.length < 4) {
                      H = !0;
                      break;
                    }
                    this.stack.pop(), x = this.stack.pop();
                    const u = this.stack.pop();
                    R = this.stack.pop(), this.lsb = R, this.width = x, this.stack.push(x, R, u), H = this.executeCommand(3, l.rmoveto);
                    break;
                  case 3084:
                    if (this.stack.length < 2) {
                      H = !0;
                      break;
                    }
                    const p = this.stack.pop(), S = this.stack.pop();
                    this.stack.push(S / p);
                    break;
                  case 3088:
                    if (this.stack.length < 2) {
                      H = !0;
                      break;
                    }
                    f = this.stack.pop();
                    const B = this.stack.pop();
                    if (f === 0 && B === 3) {
                      const T = this.stack.splice(-17, 17);
                      this.stack.push(T[2] + T[0], T[3] + T[1], T[4], T[5], T[6], T[7], T[8], T[9], T[10], T[11], T[12], T[13], T[14]), H = this.executeCommand(13, l.flex, !0), this.flexing = !1, this.stack.push(T[15], T[16]);
                    } else
                      f === 1 && B === 0 && (this.flexing = !0);
                    break;
                  case 3089:
                    break;
                  case 3105:
                    this.stack = [];
                    break;
                  default:
                    (0, e.warn)('Unknown type 1 charstring command of "' + N + '"');
                    break;
                }
                if (H)
                  break;
                continue;
              } else
                N <= 246 ? N -= 139 : N <= 250 ? N = (N - 247) * 256 + A[++c] + 108 : N <= 254 ? N = -((N - 251) * 256) - A[++c] - 108 : N = (A[++c] & 255) << 24 | (A[++c] & 255) << 16 | (A[++c] & 255) << 8 | (A[++c] & 255) << 0;
              this.stack.push(N);
            }
            return H;
          }
          executeCommand(A, I, E) {
            const k = this.stack.length;
            if (A > k)
              return !0;
            const H = k - A;
            for (let x = H; x < k; x++) {
              let R = this.stack[x];
              Number.isInteger(R) ? this.output.push(28, R >> 8 & 255, R & 255) : (R = 65536 * R | 0, this.output.push(255, R >> 24 & 255, R >> 16 & 255, R >> 8 & 255, R & 255));
            }
            return this.output.push(...I), E ? this.stack.splice(H, A) : this.stack.length = 0, !1;
          }
        }
        const U = 55665, O = 4330;
        function v(d) {
          return d >= 48 && d <= 57 || d >= 65 && d <= 70 || d >= 97 && d <= 102;
        }
        function g(d, A, I) {
          if (I >= d.length)
            return new Uint8Array(0);
          const E = 52845, k = 22719;
          let H = A | 0, x, R;
          for (x = 0; x < I; x++)
            H = (d[x] + H) * E + k & 65535;
          const f = d.length - I, c = new Uint8Array(f);
          for (x = I, R = 0; R < f; x++, R++) {
            const N = d[x];
            c[R] = N ^ H >> 8, H = (N + H) * E + k & 65535;
          }
          return c;
        }
        function b(d, A, I) {
          let H = A | 0;
          const x = d.length, R = x >>> 1, f = new Uint8Array(R);
          let c, N;
          for (c = 0, N = 0; c < x; c++) {
            const u = d[c];
            if (!v(u))
              continue;
            c++;
            let p;
            for (; c < x && !v(p = d[c]); )
              c++;
            if (c < x) {
              const S = parseInt(String.fromCharCode(u, p), 16);
              f[N++] = S ^ H >> 8, H = (S + H) * 52845 + 22719 & 65535;
            }
          }
          return f.slice(I, N);
        }
        function i(d) {
          return d === 47 || d === 91 || d === 93 || d === 123 || d === 125 || d === 40 || d === 41;
        }
        class P {
          constructor(A, I, E) {
            if (I) {
              const k = A.getBytes(), H = !((v(k[0]) || (0, F.isWhiteSpace)(k[0])) && v(k[1]) && v(k[2]) && v(k[3]) && v(k[4]) && v(k[5]) && v(k[6]) && v(k[7]));
              A = new C.Stream(H ? g(k, U, 4) : b(k, U, 4));
            }
            this.seacAnalysisEnabled = !!E, this.stream = A, this.nextChar();
          }
          readNumberArray() {
            this.getToken();
            const A = [];
            for (; ; ) {
              const I = this.getToken();
              if (I === null || I === "]" || I === "}")
                break;
              A.push(parseFloat(I || 0));
            }
            return A;
          }
          readNumber() {
            const A = this.getToken();
            return parseFloat(A || 0);
          }
          readInt() {
            const A = this.getToken();
            return parseInt(A || 0, 10) | 0;
          }
          readBoolean() {
            return this.getToken() === "true" ? 1 : 0;
          }
          nextChar() {
            return this.currentChar = this.stream.getByte();
          }
          prevChar() {
            return this.stream.skip(-2), this.currentChar = this.stream.getByte();
          }
          getToken() {
            let A = !1, I = this.currentChar;
            for (; ; ) {
              if (I === -1)
                return null;
              if (A)
                (I === 10 || I === 13) && (A = !1);
              else if (I === 37)
                A = !0;
              else if (!(0, F.isWhiteSpace)(I))
                break;
              I = this.nextChar();
            }
            if (i(I))
              return this.nextChar(), String.fromCharCode(I);
            let E = "";
            do
              E += String.fromCharCode(I), I = this.nextChar();
            while (I >= 0 && !(0, F.isWhiteSpace)(I) && !i(I));
            return E;
          }
          readCharStrings(A, I) {
            return I === -1 ? A : g(A, O, I);
          }
          extractFontProgram(A) {
            const I = this.stream, E = [], k = [], H = /* @__PURE__ */ Object.create(null);
            H.lenIV = 4;
            const x = {
              subrs: [],
              charstrings: [],
              properties: {
                privateData: H
              }
            };
            let R, f, c, N;
            for (; (R = this.getToken()) !== null; )
              if (R === "/")
                switch (R = this.getToken(), R) {
                  case "CharStrings":
                    for (this.getToken(), this.getToken(), this.getToken(), this.getToken(); R = this.getToken(), !(R === null || R === "end"); ) {
                      if (R !== "/")
                        continue;
                      const p = this.getToken();
                      f = this.readInt(), this.getToken(), c = f > 0 ? I.getBytes(f) : new Uint8Array(0), N = x.properties.privateData.lenIV;
                      const S = this.readCharStrings(c, N);
                      this.nextChar(), R = this.getToken(), R === "noaccess" ? this.getToken() : R === "/" && this.prevChar(), k.push({
                        glyph: p,
                        encoded: S
                      });
                    }
                    break;
                  case "Subrs":
                    for (this.readInt(), this.getToken(); this.getToken() === "dup"; ) {
                      const p = this.readInt();
                      f = this.readInt(), this.getToken(), c = f > 0 ? I.getBytes(f) : new Uint8Array(0), N = x.properties.privateData.lenIV;
                      const S = this.readCharStrings(c, N);
                      this.nextChar(), R = this.getToken(), R === "noaccess" && this.getToken(), E[p] = S;
                    }
                    break;
                  case "BlueValues":
                  case "OtherBlues":
                  case "FamilyBlues":
                  case "FamilyOtherBlues":
                    const u = this.readNumberArray();
                    u.length > 0 && u.length % 2 === 0 && t && (x.properties.privateData[R] = u);
                    break;
                  case "StemSnapH":
                  case "StemSnapV":
                    x.properties.privateData[R] = this.readNumberArray();
                    break;
                  case "StdHW":
                  case "StdVW":
                    x.properties.privateData[R] = this.readNumberArray()[0];
                    break;
                  case "BlueShift":
                  case "lenIV":
                  case "BlueFuzz":
                  case "BlueScale":
                  case "LanguageGroup":
                    x.properties.privateData[R] = this.readNumber();
                    break;
                  case "ExpansionFactor":
                    x.properties.privateData[R] = this.readNumber() || 0.06;
                    break;
                  case "ForceBold":
                    x.properties.privateData[R] = this.readBoolean();
                    break;
                }
            for (const {
              encoded: u,
              glyph: p
            } of k) {
              const S = new j(), B = S.convert(u, E, this.seacAnalysisEnabled);
              let T = S.output;
              B && (T = [14]);
              const D = {
                glyphName: p,
                charstring: T,
                width: S.width,
                lsb: S.lsb,
                seac: S.seac
              };
              if (p === ".notdef" ? x.charstrings.unshift(D) : x.charstrings.push(D), A.builtInEncoding) {
                const K = A.builtInEncoding.indexOf(p);
                K > -1 && A.widths[K] === void 0 && K >= A.firstChar && K <= A.lastChar && (A.widths[K] = S.width);
              }
            }
            return x;
          }
          extractFontHeader(A) {
            let I;
            for (; (I = this.getToken()) !== null; )
              if (I === "/")
                switch (I = this.getToken(), I) {
                  case "FontMatrix":
                    const E = this.readNumberArray();
                    A.fontMatrix = E;
                    break;
                  case "Encoding":
                    const k = this.getToken();
                    let H;
                    if (!/^\d+$/.test(k))
                      H = (0, n.getEncoding)(k);
                    else {
                      H = [];
                      const R = parseInt(k, 10) | 0;
                      this.getToken();
                      for (let f = 0; f < R; f++) {
                        for (I = this.getToken(); I !== "dup" && I !== "def"; )
                          if (I = this.getToken(), I === null)
                            return;
                        if (I === "def")
                          break;
                        const c = this.readInt();
                        this.getToken();
                        const N = this.getToken();
                        H[c] = N, this.getToken();
                      }
                    }
                    A.builtInEncoding = H;
                    break;
                  case "FontBBox":
                    const x = this.readNumberArray();
                    A.ascent = Math.max(x[3], x[1]), A.descent = Math.min(x[1], x[3]), A.ascentScaled = !0;
                    break;
                }
          }
        }
        w.Type1Parser = P;
      },
      /* 50 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.Pattern = void 0, w.clearPatternCaches = i, w.getTilingPatternIR = A;
        var n = V(2), F = V(5), C = V(12), e = V(3);
        const t = {
          FUNCTION_BASED: 1,
          AXIAL: 2,
          RADIAL: 3,
          FREE_FORM_MESH: 4,
          LATTICE_FORM_MESH: 5,
          COONS_PATCH_MESH: 6,
          TENSOR_PATCH_MESH: 7
        };
        class l {
          constructor() {
            (0, n.unreachable)("Cannot initialize Pattern.");
          }
          static parseShading(H, x, R, f, c) {
            const N = H instanceof F.BaseStream ? H.dict : H, u = N.get("ShadingType");
            try {
              switch (u) {
                case t.AXIAL:
                case t.RADIAL:
                  return new U(N, x, R, f, c);
                case t.FREE_FORM_MESH:
                case t.LATTICE_FORM_MESH:
                case t.COONS_PATCH_MESH:
                case t.TENSOR_PATCH_MESH:
                  return new P(H, x, R, f, c);
                default:
                  throw new n.FormatError("Unsupported ShadingType: " + u);
              }
            } catch (p) {
              if (p instanceof e.MissingDataException)
                throw p;
              return (0, n.warn)(p), new d();
            }
          }
        }
        w.Pattern = l;
        const I = class I {
          constructor() {
            this.constructor === I && (0, n.unreachable)("Cannot initialize BaseShading.");
          }
          getIR() {
            (0, n.unreachable)("Abstract method `getIR` called.");
          }
        };
        Ot(I, "SMALL_NUMBER", 1e-6);
        let j = I;
        class U extends j {
          constructor(H, x, R, f, c) {
            super(), this.coordsArr = H.getArray("Coords"), this.shadingType = H.get("ShadingType");
            const N = C.ColorSpace.parse({
              cs: H.getRaw("CS") || H.getRaw("ColorSpace"),
              xref: x,
              resources: R,
              pdfFunctionFactory: f,
              localColorSpaceCache: c
            }), u = H.getArray("BBox");
            this.bbox = Array.isArray(u) && u.length === 4 ? n.Util.normalizeRect(u) : null;
            let p = 0, S = 1;
            if (H.has("Domain")) {
              const se = H.getArray("Domain");
              p = se[0], S = se[1];
            }
            let B = !1, T = !1;
            if (H.has("Extend")) {
              const se = H.getArray("Extend");
              B = se[0], T = se[1];
            }
            if (this.shadingType === t.RADIAL && (!B || !T)) {
              const [se, Q, z, ie, ne, W] = this.coordsArr, oe = Math.hypot(se - ie, Q - ne);
              z <= W + oe && W <= z + oe && (0, n.warn)("Unsupported radial gradient.");
            }
            this.extendStart = B, this.extendEnd = T;
            const D = H.getRaw("Function"), K = f.createFromArray(D), _ = 840, o = (S - p) / _, m = this.colorStops = [];
            if (p >= S || o <= 0) {
              (0, n.info)("Bad shading domain.");
              return;
            }
            const s = new Float32Array(N.numComps), r = new Float32Array(1);
            let y, M = 0;
            r[0] = p, K(r, 0, s, 0);
            let $ = N.getRgb(s, 0);
            const G = n.Util.makeHexColor($[0], $[1], $[2]);
            m.push([0, G]);
            let ce = 1;
            r[0] = p + o, K(r, 0, s, 0);
            let q = N.getRgb(s, 0), re = q[0] - $[0] + 1, Z = q[1] - $[1] + 1, te = q[2] - $[2] + 1, L = q[0] - $[0] - 1, X = q[1] - $[1] - 1, J = q[2] - $[2] - 1;
            for (let se = 2; se < _; se++) {
              r[0] = p + se * o, K(r, 0, s, 0), y = N.getRgb(s, 0);
              const Q = se - M;
              if (re = Math.min(re, (y[0] - $[0] + 1) / Q), Z = Math.min(Z, (y[1] - $[1] + 1) / Q), te = Math.min(te, (y[2] - $[2] + 1) / Q), L = Math.max(L, (y[0] - $[0] - 1) / Q), X = Math.max(X, (y[1] - $[1] - 1) / Q), J = Math.max(J, (y[2] - $[2] - 1) / Q), !(L <= re && X <= Z && J <= te)) {
                const ie = n.Util.makeHexColor(q[0], q[1], q[2]);
                m.push([ce / _, ie]), re = y[0] - q[0] + 1, Z = y[1] - q[1] + 1, te = y[2] - q[2] + 1, L = y[0] - q[0] - 1, X = y[1] - q[1] - 1, J = y[2] - q[2] - 1, M = ce, $ = q;
              }
              ce = se, q = y;
            }
            const Y = n.Util.makeHexColor(q[0], q[1], q[2]);
            m.push([1, Y]);
            let ae = "transparent";
            H.has("Background") && (y = N.getRgb(H.get("Background"), 0), ae = n.Util.makeHexColor(y[0], y[1], y[2])), B || (m.unshift([0, ae]), m[1][0] += j.SMALL_NUMBER), T || (m.at(-1)[0] -= j.SMALL_NUMBER, m.push([1, ae])), this.colorStops = m;
          }
          getIR() {
            const H = this.coordsArr, x = this.shadingType;
            let R, f, c, N, u;
            return x === t.AXIAL ? (f = [H[0], H[1]], c = [H[2], H[3]], N = null, u = null, R = "axial") : x === t.RADIAL ? (f = [H[0], H[1]], c = [H[3], H[4]], N = H[2], u = H[5], R = "radial") : (0, n.unreachable)(`getPattern type unknown: ${x}`), ["RadialAxial", R, this.bbox, this.colorStops, f, c, N, u];
          }
        }
        class O {
          constructor(H, x) {
            this.stream = H, this.context = x, this.buffer = 0, this.bufferLength = 0;
            const R = x.numComps;
            this.tmpCompsBuf = new Float32Array(R);
            const f = x.colorSpace.numComps;
            this.tmpCsCompsBuf = x.colorFn ? new Float32Array(f) : this.tmpCompsBuf;
          }
          get hasData() {
            if (this.stream.end)
              return this.stream.pos < this.stream.end;
            if (this.bufferLength > 0)
              return !0;
            const H = this.stream.getByte();
            return H < 0 ? !1 : (this.buffer = H, this.bufferLength = 8, !0);
          }
          readBits(H) {
            let x = this.buffer, R = this.bufferLength;
            if (H === 32) {
              if (R === 0)
                return (this.stream.getByte() << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte()) >>> 0;
              x = x << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte();
              const f = this.stream.getByte();
              return this.buffer = f & (1 << R) - 1, (x << 8 - R | (f & 255) >> R) >>> 0;
            }
            if (H === 8 && R === 0)
              return this.stream.getByte();
            for (; R < H; )
              x = x << 8 | this.stream.getByte(), R += 8;
            return R -= H, this.bufferLength = R, this.buffer = x & (1 << R) - 1, x >> R;
          }
          align() {
            this.buffer = 0, this.bufferLength = 0;
          }
          readFlag() {
            return this.readBits(this.context.bitsPerFlag);
          }
          readCoordinate() {
            const H = this.context.bitsPerCoordinate, x = this.readBits(H), R = this.readBits(H), f = this.context.decode, c = H < 32 ? 1 / ((1 << H) - 1) : 23283064365386963e-26;
            return [x * c * (f[1] - f[0]) + f[0], R * c * (f[3] - f[2]) + f[2]];
          }
          readComponents() {
            const H = this.context.numComps, x = this.context.bitsPerComponent, R = x < 32 ? 1 / ((1 << x) - 1) : 23283064365386963e-26, f = this.context.decode, c = this.tmpCompsBuf;
            for (let u = 0, p = 4; u < H; u++, p += 2) {
              const S = this.readBits(x);
              c[u] = S * R * (f[p + 1] - f[p]) + f[p];
            }
            const N = this.tmpCsCompsBuf;
            return this.context.colorFn && this.context.colorFn(c, 0, N, 0), this.context.colorSpace.getRgb(N, 0);
          }
        }
        let v = /* @__PURE__ */ Object.create(null);
        function g(k) {
          const H = [];
          for (let x = 0; x <= k; x++) {
            const R = x / k, f = 1 - R;
            H.push(new Float32Array([f ** 3, 3 * R * f ** 2, 3 * R ** 2 * f, R ** 3]));
          }
          return H;
        }
        function b(k) {
          return v[k] || (v[k] = g(k));
        }
        function i() {
          v = /* @__PURE__ */ Object.create(null);
        }
        const E = class E extends j {
          constructor(H, x, R, f, c) {
            if (super(), !(H instanceof F.BaseStream))
              throw new n.FormatError("Mesh data is not a stream");
            const N = H.dict;
            this.shadingType = N.get("ShadingType");
            const u = N.getArray("BBox");
            this.bbox = Array.isArray(u) && u.length === 4 ? n.Util.normalizeRect(u) : null;
            const p = C.ColorSpace.parse({
              cs: N.getRaw("CS") || N.getRaw("ColorSpace"),
              xref: x,
              resources: R,
              pdfFunctionFactory: f,
              localColorSpaceCache: c
            });
            this.background = N.has("Background") ? p.getRgb(N.get("Background"), 0) : null;
            const S = N.getRaw("Function"), B = S ? f.createFromArray(S) : null;
            this.coords = [], this.colors = [], this.figures = [];
            const T = {
              bitsPerCoordinate: N.get("BitsPerCoordinate"),
              bitsPerComponent: N.get("BitsPerComponent"),
              bitsPerFlag: N.get("BitsPerFlag"),
              decode: N.getArray("Decode"),
              colorFn: B,
              colorSpace: p,
              numComps: B ? 1 : p.numComps
            }, D = new O(H, T);
            let K = !1;
            switch (this.shadingType) {
              case t.FREE_FORM_MESH:
                this._decodeType4Shading(D);
                break;
              case t.LATTICE_FORM_MESH:
                const _ = N.get("VerticesPerRow") | 0;
                if (_ < 2)
                  throw new n.FormatError("Invalid VerticesPerRow");
                this._decodeType5Shading(D, _);
                break;
              case t.COONS_PATCH_MESH:
                this._decodeType6Shading(D), K = !0;
                break;
              case t.TENSOR_PATCH_MESH:
                this._decodeType7Shading(D), K = !0;
                break;
              default:
                (0, n.unreachable)("Unsupported mesh type.");
                break;
            }
            if (K) {
              this._updateBounds();
              for (let _ = 0, o = this.figures.length; _ < o; _++)
                this._buildFigureFromPatch(_);
            }
            this._updateBounds(), this._packData();
          }
          _decodeType4Shading(H) {
            const x = this.coords, R = this.colors, f = [];
            let c = 0;
            for (; H.hasData; ) {
              const N = H.readFlag(), u = H.readCoordinate(), p = H.readComponents();
              if (c === 0) {
                if (!(0 <= N && N <= 2))
                  throw new n.FormatError("Unknown type4 flag");
                switch (N) {
                  case 0:
                    c = 3;
                    break;
                  case 1:
                    f.push(f.at(-2), f.at(-1)), c = 1;
                    break;
                  case 2:
                    f.push(f.at(-3), f.at(-1)), c = 1;
                    break;
                }
              }
              f.push(x.length), x.push(u), R.push(p), c--, H.align();
            }
            this.figures.push({
              type: "triangles",
              coords: new Int32Array(f),
              colors: new Int32Array(f)
            });
          }
          _decodeType5Shading(H, x) {
            const R = this.coords, f = this.colors, c = [];
            for (; H.hasData; ) {
              const N = H.readCoordinate(), u = H.readComponents();
              c.push(R.length), R.push(N), f.push(u);
            }
            this.figures.push({
              type: "lattice",
              coords: new Int32Array(c),
              colors: new Int32Array(c),
              verticesPerRow: x
            });
          }
          _decodeType6Shading(H) {
            const x = this.coords, R = this.colors, f = new Int32Array(16), c = new Int32Array(4);
            for (; H.hasData; ) {
              const N = H.readFlag();
              if (!(0 <= N && N <= 3))
                throw new n.FormatError("Unknown type6 flag");
              const u = x.length;
              for (let K = 0, _ = N !== 0 ? 8 : 12; K < _; K++)
                x.push(H.readCoordinate());
              const p = R.length;
              for (let K = 0, _ = N !== 0 ? 2 : 4; K < _; K++)
                R.push(H.readComponents());
              let S, B, T, D;
              switch (N) {
                case 0:
                  f[12] = u + 3, f[13] = u + 4, f[14] = u + 5, f[15] = u + 6, f[8] = u + 2, f[11] = u + 7, f[4] = u + 1, f[7] = u + 8, f[0] = u, f[1] = u + 11, f[2] = u + 10, f[3] = u + 9, c[2] = p + 1, c[3] = p + 2, c[0] = p, c[1] = p + 3;
                  break;
                case 1:
                  S = f[12], B = f[13], T = f[14], D = f[15], f[12] = D, f[13] = u + 0, f[14] = u + 1, f[15] = u + 2, f[8] = T, f[11] = u + 3, f[4] = B, f[7] = u + 4, f[0] = S, f[1] = u + 7, f[2] = u + 6, f[3] = u + 5, S = c[2], B = c[3], c[2] = B, c[3] = p, c[0] = S, c[1] = p + 1;
                  break;
                case 2:
                  S = f[15], B = f[11], f[12] = f[3], f[13] = u + 0, f[14] = u + 1, f[15] = u + 2, f[8] = f[7], f[11] = u + 3, f[4] = B, f[7] = u + 4, f[0] = S, f[1] = u + 7, f[2] = u + 6, f[3] = u + 5, S = c[3], c[2] = c[1], c[3] = p, c[0] = S, c[1] = p + 1;
                  break;
                case 3:
                  f[12] = f[0], f[13] = u + 0, f[14] = u + 1, f[15] = u + 2, f[8] = f[1], f[11] = u + 3, f[4] = f[2], f[7] = u + 4, f[0] = f[3], f[1] = u + 7, f[2] = u + 6, f[3] = u + 5, c[2] = c[0], c[3] = p, c[0] = c[1], c[1] = p + 1;
                  break;
              }
              f[5] = x.length, x.push([(-4 * x[f[0]][0] - x[f[15]][0] + 6 * (x[f[4]][0] + x[f[1]][0]) - 2 * (x[f[12]][0] + x[f[3]][0]) + 3 * (x[f[13]][0] + x[f[7]][0])) / 9, (-4 * x[f[0]][1] - x[f[15]][1] + 6 * (x[f[4]][1] + x[f[1]][1]) - 2 * (x[f[12]][1] + x[f[3]][1]) + 3 * (x[f[13]][1] + x[f[7]][1])) / 9]), f[6] = x.length, x.push([(-4 * x[f[3]][0] - x[f[12]][0] + 6 * (x[f[2]][0] + x[f[7]][0]) - 2 * (x[f[0]][0] + x[f[15]][0]) + 3 * (x[f[4]][0] + x[f[14]][0])) / 9, (-4 * x[f[3]][1] - x[f[12]][1] + 6 * (x[f[2]][1] + x[f[7]][1]) - 2 * (x[f[0]][1] + x[f[15]][1]) + 3 * (x[f[4]][1] + x[f[14]][1])) / 9]), f[9] = x.length, x.push([(-4 * x[f[12]][0] - x[f[3]][0] + 6 * (x[f[8]][0] + x[f[13]][0]) - 2 * (x[f[0]][0] + x[f[15]][0]) + 3 * (x[f[11]][0] + x[f[1]][0])) / 9, (-4 * x[f[12]][1] - x[f[3]][1] + 6 * (x[f[8]][1] + x[f[13]][1]) - 2 * (x[f[0]][1] + x[f[15]][1]) + 3 * (x[f[11]][1] + x[f[1]][1])) / 9]), f[10] = x.length, x.push([(-4 * x[f[15]][0] - x[f[0]][0] + 6 * (x[f[11]][0] + x[f[14]][0]) - 2 * (x[f[12]][0] + x[f[3]][0]) + 3 * (x[f[2]][0] + x[f[8]][0])) / 9, (-4 * x[f[15]][1] - x[f[0]][1] + 6 * (x[f[11]][1] + x[f[14]][1]) - 2 * (x[f[12]][1] + x[f[3]][1]) + 3 * (x[f[2]][1] + x[f[8]][1])) / 9]), this.figures.push({
                type: "patch",
                coords: new Int32Array(f),
                colors: new Int32Array(c)
              });
            }
          }
          _decodeType7Shading(H) {
            const x = this.coords, R = this.colors, f = new Int32Array(16), c = new Int32Array(4);
            for (; H.hasData; ) {
              const N = H.readFlag();
              if (!(0 <= N && N <= 3))
                throw new n.FormatError("Unknown type7 flag");
              const u = x.length;
              for (let K = 0, _ = N !== 0 ? 12 : 16; K < _; K++)
                x.push(H.readCoordinate());
              const p = R.length;
              for (let K = 0, _ = N !== 0 ? 2 : 4; K < _; K++)
                R.push(H.readComponents());
              let S, B, T, D;
              switch (N) {
                case 0:
                  f[12] = u + 3, f[13] = u + 4, f[14] = u + 5, f[15] = u + 6, f[8] = u + 2, f[9] = u + 13, f[10] = u + 14, f[11] = u + 7, f[4] = u + 1, f[5] = u + 12, f[6] = u + 15, f[7] = u + 8, f[0] = u, f[1] = u + 11, f[2] = u + 10, f[3] = u + 9, c[2] = p + 1, c[3] = p + 2, c[0] = p, c[1] = p + 3;
                  break;
                case 1:
                  S = f[12], B = f[13], T = f[14], D = f[15], f[12] = D, f[13] = u + 0, f[14] = u + 1, f[15] = u + 2, f[8] = T, f[9] = u + 9, f[10] = u + 10, f[11] = u + 3, f[4] = B, f[5] = u + 8, f[6] = u + 11, f[7] = u + 4, f[0] = S, f[1] = u + 7, f[2] = u + 6, f[3] = u + 5, S = c[2], B = c[3], c[2] = B, c[3] = p, c[0] = S, c[1] = p + 1;
                  break;
                case 2:
                  S = f[15], B = f[11], f[12] = f[3], f[13] = u + 0, f[14] = u + 1, f[15] = u + 2, f[8] = f[7], f[9] = u + 9, f[10] = u + 10, f[11] = u + 3, f[4] = B, f[5] = u + 8, f[6] = u + 11, f[7] = u + 4, f[0] = S, f[1] = u + 7, f[2] = u + 6, f[3] = u + 5, S = c[3], c[2] = c[1], c[3] = p, c[0] = S, c[1] = p + 1;
                  break;
                case 3:
                  f[12] = f[0], f[13] = u + 0, f[14] = u + 1, f[15] = u + 2, f[8] = f[1], f[9] = u + 9, f[10] = u + 10, f[11] = u + 3, f[4] = f[2], f[5] = u + 8, f[6] = u + 11, f[7] = u + 4, f[0] = f[3], f[1] = u + 7, f[2] = u + 6, f[3] = u + 5, c[2] = c[0], c[3] = p, c[0] = c[1], c[1] = p + 1;
                  break;
              }
              this.figures.push({
                type: "patch",
                coords: new Int32Array(f),
                colors: new Int32Array(c)
              });
            }
          }
          _buildFigureFromPatch(H) {
            const x = this.figures[H];
            (0, n.assert)(x.type === "patch", "Unexpected patch mesh figure");
            const R = this.coords, f = this.colors, c = x.coords, N = x.colors, u = Math.min(R[c[0]][0], R[c[3]][0], R[c[12]][0], R[c[15]][0]), p = Math.min(R[c[0]][1], R[c[3]][1], R[c[12]][1], R[c[15]][1]), S = Math.max(R[c[0]][0], R[c[3]][0], R[c[12]][0], R[c[15]][0]), B = Math.max(R[c[0]][1], R[c[3]][1], R[c[12]][1], R[c[15]][1]);
            let T = Math.ceil((S - u) * E.TRIANGLE_DENSITY / (this.bounds[2] - this.bounds[0]));
            T = Math.max(E.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(E.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, T));
            let D = Math.ceil((B - p) * E.TRIANGLE_DENSITY / (this.bounds[3] - this.bounds[1]));
            D = Math.max(E.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(E.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, D));
            const K = T + 1, _ = new Int32Array((D + 1) * K), o = new Int32Array((D + 1) * K);
            let m = 0;
            const s = new Uint8Array(3), r = new Uint8Array(3), y = f[N[0]], M = f[N[1]], $ = f[N[2]], G = f[N[3]], ce = b(D), q = b(T);
            for (let re = 0; re <= D; re++) {
              s[0] = (y[0] * (D - re) + $[0] * re) / D | 0, s[1] = (y[1] * (D - re) + $[1] * re) / D | 0, s[2] = (y[2] * (D - re) + $[2] * re) / D | 0, r[0] = (M[0] * (D - re) + G[0] * re) / D | 0, r[1] = (M[1] * (D - re) + G[1] * re) / D | 0, r[2] = (M[2] * (D - re) + G[2] * re) / D | 0;
              for (let Z = 0; Z <= T; Z++, m++) {
                if ((re === 0 || re === D) && (Z === 0 || Z === T))
                  continue;
                let te = 0, L = 0, X = 0;
                for (let Y = 0; Y <= 3; Y++)
                  for (let ae = 0; ae <= 3; ae++, X++) {
                    const se = ce[re][Y] * q[Z][ae];
                    te += R[c[X]][0] * se, L += R[c[X]][1] * se;
                  }
                _[m] = R.length, R.push([te, L]), o[m] = f.length;
                const J = new Uint8Array(3);
                J[0] = (s[0] * (T - Z) + r[0] * Z) / T | 0, J[1] = (s[1] * (T - Z) + r[1] * Z) / T | 0, J[2] = (s[2] * (T - Z) + r[2] * Z) / T | 0, f.push(J);
              }
            }
            _[0] = c[0], o[0] = N[0], _[T] = c[3], o[T] = N[1], _[K * D] = c[12], o[K * D] = N[2], _[K * D + T] = c[15], o[K * D + T] = N[3], this.figures[H] = {
              type: "lattice",
              coords: _,
              colors: o,
              verticesPerRow: K
            };
          }
          _updateBounds() {
            let H = this.coords[0][0], x = this.coords[0][1], R = H, f = x;
            for (let c = 1, N = this.coords.length; c < N; c++) {
              const u = this.coords[c][0], p = this.coords[c][1];
              H = H > u ? u : H, x = x > p ? p : x, R = R < u ? u : R, f = f < p ? p : f;
            }
            this.bounds = [H, x, R, f];
          }
          _packData() {
            let H, x, R, f;
            const c = this.coords, N = new Float32Array(c.length * 2);
            for (H = 0, R = 0, x = c.length; H < x; H++) {
              const B = c[H];
              N[R++] = B[0], N[R++] = B[1];
            }
            this.coords = N;
            const u = this.colors, p = new Uint8Array(u.length * 3);
            for (H = 0, R = 0, x = u.length; H < x; H++) {
              const B = u[H];
              p[R++] = B[0], p[R++] = B[1], p[R++] = B[2];
            }
            this.colors = p;
            const S = this.figures;
            for (H = 0, x = S.length; H < x; H++) {
              const B = S[H], T = B.coords, D = B.colors;
              for (R = 0, f = T.length; R < f; R++)
                T[R] *= 2, D[R] *= 3;
            }
          }
          getIR() {
            return ["Mesh", this.shadingType, this.coords, this.colors, this.figures, this.bounds, this.bbox, this.background];
          }
        };
        Ot(E, "MIN_SPLIT_PATCH_CHUNKS_AMOUNT", 3), Ot(E, "MAX_SPLIT_PATCH_CHUNKS_AMOUNT", 20), Ot(E, "TRIANGLE_DENSITY", 20);
        let P = E;
        class d extends j {
          getIR() {
            return ["Dummy"];
          }
        }
        function A(k, H, x) {
          const R = H.getArray("Matrix"), f = n.Util.normalizeRect(H.getArray("BBox")), c = H.get("XStep"), N = H.get("YStep"), u = H.get("PaintType"), p = H.get("TilingType");
          if (f[2] - f[0] === 0 || f[3] - f[1] === 0)
            throw new n.FormatError(`Invalid getTilingPatternIR /BBox array: [${f}].`);
          return ["TilingPattern", x, k, R, f, c, N, u, p];
        }
      },
      /* 51 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.getXfaFontDict = b, w.getXfaFontName = v;
        var n = V(52), F = V(4), C = V(53), e = V(54), t = V(55), l = V(56), j = V(3), U = V(38);
        const O = (0, j.getLookupTableFactory)(function(i) {
          i["MyriadPro-Regular"] = i["PdfJS-Fallback-Regular"] = {
            name: "LiberationSans-Regular",
            factors: t.MyriadProRegularFactors,
            baseWidths: e.LiberationSansRegularWidths,
            baseMapping: e.LiberationSansRegularMapping,
            metrics: t.MyriadProRegularMetrics
          }, i["MyriadPro-Bold"] = i["PdfJS-Fallback-Bold"] = {
            name: "LiberationSans-Bold",
            factors: t.MyriadProBoldFactors,
            baseWidths: e.LiberationSansBoldWidths,
            baseMapping: e.LiberationSansBoldMapping,
            metrics: t.MyriadProBoldMetrics
          }, i["MyriadPro-It"] = i["MyriadPro-Italic"] = i["PdfJS-Fallback-Italic"] = {
            name: "LiberationSans-Italic",
            factors: t.MyriadProItalicFactors,
            baseWidths: e.LiberationSansItalicWidths,
            baseMapping: e.LiberationSansItalicMapping,
            metrics: t.MyriadProItalicMetrics
          }, i["MyriadPro-BoldIt"] = i["MyriadPro-BoldItalic"] = i["PdfJS-Fallback-BoldItalic"] = {
            name: "LiberationSans-BoldItalic",
            factors: t.MyriadProBoldItalicFactors,
            baseWidths: e.LiberationSansBoldItalicWidths,
            baseMapping: e.LiberationSansBoldItalicMapping,
            metrics: t.MyriadProBoldItalicMetrics
          }, i.ArialMT = i.Arial = i["Arial-Regular"] = {
            name: "LiberationSans-Regular",
            baseWidths: e.LiberationSansRegularWidths,
            baseMapping: e.LiberationSansRegularMapping
          }, i["Arial-BoldMT"] = i["Arial-Bold"] = {
            name: "LiberationSans-Bold",
            baseWidths: e.LiberationSansBoldWidths,
            baseMapping: e.LiberationSansBoldMapping
          }, i["Arial-ItalicMT"] = i["Arial-Italic"] = {
            name: "LiberationSans-Italic",
            baseWidths: e.LiberationSansItalicWidths,
            baseMapping: e.LiberationSansItalicMapping
          }, i["Arial-BoldItalicMT"] = i["Arial-BoldItalic"] = {
            name: "LiberationSans-BoldItalic",
            baseWidths: e.LiberationSansBoldItalicWidths,
            baseMapping: e.LiberationSansBoldItalicMapping
          }, i["Calibri-Regular"] = {
            name: "LiberationSans-Regular",
            factors: n.CalibriRegularFactors,
            baseWidths: e.LiberationSansRegularWidths,
            baseMapping: e.LiberationSansRegularMapping,
            metrics: n.CalibriRegularMetrics
          }, i["Calibri-Bold"] = {
            name: "LiberationSans-Bold",
            factors: n.CalibriBoldFactors,
            baseWidths: e.LiberationSansBoldWidths,
            baseMapping: e.LiberationSansBoldMapping,
            metrics: n.CalibriBoldMetrics
          }, i["Calibri-Italic"] = {
            name: "LiberationSans-Italic",
            factors: n.CalibriItalicFactors,
            baseWidths: e.LiberationSansItalicWidths,
            baseMapping: e.LiberationSansItalicMapping,
            metrics: n.CalibriItalicMetrics
          }, i["Calibri-BoldItalic"] = {
            name: "LiberationSans-BoldItalic",
            factors: n.CalibriBoldItalicFactors,
            baseWidths: e.LiberationSansBoldItalicWidths,
            baseMapping: e.LiberationSansBoldItalicMapping,
            metrics: n.CalibriBoldItalicMetrics
          }, i["Segoeui-Regular"] = {
            name: "LiberationSans-Regular",
            factors: l.SegoeuiRegularFactors,
            baseWidths: e.LiberationSansRegularWidths,
            baseMapping: e.LiberationSansRegularMapping,
            metrics: l.SegoeuiRegularMetrics
          }, i["Segoeui-Bold"] = {
            name: "LiberationSans-Bold",
            factors: l.SegoeuiBoldFactors,
            baseWidths: e.LiberationSansBoldWidths,
            baseMapping: e.LiberationSansBoldMapping,
            metrics: l.SegoeuiBoldMetrics
          }, i["Segoeui-Italic"] = {
            name: "LiberationSans-Italic",
            factors: l.SegoeuiItalicFactors,
            baseWidths: e.LiberationSansItalicWidths,
            baseMapping: e.LiberationSansItalicMapping,
            metrics: l.SegoeuiItalicMetrics
          }, i["Segoeui-BoldItalic"] = {
            name: "LiberationSans-BoldItalic",
            factors: l.SegoeuiBoldItalicFactors,
            baseWidths: e.LiberationSansBoldItalicWidths,
            baseMapping: e.LiberationSansBoldItalicMapping,
            metrics: l.SegoeuiBoldItalicMetrics
          }, i["Helvetica-Regular"] = i.Helvetica = {
            name: "LiberationSans-Regular",
            factors: C.HelveticaRegularFactors,
            baseWidths: e.LiberationSansRegularWidths,
            baseMapping: e.LiberationSansRegularMapping,
            metrics: C.HelveticaRegularMetrics
          }, i["Helvetica-Bold"] = {
            name: "LiberationSans-Bold",
            factors: C.HelveticaBoldFactors,
            baseWidths: e.LiberationSansBoldWidths,
            baseMapping: e.LiberationSansBoldMapping,
            metrics: C.HelveticaBoldMetrics
          }, i["Helvetica-Italic"] = {
            name: "LiberationSans-Italic",
            factors: C.HelveticaItalicFactors,
            baseWidths: e.LiberationSansItalicWidths,
            baseMapping: e.LiberationSansItalicMapping,
            metrics: C.HelveticaItalicMetrics
          }, i["Helvetica-BoldItalic"] = {
            name: "LiberationSans-BoldItalic",
            factors: C.HelveticaBoldItalicFactors,
            baseWidths: e.LiberationSansBoldItalicWidths,
            baseMapping: e.LiberationSansBoldItalicMapping,
            metrics: C.HelveticaBoldItalicMetrics
          };
        });
        function v(i) {
          const P = (0, U.normalizeFontName)(i);
          return O()[P];
        }
        function g(i) {
          const P = v(i);
          if (!P)
            return null;
          const {
            baseWidths: d,
            baseMapping: A,
            factors: I
          } = P, E = I ? d.map((R, f) => R * I[f]) : d;
          let k = -2, H;
          const x = [];
          for (const [R, f] of A.map((c, N) => [c, N]).sort(([c], [N]) => c - N))
            R !== -1 && (R === k + 1 ? (H.push(E[f]), k += 1) : (k = R, H = [E[f]], x.push(R, H)));
          return x;
        }
        function b(i) {
          const P = g(i), d = new F.Dict(null);
          d.set("BaseFont", F.Name.get(i)), d.set("Type", F.Name.get("Font")), d.set("Subtype", F.Name.get("CIDFontType2")), d.set("Encoding", F.Name.get("Identity-H")), d.set("CIDToGIDMap", F.Name.get("Identity")), d.set("W", P), d.set("FirstChar", P[0]), d.set("LastChar", P.at(-2) + P.at(-1).length - 1);
          const A = new F.Dict(null);
          d.set("FontDescriptor", A);
          const I = new F.Dict(null);
          return I.set("Ordering", "Identity"), I.set("Registry", "Adobe"), I.set("Supplement", 0), d.set("CIDSystemInfo", I), d;
        }
      },
      /* 52 */
      /***/
      (fe, w) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.CalibriRegularMetrics = w.CalibriRegularFactors = w.CalibriItalicMetrics = w.CalibriItalicFactors = w.CalibriBoldMetrics = w.CalibriBoldItalicMetrics = w.CalibriBoldItalicFactors = w.CalibriBoldFactors = void 0;
        const V = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.54657, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.73293, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.9121, 0.86943, 0.79795, 0.88198, 0.77958, 0.70864, 0.81055, 0.90399, 0.88653, 0.96017, 0.82577, 0.77892, 0.78257, 0.97507, 1.54657, 0.97507, 0.85284, 0.89552, 0.90176, 0.88762, 0.8785, 0.75241, 0.8785, 0.90518, 0.95015, 0.77618, 0.8785, 0.88401, 0.91916, 0.86304, 0.88401, 0.91488, 0.8785, 0.8801, 0.8785, 0.8785, 0.91343, 0.7173, 1.04106, 0.8785, 0.85075, 0.95794, 0.82616, 0.85162, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.12401, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.73293, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.9121, 0.86943, 0.86943, 0.86943, 0.86943, 0.86943, 0.85284, 0.87508, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.8715, 0.75241, 0.90518, 0.90518, 0.90518, 0.90518, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.8785, 0.8801, 0.8801, 0.8801, 0.8801, 0.8801, 0.90747, 0.89049, 0.8785, 0.8785, 0.8785, 0.8785, 0.85162, 0.8785, 0.85162, 0.83908, 0.88762, 0.83908, 0.88762, 0.83908, 0.88762, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.87289, 0.83016, 0.88506, 0.93125, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.81921, 0.77618, 0.81921, 0.77618, 0.81921, 0.77618, 1, 1, 0.87356, 0.8785, 0.91075, 0.89608, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76229, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.79468, 0.91926, 0.88175, 0.70823, 0.94903, 0.9121, 0.8785, 1, 1, 0.9121, 0.8785, 0.87802, 0.88656, 0.8785, 0.86943, 0.8801, 0.86943, 0.8801, 0.86943, 0.8801, 0.87402, 0.89291, 0.77958, 0.91343, 1, 1, 0.77958, 0.91343, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.96017, 0.95794, 0.77892, 0.85162, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.88762, 0.77539, 0.8715, 0.87508, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70674, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.06303, 0.83908, 0.80352, 0.57184, 0.6965, 0.56289, 0.82001, 0.56029, 0.81235, 1.02988, 0.83908, 0.7762, 0.68156, 0.80367, 0.73133, 0.78257, 0.87356, 0.86943, 0.95958, 0.75727, 0.89019, 1.04924, 0.9121, 0.7648, 0.86943, 0.87356, 0.79795, 0.78275, 0.81055, 0.77892, 0.9762, 0.82577, 0.99819, 0.84896, 0.95958, 0.77892, 0.96108, 1.01407, 0.89049, 1.02988, 0.94211, 0.96108, 0.8936, 0.84021, 0.87842, 0.96399, 0.79109, 0.89049, 1.00813, 1.02988, 0.86077, 0.87445, 0.92099, 0.84723, 0.86513, 0.8801, 0.75638, 0.85714, 0.78216, 0.79586, 0.87965, 0.94211, 0.97747, 0.78287, 0.97926, 0.84971, 1.02988, 0.94211, 0.8801, 0.94211, 0.84971, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90264, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90518, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90548, 1, 1, 1, 1, 1, 1, 0.96017, 0.95794, 0.96017, 0.95794, 0.96017, 0.95794, 0.77892, 0.85162, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.92794, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71143, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.93835, 0.83406, 0.91133, 0.84107, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90527, 1.81055, 0.90527, 1.81055, 1.31006, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        w.CalibriBoldFactors = V;
        const n = {
          lineHeight: 1.2207,
          lineGap: 0.2207
        };
        w.CalibriBoldMetrics = n;
        const F = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.56239, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.71805, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.90872, 0.85938, 0.79795, 0.87068, 0.77958, 0.69766, 0.81055, 0.90399, 0.88653, 0.96068, 0.82577, 0.77892, 0.78257, 0.97507, 1.529, 0.97507, 0.85284, 0.89552, 0.90176, 0.94908, 0.86411, 0.74012, 0.86411, 0.88323, 0.95015, 0.86411, 0.86331, 0.88401, 0.91916, 0.86304, 0.88401, 0.9039, 0.86331, 0.86331, 0.86411, 0.86411, 0.90464, 0.70852, 1.04106, 0.86331, 0.84372, 0.95794, 0.82616, 0.84548, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.19129, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.71805, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.90872, 0.85938, 0.85938, 0.85938, 0.85938, 0.85938, 0.85284, 0.87068, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.85887, 0.74012, 0.88323, 0.88323, 0.88323, 0.88323, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.90747, 0.89049, 0.86331, 0.86331, 0.86331, 0.86331, 0.84548, 0.86411, 0.84548, 0.83908, 0.94908, 0.83908, 0.94908, 0.83908, 0.94908, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.87289, 0.79538, 0.88506, 0.92726, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.81921, 0.86411, 0.81921, 0.86411, 0.81921, 0.86411, 1, 1, 0.87356, 0.86331, 0.91075, 0.8777, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76467, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.77312, 0.91926, 0.88175, 0.70823, 0.94903, 0.90872, 0.86331, 1, 1, 0.90872, 0.86331, 0.86906, 0.88116, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.87402, 0.86549, 0.77958, 0.90464, 1, 1, 0.77958, 0.90464, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.96068, 0.95794, 0.77892, 0.84548, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.94908, 0.77539, 0.85887, 0.87068, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70088, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.48387, 0.83908, 0.80352, 0.57118, 0.6965, 0.56347, 0.79179, 0.55853, 0.80346, 1.02988, 0.83908, 0.7762, 0.67174, 0.86036, 0.73133, 0.78257, 0.87356, 0.86441, 0.95958, 0.75727, 0.89019, 1.04924, 0.90872, 0.74889, 0.85938, 0.87891, 0.79795, 0.7957, 0.81055, 0.77892, 0.97447, 0.82577, 0.97466, 0.87179, 0.95958, 0.77892, 0.94252, 0.95612, 0.8753, 1.02988, 0.92733, 0.94252, 0.87411, 0.84021, 0.8728, 0.95612, 0.74081, 0.8753, 1.02189, 1.02988, 0.84814, 0.87445, 0.91822, 0.84723, 0.85668, 0.86331, 0.81344, 0.87581, 0.76422, 0.82046, 0.96057, 0.92733, 0.99375, 0.78022, 0.95452, 0.86015, 1.02988, 0.92733, 0.86331, 0.92733, 0.86015, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90631, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88323, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85174, 1, 1, 1, 1, 1, 1, 0.96068, 0.95794, 0.96068, 0.95794, 0.96068, 0.95794, 0.77892, 0.84548, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.89807, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71094, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.92972, 0.83406, 0.91133, 0.83326, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90616, 1.81055, 0.90527, 1.81055, 1.3107, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        w.CalibriBoldItalicFactors = F;
        const C = {
          lineHeight: 1.2207,
          lineGap: 0.2207
        };
        w.CalibriBoldItalicMetrics = C;
        const e = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39543, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.72346, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89249, 0.84118, 0.77452, 0.85374, 0.75186, 0.67789, 0.79776, 0.88844, 0.85066, 0.94309, 0.77818, 0.7306, 0.76659, 1.10369, 1.38313, 1.10369, 1.06139, 0.89552, 0.8739, 0.9245, 0.9245, 0.83203, 0.9245, 0.85865, 1.09842, 0.9245, 0.9245, 1.03297, 1.07692, 0.90918, 1.03297, 0.94959, 0.9245, 0.92274, 0.9245, 0.9245, 1.02933, 0.77832, 1.20562, 0.9245, 0.8916, 0.98986, 0.86621, 0.89453, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.16359, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.72346, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89249, 0.84118, 0.84118, 0.84118, 0.84118, 0.84118, 0.85284, 0.84557, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.84843, 0.83203, 0.85865, 0.85865, 0.85865, 0.85865, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.9245, 0.92274, 0.92274, 0.92274, 0.92274, 0.92274, 0.90747, 0.86651, 0.9245, 0.9245, 0.9245, 0.9245, 0.89453, 0.9245, 0.89453, 0.8675, 0.9245, 0.8675, 0.9245, 0.8675, 0.9245, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.85193, 0.8875, 0.86477, 0.99034, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.81105, 0.9245, 0.81105, 0.9245, 0.81105, 0.9245, 1, 1, 0.86275, 0.9245, 0.90872, 0.93591, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77896, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.9375, 0.98156, 0.93407, 0.77261, 1.11429, 0.89249, 0.9245, 1, 1, 0.89249, 0.9245, 0.92534, 0.86698, 0.9245, 0.84118, 0.92274, 0.84118, 0.92274, 0.84118, 0.92274, 0.8667, 0.86291, 0.75186, 1.02933, 1, 1, 0.75186, 1.02933, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 1, 1, 0.79776, 0.97655, 0.79776, 1.23023, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.94309, 0.98986, 0.7306, 0.89453, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.9245, 0.76318, 0.84843, 0.84557, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67009, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.8675, 0.90861, 0.6192, 0.7363, 0.64824, 0.82411, 0.56321, 0.85696, 1.23516, 0.8675, 0.81552, 0.7286, 0.84134, 0.73206, 0.76659, 0.86275, 0.84369, 0.90685, 0.77892, 0.85871, 1.02638, 0.89249, 0.75828, 0.84118, 0.85984, 0.77452, 0.76466, 0.79776, 0.7306, 0.90782, 0.77818, 0.903, 0.87291, 0.90685, 0.7306, 0.99058, 1.03667, 0.94635, 1.23516, 0.9849, 0.99058, 0.92393, 0.8916, 0.942, 1.03667, 0.75026, 0.94635, 1.0297, 1.23516, 0.90918, 0.94048, 0.98217, 0.89746, 0.84153, 0.92274, 0.82507, 0.88832, 0.84438, 0.88178, 1.03525, 0.9849, 1.00225, 0.78086, 0.97248, 0.89404, 1.23516, 0.9849, 0.92274, 0.9849, 0.89404, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89693, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85865, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90933, 1, 1, 1, 1, 1, 1, 0.94309, 0.98986, 0.94309, 0.98986, 0.94309, 0.98986, 0.7306, 0.89453, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.68994, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.97858, 0.82616, 0.91133, 0.83437, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90572, 1.81055, 0.90749, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85284, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        w.CalibriItalicFactors = e;
        const t = {
          lineHeight: 1.2207,
          lineGap: 0.2207
        };
        w.CalibriItalicMetrics = t;
        const l = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39016, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.73834, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89385, 0.85122, 0.77452, 0.86503, 0.75186, 0.68887, 0.79776, 0.88844, 0.85066, 0.94258, 0.77818, 0.7306, 0.76659, 1.10369, 1.39016, 1.10369, 1.06139, 0.89552, 0.8739, 0.86128, 0.94469, 0.8457, 0.94469, 0.89464, 1.09842, 0.84636, 0.94469, 1.03297, 1.07692, 0.90918, 1.03297, 0.95897, 0.94469, 0.9482, 0.94469, 0.94469, 1.04692, 0.78223, 1.20562, 0.94469, 0.90332, 0.98986, 0.86621, 0.90527, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.08707, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.73834, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89385, 0.85122, 0.85122, 0.85122, 0.85122, 0.85122, 0.85284, 0.85311, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.8693, 0.8457, 0.89464, 0.89464, 0.89464, 0.89464, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.94469, 0.9482, 0.9482, 0.9482, 0.9482, 0.9482, 0.90747, 0.86651, 0.94469, 0.94469, 0.94469, 0.94469, 0.90527, 0.94469, 0.90527, 0.8675, 0.86128, 0.8675, 0.86128, 0.8675, 0.86128, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.85193, 0.92454, 0.86477, 0.9921, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.81105, 0.84636, 0.81105, 0.84636, 0.81105, 0.84636, 1, 1, 0.86275, 0.94469, 0.90872, 0.95786, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77741, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.90452, 0.98156, 1.11842, 0.77261, 1.11429, 0.89385, 0.94469, 1, 1, 0.89385, 0.94469, 0.95877, 0.86901, 0.94469, 0.85122, 0.9482, 0.85122, 0.9482, 0.85122, 0.9482, 0.8667, 0.90016, 0.75186, 1.04692, 1, 1, 0.75186, 1.04692, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 1, 1, 0.79776, 0.92188, 0.79776, 1.23023, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.94258, 0.98986, 0.7306, 0.90527, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.86128, 0.76318, 0.8693, 0.85311, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67742, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.86686, 0.90861, 0.62267, 0.74359, 0.65649, 0.85498, 0.56963, 0.88254, 1.23516, 0.8675, 0.81552, 0.75443, 0.84503, 0.73206, 0.76659, 0.86275, 0.85122, 0.90685, 0.77892, 0.85746, 1.02638, 0.89385, 0.75657, 0.85122, 0.86275, 0.77452, 0.74171, 0.79776, 0.7306, 0.95165, 0.77818, 0.89772, 0.88831, 0.90685, 0.7306, 0.98142, 1.02191, 0.96576, 1.23516, 0.99018, 0.98142, 0.9236, 0.89258, 0.94035, 1.02191, 0.78848, 0.96576, 0.9561, 1.23516, 0.90918, 0.92578, 0.95424, 0.89746, 0.83969, 0.9482, 0.80113, 0.89442, 0.85208, 0.86155, 0.98022, 0.99018, 1.00452, 0.81209, 0.99247, 0.89181, 1.23516, 0.99018, 0.9482, 0.99018, 0.89181, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88844, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89464, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96766, 1, 1, 1, 1, 1, 1, 0.94258, 0.98986, 0.94258, 0.98986, 0.94258, 0.98986, 0.7306, 0.90527, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.69043, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.99331, 0.82616, 0.91133, 0.84286, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90527, 1.81055, 0.90527, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1.07185, 0.99413, 0.96334, 1.08065, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        w.CalibriRegularFactors = l;
        const j = {
          lineHeight: 1.2207,
          lineGap: 0.2207
        };
        w.CalibriRegularMetrics = j;
      },
      /* 53 */
      /***/
      (fe, w) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.HelveticaRegularMetrics = w.HelveticaRegularFactors = w.HelveticaItalicMetrics = w.HelveticaItalicFactors = w.HelveticaBoldMetrics = w.HelveticaBoldItalicMetrics = w.HelveticaBoldItalicFactors = w.HelveticaBoldFactors = void 0;
        const V = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.03374, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.00042, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.03828, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00034, 0.99977, 1, 0.99997, 1.00026, 1.00078, 1.00036, 0.99973, 1.00013, 1.0006, 0.99977, 0.99977, 0.99988, 0.85148, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 1.00069, 1.00022, 0.99977, 1.00001, 0.99984, 1.00026, 1.00001, 1.00024, 1.00001, 0.9999, 1, 1.0006, 1.00001, 1.00041, 0.99962, 1.00026, 1.0006, 0.99995, 1.00041, 0.99942, 0.99973, 0.99927, 1.00082, 0.99902, 1.00026, 1.00087, 1.0006, 1.00069, 0.99973, 0.99867, 0.99973, 0.9993, 1.00026, 1.00049, 1.00056, 1, 0.99988, 0.99935, 0.99995, 0.99954, 1.00055, 0.99945, 1.00032, 1.0006, 0.99995, 1.00026, 0.99995, 1.00032, 1.00001, 1.00008, 0.99971, 1.00019, 0.9994, 1.00001, 1.0006, 1.00044, 0.99973, 1.00023, 1.00047, 1, 0.99942, 0.99561, 0.99989, 1.00035, 0.99977, 1.00035, 0.99977, 1.00019, 0.99944, 1.00001, 1.00021, 0.99926, 1.00035, 1.00035, 0.99942, 1.00048, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.99989, 1.00057, 1.00001, 0.99936, 1.00052, 1.00012, 0.99996, 1.00043, 1, 1.00035, 0.9994, 0.99976, 1.00035, 0.99973, 1.00052, 1.00041, 1.00119, 1.00037, 0.99973, 1.00002, 0.99986, 1.00041, 1.00041, 0.99902, 0.9996, 1.00034, 0.99999, 1.00026, 0.99999, 1.00026, 0.99973, 1.00052, 0.99973, 1, 0.99973, 1.00041, 1.00075, 0.9994, 1.0003, 0.99999, 1, 1.00041, 0.99955, 1, 0.99915, 0.99973, 0.99973, 1.00026, 1.00119, 0.99955, 0.99973, 1.0006, 0.99911, 1.0006, 1.00026, 0.99972, 1.00026, 0.99902, 1.00041, 0.99973, 0.99999, 1, 1, 1.00038, 1.0005, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 1.00047, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        w.HelveticaBoldFactors = V;
        const n = {
          lineHeight: 1.2,
          lineGap: 0.2
        };
        w.HelveticaBoldMetrics = n;
        const F = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.0044, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99971, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.01011, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99977, 1, 1, 1.00026, 0.99969, 0.99972, 0.99981, 0.9998, 1.0006, 0.99977, 0.99977, 1.00022, 0.91155, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 0.99966, 1.00022, 1.00032, 1.00001, 0.99944, 1.00026, 1.00001, 0.99968, 1.00001, 1.00047, 1, 1.0006, 1.00001, 0.99981, 1.00101, 1.00026, 1.0006, 0.99948, 0.99981, 1.00064, 0.99973, 0.99942, 1.00101, 1.00061, 1.00026, 1.00069, 1.0006, 1.00014, 0.99973, 1.01322, 0.99973, 1.00065, 1.00026, 1.00012, 0.99923, 1, 1.00064, 1.00076, 0.99948, 1.00055, 1.00063, 1.00007, 0.99943, 1.0006, 0.99948, 1.00026, 0.99948, 0.99943, 1.00001, 1.00001, 1.00029, 1.00038, 1.00035, 1.00001, 1.0006, 1.0006, 0.99973, 0.99978, 1.00001, 1.00057, 0.99989, 0.99967, 0.99964, 0.99967, 0.99977, 0.99999, 0.99977, 1.00038, 0.99977, 1.00001, 0.99973, 1.00066, 0.99967, 0.99967, 1.00041, 0.99998, 0.99999, 0.99977, 1.00022, 0.99967, 1.00001, 0.99977, 1.00026, 0.99964, 1.00031, 1.00001, 0.99999, 0.99999, 1, 1.00023, 1, 1, 0.99999, 1.00035, 1.00001, 0.99999, 0.99973, 0.99977, 0.99999, 1.00058, 0.99973, 0.99973, 0.99955, 0.9995, 1.00026, 1.00026, 1.00032, 0.99989, 1.00034, 0.99999, 1.00026, 1.00026, 1.00026, 0.99973, 0.45998, 0.99973, 1.00026, 0.99973, 1.00001, 0.99999, 0.99982, 0.99994, 0.99996, 1, 1.00042, 1.00044, 1.00029, 1.00023, 0.99973, 0.99973, 1.00026, 0.99949, 1.00002, 0.99973, 1.0006, 1.0006, 1.0006, 0.99975, 1.00026, 1.00026, 1.00032, 0.98685, 0.99973, 1.00026, 1, 1, 0.99966, 1.00044, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1, 0.99973, 0.99971, 0.99978, 1, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00098, 1, 1, 1, 1.00049, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        w.HelveticaBoldItalicFactors = F;
        const C = {
          lineHeight: 1.35,
          lineGap: 0.2
        };
        w.HelveticaBoldItalicMetrics = C;
        const e = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.0288, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 0.99946, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.06311, 0.99973, 1.00024, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00041, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.89547, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00001, 1, 1.00054, 0.99977, 1.00084, 1.00007, 0.99973, 1.00013, 0.99924, 1.00001, 1.00001, 0.99945, 0.91221, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00001, 0.99999, 0.99977, 0.99933, 1.00022, 1.00054, 1.00001, 1.00065, 1.00026, 1.00001, 1.0001, 1.00001, 1.00052, 1, 1.0006, 1.00001, 0.99945, 0.99897, 0.99968, 0.99924, 1.00036, 0.99945, 0.99949, 1, 1.0006, 0.99897, 0.99918, 0.99968, 0.99911, 0.99924, 1, 0.99962, 1.01487, 1, 1.0005, 0.99973, 1.00012, 1.00043, 1, 0.99995, 0.99994, 1.00036, 0.99947, 1.00019, 1.00063, 1.00025, 0.99924, 1.00036, 0.99973, 1.00036, 1.00025, 1.00001, 1.00001, 1.00027, 1.0001, 1.00068, 1.00001, 1.0006, 1.0006, 1, 1.00008, 0.99957, 0.99972, 0.9994, 0.99954, 0.99975, 1.00051, 1.00001, 1.00019, 1.00001, 1.0001, 0.99986, 1.00001, 1.00001, 1.00038, 0.99954, 0.99954, 0.9994, 1.00066, 0.99999, 0.99977, 1.00022, 1.00054, 1.00001, 0.99977, 1.00026, 0.99975, 1.0001, 1.00001, 0.99993, 0.9995, 0.99955, 1.00016, 0.99978, 0.99974, 1.00019, 1.00022, 0.99955, 1.00053, 0.99973, 1.00089, 1.00005, 0.99967, 1.00048, 0.99973, 1.00002, 1.00034, 0.99973, 0.99973, 0.99964, 1.00006, 1.00066, 0.99947, 0.99973, 0.98894, 0.99973, 1, 0.44898, 1, 0.99946, 1, 1.00039, 1.00082, 0.99991, 0.99991, 0.99985, 1.00022, 1.00023, 1.00061, 1.00006, 0.99966, 0.99973, 0.99973, 0.99973, 1.00019, 1.0008, 1, 0.99924, 0.99924, 0.99924, 0.99983, 1.00044, 0.99973, 0.99964, 0.98332, 1, 0.99973, 1, 1, 0.99962, 0.99895, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 1.00423, 0.99925, 0.99999, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00049, 1, 1.00245, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 1.00003, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        w.HelveticaItalicFactors = e;
        const t = {
          lineHeight: 1.35,
          lineGap: 0.2
        };
        w.HelveticaItalicMetrics = t;
        const l = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.04596, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 1.00019, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.02572, 0.99973, 1.00005, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99999, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.84533, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99928, 1, 0.99977, 1.00013, 1.00055, 0.99947, 0.99945, 0.99941, 0.99924, 1.00001, 1.00001, 1.0004, 0.91621, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00005, 0.99999, 0.99977, 1.00015, 1.00022, 0.99977, 1.00001, 0.99973, 1.00026, 1.00001, 1.00019, 1.00001, 0.99946, 1, 1.0006, 1.00001, 0.99978, 1.00045, 0.99973, 0.99924, 1.00023, 0.99978, 0.99966, 1, 1.00065, 1.00045, 1.00019, 0.99973, 0.99973, 0.99924, 1, 1, 0.96499, 1, 1.00055, 0.99973, 1.00008, 1.00027, 1, 0.9997, 0.99995, 1.00023, 0.99933, 1.00019, 1.00015, 1.00031, 0.99924, 1.00023, 0.99973, 1.00023, 1.00031, 1.00001, 0.99928, 1.00029, 1.00092, 1.00035, 1.00001, 1.0006, 1.0006, 1, 0.99988, 0.99975, 1, 1.00082, 0.99561, 0.9996, 1.00035, 1.00001, 0.99962, 1.00001, 1.00092, 0.99964, 1.00001, 0.99963, 0.99999, 1.00035, 1.00035, 1.00082, 0.99962, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.9996, 0.99967, 1.00001, 1.00034, 1.00074, 1.00054, 1.00053, 1.00063, 0.99971, 0.99962, 1.00035, 0.99975, 0.99977, 0.99973, 1.00043, 0.99953, 1.0007, 0.99915, 0.99973, 1.00008, 0.99892, 1.00073, 1.00073, 1.00114, 0.99915, 1.00073, 0.99955, 0.99973, 1.00092, 0.99973, 1, 0.99998, 1, 1.0003, 1, 1.00043, 1.00001, 0.99969, 1.0003, 1, 1.00035, 1.00001, 0.9995, 1, 1.00092, 0.99973, 0.99973, 0.99973, 1.0007, 0.9995, 1, 0.99924, 1.0006, 0.99924, 0.99972, 1.00062, 0.99973, 1.00114, 1.00073, 1, 0.99955, 1, 1, 1.00047, 0.99968, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 0.99925, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        w.HelveticaRegularFactors = l;
        const j = {
          lineHeight: 1.2,
          lineGap: 0.2
        };
        w.HelveticaRegularMetrics = j;
      },
      /* 54 */
      /***/
      (fe, w) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.LiberationSansRegularWidths = w.LiberationSansRegularMapping = w.LiberationSansItalicWidths = w.LiberationSansItalicMapping = w.LiberationSansBoldWidths = w.LiberationSansBoldMapping = w.LiberationSansBoldItalicWidths = w.LiberationSansBoldItalicMapping = void 0;
        const V = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 719, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 785, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 385, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 465, 722, 333, 853, 906, 474, 825, 927, 838, 278, 722, 722, 601, 719, 667, 611, 722, 778, 278, 722, 667, 833, 722, 644, 778, 722, 667, 600, 611, 667, 821, 667, 809, 802, 278, 667, 615, 451, 611, 278, 582, 615, 610, 556, 606, 475, 460, 611, 541, 278, 558, 556, 612, 556, 445, 611, 766, 619, 520, 684, 446, 582, 715, 576, 753, 845, 278, 582, 611, 582, 845, 667, 669, 885, 567, 711, 667, 278, 276, 556, 1094, 1062, 875, 610, 722, 622, 719, 722, 719, 722, 567, 712, 667, 904, 626, 719, 719, 610, 702, 833, 722, 778, 719, 667, 722, 611, 622, 854, 667, 730, 703, 1005, 1019, 870, 979, 719, 711, 1031, 719, 556, 618, 615, 417, 635, 556, 709, 497, 615, 615, 500, 635, 740, 604, 611, 604, 611, 556, 490, 556, 875, 556, 615, 581, 833, 844, 729, 854, 615, 552, 854, 583, 556, 556, 611, 417, 552, 556, 278, 281, 278, 969, 906, 611, 500, 615, 556, 604, 778, 611, 487, 447, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1094, 556, 885, 489, 1115, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333];
        w.LiberationSansBoldWidths = V;
        const n = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
        w.LiberationSansBoldMapping = n;
        const F = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 740, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 782, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 396, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 722, 333, 854, 906, 473, 844, 930, 847, 278, 722, 722, 610, 671, 667, 611, 722, 778, 278, 722, 667, 833, 722, 657, 778, 718, 667, 590, 611, 667, 822, 667, 829, 781, 278, 667, 620, 479, 611, 278, 591, 620, 621, 556, 610, 479, 492, 611, 558, 278, 566, 556, 603, 556, 450, 611, 712, 605, 532, 664, 409, 591, 704, 578, 773, 834, 278, 591, 611, 591, 834, 667, 667, 886, 614, 719, 667, 278, 278, 556, 1094, 1042, 854, 622, 719, 677, 719, 722, 708, 722, 614, 722, 667, 927, 643, 719, 719, 615, 687, 833, 722, 778, 719, 667, 722, 611, 677, 781, 667, 729, 708, 979, 989, 854, 1e3, 708, 719, 1042, 729, 556, 619, 604, 534, 618, 556, 736, 510, 611, 611, 507, 622, 740, 604, 611, 611, 611, 556, 889, 556, 885, 556, 646, 583, 889, 935, 707, 854, 594, 552, 865, 589, 556, 556, 611, 469, 563, 556, 278, 278, 278, 969, 906, 611, 507, 619, 556, 611, 778, 611, 575, 467, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1104, 556, 885, 516, 1146, 1e3, 768, 600, 834, 834, 834, 834, 999, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333];
        w.LiberationSansBoldItalicWidths = F;
        const C = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
        w.LiberationSansBoldItalicMapping = C;
        const e = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 625, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 733, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 281, 556, 400, 556, 222, 722, 556, 722, 556, 722, 556, 615, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 354, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 789, 846, 389, 794, 865, 775, 222, 667, 667, 570, 671, 667, 611, 722, 778, 278, 667, 667, 833, 722, 648, 778, 725, 667, 600, 611, 667, 837, 667, 831, 761, 278, 667, 570, 439, 555, 222, 550, 570, 571, 500, 556, 439, 463, 555, 542, 222, 500, 492, 548, 500, 447, 556, 670, 573, 486, 603, 374, 550, 652, 546, 728, 779, 222, 550, 556, 550, 779, 667, 667, 843, 544, 708, 667, 278, 278, 500, 1066, 982, 844, 589, 715, 639, 724, 667, 651, 667, 544, 704, 667, 917, 614, 715, 715, 589, 686, 833, 722, 778, 725, 667, 722, 611, 639, 795, 667, 727, 673, 920, 923, 805, 886, 651, 694, 1022, 682, 556, 562, 522, 493, 553, 556, 688, 465, 556, 556, 472, 564, 686, 550, 556, 556, 556, 500, 833, 500, 835, 500, 572, 518, 830, 851, 621, 736, 526, 492, 752, 534, 556, 556, 556, 378, 496, 500, 222, 222, 222, 910, 828, 556, 472, 565, 500, 556, 778, 556, 492, 339, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1083, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 998, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 584, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285];
        w.LiberationSansItalicWidths = e;
        const t = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
        w.LiberationSansItalicMapping = t;
        const l = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 615, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 735, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 292, 556, 334, 556, 222, 722, 556, 722, 556, 722, 556, 604, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 375, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 784, 838, 384, 774, 855, 752, 222, 667, 667, 551, 668, 667, 611, 722, 778, 278, 667, 668, 833, 722, 650, 778, 722, 667, 618, 611, 667, 798, 667, 835, 748, 278, 667, 578, 446, 556, 222, 547, 578, 575, 500, 557, 446, 441, 556, 556, 222, 500, 500, 576, 500, 448, 556, 690, 569, 482, 617, 395, 547, 648, 525, 713, 781, 222, 547, 556, 547, 781, 667, 667, 865, 542, 719, 667, 278, 278, 500, 1057, 1010, 854, 583, 722, 635, 719, 667, 656, 667, 542, 677, 667, 923, 604, 719, 719, 583, 656, 833, 722, 778, 719, 667, 722, 611, 635, 760, 667, 740, 667, 917, 938, 792, 885, 656, 719, 1010, 722, 556, 573, 531, 365, 583, 556, 669, 458, 559, 559, 438, 583, 688, 552, 556, 542, 556, 500, 458, 500, 823, 500, 573, 521, 802, 823, 625, 719, 521, 510, 750, 542, 556, 556, 556, 365, 510, 500, 222, 278, 222, 906, 812, 556, 438, 559, 500, 552, 778, 556, 489, 411, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1073, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285];
        w.LiberationSansRegularWidths = l;
        const j = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
        w.LiberationSansRegularMapping = j;
      },
      /* 55 */
      /***/
      (fe, w) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.MyriadProRegularMetrics = w.MyriadProRegularFactors = w.MyriadProItalicMetrics = w.MyriadProItalicFactors = w.MyriadProBoldMetrics = w.MyriadProBoldItalicMetrics = w.MyriadProBoldItalicFactors = w.MyriadProBoldFactors = void 0;
        const V = [1.36898, 1, 1, 0.72706, 0.80479, 0.83734, 0.98894, 0.99793, 0.9897, 0.93884, 0.86209, 0.94292, 0.94292, 1.16661, 1.02058, 0.93582, 0.96694, 0.93582, 1.19137, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.72851, 0.78966, 0.90838, 0.83637, 0.82391, 0.96376, 0.80061, 0.86275, 0.8768, 0.95407, 1.0258, 0.73901, 0.85022, 0.83655, 1.0156, 0.95546, 0.92179, 0.87107, 0.92179, 0.82114, 0.8096, 0.89713, 0.94438, 0.95353, 0.94083, 0.91905, 0.90406, 0.9446, 0.94292, 1.18777, 0.94292, 1.02058, 0.89903, 0.90088, 0.94938, 0.97898, 0.81093, 0.97571, 0.94938, 1.024, 0.9577, 0.95933, 0.98621, 1.0474, 0.97455, 0.98981, 0.9672, 0.95933, 0.9446, 0.97898, 0.97407, 0.97646, 0.78036, 1.10208, 0.95442, 0.95298, 0.97579, 0.9332, 0.94039, 0.938, 0.80687, 1.01149, 0.80687, 1.02058, 0.80479, 0.99793, 0.99793, 0.99793, 0.99793, 1.01149, 1.00872, 0.90088, 0.91882, 1.0213, 0.8361, 1.02058, 0.62295, 0.54324, 0.89022, 1.08595, 1, 1, 0.90088, 1, 0.97455, 0.93582, 0.90088, 1, 1.05686, 0.8361, 0.99642, 0.99642, 0.99642, 0.72851, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.868, 0.82391, 0.80061, 0.80061, 0.80061, 0.80061, 1.0258, 1.0258, 1.0258, 1.0258, 0.97484, 0.95546, 0.92179, 0.92179, 0.92179, 0.92179, 0.92179, 1.02058, 0.92179, 0.94438, 0.94438, 0.94438, 0.94438, 0.90406, 0.86958, 0.98225, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.9031, 0.81093, 0.94938, 0.94938, 0.94938, 0.94938, 0.98621, 0.98621, 0.98621, 0.98621, 0.93969, 0.95933, 0.9446, 0.9446, 0.9446, 0.9446, 0.9446, 1.08595, 0.9446, 0.95442, 0.95442, 0.95442, 0.95442, 0.94039, 0.97898, 0.94039, 0.90838, 0.94938, 0.90838, 0.94938, 0.90838, 0.94938, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.96376, 0.84313, 0.97484, 0.97571, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.8768, 0.9577, 0.8768, 0.9577, 0.8768, 0.9577, 1, 1, 0.95407, 0.95933, 0.97069, 0.95933, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 0.887, 1.01591, 0.73901, 1.0474, 1, 1, 0.97455, 0.83655, 0.98981, 1, 1, 0.83655, 0.73977, 0.83655, 0.73903, 0.84638, 1.033, 0.95546, 0.95933, 1, 1, 0.95546, 0.95933, 0.8271, 0.95417, 0.95933, 0.92179, 0.9446, 0.92179, 0.9446, 0.92179, 0.9446, 0.936, 0.91964, 0.82114, 0.97646, 1, 1, 0.82114, 0.97646, 0.8096, 0.78036, 0.8096, 0.78036, 1, 1, 0.8096, 0.78036, 1, 1, 0.89713, 0.77452, 0.89713, 1.10208, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94083, 0.97579, 0.90406, 0.94039, 0.90406, 0.9446, 0.938, 0.9446, 0.938, 0.9446, 0.938, 1, 0.99793, 0.90838, 0.94938, 0.868, 0.9031, 0.92179, 0.9446, 1, 1, 0.89713, 1.10208, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90989, 0.9358, 0.91945, 0.83181, 0.75261, 0.87992, 0.82976, 0.96034, 0.83689, 0.97268, 1.0078, 0.90838, 0.83637, 0.8019, 0.90157, 0.80061, 0.9446, 0.95407, 0.92436, 1.0258, 0.85022, 0.97153, 1.0156, 0.95546, 0.89192, 0.92179, 0.92361, 0.87107, 0.96318, 0.89713, 0.93704, 0.95638, 0.91905, 0.91709, 0.92796, 1.0258, 0.93704, 0.94836, 1.0373, 0.95933, 1.0078, 0.95871, 0.94836, 0.96174, 0.92601, 0.9498, 0.98607, 0.95776, 0.95933, 1.05453, 1.0078, 0.98275, 0.9314, 0.95617, 0.91701, 1.05993, 0.9446, 0.78367, 0.9553, 1, 0.86832, 1.0128, 0.95871, 0.99394, 0.87548, 0.96361, 0.86774, 1.0078, 0.95871, 0.9446, 0.95871, 0.86774, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.94083, 0.97579, 0.94083, 0.97579, 0.94083, 0.97579, 0.90406, 0.94039, 0.96694, 1, 0.89903, 1, 1, 1, 0.93582, 0.93582, 0.93582, 1, 0.908, 0.908, 0.918, 0.94219, 0.94219, 0.96544, 1, 1.285, 1, 1, 0.81079, 0.81079, 1, 1, 0.74854, 1, 1, 1, 1, 0.99793, 1, 1, 1, 0.65, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.17173, 1, 0.80535, 0.76169, 1.02058, 1.0732, 1.05486, 1, 1, 1.30692, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.16161, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        w.MyriadProBoldFactors = V;
        const n = {
          lineHeight: 1.2,
          lineGap: 0.2
        };
        w.MyriadProBoldMetrics = n;
        const F = [1.36898, 1, 1, 0.66227, 0.80779, 0.81625, 0.97276, 0.97276, 0.97733, 0.92222, 0.83266, 0.94292, 0.94292, 1.16148, 1.02058, 0.93582, 0.96694, 0.93582, 1.17337, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.71541, 0.76813, 0.85576, 0.80591, 0.80729, 0.94299, 0.77512, 0.83655, 0.86523, 0.92222, 0.98621, 0.71743, 0.81698, 0.79726, 0.98558, 0.92222, 0.90637, 0.83809, 0.90637, 0.80729, 0.76463, 0.86275, 0.90699, 0.91605, 0.9154, 0.85308, 0.85458, 0.90531, 0.94292, 1.21296, 0.94292, 1.02058, 0.89903, 1.18616, 0.99613, 0.91677, 0.78216, 0.91677, 0.90083, 0.98796, 0.9135, 0.92168, 0.95381, 0.98981, 0.95298, 0.95381, 0.93459, 0.92168, 0.91513, 0.92004, 0.91677, 0.95077, 0.748, 1.04502, 0.91677, 0.92061, 0.94236, 0.89544, 0.89364, 0.9, 0.80687, 0.8578, 0.80687, 1.02058, 0.80779, 0.97276, 0.97276, 0.97276, 0.97276, 0.8578, 0.99973, 1.18616, 0.91339, 1.08074, 0.82891, 1.02058, 0.55509, 0.71526, 0.89022, 1.08595, 1, 1, 1.18616, 1, 0.96736, 0.93582, 1.18616, 1, 1.04864, 0.82711, 0.99043, 0.99043, 0.99043, 0.71541, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.845, 0.80729, 0.77512, 0.77512, 0.77512, 0.77512, 0.98621, 0.98621, 0.98621, 0.98621, 0.95961, 0.92222, 0.90637, 0.90637, 0.90637, 0.90637, 0.90637, 1.02058, 0.90251, 0.90699, 0.90699, 0.90699, 0.90699, 0.85458, 0.83659, 0.94951, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.85811, 0.78216, 0.90083, 0.90083, 0.90083, 0.90083, 0.95381, 0.95381, 0.95381, 0.95381, 0.9135, 0.92168, 0.91513, 0.91513, 0.91513, 0.91513, 0.91513, 1.08595, 0.91677, 0.91677, 0.91677, 0.91677, 0.91677, 0.89364, 0.92332, 0.89364, 0.85576, 0.99613, 0.85576, 0.99613, 0.85576, 0.99613, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.94299, 0.76783, 0.95961, 0.91677, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.86523, 0.9135, 0.86523, 0.9135, 0.86523, 0.9135, 1, 1, 0.92222, 0.92168, 0.92222, 0.92168, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.86036, 0.97096, 0.71743, 0.98981, 1, 1, 0.95298, 0.79726, 0.95381, 1, 1, 0.79726, 0.6894, 0.79726, 0.74321, 0.81691, 1.0006, 0.92222, 0.92168, 1, 1, 0.92222, 0.92168, 0.79464, 0.92098, 0.92168, 0.90637, 0.91513, 0.90637, 0.91513, 0.90637, 0.91513, 0.909, 0.87514, 0.80729, 0.95077, 1, 1, 0.80729, 0.95077, 0.76463, 0.748, 0.76463, 0.748, 1, 1, 0.76463, 0.748, 1, 1, 0.86275, 0.72651, 0.86275, 1.04502, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.9154, 0.94236, 0.85458, 0.89364, 0.85458, 0.90531, 0.9, 0.90531, 0.9, 0.90531, 0.9, 1, 0.97276, 0.85576, 0.99613, 0.845, 0.85811, 0.90251, 0.91677, 1, 1, 0.86275, 1.04502, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.00899, 1.30628, 0.85576, 0.80178, 0.66862, 0.7927, 0.69323, 0.88127, 0.72459, 0.89711, 0.95381, 0.85576, 0.80591, 0.7805, 0.94729, 0.77512, 0.90531, 0.92222, 0.90637, 0.98621, 0.81698, 0.92655, 0.98558, 0.92222, 0.85359, 0.90637, 0.90976, 0.83809, 0.94523, 0.86275, 0.83509, 0.93157, 0.85308, 0.83392, 0.92346, 0.98621, 0.83509, 0.92886, 0.91324, 0.92168, 0.95381, 0.90646, 0.92886, 0.90557, 0.86847, 0.90276, 0.91324, 0.86842, 0.92168, 0.99531, 0.95381, 0.9224, 0.85408, 0.92699, 0.86847, 1.0051, 0.91513, 0.80487, 0.93481, 1, 0.88159, 1.05214, 0.90646, 0.97355, 0.81539, 0.89398, 0.85923, 0.95381, 0.90646, 0.91513, 0.90646, 0.85923, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9154, 0.94236, 0.9154, 0.94236, 0.9154, 0.94236, 0.85458, 0.89364, 0.96694, 1, 0.89903, 1, 1, 1, 0.91782, 0.91782, 0.91782, 1, 0.896, 0.896, 0.896, 0.9332, 0.9332, 0.95973, 1, 1.26, 1, 1, 0.80479, 0.80178, 1, 1, 0.85633, 1, 1, 1, 1, 0.97276, 1, 1, 1, 0.698, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.14542, 1, 0.79199, 0.78694, 1.02058, 1.03493, 1.05486, 1, 1, 1.23026, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.20006, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        w.MyriadProBoldItalicFactors = F;
        const C = {
          lineHeight: 1.2,
          lineGap: 0.2
        };
        w.MyriadProBoldItalicMetrics = C;
        const e = [1.36898, 1, 1, 0.65507, 0.84943, 0.85639, 0.88465, 0.88465, 0.86936, 0.88307, 0.86948, 0.85283, 0.85283, 1.06383, 1.02058, 0.75945, 0.9219, 0.75945, 1.17337, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.75945, 0.75945, 1.02058, 1.02058, 1.02058, 0.69046, 0.70926, 0.85158, 0.77812, 0.76852, 0.89591, 0.70466, 0.76125, 0.80094, 0.86822, 0.83864, 0.728, 0.77212, 0.79475, 0.93637, 0.87514, 0.8588, 0.76013, 0.8588, 0.72421, 0.69866, 0.77598, 0.85991, 0.80811, 0.87832, 0.78112, 0.77512, 0.8562, 1.0222, 1.18417, 1.0222, 1.27014, 0.89903, 1.15012, 0.93859, 0.94399, 0.846, 0.94399, 0.81453, 1.0186, 0.94219, 0.96017, 1.03075, 1.02175, 0.912, 1.03075, 0.96998, 0.96017, 0.93859, 0.94399, 0.94399, 0.95493, 0.746, 1.12658, 0.94578, 0.91, 0.979, 0.882, 0.882, 0.83, 0.85034, 0.83537, 0.85034, 1.02058, 0.70869, 0.88465, 0.88465, 0.88465, 0.88465, 0.83537, 0.90083, 1.15012, 0.9161, 0.94565, 0.73541, 1.02058, 0.53609, 0.69353, 0.79519, 1.08595, 1, 1, 1.15012, 1, 0.91974, 0.75945, 1.15012, 1, 0.9446, 0.73361, 0.9005, 0.9005, 0.9005, 0.62864, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.773, 0.76852, 0.70466, 0.70466, 0.70466, 0.70466, 0.83864, 0.83864, 0.83864, 0.83864, 0.90561, 0.87514, 0.8588, 0.8588, 0.8588, 0.8588, 0.8588, 1.02058, 0.85751, 0.85991, 0.85991, 0.85991, 0.85991, 0.77512, 0.76013, 0.88075, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.8075, 0.846, 0.81453, 0.81453, 0.81453, 0.81453, 0.82424, 0.82424, 0.82424, 0.82424, 0.9278, 0.96017, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 1.08595, 0.8562, 0.94578, 0.94578, 0.94578, 0.94578, 0.882, 0.94578, 0.882, 0.85158, 0.93859, 0.85158, 0.93859, 0.85158, 0.93859, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.89591, 0.8544, 0.90561, 0.94399, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.80094, 0.94219, 0.80094, 0.94219, 0.80094, 0.94219, 1, 1, 0.86822, 0.96017, 0.86822, 0.96017, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 1.03075, 0.83864, 0.82424, 0.81402, 1.02738, 0.728, 1.02175, 1, 1, 0.912, 0.79475, 1.03075, 1, 1, 0.79475, 0.83911, 0.79475, 0.66266, 0.80553, 1.06676, 0.87514, 0.96017, 1, 1, 0.87514, 0.96017, 0.86865, 0.87396, 0.96017, 0.8588, 0.93859, 0.8588, 0.93859, 0.8588, 0.93859, 0.867, 0.84759, 0.72421, 0.95493, 1, 1, 0.72421, 0.95493, 0.69866, 0.746, 0.69866, 0.746, 1, 1, 0.69866, 0.746, 1, 1, 0.77598, 0.88417, 0.77598, 1.12658, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.87832, 0.979, 0.77512, 0.882, 0.77512, 0.8562, 0.83, 0.8562, 0.83, 0.8562, 0.83, 1, 0.88465, 0.85158, 0.93859, 0.773, 0.8075, 0.85751, 0.8562, 1, 1, 0.77598, 1.12658, 1.15012, 1.15012, 1.15012, 1.15012, 1.15012, 1.15313, 1.15012, 1.15012, 1.15012, 1.08106, 1.03901, 0.85158, 0.77025, 0.62264, 0.7646, 0.65351, 0.86026, 0.69461, 0.89947, 1.03075, 0.85158, 0.77812, 0.76449, 0.88836, 0.70466, 0.8562, 0.86822, 0.8588, 0.83864, 0.77212, 0.85308, 0.93637, 0.87514, 0.82352, 0.8588, 0.85701, 0.76013, 0.89058, 0.77598, 0.8156, 0.82565, 0.78112, 0.77899, 0.89386, 0.83864, 0.8156, 0.9486, 0.92388, 0.96186, 1.03075, 0.91123, 0.9486, 0.93298, 0.878, 0.93942, 0.92388, 0.84596, 0.96186, 0.95119, 1.03075, 0.922, 0.88787, 0.95829, 0.88, 0.93559, 0.93859, 0.78815, 0.93758, 1, 0.89217, 1.03737, 0.91123, 0.93969, 0.77487, 0.85769, 0.86799, 1.03075, 0.91123, 0.93859, 0.91123, 0.86799, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87832, 0.979, 0.87832, 0.979, 0.87832, 0.979, 0.77512, 0.882, 0.9219, 1, 0.89903, 1, 1, 1, 0.87321, 0.87321, 0.87321, 1, 1.027, 1.027, 1.027, 0.86847, 0.86847, 0.79121, 1, 1.124, 1, 1, 0.73572, 0.73572, 1, 1, 0.85034, 1, 1, 1, 1, 0.88465, 1, 1, 1, 0.669, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04828, 1, 0.74948, 0.75187, 1.02058, 0.98391, 1.02119, 1, 1, 1.06233, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05233, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        w.MyriadProItalicFactors = e;
        const t = {
          lineHeight: 1.2,
          lineGap: 0.2
        };
        w.MyriadProItalicMetrics = t;
        const l = [1.36898, 1, 1, 0.76305, 0.82784, 0.94935, 0.89364, 0.92241, 0.89073, 0.90706, 0.98472, 0.85283, 0.85283, 1.0664, 1.02058, 0.74505, 0.9219, 0.74505, 1.23456, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.74505, 0.74505, 1.02058, 1.02058, 1.02058, 0.73002, 0.72601, 0.91755, 0.8126, 0.80314, 0.92222, 0.73764, 0.79726, 0.83051, 0.90284, 0.86023, 0.74, 0.8126, 0.84869, 0.96518, 0.91115, 0.8858, 0.79761, 0.8858, 0.74498, 0.73914, 0.81363, 0.89591, 0.83659, 0.89633, 0.85608, 0.8111, 0.90531, 1.0222, 1.22736, 1.0222, 1.27014, 0.89903, 0.90088, 0.86667, 1.0231, 0.896, 1.01411, 0.90083, 1.05099, 1.00512, 0.99793, 1.05326, 1.09377, 0.938, 1.06226, 1.00119, 0.99793, 0.98714, 1.0231, 1.01231, 0.98196, 0.792, 1.19137, 0.99074, 0.962, 1.01915, 0.926, 0.942, 0.856, 0.85034, 0.92006, 0.85034, 1.02058, 0.69067, 0.92241, 0.92241, 0.92241, 0.92241, 0.92006, 0.9332, 0.90088, 0.91882, 0.93484, 0.75339, 1.02058, 0.56866, 0.54324, 0.79519, 1.08595, 1, 1, 0.90088, 1, 0.95325, 0.74505, 0.90088, 1, 0.97198, 0.75339, 0.91009, 0.91009, 0.91009, 0.66466, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.788, 0.80314, 0.73764, 0.73764, 0.73764, 0.73764, 0.86023, 0.86023, 0.86023, 0.86023, 0.92915, 0.91115, 0.8858, 0.8858, 0.8858, 0.8858, 0.8858, 1.02058, 0.8858, 0.89591, 0.89591, 0.89591, 0.89591, 0.8111, 0.79611, 0.89713, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86936, 0.896, 0.90083, 0.90083, 0.90083, 0.90083, 0.84224, 0.84224, 0.84224, 0.84224, 0.97276, 0.99793, 0.98714, 0.98714, 0.98714, 0.98714, 0.98714, 1.08595, 0.89876, 0.99074, 0.99074, 0.99074, 0.99074, 0.942, 1.0231, 0.942, 0.91755, 0.86667, 0.91755, 0.86667, 0.91755, 0.86667, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.92222, 0.93372, 0.92915, 1.01411, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.83051, 1.00512, 0.83051, 1.00512, 0.83051, 1.00512, 1, 1, 0.90284, 0.99793, 0.90976, 0.99793, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 1.05326, 0.86023, 0.84224, 0.82873, 1.07469, 0.74, 1.09377, 1, 1, 0.938, 0.84869, 1.06226, 1, 1, 0.84869, 0.83704, 0.84869, 0.81441, 0.85588, 1.08927, 0.91115, 0.99793, 1, 1, 0.91115, 0.99793, 0.91887, 0.90991, 0.99793, 0.8858, 0.98714, 0.8858, 0.98714, 0.8858, 0.98714, 0.894, 0.91434, 0.74498, 0.98196, 1, 1, 0.74498, 0.98196, 0.73914, 0.792, 0.73914, 0.792, 1, 1, 0.73914, 0.792, 1, 1, 0.81363, 0.904, 0.81363, 1.19137, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89633, 1.01915, 0.8111, 0.942, 0.8111, 0.90531, 0.856, 0.90531, 0.856, 0.90531, 0.856, 1, 0.92241, 0.91755, 0.86667, 0.788, 0.86936, 0.8858, 0.89876, 1, 1, 0.81363, 1.19137, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90388, 1.03901, 0.92138, 0.78105, 0.7154, 0.86169, 0.80513, 0.94007, 0.82528, 0.98612, 1.06226, 0.91755, 0.8126, 0.81884, 0.92819, 0.73764, 0.90531, 0.90284, 0.8858, 0.86023, 0.8126, 0.91172, 0.96518, 0.91115, 0.83089, 0.8858, 0.87791, 0.79761, 0.89297, 0.81363, 0.88157, 0.89992, 0.85608, 0.81992, 0.94307, 0.86023, 0.88157, 0.95308, 0.98699, 0.99793, 1.06226, 0.95817, 0.95308, 0.97358, 0.928, 0.98088, 0.98699, 0.92761, 0.99793, 0.96017, 1.06226, 0.986, 0.944, 0.95978, 0.938, 0.96705, 0.98714, 0.80442, 0.98972, 1, 0.89762, 1.04552, 0.95817, 0.99007, 0.87064, 0.91879, 0.88888, 1.06226, 0.95817, 0.98714, 0.95817, 0.88888, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89633, 1.01915, 0.89633, 1.01915, 0.89633, 1.01915, 0.8111, 0.942, 0.9219, 1, 0.89903, 1, 1, 1, 0.93173, 0.93173, 0.93173, 1, 1.06304, 1.06304, 1.06904, 0.89903, 0.89903, 0.80549, 1, 1.156, 1, 1, 0.76575, 0.76575, 1, 1, 0.72458, 1, 1, 1, 1, 0.92241, 1, 1, 1, 0.619, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.07257, 1, 0.74705, 0.71119, 1.02058, 1.024, 1.02119, 1, 1, 1.1536, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05638, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        w.MyriadProRegularFactors = l;
        const j = {
          lineHeight: 1.2,
          lineGap: 0.2
        };
        w.MyriadProRegularMetrics = j;
      },
      /* 56 */
      /***/
      (fe, w) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.SegoeuiRegularMetrics = w.SegoeuiRegularFactors = w.SegoeuiItalicMetrics = w.SegoeuiItalicFactors = w.SegoeuiBoldMetrics = w.SegoeuiBoldItalicMetrics = w.SegoeuiBoldItalicFactors = w.SegoeuiBoldFactors = void 0;
        const V = [1.76738, 1, 1, 0.99297, 0.9824, 1.04016, 1.06497, 1.03424, 0.97529, 1.17647, 1.23203, 1.1085, 1.1085, 1.16939, 1.2107, 0.9754, 1.21408, 0.9754, 1.59578, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 0.81378, 0.81378, 1.2107, 1.2107, 1.2107, 0.71703, 0.97847, 0.97363, 0.88776, 0.8641, 1.02096, 0.79795, 0.85132, 0.914, 1.06085, 1.1406, 0.8007, 0.89858, 0.83693, 1.14889, 1.09398, 0.97489, 0.92094, 0.97489, 0.90399, 0.84041, 0.95923, 1.00135, 1, 1.06467, 0.98243, 0.90996, 0.99361, 1.1085, 1.56942, 1.1085, 1.2107, 0.74627, 0.94282, 0.96752, 1.01519, 0.86304, 1.01359, 0.97278, 1.15103, 1.01359, 0.98561, 1.02285, 1.02285, 1.00527, 1.02285, 1.0302, 0.99041, 1.0008, 1.01519, 1.01359, 1.02258, 0.79104, 1.16862, 0.99041, 0.97454, 1.02511, 0.99298, 0.96752, 0.95801, 0.94856, 1.16579, 0.94856, 1.2107, 0.9824, 1.03424, 1.03424, 1, 1.03424, 1.16579, 0.8727, 1.3871, 1.18622, 1.10818, 1.04478, 1.2107, 1.18622, 0.75155, 0.94994, 1.28826, 1.21408, 1.21408, 0.91056, 1, 0.91572, 0.9754, 0.64663, 1.18328, 1.24866, 1.04478, 1.14169, 1.15749, 1.17389, 0.71703, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.93506, 0.8641, 0.79795, 0.79795, 0.79795, 0.79795, 1.1406, 1.1406, 1.1406, 1.1406, 1.02096, 1.09398, 0.97426, 0.97426, 0.97426, 0.97426, 0.97426, 1.2107, 0.97489, 1.00135, 1.00135, 1.00135, 1.00135, 0.90996, 0.92094, 1.02798, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.93136, 0.86304, 0.97278, 0.97278, 0.97278, 0.97278, 1.02285, 1.02285, 1.02285, 1.02285, 0.97122, 0.99041, 1, 1, 1, 1, 1, 1.28826, 1.0008, 0.99041, 0.99041, 0.99041, 0.99041, 0.96752, 1.01519, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 1.02096, 1.03057, 1.02096, 1.03517, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.914, 1.01359, 0.914, 1.01359, 0.914, 1.01359, 1, 1, 1.06085, 0.98561, 1.06085, 1.00879, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 0.97138, 1.08692, 0.8007, 1.02285, 1, 1, 1.00527, 0.83693, 1.02285, 1, 1, 0.83693, 0.9455, 0.83693, 0.90418, 0.83693, 1.13005, 1.09398, 0.99041, 1, 1, 1.09398, 0.99041, 0.96692, 1.09251, 0.99041, 0.97489, 1.0008, 0.97489, 1.0008, 0.97489, 1.0008, 0.93994, 0.97931, 0.90399, 1.02258, 1, 1, 0.90399, 1.02258, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 1, 1, 0.95923, 1.07034, 0.95923, 1.16862, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.06467, 1.02511, 0.90996, 0.96752, 0.90996, 0.99361, 0.95801, 0.99361, 0.95801, 0.99361, 0.95801, 1.07733, 1.03424, 0.97363, 0.96752, 0.93506, 0.93136, 0.97489, 1.0008, 1, 1, 0.95923, 1.16862, 1.15103, 1.15103, 1.01173, 1.03959, 0.75953, 0.81378, 0.79912, 1.15103, 1.21994, 0.95161, 0.87815, 1.01149, 0.81525, 0.7676, 0.98167, 1.01134, 1.02546, 0.84097, 1.03089, 1.18102, 0.97363, 0.88776, 0.85134, 0.97826, 0.79795, 0.99361, 1.06085, 0.97489, 1.1406, 0.89858, 1.0388, 1.14889, 1.09398, 0.86039, 0.97489, 1.0595, 0.92094, 0.94793, 0.95923, 0.90996, 0.99346, 0.98243, 1.02112, 0.95493, 1.1406, 0.90996, 1.03574, 1.02597, 1.0008, 1.18102, 1.06628, 1.03574, 1.0192, 1.01932, 1.00886, 0.97531, 1.0106, 1.0008, 1.13189, 1.18102, 1.02277, 0.98683, 1.0016, 0.99561, 1.07237, 1.0008, 0.90434, 0.99921, 0.93803, 0.8965, 1.23085, 1.06628, 1.04983, 0.96268, 1.0499, 0.98439, 1.18102, 1.06628, 1.0008, 1.06628, 0.98439, 0.79795, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09466, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.97278, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.02065, 1, 1, 1, 1, 1, 1, 1.06467, 1.02511, 1.06467, 1.02511, 1.06467, 1.02511, 0.90996, 0.96752, 1, 1.21408, 0.89903, 1, 1, 0.75155, 1.04394, 1.04394, 1.04394, 1.04394, 0.98633, 0.98633, 0.98633, 0.73047, 0.73047, 1.20642, 0.91211, 1.25635, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.12454, 0.93503, 1.03424, 1.19687, 1.03424, 1, 1, 1, 0.771, 1, 1, 1.15749, 1.15749, 1.15749, 1.10948, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.16897, 1, 0.96085, 0.90137, 1.2107, 1.18416, 1.13973, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21172, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18874, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.09193, 1.09193, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        w.SegoeuiBoldFactors = V;
        const n = {
          lineHeight: 1.33008,
          lineGap: 0
        };
        w.SegoeuiBoldMetrics = n;
        const F = [1.76738, 1, 1, 0.98946, 1.03959, 1.04016, 1.02809, 1.036, 0.97639, 1.10953, 1.23203, 1.11144, 1.11144, 1.16939, 1.21237, 0.9754, 1.21261, 0.9754, 1.59754, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 0.81378, 0.81378, 1.21237, 1.21237, 1.21237, 0.73541, 0.97847, 0.97363, 0.89723, 0.87897, 1.0426, 0.79429, 0.85292, 0.91149, 1.05815, 1.1406, 0.79631, 0.90128, 0.83853, 1.04396, 1.10615, 0.97552, 0.94436, 0.97552, 0.88641, 0.80527, 0.96083, 1.00135, 1, 1.06777, 0.9817, 0.91142, 0.99361, 1.11144, 1.57293, 1.11144, 1.21237, 0.74627, 1.31818, 1.06585, 0.97042, 0.83055, 0.97042, 0.93503, 1.1261, 0.97042, 0.97922, 1.14236, 0.94552, 1.01054, 1.14236, 1.02471, 0.97922, 0.94165, 0.97042, 0.97042, 1.0276, 0.78929, 1.1261, 0.97922, 0.95874, 1.02197, 0.98507, 0.96752, 0.97168, 0.95107, 1.16579, 0.95107, 1.21237, 1.03959, 1.036, 1.036, 1, 1.036, 1.16579, 0.87357, 1.31818, 1.18754, 1.26781, 1.05356, 1.21237, 1.18622, 0.79487, 0.94994, 1.29004, 1.24047, 1.24047, 1.31818, 1, 0.91484, 0.9754, 1.31818, 1.1349, 1.24866, 1.05356, 1.13934, 1.15574, 1.17389, 0.73541, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.94385, 0.87897, 0.79429, 0.79429, 0.79429, 0.79429, 1.1406, 1.1406, 1.1406, 1.1406, 1.0426, 1.10615, 0.97552, 0.97552, 0.97552, 0.97552, 0.97552, 1.21237, 0.97552, 1.00135, 1.00135, 1.00135, 1.00135, 0.91142, 0.94436, 0.98721, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 0.96705, 0.83055, 0.93503, 0.93503, 0.93503, 0.93503, 1.14236, 1.14236, 1.14236, 1.14236, 0.93125, 0.97922, 0.94165, 0.94165, 0.94165, 0.94165, 0.94165, 1.29004, 0.94165, 0.97922, 0.97922, 0.97922, 0.97922, 0.96752, 0.97042, 0.96752, 0.97363, 1.06585, 0.97363, 1.06585, 0.97363, 1.06585, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 1.0426, 1.0033, 1.0426, 0.97042, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.91149, 0.97042, 0.91149, 0.97042, 0.91149, 0.97042, 1, 1, 1.05815, 0.97922, 1.05815, 0.97922, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 0.97441, 1.04302, 0.79631, 1.01582, 1, 1, 1.01054, 0.83853, 1.14236, 1, 1, 0.83853, 1.09125, 0.83853, 0.90418, 0.83853, 1.19508, 1.10615, 0.97922, 1, 1, 1.10615, 0.97922, 1.01034, 1.10466, 0.97922, 0.97552, 0.94165, 0.97552, 0.94165, 0.97552, 0.94165, 0.91602, 0.91981, 0.88641, 1.0276, 1, 1, 0.88641, 1.0276, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 1, 1, 0.96083, 1.05403, 0.95923, 1.16862, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.06777, 1.02197, 0.91142, 0.96752, 0.91142, 0.99361, 0.97168, 0.99361, 0.97168, 0.99361, 0.97168, 1.23199, 1.036, 0.97363, 1.06585, 0.94385, 0.96705, 0.97552, 0.94165, 1, 1, 0.96083, 1.1261, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 0.95161, 1.27126, 1.00811, 0.83284, 0.77702, 0.99137, 0.95253, 1.0347, 0.86142, 1.07205, 1.14236, 0.97363, 0.89723, 0.86869, 1.09818, 0.79429, 0.99361, 1.05815, 0.97552, 1.1406, 0.90128, 1.06662, 1.04396, 1.10615, 0.84918, 0.97552, 1.04694, 0.94436, 0.98015, 0.96083, 0.91142, 1.00356, 0.9817, 1.01945, 0.98999, 1.1406, 0.91142, 1.04961, 0.9898, 1.00639, 1.14236, 1.07514, 1.04961, 0.99607, 1.02897, 1.008, 0.9898, 0.95134, 1.00639, 1.11121, 1.14236, 1.00518, 0.97981, 1.02186, 1, 1.08578, 0.94165, 0.99314, 0.98387, 0.93028, 0.93377, 1.35125, 1.07514, 1.10687, 0.93491, 1.04232, 1.00351, 1.14236, 1.07514, 0.94165, 1.07514, 1.00351, 0.79429, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09097, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.93503, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96609, 1, 1, 1, 1, 1, 1, 1.06777, 1.02197, 1.06777, 1.02197, 1.06777, 1.02197, 0.91142, 0.96752, 1, 1.21261, 0.89903, 1, 1, 0.75155, 1.04745, 1.04745, 1.04745, 1.04394, 0.98633, 0.98633, 0.98633, 0.72959, 0.72959, 1.20502, 0.91406, 1.26514, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.09125, 0.93327, 1.03336, 1.16541, 1.036, 1, 1, 1, 0.771, 1, 1, 1.15574, 1.15574, 1.15574, 1.15574, 0.86364, 0.94434, 0.86279, 0.94434, 0.86224, 1, 1, 1.16798, 1, 0.96085, 0.90068, 1.21237, 1.18416, 1.13904, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21339, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18775, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.13269, 1.13269, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        w.SegoeuiBoldItalicFactors = F;
        const C = {
          lineHeight: 1.33008,
          lineGap: 0
        };
        w.SegoeuiBoldItalicMetrics = C;
        const e = [1.76738, 1, 1, 0.98946, 1.14763, 1.05365, 1.06234, 0.96927, 0.92586, 1.15373, 1.18414, 0.91349, 0.91349, 1.07403, 1.17308, 0.78383, 1.20088, 0.78383, 1.42531, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78383, 0.78383, 1.17308, 1.17308, 1.17308, 0.77349, 0.94565, 0.94729, 0.85944, 0.88506, 0.9858, 0.74817, 0.80016, 0.88449, 0.98039, 0.95782, 0.69238, 0.89898, 0.83231, 0.98183, 1.03989, 0.96924, 0.86237, 0.96924, 0.80595, 0.74524, 0.86091, 0.95402, 0.94143, 0.98448, 0.8858, 0.83089, 0.93285, 1.0949, 1.39016, 1.0949, 1.45994, 0.74627, 1.04839, 0.97454, 0.97454, 0.87207, 0.97454, 0.87533, 1.06151, 0.97454, 1.00176, 1.16484, 1.08132, 0.98047, 1.16484, 1.02989, 1.01054, 0.96225, 0.97454, 0.97454, 1.06598, 0.79004, 1.16344, 1.00351, 0.94629, 0.9973, 0.91016, 0.96777, 0.9043, 0.91082, 0.92481, 0.91082, 1.17308, 0.95748, 0.96927, 0.96927, 1, 0.96927, 0.92481, 0.80597, 1.04839, 1.23393, 1.1781, 0.9245, 1.17308, 1.20808, 0.63218, 0.94261, 1.24822, 1.09971, 1.09971, 1.04839, 1, 0.85273, 0.78032, 1.04839, 1.09971, 1.22326, 0.9245, 1.09836, 1.13525, 1.15222, 0.70424, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.85498, 0.88506, 0.74817, 0.74817, 0.74817, 0.74817, 0.95782, 0.95782, 0.95782, 0.95782, 0.9858, 1.03989, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.17308, 0.96924, 0.95402, 0.95402, 0.95402, 0.95402, 0.83089, 0.86237, 0.88409, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.92916, 0.87207, 0.87533, 0.87533, 0.87533, 0.87533, 0.93146, 0.93146, 0.93146, 0.93146, 0.93854, 1.01054, 0.96225, 0.96225, 0.96225, 0.96225, 0.96225, 1.24822, 0.8761, 1.00351, 1.00351, 1.00351, 1.00351, 0.96777, 0.97454, 0.96777, 0.94729, 0.97454, 0.94729, 0.97454, 0.94729, 0.97454, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.9858, 0.95391, 0.9858, 0.97454, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.88449, 0.97454, 0.88449, 0.97454, 0.88449, 0.97454, 1, 1, 0.98039, 1.00176, 0.98039, 1.00176, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 1.16484, 0.95782, 0.93146, 0.84421, 1.12761, 0.69238, 1.08132, 1, 1, 0.98047, 0.83231, 1.16484, 1, 1, 0.84723, 1.04861, 0.84723, 0.78755, 0.83231, 1.23736, 1.03989, 1.01054, 1, 1, 1.03989, 1.01054, 0.9857, 1.03849, 1.01054, 0.96924, 0.96225, 0.96924, 0.96225, 0.96924, 0.96225, 0.92383, 0.90171, 0.80595, 1.06598, 1, 1, 0.80595, 1.06598, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 1, 1, 0.86091, 1.02759, 0.85771, 1.16344, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.98448, 0.9973, 0.83089, 0.96777, 0.83089, 0.93285, 0.9043, 0.93285, 0.9043, 0.93285, 0.9043, 1.31868, 0.96927, 0.94729, 0.97454, 0.85498, 0.92916, 0.96924, 0.8761, 1, 1, 0.86091, 1.16344, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 0.81965, 0.81965, 0.94729, 0.78032, 0.71022, 0.90883, 0.84171, 0.99877, 0.77596, 1.05734, 1.2, 0.94729, 0.85944, 0.82791, 0.9607, 0.74817, 0.93285, 0.98039, 0.96924, 0.95782, 0.89898, 0.98316, 0.98183, 1.03989, 0.78614, 0.96924, 0.97642, 0.86237, 0.86075, 0.86091, 0.83089, 0.90082, 0.8858, 0.97296, 1.01284, 0.95782, 0.83089, 1.0976, 1.04, 1.03342, 1.2, 1.0675, 1.0976, 0.98205, 1.03809, 1.05097, 1.04, 0.95364, 1.03342, 1.05401, 1.2, 1.02148, 1.0119, 1.04724, 1.0127, 1.02732, 0.96225, 0.8965, 0.97783, 0.93574, 0.94818, 1.30679, 1.0675, 1.11826, 0.99821, 1.0557, 1.0326, 1.2, 1.0675, 0.96225, 1.0675, 1.0326, 0.74817, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03754, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87533, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.98705, 1, 1, 1, 1, 1, 1, 0.98448, 0.9973, 0.98448, 0.9973, 0.98448, 0.9973, 0.83089, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 0.94945, 0.94945, 0.94945, 0.94945, 1.12317, 1.12317, 1.12317, 0.67603, 0.67603, 1.15621, 0.73584, 1.21191, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87709, 0.96927, 1.01473, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.09836, 1.09836, 1.09836, 1.01522, 0.86321, 0.94434, 0.8649, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86438, 1.17308, 1.18416, 1.14589, 0.69825, 0.97622, 1.96791, 1.24822, 1.24822, 1.17308, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.17984, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10742, 1.10742, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        w.SegoeuiItalicFactors = e;
        const t = {
          lineHeight: 1.33008,
          lineGap: 0
        };
        w.SegoeuiItalicMetrics = t;
        const l = [1.76738, 1, 1, 0.98594, 1.02285, 1.10454, 1.06234, 0.96927, 0.92037, 1.19985, 1.2046, 0.90616, 0.90616, 1.07152, 1.1714, 0.78032, 1.20088, 0.78032, 1.40246, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78032, 0.78032, 1.1714, 1.1714, 1.1714, 0.80597, 0.94084, 0.96706, 0.85944, 0.85734, 0.97093, 0.75842, 0.79936, 0.88198, 0.9831, 0.95782, 0.71387, 0.86969, 0.84636, 1.07796, 1.03584, 0.96924, 0.83968, 0.96924, 0.82826, 0.79649, 0.85771, 0.95132, 0.93119, 0.98965, 0.88433, 0.8287, 0.93365, 1.08612, 1.3638, 1.08612, 1.45786, 0.74627, 0.80499, 0.91484, 1.05707, 0.92383, 1.05882, 0.9403, 1.12654, 1.05882, 1.01756, 1.09011, 1.09011, 0.99414, 1.09011, 1.034, 1.01756, 1.05356, 1.05707, 1.05882, 1.04399, 0.84863, 1.21968, 1.01756, 0.95801, 1.00068, 0.91797, 0.96777, 0.9043, 0.90351, 0.92105, 0.90351, 1.1714, 0.85337, 0.96927, 0.96927, 0.99912, 0.96927, 0.92105, 0.80597, 1.2434, 1.20808, 1.05937, 0.90957, 1.1714, 1.20808, 0.75155, 0.94261, 1.24644, 1.09971, 1.09971, 0.84751, 1, 0.85273, 0.78032, 0.61584, 1.05425, 1.17914, 0.90957, 1.08665, 1.11593, 1.14169, 0.73381, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.86035, 0.85734, 0.75842, 0.75842, 0.75842, 0.75842, 0.95782, 0.95782, 0.95782, 0.95782, 0.97093, 1.03584, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.1714, 0.96924, 0.95132, 0.95132, 0.95132, 0.95132, 0.8287, 0.83968, 0.89049, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.93575, 0.92383, 0.9403, 0.9403, 0.9403, 0.9403, 0.8717, 0.8717, 0.8717, 0.8717, 1.00527, 1.01756, 1.05356, 1.05356, 1.05356, 1.05356, 1.05356, 1.24644, 0.95923, 1.01756, 1.01756, 1.01756, 1.01756, 0.96777, 1.05707, 0.96777, 0.96706, 0.91484, 0.96706, 0.91484, 0.96706, 0.91484, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.97093, 1.0969, 0.97093, 1.05882, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.88198, 1.05882, 0.88198, 1.05882, 0.88198, 1.05882, 1, 1, 0.9831, 1.01756, 0.9831, 1.01756, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 1.09011, 0.95782, 0.8717, 0.84784, 1.11551, 0.71387, 1.09011, 1, 1, 0.99414, 0.84636, 1.09011, 1, 1, 0.84636, 1.0536, 0.84636, 0.94298, 0.84636, 1.23297, 1.03584, 1.01756, 1, 1, 1.03584, 1.01756, 1.00323, 1.03444, 1.01756, 0.96924, 1.05356, 0.96924, 1.05356, 0.96924, 1.05356, 0.93066, 0.98293, 0.82826, 1.04399, 1, 1, 0.82826, 1.04399, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 1, 1, 0.85771, 1.17318, 0.85771, 1.21968, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.98965, 1.00068, 0.8287, 0.96777, 0.8287, 0.93365, 0.9043, 0.93365, 0.9043, 0.93365, 0.9043, 1.08571, 0.96927, 0.96706, 0.91484, 0.86035, 0.93575, 0.96924, 0.95923, 1, 1, 0.85771, 1.21968, 1.11437, 1.11437, 0.93109, 0.91202, 0.60411, 0.84164, 0.55572, 1.01173, 0.97361, 0.81818, 0.81818, 0.96635, 0.78032, 0.72727, 0.92366, 0.98601, 1.03405, 0.77968, 1.09799, 1.2, 0.96706, 0.85944, 0.85638, 0.96491, 0.75842, 0.93365, 0.9831, 0.96924, 0.95782, 0.86969, 0.94152, 1.07796, 1.03584, 0.78437, 0.96924, 0.98715, 0.83968, 0.83491, 0.85771, 0.8287, 0.94492, 0.88433, 0.9287, 1.0098, 0.95782, 0.8287, 1.0625, 0.98248, 1.03424, 1.2, 1.01071, 1.0625, 0.95246, 1.03809, 1.04912, 0.98248, 1.00221, 1.03424, 1.05443, 1.2, 1.04785, 0.99609, 1.00169, 1.05176, 0.99346, 1.05356, 0.9087, 1.03004, 0.95542, 0.93117, 1.23362, 1.01071, 1.07831, 1.02512, 1.05205, 1.03502, 1.2, 1.01071, 1.05356, 1.01071, 1.03502, 0.75842, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03719, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9403, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04021, 1, 1, 1, 1, 1, 1, 0.98965, 1.00068, 0.98965, 1.00068, 0.98965, 1.00068, 0.8287, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 1.03077, 1.03077, 1.03077, 1.03077, 1.13196, 1.13196, 1.13196, 0.67428, 0.67428, 1.16039, 0.73291, 1.20996, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87796, 0.96927, 1.01518, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.10539, 1.10539, 1.11358, 1.06967, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86507, 1.1714, 1.18416, 1.14589, 0.69825, 0.97622, 1.9697, 1.24822, 1.24822, 1.17238, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18083, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10938, 1.10938, 1, 1, 1, 1.05425, 1.09971, 1.09971, 1.09971, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        w.SegoeuiRegularFactors = l;
        const j = {
          lineHeight: 1.33008,
          lineGap: 0
        };
        w.SegoeuiRegularMetrics = j;
      },
      /* 57 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.PostScriptEvaluator = w.PostScriptCompiler = w.PDFFunctionFactory = void 0, w.isPDFFunction = O;
        var n = V(4), F = V(2), C = V(58), e = V(5), t = V(59);
        class l {
          constructor({
            xref: p,
            isEvalSupported: S = !0
          }) {
            this.xref = p, this.isEvalSupported = S !== !1;
          }
          create(p) {
            const S = this.getCached(p);
            if (S)
              return S;
            const B = U.parse({
              xref: this.xref,
              isEvalSupported: this.isEvalSupported,
              fn: p instanceof n.Ref ? this.xref.fetch(p) : p
            });
            return this._cache(p, B), B;
          }
          createFromArray(p) {
            const S = this.getCached(p);
            if (S)
              return S;
            const B = U.parseArray({
              xref: this.xref,
              isEvalSupported: this.isEvalSupported,
              fnObj: p instanceof n.Ref ? this.xref.fetch(p) : p
            });
            return this._cache(p, B), B;
          }
          getCached(p) {
            var B;
            let S;
            if (p instanceof n.Ref ? S = p : p instanceof n.Dict ? S = p.objId : p instanceof e.BaseStream && (S = (B = p.dict) == null ? void 0 : B.objId), S) {
              const T = this._localFunctionCache.getByRef(S);
              if (T)
                return T;
            }
            return null;
          }
          _cache(p, S) {
            var T;
            if (!S)
              throw new Error('PDFFunctionFactory._cache - expected "parsedFunction" argument.');
            let B;
            p instanceof n.Ref ? B = p : p instanceof n.Dict ? B = p.objId : p instanceof e.BaseStream && (B = (T = p.dict) == null ? void 0 : T.objId), B && this._localFunctionCache.set(null, B, S);
          }
          get _localFunctionCache() {
            return (0, F.shadow)(this, "_localFunctionCache", new t.LocalFunctionCache());
          }
        }
        w.PDFFunctionFactory = l;
        function j(u) {
          if (!Array.isArray(u))
            return null;
          const p = u.length;
          for (let S = 0; S < p; S++)
            if (typeof u[S] != "number") {
              const B = new Array(p);
              for (let T = 0; T < p; T++)
                B[T] = +u[T];
              return B;
            }
          return u;
        }
        class U {
          static getSampleArray(p, S, B, T) {
            let D, K, _ = 1;
            for (D = 0, K = p.length; D < K; D++)
              _ *= p[D];
            _ *= S;
            const o = new Array(_);
            let m = 0, s = 0;
            const r = 1 / (2 ** B - 1), y = T.getBytes((_ * B + 7) / 8);
            let M = 0;
            for (D = 0; D < _; D++) {
              for (; m < B; )
                s <<= 8, s |= y[M++], m += 8;
              m -= B, o[D] = (s >> m) * r, s &= (1 << m) - 1;
            }
            return o;
          }
          static parse({
            xref: p,
            isEvalSupported: S,
            fn: B
          }) {
            const T = B.dict || B;
            switch (T.get("FunctionType")) {
              case 0:
                return this.constructSampled({
                  xref: p,
                  isEvalSupported: S,
                  fn: B,
                  dict: T
                });
              case 1:
                break;
              case 2:
                return this.constructInterpolated({
                  xref: p,
                  isEvalSupported: S,
                  dict: T
                });
              case 3:
                return this.constructStiched({
                  xref: p,
                  isEvalSupported: S,
                  dict: T
                });
              case 4:
                return this.constructPostScript({
                  xref: p,
                  isEvalSupported: S,
                  fn: B,
                  dict: T
                });
            }
            throw new F.FormatError("Unknown type of function");
          }
          static parseArray({
            xref: p,
            isEvalSupported: S,
            fnObj: B
          }) {
            if (!Array.isArray(B))
              return this.parse({
                xref: p,
                isEvalSupported: S,
                fn: B
              });
            const T = [];
            for (const D of B)
              T.push(this.parse({
                xref: p,
                isEvalSupported: S,
                fn: p.fetchIfRef(D)
              }));
            return function(D, K, _, o) {
              for (let m = 0, s = T.length; m < s; m++)
                T[m](D, K, _, o + m);
            };
          }
          static constructSampled({
            xref: p,
            isEvalSupported: S,
            fn: B,
            dict: T
          }) {
            function D(q) {
              const re = q.length, Z = [];
              let te = 0;
              for (let L = 0; L < re; L += 2)
                Z[te++] = [q[L], q[L + 1]];
              return Z;
            }
            function K(q, re, Z, te, L) {
              return te + (q - re) * ((L - te) / (Z - re));
            }
            let _ = j(T.getArray("Domain")), o = j(T.getArray("Range"));
            if (!_ || !o)
              throw new F.FormatError("No domain or range");
            const m = _.length / 2, s = o.length / 2;
            _ = D(_), o = D(o);
            const r = j(T.getArray("Size")), y = T.get("BitsPerSample"), M = T.get("Order") || 1;
            M !== 1 && (0, F.info)("No support for cubic spline interpolation: " + M);
            let $ = j(T.getArray("Encode"));
            if ($)
              $ = D($);
            else {
              $ = [];
              for (let q = 0; q < m; ++q)
                $.push([0, r[q] - 1]);
            }
            let G = j(T.getArray("Decode"));
            G = G ? D(G) : o;
            const ce = this.getSampleArray(r, s, y, B);
            return function(re, Z, te, L) {
              const X = 1 << m, J = new Float64Array(X), Y = new Uint32Array(X);
              let ae, se;
              for (se = 0; se < X; se++)
                J[se] = 1;
              let Q = s, z = 1;
              for (ae = 0; ae < m; ++ae) {
                const ie = _[ae][0], ne = _[ae][1], W = Math.min(Math.max(re[Z + ae], ie), ne);
                let oe = K(W, ie, ne, $[ae][0], $[ae][1]);
                const ue = r[ae];
                oe = Math.min(Math.max(oe, 0), ue - 1);
                const pe = oe < ue - 1 ? Math.floor(oe) : oe - 1, ve = pe + 1 - oe, Ce = oe - pe, Fe = pe * Q, Pe = Fe + Q;
                for (se = 0; se < X; se++)
                  se & z ? (J[se] *= Ce, Y[se] += Pe) : (J[se] *= ve, Y[se] += Fe);
                Q *= ue, z <<= 1;
              }
              for (se = 0; se < s; ++se) {
                let ie = 0;
                for (ae = 0; ae < X; ae++)
                  ie += ce[Y[ae] + se] * J[ae];
                ie = K(ie, 0, 1, G[se][0], G[se][1]), te[L + se] = Math.min(Math.max(ie, o[se][0]), o[se][1]);
              }
            };
          }
          static constructInterpolated({
            xref: p,
            isEvalSupported: S,
            dict: B
          }) {
            const T = j(B.getArray("C0")) || [0], D = j(B.getArray("C1")) || [1], K = B.get("N"), _ = [];
            for (let m = 0, s = T.length; m < s; ++m)
              _.push(D[m] - T[m]);
            const o = _.length;
            return function(s, r, y, M) {
              const $ = K === 1 ? s[r] : s[r] ** K;
              for (let G = 0; G < o; ++G)
                y[M + G] = T[G] + $ * _[G];
            };
          }
          static constructStiched({
            xref: p,
            isEvalSupported: S,
            dict: B
          }) {
            const T = j(B.getArray("Domain"));
            if (!T)
              throw new F.FormatError("No domain");
            if (T.length / 2 !== 1)
              throw new F.FormatError("Bad domain for stiched function");
            const K = [];
            for (const s of B.get("Functions"))
              K.push(this.parse({
                xref: p,
                isEvalSupported: S,
                fn: p.fetchIfRef(s)
              }));
            const _ = j(B.getArray("Bounds")), o = j(B.getArray("Encode")), m = new Float32Array(1);
            return function(r, y, M, $) {
              const ce = function(Y, ae, se) {
                return Y > se ? Y = se : Y < ae && (Y = ae), Y;
              }(r[y], T[0], T[1]), q = _.length;
              let re;
              for (re = 0; re < q && !(ce < _[re]); ++re)
                ;
              let Z = T[0];
              re > 0 && (Z = _[re - 1]);
              let te = T[1];
              re < _.length && (te = _[re]);
              const L = o[2 * re], X = o[2 * re + 1];
              m[0] = Z === te ? L : L + (ce - Z) * (X - L) / (te - Z), K[re](m, 0, M, $);
            };
          }
          static constructPostScript({
            xref: p,
            isEvalSupported: S,
            fn: B,
            dict: T
          }) {
            const D = j(T.getArray("Domain")), K = j(T.getArray("Range"));
            if (!D)
              throw new F.FormatError("No domain.");
            if (!K)
              throw new F.FormatError("No range.");
            const _ = new C.PostScriptLexer(B), m = new C.PostScriptParser(_).parse();
            if (S && F.FeatureTest.isEvalSupported) {
              const q = new c().compile(m, D, K);
              if (q)
                return new Function("src", "srcOffset", "dest", "destOffset", q);
            }
            (0, F.info)("Unable to compile PS function");
            const s = K.length >> 1, r = D.length >> 1, y = new g(m), M = /* @__PURE__ */ Object.create(null);
            let G = 2048 * 4;
            const ce = new Float32Array(r);
            return function(re, Z, te, L) {
              let X, J, Y = "";
              const ae = ce;
              for (X = 0; X < r; X++)
                J = re[Z + X], ae[X] = J, Y += J + "_";
              const se = M[Y];
              if (se !== void 0) {
                te.set(se, L);
                return;
              }
              const Q = new Float32Array(s), z = y.execute(ae), ie = z.length - s;
              for (X = 0; X < s; X++) {
                J = z[ie + X];
                let ne = K[X * 2];
                J < ne ? J = ne : (ne = K[X * 2 + 1], J > ne && (J = ne)), Q[X] = J;
              }
              G > 0 && (G--, M[Y] = Q), te.set(Q, L);
            };
          }
        }
        function O(u) {
          let p;
          if (u instanceof n.Dict)
            p = u;
          else if (u instanceof e.BaseStream)
            p = u.dict;
          else
            return !1;
          return p.has("FunctionType");
        }
        const N = class N {
          constructor(p) {
            this.stack = p ? Array.from(p) : [];
          }
          push(p) {
            if (this.stack.length >= N.MAX_STACK_SIZE)
              throw new Error("PostScript function stack overflow.");
            this.stack.push(p);
          }
          pop() {
            if (this.stack.length <= 0)
              throw new Error("PostScript function stack underflow.");
            return this.stack.pop();
          }
          copy(p) {
            if (this.stack.length + p >= N.MAX_STACK_SIZE)
              throw new Error("PostScript function stack overflow.");
            const S = this.stack;
            for (let B = S.length - p, T = p - 1; T >= 0; T--, B++)
              S.push(S[B]);
          }
          index(p) {
            this.push(this.stack[this.stack.length - p - 1]);
          }
          roll(p, S) {
            const B = this.stack, T = B.length - p, D = B.length - 1, K = T + (S - Math.floor(S / p) * p);
            for (let _ = T, o = D; _ < o; _++, o--) {
              const m = B[_];
              B[_] = B[o], B[o] = m;
            }
            for (let _ = T, o = K - 1; _ < o; _++, o--) {
              const m = B[_];
              B[_] = B[o], B[o] = m;
            }
            for (let _ = K, o = D; _ < o; _++, o--) {
              const m = B[_];
              B[_] = B[o], B[o] = m;
            }
          }
        };
        Ot(N, "MAX_STACK_SIZE", 100);
        let v = N;
        class g {
          constructor(p) {
            this.operators = p;
          }
          execute(p) {
            const S = new v(p);
            let B = 0;
            const T = this.operators, D = T.length;
            let K, _, o;
            for (; B < D; ) {
              if (K = T[B++], typeof K == "number") {
                S.push(K);
                continue;
              }
              switch (K) {
                case "jz":
                  o = S.pop(), _ = S.pop(), _ || (B = o);
                  break;
                case "j":
                  _ = S.pop(), B = _;
                  break;
                case "abs":
                  _ = S.pop(), S.push(Math.abs(_));
                  break;
                case "add":
                  o = S.pop(), _ = S.pop(), S.push(_ + o);
                  break;
                case "and":
                  o = S.pop(), _ = S.pop(), typeof _ == "boolean" && typeof o == "boolean" ? S.push(_ && o) : S.push(_ & o);
                  break;
                case "atan":
                  o = S.pop(), _ = S.pop(), _ = Math.atan2(_, o) / Math.PI * 180, _ < 0 && (_ += 360), S.push(_);
                  break;
                case "bitshift":
                  o = S.pop(), _ = S.pop(), _ > 0 ? S.push(_ << o) : S.push(_ >> o);
                  break;
                case "ceiling":
                  _ = S.pop(), S.push(Math.ceil(_));
                  break;
                case "copy":
                  _ = S.pop(), S.copy(_);
                  break;
                case "cos":
                  _ = S.pop(), S.push(Math.cos(_ % 360 / 180 * Math.PI));
                  break;
                case "cvi":
                  _ = S.pop() | 0, S.push(_);
                  break;
                case "cvr":
                  break;
                case "div":
                  o = S.pop(), _ = S.pop(), S.push(_ / o);
                  break;
                case "dup":
                  S.copy(1);
                  break;
                case "eq":
                  o = S.pop(), _ = S.pop(), S.push(_ === o);
                  break;
                case "exch":
                  S.roll(2, 1);
                  break;
                case "exp":
                  o = S.pop(), _ = S.pop(), S.push(_ ** o);
                  break;
                case "false":
                  S.push(!1);
                  break;
                case "floor":
                  _ = S.pop(), S.push(Math.floor(_));
                  break;
                case "ge":
                  o = S.pop(), _ = S.pop(), S.push(_ >= o);
                  break;
                case "gt":
                  o = S.pop(), _ = S.pop(), S.push(_ > o);
                  break;
                case "idiv":
                  o = S.pop(), _ = S.pop(), S.push(_ / o | 0);
                  break;
                case "index":
                  _ = S.pop(), S.index(_);
                  break;
                case "le":
                  o = S.pop(), _ = S.pop(), S.push(_ <= o);
                  break;
                case "ln":
                  _ = S.pop(), S.push(Math.log(_));
                  break;
                case "log":
                  _ = S.pop(), S.push(Math.log10(_));
                  break;
                case "lt":
                  o = S.pop(), _ = S.pop(), S.push(_ < o);
                  break;
                case "mod":
                  o = S.pop(), _ = S.pop(), S.push(_ % o);
                  break;
                case "mul":
                  o = S.pop(), _ = S.pop(), S.push(_ * o);
                  break;
                case "ne":
                  o = S.pop(), _ = S.pop(), S.push(_ !== o);
                  break;
                case "neg":
                  _ = S.pop(), S.push(-_);
                  break;
                case "not":
                  _ = S.pop(), typeof _ == "boolean" ? S.push(!_) : S.push(~_);
                  break;
                case "or":
                  o = S.pop(), _ = S.pop(), typeof _ == "boolean" && typeof o == "boolean" ? S.push(_ || o) : S.push(_ | o);
                  break;
                case "pop":
                  S.pop();
                  break;
                case "roll":
                  o = S.pop(), _ = S.pop(), S.roll(_, o);
                  break;
                case "round":
                  _ = S.pop(), S.push(Math.round(_));
                  break;
                case "sin":
                  _ = S.pop(), S.push(Math.sin(_ % 360 / 180 * Math.PI));
                  break;
                case "sqrt":
                  _ = S.pop(), S.push(Math.sqrt(_));
                  break;
                case "sub":
                  o = S.pop(), _ = S.pop(), S.push(_ - o);
                  break;
                case "true":
                  S.push(!0);
                  break;
                case "truncate":
                  _ = S.pop(), _ = _ < 0 ? Math.ceil(_) : Math.floor(_), S.push(_);
                  break;
                case "xor":
                  o = S.pop(), _ = S.pop(), typeof _ == "boolean" && typeof o == "boolean" ? S.push(_ !== o) : S.push(_ ^ o);
                  break;
                default:
                  throw new F.FormatError(`Unknown operator ${K}`);
              }
            }
            return S.stack;
          }
        }
        w.PostScriptEvaluator = g;
        class b {
          constructor(p) {
            this.type = p;
          }
          visit(p) {
            (0, F.unreachable)("abstract method");
          }
        }
        class i extends b {
          constructor(p, S, B) {
            super("args"), this.index = p, this.min = S, this.max = B;
          }
          visit(p) {
            p.visitArgument(this);
          }
        }
        class P extends b {
          constructor(p) {
            super("literal"), this.number = p, this.min = p, this.max = p;
          }
          visit(p) {
            p.visitLiteral(this);
          }
        }
        class d extends b {
          constructor(p, S, B, T, D) {
            super("binary"), this.op = p, this.arg1 = S, this.arg2 = B, this.min = T, this.max = D;
          }
          visit(p) {
            p.visitBinaryOperation(this);
          }
        }
        class A extends b {
          constructor(p, S) {
            super("max"), this.arg = p, this.min = p.min, this.max = S;
          }
          visit(p) {
            p.visitMin(this);
          }
        }
        class I extends b {
          constructor(p, S, B) {
            super("var"), this.index = p, this.min = S, this.max = B;
          }
          visit(p) {
            p.visitVariable(this);
          }
        }
        class E extends b {
          constructor(p, S) {
            super("definition"), this.variable = p, this.arg = S;
          }
          visit(p) {
            p.visitVariableDefinition(this);
          }
        }
        class k {
          constructor() {
            this.parts = [];
          }
          visitArgument(p) {
            this.parts.push("Math.max(", p.min, ", Math.min(", p.max, ", src[srcOffset + ", p.index, "]))");
          }
          visitVariable(p) {
            this.parts.push("v", p.index);
          }
          visitLiteral(p) {
            this.parts.push(p.number);
          }
          visitBinaryOperation(p) {
            this.parts.push("("), p.arg1.visit(this), this.parts.push(" ", p.op, " "), p.arg2.visit(this), this.parts.push(")");
          }
          visitVariableDefinition(p) {
            this.parts.push("var "), p.variable.visit(this), this.parts.push(" = "), p.arg.visit(this), this.parts.push(";");
          }
          visitMin(p) {
            this.parts.push("Math.min("), p.arg.visit(this), this.parts.push(", ", p.max, ")");
          }
          toString() {
            return this.parts.join("");
          }
        }
        function H(u, p) {
          return p.type === "literal" && p.number === 0 ? u : u.type === "literal" && u.number === 0 ? p : p.type === "literal" && u.type === "literal" ? new P(u.number + p.number) : new d("+", u, p, u.min + p.min, u.max + p.max);
        }
        function x(u, p) {
          if (p.type === "literal") {
            if (p.number === 0)
              return new P(0);
            if (p.number === 1)
              return u;
            if (u.type === "literal")
              return new P(u.number * p.number);
          }
          if (u.type === "literal") {
            if (u.number === 0)
              return new P(0);
            if (u.number === 1)
              return p;
          }
          const S = Math.min(u.min * p.min, u.min * p.max, u.max * p.min, u.max * p.max), B = Math.max(u.min * p.min, u.min * p.max, u.max * p.min, u.max * p.max);
          return new d("*", u, p, S, B);
        }
        function R(u, p) {
          if (p.type === "literal") {
            if (p.number === 0)
              return u;
            if (u.type === "literal")
              return new P(u.number - p.number);
          }
          return p.type === "binary" && p.op === "-" && u.type === "literal" && u.number === 1 && p.arg1.type === "literal" && p.arg1.number === 1 ? p.arg2 : new d("-", u, p, u.min - p.max, u.max - p.min);
        }
        function f(u, p) {
          return u.min >= p ? new P(p) : u.max <= p ? u : new A(u, p);
        }
        class c {
          compile(p, S, B) {
            const T = [], D = [], K = S.length >> 1, _ = B.length >> 1;
            let o = 0, m, s, r, y, M, $, G, ce;
            for (let re = 0; re < K; re++)
              T.push(new i(re, S[re * 2], S[re * 2 + 1]));
            for (let re = 0, Z = p.length; re < Z; re++) {
              if (ce = p[re], typeof ce == "number") {
                T.push(new P(ce));
                continue;
              }
              switch (ce) {
                case "add":
                  if (T.length < 2)
                    return null;
                  y = T.pop(), r = T.pop(), T.push(H(r, y));
                  break;
                case "cvr":
                  if (T.length < 1)
                    return null;
                  break;
                case "mul":
                  if (T.length < 2)
                    return null;
                  y = T.pop(), r = T.pop(), T.push(x(r, y));
                  break;
                case "sub":
                  if (T.length < 2)
                    return null;
                  y = T.pop(), r = T.pop(), T.push(R(r, y));
                  break;
                case "exch":
                  if (T.length < 2)
                    return null;
                  M = T.pop(), $ = T.pop(), T.push(M, $);
                  break;
                case "pop":
                  if (T.length < 1)
                    return null;
                  T.pop();
                  break;
                case "index":
                  if (T.length < 1 || (r = T.pop(), r.type !== "literal") || (m = r.number, m < 0 || !Number.isInteger(m) || T.length < m))
                    return null;
                  if (M = T[T.length - m - 1], M.type === "literal" || M.type === "var") {
                    T.push(M);
                    break;
                  }
                  G = new I(o++, M.min, M.max), T[T.length - m - 1] = G, T.push(G), D.push(new E(G, M));
                  break;
                case "dup":
                  if (T.length < 1)
                    return null;
                  if (typeof p[re + 1] == "number" && p[re + 2] === "gt" && p[re + 3] === re + 7 && p[re + 4] === "jz" && p[re + 5] === "pop" && p[re + 6] === p[re + 1]) {
                    r = T.pop(), T.push(f(r, p[re + 1])), re += 6;
                    break;
                  }
                  if (M = T.at(-1), M.type === "literal" || M.type === "var") {
                    T.push(M);
                    break;
                  }
                  G = new I(o++, M.min, M.max), T[T.length - 1] = G, T.push(G), D.push(new E(G, M));
                  break;
                case "roll":
                  if (T.length < 2 || (y = T.pop(), r = T.pop(), y.type !== "literal" || r.type !== "literal") || (s = y.number, m = r.number, m <= 0 || !Number.isInteger(m) || !Number.isInteger(s) || T.length < m))
                    return null;
                  if (s = (s % m + m) % m, s === 0)
                    break;
                  T.push(...T.splice(T.length - m, m - s));
                  break;
                default:
                  return null;
              }
            }
            if (T.length !== _)
              return null;
            const q = [];
            for (const re of D) {
              const Z = new k();
              re.visit(Z), q.push(Z.toString());
            }
            for (let re = 0, Z = T.length; re < Z; re++) {
              const te = T[re], L = new k();
              te.visit(L);
              const X = B[re * 2], J = B[re * 2 + 1], Y = [L.toString()];
              X > te.min && (Y.unshift("Math.max(", X, ", "), Y.push(")")), J < te.max && (Y.unshift("Math.min(", J, ", "), Y.push(")")), Y.unshift("dest[destOffset + ", re, "] = "), Y.push(";"), q.push(Y.join(""));
            }
            return q.join(`
`);
          }
        }
        w.PostScriptCompiler = c;
      },
      /* 58 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.PostScriptParser = w.PostScriptLexer = void 0;
        var n = V(2), F = V(4), C = V(3);
        class e {
          constructor(O) {
            this.lexer = O, this.operators = [], this.token = null, this.prev = null;
          }
          nextToken() {
            this.prev = this.token, this.token = this.lexer.getToken();
          }
          accept(O) {
            return this.token.type === O ? (this.nextToken(), !0) : !1;
          }
          expect(O) {
            if (this.accept(O))
              return !0;
            throw new n.FormatError(`Unexpected symbol: found ${this.token.type} expected ${O}.`);
          }
          parse() {
            return this.nextToken(), this.expect(t.LBRACE), this.parseBlock(), this.expect(t.RBRACE), this.operators;
          }
          parseBlock() {
            for (; ; )
              if (this.accept(t.NUMBER))
                this.operators.push(this.prev.value);
              else if (this.accept(t.OPERATOR))
                this.operators.push(this.prev.value);
              else if (this.accept(t.LBRACE))
                this.parseCondition();
              else
                return;
          }
          parseCondition() {
            const O = this.operators.length;
            if (this.operators.push(null, null), this.parseBlock(), this.expect(t.RBRACE), this.accept(t.IF))
              this.operators[O] = this.operators.length, this.operators[O + 1] = "jz";
            else if (this.accept(t.LBRACE)) {
              const v = this.operators.length;
              this.operators.push(null, null);
              const g = this.operators.length;
              this.parseBlock(), this.expect(t.RBRACE), this.expect(t.IFELSE), this.operators[v] = this.operators.length, this.operators[v + 1] = "j", this.operators[O] = g, this.operators[O + 1] = "jz";
            } else
              throw new n.FormatError("PS Function: error parsing conditional.");
          }
        }
        w.PostScriptParser = e;
        const t = {
          LBRACE: 0,
          RBRACE: 1,
          NUMBER: 2,
          OPERATOR: 3,
          IF: 4,
          IFELSE: 5
        };
        class l {
          static get opCache() {
            return (0, n.shadow)(this, "opCache", /* @__PURE__ */ Object.create(null));
          }
          constructor(O, v) {
            this.type = O, this.value = v;
          }
          static getOperator(O) {
            var v;
            return (v = l.opCache)[O] || (v[O] = new l(t.OPERATOR, O));
          }
          static get LBRACE() {
            return (0, n.shadow)(this, "LBRACE", new l(t.LBRACE, "{"));
          }
          static get RBRACE() {
            return (0, n.shadow)(this, "RBRACE", new l(t.RBRACE, "}"));
          }
          static get IF() {
            return (0, n.shadow)(this, "IF", new l(t.IF, "IF"));
          }
          static get IFELSE() {
            return (0, n.shadow)(this, "IFELSE", new l(t.IFELSE, "IFELSE"));
          }
        }
        class j {
          constructor(O) {
            this.stream = O, this.nextChar(), this.strBuf = [];
          }
          nextChar() {
            return this.currentChar = this.stream.getByte();
          }
          getToken() {
            let O = !1, v = this.currentChar;
            for (; ; ) {
              if (v < 0)
                return F.EOF;
              if (O)
                (v === 10 || v === 13) && (O = !1);
              else if (v === 37)
                O = !0;
              else if (!(0, C.isWhiteSpace)(v))
                break;
              v = this.nextChar();
            }
            switch (v | 0) {
              case 48:
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
              case 43:
              case 45:
              case 46:
                return new l(t.NUMBER, this.getNumber());
              case 123:
                return this.nextChar(), l.LBRACE;
              case 125:
                return this.nextChar(), l.RBRACE;
            }
            const g = this.strBuf;
            for (g.length = 0, g[0] = String.fromCharCode(v); (v = this.nextChar()) >= 0 && (v >= 65 && v <= 90 || v >= 97 && v <= 122); )
              g.push(String.fromCharCode(v));
            const b = g.join("");
            switch (b.toLowerCase()) {
              case "if":
                return l.IF;
              case "ifelse":
                return l.IFELSE;
              default:
                return l.getOperator(b);
            }
          }
          getNumber() {
            let O = this.currentChar;
            const v = this.strBuf;
            for (v.length = 0, v[0] = String.fromCharCode(O); (O = this.nextChar()) >= 0 && (O >= 48 && O <= 57 || O === 45 || O === 46); )
              v.push(String.fromCharCode(O));
            const g = parseFloat(v.join(""));
            if (isNaN(g))
              throw new n.FormatError(`Invalid floating point number: ${g}`);
            return g;
          }
        }
        w.PostScriptLexer = j;
      },
      /* 59 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.RegionalImageCache = w.LocalTilingPatternCache = w.LocalImageCache = w.LocalGStateCache = w.LocalFunctionCache = w.LocalColorSpaceCache = w.GlobalImageCache = void 0;
        var n = V(2), F = V(4);
        class C {
          constructor(i) {
            this.constructor === C && (0, n.unreachable)("Cannot initialize BaseLocalCache."), this._onlyRefs = (i == null ? void 0 : i.onlyRefs) === !0, this._onlyRefs || (this._nameRefMap = /* @__PURE__ */ new Map(), this._imageMap = /* @__PURE__ */ new Map()), this._imageCache = new F.RefSetCache();
          }
          getByName(i) {
            this._onlyRefs && (0, n.unreachable)("Should not call `getByName` method.");
            const P = this._nameRefMap.get(i);
            return P ? this.getByRef(P) : this._imageMap.get(i) || null;
          }
          getByRef(i) {
            return this._imageCache.get(i) || null;
          }
          set(i, P, d) {
            (0, n.unreachable)("Abstract method `set` called.");
          }
        }
        class e extends C {
          set(i, P = null, d) {
            if (typeof i != "string")
              throw new Error('LocalImageCache.set - expected "name" argument.');
            if (P) {
              if (this._imageCache.has(P))
                return;
              this._nameRefMap.set(i, P), this._imageCache.put(P, d);
              return;
            }
            this._imageMap.has(i) || this._imageMap.set(i, d);
          }
        }
        w.LocalImageCache = e;
        class t extends C {
          set(i = null, P = null, d) {
            if (typeof i != "string" && !P)
              throw new Error('LocalColorSpaceCache.set - expected "name" and/or "ref" argument.');
            if (P) {
              if (this._imageCache.has(P))
                return;
              i !== null && this._nameRefMap.set(i, P), this._imageCache.put(P, d);
              return;
            }
            this._imageMap.has(i) || this._imageMap.set(i, d);
          }
        }
        w.LocalColorSpaceCache = t;
        class l extends C {
          constructor(i) {
            super({
              onlyRefs: !0
            });
          }
          set(i = null, P, d) {
            if (!P)
              throw new Error('LocalFunctionCache.set - expected "ref" argument.');
            this._imageCache.has(P) || this._imageCache.put(P, d);
          }
        }
        w.LocalFunctionCache = l;
        class j extends C {
          set(i, P = null, d) {
            if (typeof i != "string")
              throw new Error('LocalGStateCache.set - expected "name" argument.');
            if (P) {
              if (this._imageCache.has(P))
                return;
              this._nameRefMap.set(i, P), this._imageCache.put(P, d);
              return;
            }
            this._imageMap.has(i) || this._imageMap.set(i, d);
          }
        }
        w.LocalGStateCache = j;
        class U extends C {
          constructor(i) {
            super({
              onlyRefs: !0
            });
          }
          set(i = null, P, d) {
            if (!P)
              throw new Error('LocalTilingPatternCache.set - expected "ref" argument.');
            this._imageCache.has(P) || this._imageCache.put(P, d);
          }
        }
        w.LocalTilingPatternCache = U;
        class O extends C {
          constructor(i) {
            super({
              onlyRefs: !0
            });
          }
          set(i = null, P, d) {
            if (!P)
              throw new Error('RegionalImageCache.set - expected "ref" argument.');
            this._imageCache.has(P) || this._imageCache.put(P, d);
          }
        }
        w.RegionalImageCache = O;
        const g = class g {
          constructor() {
            this._refCache = new F.RefSetCache(), this._imageCache = new F.RefSetCache();
          }
          get _byteSize() {
            let i = 0;
            for (const P of this._imageCache)
              i += P.byteSize;
            return i;
          }
          get _cacheLimitReached() {
            return !(this._imageCache.size < g.MIN_IMAGES_TO_CACHE || this._byteSize < g.MAX_BYTE_SIZE);
          }
          shouldCache(i, P) {
            let d = this._refCache.get(i);
            return d || (d = /* @__PURE__ */ new Set(), this._refCache.put(i, d)), d.add(P), !(d.size < g.NUM_PAGES_THRESHOLD || !this._imageCache.has(i) && this._cacheLimitReached);
          }
          addByteSize(i, P) {
            const d = this._imageCache.get(i);
            d && (d.byteSize || (d.byteSize = P));
          }
          getData(i, P) {
            const d = this._refCache.get(i);
            if (!d || d.size < g.NUM_PAGES_THRESHOLD)
              return null;
            const A = this._imageCache.get(i);
            return A ? (d.add(P), A) : null;
          }
          setData(i, P) {
            if (!this._refCache.has(i))
              throw new Error('GlobalImageCache.setData - expected "shouldCache" to have been called.');
            if (!this._imageCache.has(i)) {
              if (this._cacheLimitReached) {
                (0, n.warn)("GlobalImageCache.setData - cache limit reached.");
                return;
              }
              this._imageCache.put(i, P);
            }
          }
          clear(i = !1) {
            i || this._refCache.clear(), this._imageCache.clear();
          }
        };
        Ot(g, "NUM_PAGES_THRESHOLD", 2), Ot(g, "MIN_IMAGES_TO_CACHE", 10), Ot(g, "MAX_BYTE_SIZE", 5 * n.MAX_IMAGE_SIZE_TO_CACHE);
        let v = g;
        w.GlobalImageCache = v;
      },
      /* 60 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.bidi = b;
        var n = V(2);
        const F = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "ON", "ON", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "ON", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "ON", "ET", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "L", "ON", "ON", "BN", "ON", "ON", "ET", "ET", "EN", "EN", "ON", "L", "ON", "ON", "ON", "EN", "L", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L"], C = ["AN", "AN", "AN", "AN", "AN", "AN", "ON", "ON", "AL", "ET", "ET", "AL", "CS", "AL", "ON", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "ON", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL"];
        function e(i) {
          return (i & 1) !== 0;
        }
        function t(i) {
          return (i & 1) === 0;
        }
        function l(i, P, d) {
          let A, I;
          for (A = P, I = i.length; A < I; ++A)
            if (i[A] !== d)
              return A;
          return A;
        }
        function j(i, P, d, A) {
          for (let I = P; I < d; ++I)
            i[I] = A;
        }
        function U(i, P, d) {
          for (let A = P, I = d - 1; A < I; ++A, --I) {
            const E = i[A];
            i[A] = i[I], i[I] = E;
          }
        }
        function O(i, P, d = !1) {
          let A = "ltr";
          return d ? A = "ttb" : P || (A = "rtl"), {
            str: i,
            dir: A
          };
        }
        const v = [], g = [];
        function b(i, P = -1, d = !1) {
          let A = !0;
          const I = i.length;
          if (I === 0 || d)
            return O(i, A, d);
          v.length = I, g.length = I;
          let E = 0, k, H;
          for (k = 0; k < I; ++k) {
            v[k] = i.charAt(k);
            const T = i.charCodeAt(k);
            let D = "L";
            T <= 255 ? D = F[T] : 1424 <= T && T <= 1524 ? D = "R" : 1536 <= T && T <= 1791 ? (D = C[T & 255], D || (0, n.warn)("Bidi: invalid Unicode character " + T.toString(16))) : (1792 <= T && T <= 2220 || 64336 <= T && T <= 65023 || 65136 <= T && T <= 65279) && (D = "AL"), (D === "R" || D === "AL" || D === "AN") && E++, g[k] = D;
          }
          if (E === 0)
            return A = !0, O(i, A);
          P === -1 && (E / I < 0.3 && I > 4 ? (A = !0, P = 0) : (A = !1, P = 1));
          const x = [];
          for (k = 0; k < I; ++k)
            x[k] = P;
          const R = e(P) ? "R" : "L", f = R, c = f;
          let N = f;
          for (k = 0; k < I; ++k)
            g[k] === "NSM" ? g[k] = N : N = g[k];
          N = f;
          let u;
          for (k = 0; k < I; ++k)
            u = g[k], u === "EN" ? g[k] = N === "AL" ? "AN" : "EN" : (u === "R" || u === "L" || u === "AL") && (N = u);
          for (k = 0; k < I; ++k)
            u = g[k], u === "AL" && (g[k] = "R");
          for (k = 1; k < I - 1; ++k)
            g[k] === "ES" && g[k - 1] === "EN" && g[k + 1] === "EN" && (g[k] = "EN"), g[k] === "CS" && (g[k - 1] === "EN" || g[k - 1] === "AN") && g[k + 1] === g[k - 1] && (g[k] = g[k - 1]);
          for (k = 0; k < I; ++k)
            if (g[k] === "EN") {
              for (let T = k - 1; T >= 0 && g[T] === "ET"; --T)
                g[T] = "EN";
              for (let T = k + 1; T < I && g[T] === "ET"; ++T)
                g[T] = "EN";
            }
          for (k = 0; k < I; ++k)
            u = g[k], (u === "WS" || u === "ES" || u === "ET" || u === "CS") && (g[k] = "ON");
          for (N = f, k = 0; k < I; ++k)
            u = g[k], u === "EN" ? g[k] = N === "L" ? "L" : "EN" : (u === "R" || u === "L") && (N = u);
          for (k = 0; k < I; ++k)
            if (g[k] === "ON") {
              const T = l(g, k + 1, "ON");
              let D = f;
              k > 0 && (D = g[k - 1]);
              let K = c;
              T + 1 < I && (K = g[T + 1]), D !== "L" && (D = "R"), K !== "L" && (K = "R"), D === K && j(g, k, T, D), k = T - 1;
            }
          for (k = 0; k < I; ++k)
            g[k] === "ON" && (g[k] = R);
          for (k = 0; k < I; ++k)
            u = g[k], t(x[k]) ? u === "R" ? x[k] += 1 : (u === "AN" || u === "EN") && (x[k] += 2) : (u === "L" || u === "AN" || u === "EN") && (x[k] += 1);
          let p = -1, S = 99, B;
          for (k = 0, H = x.length; k < H; ++k)
            B = x[k], p < B && (p = B), S > B && e(B) && (S = B);
          for (B = p; B >= S; --B) {
            let T = -1;
            for (k = 0, H = x.length; k < H; ++k)
              x[k] < B ? T >= 0 && (U(v, T, k), T = -1) : T < 0 && (T = k);
            T >= 0 && U(v, T, x.length);
          }
          for (k = 0, H = v.length; k < H; ++k) {
            const T = v[k];
            (T === "<" || T === ">") && (v[k] = "");
          }
          return O(v.join(""), A);
        }
      },
      /* 61 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.getFontSubstitution = g;
        var n = V(38), F = V(3);
        const C = {
          style: "normal",
          weight: "normal"
        }, e = {
          style: "normal",
          weight: "bold"
        }, t = {
          style: "italic",
          weight: "normal"
        }, l = {
          style: "italic",
          weight: "bold"
        }, j = /* @__PURE__ */ new Map([["Times-Roman", {
          local: ["Times New Roman", "Times-Roman", "Times", "Liberation Serif", "Nimbus Roman", "Nimbus Roman L", "Tinos", "Thorndale", "TeX Gyre Termes", "FreeSerif", "DejaVu Serif", "Bitstream Vera Serif", "Ubuntu"],
          style: C,
          ultimate: "serif"
        }], ["Times-Bold", {
          alias: "Times-Roman",
          style: e,
          ultimate: "serif"
        }], ["Times-Italic", {
          alias: "Times-Roman",
          style: t,
          ultimate: "serif"
        }], ["Times-BoldItalic", {
          alias: "Times-Roman",
          style: l,
          ultimate: "serif"
        }], ["Helvetica", {
          local: ["Helvetica", "Helvetica Neue", "Arial", "Arial Nova", "Liberation Sans", "Arimo", "Nimbus Sans", "Nimbus Sans L", "A030", "TeX Gyre Heros", "FreeSans", "DejaVu Sans", "Albany", "Bitstream Vera Sans", "Arial Unicode MS", "Microsoft Sans Serif", "Apple Symbols", "Cantarell"],
          path: "LiberationSans-Regular.ttf",
          style: C,
          ultimate: "sans-serif"
        }], ["Helvetica-Bold", {
          alias: "Helvetica",
          path: "LiberationSans-Bold.ttf",
          style: e,
          ultimate: "sans-serif"
        }], ["Helvetica-Oblique", {
          alias: "Helvetica",
          path: "LiberationSans-Italic.ttf",
          style: t,
          ultimate: "sans-serif"
        }], ["Helvetica-BoldOblique", {
          alias: "Helvetica",
          path: "LiberationSans-BoldItalic.ttf",
          style: l,
          ultimate: "sans-serif"
        }], ["Courier", {
          local: ["Courier", "Courier New", "Liberation Mono", "Nimbus Mono", "Nimbus Mono L", "Cousine", "Cumberland", "TeX Gyre Cursor", "FreeMono"],
          style: C,
          ultimate: "monospace"
        }], ["Courier-Bold", {
          alias: "Courier",
          style: e,
          ultimate: "monospace"
        }], ["Courier-Oblique", {
          alias: "Courier",
          style: t,
          ultimate: "monospace"
        }], ["Courier-BoldOblique", {
          alias: "Courier",
          style: l,
          ultimate: "monospace"
        }], ["ArialBlack", {
          local: ["Arial Black"],
          style: {
            style: "normal",
            weight: "900"
          },
          fallback: "Helvetica-Bold"
        }], ["ArialBlack-Bold", {
          alias: "ArialBlack"
        }], ["ArialBlack-Italic", {
          alias: "ArialBlack",
          style: {
            style: "italic",
            weight: "900"
          },
          fallback: "Helvetica-BoldOblique"
        }], ["ArialBlack-BoldItalic", {
          alias: "ArialBlack-Italic"
        }], ["ArialNarrow", {
          local: ["Arial Narrow", "Liberation Sans Narrow", "Helvetica Condensed", "Nimbus Sans Narrow", "TeX Gyre Heros Cn"],
          style: C,
          fallback: "Helvetica"
        }], ["ArialNarrow-Bold", {
          alias: "ArialNarrow",
          style: e,
          fallback: "Helvetica-Bold"
        }], ["ArialNarrow-Italic", {
          alias: "ArialNarrow",
          style: t,
          fallback: "Helvetica-Oblique"
        }], ["ArialNarrow-BoldItalic", {
          alias: "ArialNarrow",
          style: l,
          fallback: "Helvetica-BoldOblique"
        }], ["Calibri", {
          local: ["Calibri", "Carlito"],
          style: C,
          fallback: "Helvetica"
        }], ["Calibri-Bold", {
          alias: "Calibri",
          style: e,
          fallback: "Helvetica-Bold"
        }], ["Calibri-Italic", {
          alias: "Calibri",
          style: t,
          fallback: "Helvetica-Oblique"
        }], ["Calibri-BoldItalic", {
          alias: "Calibri",
          style: l,
          fallback: "Helvetica-BoldOblique"
        }], ["Wingdings", {
          local: ["Wingdings", "URW Dingbats"],
          style: C
        }], ["Wingdings-Regular", {
          alias: "Wingdings"
        }], ["Wingdings-Bold", {
          alias: "Wingdings"
        }]]), U = /* @__PURE__ */ new Map([["Arial-Black", "ArialBlack"]]);
        function O(b) {
          switch (b) {
            case e:
              return "Bold";
            case t:
              return "Italic";
            case l:
              return "Bold Italic";
            default:
              if ((b == null ? void 0 : b.weight) === "bold")
                return "Bold";
              if ((b == null ? void 0 : b.style) === "italic")
                return "Italic";
          }
          return "";
        }
        function v({
          alias: b,
          local: i,
          path: P,
          fallback: d,
          style: A,
          ultimate: I
        }, E, k, H = !0, x = !0, R = "") {
          const f = {
            style: null,
            ultimate: null
          };
          if (i) {
            const c = R ? ` ${R}` : "";
            for (const N of i)
              E.push(`local(${N}${c})`);
          }
          if (b) {
            const c = j.get(b), N = R || O(A);
            Object.assign(f, v(c, E, k, H && !d, x && !P, N));
          }
          if (A && (f.style = A), I && (f.ultimate = I), H && d) {
            const c = j.get(d), {
              ultimate: N
            } = v(c, E, k, H, x && !P, R);
            f.ultimate || (f.ultimate = N);
          }
          return x && P && k && E.push(`url(${k}${P})`), f;
        }
        function g(b, i, P, d, A) {
          d = (0, n.normalizeFontName)(d);
          const I = d;
          let E = b.get(I);
          if (E)
            return E;
          let k = j.get(d);
          if (!k) {
            for (const [p, S] of U)
              if (d.startsWith(p)) {
                d = `${S}${d.substring(p.length)}`, k = j.get(d);
                break;
              }
          }
          let H = !1;
          k || (k = j.get(A), H = !0);
          const x = `${i.getDocId()}_s${i.createFontId()}`;
          if (!k) {
            if (!(0, F.validateFontName)(d))
              return b.set(I, null), null;
            const p = /bold/gi.test(d), S = /oblique|italic/gi.test(d), B = p && S && l || p && e || S && t || C;
            return E = {
              css: x,
              guessFallback: !0,
              loadedName: x,
              baseFontName: d,
              src: `local(${d})`,
              style: B
            }, b.set(I, E), E;
          }
          const R = [];
          H && (0, F.validateFontName)(d) && R.push(`local(${d})`);
          const {
            style: f,
            ultimate: c
          } = v(k, R, P), N = c === null, u = N ? "" : `,${c}`;
          return E = {
            css: `${x}${u}`,
            guessFallback: N,
            loadedName: x,
            baseFontName: d,
            src: R.join(","),
            style: f
          }, b.set(I, E), E;
        }
      },
      /* 62 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.ImageResizer = void 0;
        var n = V(2);
        const F = 2048, C = 65537, e = 128;
        class t {
          constructor(j, U) {
            this._imgData = j, this._isMask = U;
          }
          static needsToBeResized(j, U) {
            if (j <= this._goodSquareLength && U <= this._goodSquareLength)
              return !1;
            const {
              MAX_DIM: O
            } = this;
            if (j > O || U > O)
              return !0;
            const v = j * U;
            if (this._hasMaxArea)
              return v > this.MAX_AREA;
            if (v < this._goodSquareLength ** 2)
              return !1;
            if (this._areGoodDims(j, U))
              return this._goodSquareLength = Math.max(this._goodSquareLength, Math.floor(Math.sqrt(j * U))), !1;
            this._goodSquareLength = this._guessMax(this._goodSquareLength, O, e, 0);
            const g = this.MAX_AREA = this._goodSquareLength ** 2;
            return v > g;
          }
          static get MAX_DIM() {
            return (0, n.shadow)(this, "MAX_DIM", this._guessMax(F, C, 0, 1));
          }
          static get MAX_AREA() {
            return this._hasMaxArea = !0, (0, n.shadow)(this, "MAX_AREA", this._guessMax(t._goodSquareLength, this.MAX_DIM, e, 0) ** 2);
          }
          static set MAX_AREA(j) {
            j >= 0 && (this._hasMaxArea = !0, (0, n.shadow)(this, "MAX_AREA", j));
          }
          static setMaxArea(j) {
            this._hasMaxArea || (this.MAX_AREA = j >> 2);
          }
          static _areGoodDims(j, U) {
            try {
              const O = new OffscreenCanvas(j, U), v = O.getContext("2d");
              v.fillRect(0, 0, 1, 1);
              const g = v.getImageData(0, 0, 1, 1).data[3];
              return O.width = O.height = 1, g !== 0;
            } catch {
              return !1;
            }
          }
          static _guessMax(j, U, O, v) {
            for (; j + O + 1 < U; ) {
              const g = Math.floor((j + U) / 2), b = v || g;
              this._areGoodDims(g, b) ? j = g : U = g;
            }
            return j;
          }
          static async createImage(j, U = !1) {
            return new t(j, U)._createImage();
          }
          async _createImage() {
            const j = this._encodeBMP(), U = new Blob([j.buffer], {
              type: "image/bmp"
            }), O = createImageBitmap(U), {
              MAX_AREA: v,
              MAX_DIM: g
            } = t, {
              _imgData: b
            } = this, {
              width: i,
              height: P
            } = b, d = Math.max(i / g, P / g, Math.sqrt(i * P / v)), A = Math.max(d, 2), I = Math.round(10 * (d + 1.25)) / 10 / A, E = Math.floor(Math.log2(I)), k = new Array(E + 2).fill(2);
            k[0] = A, k.splice(-1, 1, I / (1 << E));
            let H = i, x = P, R = await O;
            for (const f of k) {
              const c = H, N = x;
              H = Math.floor(H / f) - 1, x = Math.floor(x / f) - 1;
              const u = new OffscreenCanvas(H, x);
              u.getContext("2d").drawImage(R, 0, 0, c, N, 0, 0, H, x), R = u.transferToImageBitmap();
            }
            return b.data = null, b.bitmap = R, b.width = H, b.height = x, b;
          }
          _encodeBMP() {
            const {
              width: j,
              height: U,
              kind: O
            } = this._imgData;
            let v = this._imgData.data, g, b = new Uint8Array(0), i = b, P = 0;
            switch (O) {
              case n.ImageKind.GRAYSCALE_1BPP: {
                g = 1, b = new Uint8Array(this._isMask ? [255, 255, 255, 255, 0, 0, 0, 0] : [0, 0, 0, 0, 255, 255, 255, 255]);
                const x = j + 7 >> 3, R = x + 3 & -4;
                if (x !== R) {
                  const f = new Uint8Array(R * U);
                  let c = 0;
                  for (let N = 0, u = U * x; N < u; N += x, c += R)
                    f.set(v.subarray(N, N + x), c);
                  v = f;
                }
                break;
              }
              case n.ImageKind.RGB_24BPP: {
                if (g = 24, j & 3) {
                  const x = 3 * j, R = x + 3 & -4, f = R - x, c = new Uint8Array(R * U);
                  let N = 0;
                  for (let u = 0, p = U * x; u < p; u += x) {
                    const S = v.subarray(u, u + x);
                    for (let B = 0; B < x; B += 3)
                      c[N++] = S[B + 2], c[N++] = S[B + 1], c[N++] = S[B];
                    N += f;
                  }
                  v = c;
                } else
                  for (let x = 0, R = v.length; x < R; x += 3) {
                    const f = v[x];
                    v[x] = v[x + 2], v[x + 2] = f;
                  }
                break;
              }
              case n.ImageKind.RGBA_32BPP:
                g = 32, P = 3, i = new Uint8Array(68);
                const H = new DataView(i.buffer);
                n.FeatureTest.isLittleEndian ? (H.setUint32(0, 255, !0), H.setUint32(4, 65280, !0), H.setUint32(8, 16711680, !0), H.setUint32(12, 4278190080, !0)) : (H.setUint32(0, 4278190080, !0), H.setUint32(4, 16711680, !0), H.setUint32(8, 65280, !0), H.setUint32(12, 255, !0));
                break;
              default:
                throw new Error("invalid format");
            }
            let d = 0;
            const A = 40 + i.length, I = 14 + A + b.length + v.length, E = new Uint8Array(I), k = new DataView(E.buffer);
            return k.setUint16(d, 19778, !0), d += 2, k.setUint32(d, I, !0), d += 4, k.setUint32(d, 0, !0), d += 4, k.setUint32(d, 14 + A + b.length, !0), d += 4, k.setUint32(d, A, !0), d += 4, k.setInt32(d, j, !0), d += 4, k.setInt32(d, -U, !0), d += 4, k.setUint16(d, 1, !0), d += 2, k.setUint16(d, g, !0), d += 2, k.setUint32(d, P, !0), d += 4, k.setUint32(d, 0, !0), d += 4, k.setInt32(d, 0, !0), d += 4, k.setInt32(d, 0, !0), d += 4, k.setUint32(d, b.length / 4, !0), d += 4, k.setUint32(d, 0, !0), d += 4, E.set(i, d), d += i.length, E.set(b, d), d += b.length, E.set(v, d), E;
          }
        }
        w.ImageResizer = t, t._goodSquareLength = F;
      },
      /* 63 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.MurmurHash3_64 = void 0;
        var n = V(2);
        const F = 3285377520, C = 4294901760, e = 65535;
        class t {
          constructor(j) {
            this.h1 = j ? j & 4294967295 : F, this.h2 = j ? j & 4294967295 : F;
          }
          update(j) {
            let U, O;
            if (typeof j == "string") {
              U = new Uint8Array(j.length * 2), O = 0;
              for (let x = 0, R = j.length; x < R; x++) {
                const f = j.charCodeAt(x);
                f <= 255 ? U[O++] = f : (U[O++] = f >>> 8, U[O++] = f & 255);
              }
            } else if ((0, n.isArrayBuffer)(j))
              U = j.slice(), O = U.byteLength;
            else
              throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");
            const v = O >> 2, g = O - v * 4, b = new Uint32Array(U.buffer, 0, v);
            let i = 0, P = 0, d = this.h1, A = this.h2;
            const I = 3432918353, E = 461845907, k = I & e, H = E & e;
            for (let x = 0; x < v; x++)
              x & 1 ? (i = b[x], i = i * I & C | i * k & e, i = i << 15 | i >>> 17, i = i * E & C | i * H & e, d ^= i, d = d << 13 | d >>> 19, d = d * 5 + 3864292196) : (P = b[x], P = P * I & C | P * k & e, P = P << 15 | P >>> 17, P = P * E & C | P * H & e, A ^= P, A = A << 13 | A >>> 19, A = A * 5 + 3864292196);
            switch (i = 0, g) {
              case 3:
                i ^= U[v * 4 + 2] << 16;
              case 2:
                i ^= U[v * 4 + 1] << 8;
              case 1:
                i ^= U[v * 4], i = i * I & C | i * k & e, i = i << 15 | i >>> 17, i = i * E & C | i * H & e, v & 1 ? d ^= i : A ^= i;
            }
            this.h1 = d, this.h2 = A;
          }
          hexdigest() {
            let j = this.h1, U = this.h2;
            return j ^= U >>> 1, j = j * 3981806797 & C | j * 36045 & e, U = U * 4283543511 & C | ((U << 16 | j >>> 16) * 2950163797 & C) >>> 16, j ^= U >>> 1, j = j * 444984403 & C | j * 60499 & e, U = U * 3301882366 & C | ((U << 16 | j >>> 16) * 3120437893 & C) >>> 16, j ^= U >>> 1, (j >>> 0).toString(16).padStart(8, "0") + (U >>> 0).toString(16).padStart(8, "0");
          }
        }
        w.MurmurHash3_64 = t;
      },
      /* 64 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.OperatorList = void 0;
        var n = V(2);
        function F(U, O, v, g, b) {
          let i = U;
          for (let P = 0, d = O.length - 1; P < d; P++) {
            const A = O[P];
            i = i[A] || (i[A] = []);
          }
          i[O.at(-1)] = {
            checkFn: v,
            iterateFn: g,
            processFn: b
          };
        }
        const C = [];
        F(C, [n.OPS.save, n.OPS.transform, n.OPS.paintInlineImageXObject, n.OPS.restore], null, function(O, v) {
          const g = O.fnArray, b = O.iCurr - 3, i = (v - b) % 4;
          switch (i) {
            case 0:
              return g[v] === n.OPS.save;
            case 1:
              return g[v] === n.OPS.transform;
            case 2:
              return g[v] === n.OPS.paintInlineImageXObject;
            case 3:
              return g[v] === n.OPS.restore;
          }
          throw new Error(`iterateInlineImageGroup - invalid pos: ${i}`);
        }, function(O, v) {
          const d = O.fnArray, A = O.argsArray, I = O.iCurr, E = I - 3, k = I - 2, H = I - 1, x = Math.min(Math.floor((v - E) / 4), 200);
          if (x < 10)
            return v - (v - E) % 4;
          let R = 0;
          const f = [];
          let c = 0, N = 1, u = 1;
          for (let K = 0; K < x; K++) {
            const _ = A[k + (K << 2)], o = A[H + (K << 2)][0];
            N + o.width > 1e3 && (R = Math.max(R, N), u += c + 2, N = 0, c = 0), f.push({
              transform: _,
              x: N,
              y: u,
              w: o.width,
              h: o.height
            }), N += o.width + 2, c = Math.max(c, o.height);
          }
          const p = Math.max(R, N) + 1, S = u + c + 1, B = new Uint8Array(p * S * 4), T = p << 2;
          for (let K = 0; K < x; K++) {
            const _ = A[H + (K << 2)][0].data, o = f[K].w << 2;
            let m = 0, s = f[K].x + f[K].y * p << 2;
            B.set(_.subarray(0, o), s - T);
            for (let r = 0, y = f[K].h; r < y; r++)
              B.set(_.subarray(m, m + o), s), m += o, s += T;
            for (B.set(_.subarray(m - o, m), s); s >= 0; )
              _[s - 4] = _[s], _[s - 3] = _[s + 1], _[s - 2] = _[s + 2], _[s - 1] = _[s + 3], _[s + o] = _[s + o - 4], _[s + o + 1] = _[s + o - 3], _[s + o + 2] = _[s + o - 2], _[s + o + 3] = _[s + o - 1], s -= T;
          }
          const D = {
            width: p,
            height: S
          };
          if (O.isOffscreenCanvasSupported) {
            const K = new OffscreenCanvas(p, S);
            K.getContext("2d").putImageData(new ImageData(new Uint8ClampedArray(B.buffer), p, S), 0, 0), D.bitmap = K.transferToImageBitmap(), D.data = null;
          } else
            D.kind = n.ImageKind.RGBA_32BPP, D.data = B;
          return d.splice(E, x * 4, n.OPS.paintInlineImageXObjectGroup), A.splice(E, x * 4, [D, f]), E + 1;
        }), F(C, [n.OPS.save, n.OPS.transform, n.OPS.paintImageMaskXObject, n.OPS.restore], null, function(O, v) {
          const g = O.fnArray, b = O.iCurr - 3, i = (v - b) % 4;
          switch (i) {
            case 0:
              return g[v] === n.OPS.save;
            case 1:
              return g[v] === n.OPS.transform;
            case 2:
              return g[v] === n.OPS.paintImageMaskXObject;
            case 3:
              return g[v] === n.OPS.restore;
          }
          throw new Error(`iterateImageMaskGroup - invalid pos: ${i}`);
        }, function(O, v) {
          const P = O.fnArray, d = O.argsArray, A = O.iCurr, I = A - 3, E = A - 2, k = A - 1;
          let H = Math.floor((v - I) / 4);
          if (H < 10)
            return v - (v - I) % 4;
          let x = !1, R, f;
          const c = d[k][0], N = d[E][0], u = d[E][1], p = d[E][2], S = d[E][3];
          if (u === p) {
            x = !0, R = E + 4;
            let B = k + 4;
            for (let T = 1; T < H; T++, R += 4, B += 4)
              if (f = d[R], d[B][0] !== c || f[0] !== N || f[1] !== u || f[2] !== p || f[3] !== S) {
                T < 10 ? x = !1 : H = T;
                break;
              }
          }
          if (x) {
            H = Math.min(H, 1e3);
            const B = new Float32Array(H * 2);
            R = E;
            for (let T = 0; T < H; T++, R += 4)
              f = d[R], B[T << 1] = f[4], B[(T << 1) + 1] = f[5];
            P.splice(I, H * 4, n.OPS.paintImageMaskXObjectRepeat), d.splice(I, H * 4, [c, N, u, p, S, B]);
          } else {
            H = Math.min(H, 100);
            const B = [];
            for (let T = 0; T < H; T++) {
              f = d[E + (T << 2)];
              const D = d[k + (T << 2)][0];
              B.push({
                data: D.data,
                width: D.width,
                height: D.height,
                interpolate: D.interpolate,
                count: D.count,
                transform: f
              });
            }
            P.splice(I, H * 4, n.OPS.paintImageMaskXObjectGroup), d.splice(I, H * 4, [B]);
          }
          return I + 1;
        }), F(C, [n.OPS.save, n.OPS.transform, n.OPS.paintImageXObject, n.OPS.restore], function(U) {
          const O = U.argsArray, v = U.iCurr - 2;
          return O[v][1] === 0 && O[v][2] === 0;
        }, function(O, v) {
          const g = O.fnArray, b = O.argsArray, i = O.iCurr - 3, P = (v - i) % 4;
          switch (P) {
            case 0:
              return g[v] === n.OPS.save;
            case 1:
              if (g[v] !== n.OPS.transform)
                return !1;
              const d = O.iCurr - 2, A = b[d][0], I = b[d][3];
              return !(b[v][0] !== A || b[v][1] !== 0 || b[v][2] !== 0 || b[v][3] !== I);
            case 2:
              if (g[v] !== n.OPS.paintImageXObject)
                return !1;
              const E = O.iCurr - 1, k = b[E][0];
              return b[v][0] === k;
            case 3:
              return g[v] === n.OPS.restore;
          }
          throw new Error(`iterateImageGroup - invalid pos: ${P}`);
        }, function(U, O) {
          const b = U.fnArray, i = U.argsArray, P = U.iCurr, d = P - 3, A = P - 2, I = P - 1, E = i[I][0], k = i[A][0], H = i[A][3], x = Math.min(Math.floor((O - d) / 4), 1e3);
          if (x < 3)
            return O - (O - d) % 4;
          const R = new Float32Array(x * 2);
          let f = A;
          for (let N = 0; N < x; N++, f += 4) {
            const u = i[f];
            R[N << 1] = u[4], R[(N << 1) + 1] = u[5];
          }
          const c = [E, k, H, R];
          return b.splice(d, x * 4, n.OPS.paintImageXObjectRepeat), i.splice(d, x * 4, c), d + 1;
        }), F(C, [n.OPS.beginText, n.OPS.setFont, n.OPS.setTextMatrix, n.OPS.showText, n.OPS.endText], null, function(O, v) {
          const g = O.fnArray, b = O.argsArray, i = O.iCurr - 4, P = (v - i) % 5;
          switch (P) {
            case 0:
              return g[v] === n.OPS.beginText;
            case 1:
              return g[v] === n.OPS.setFont;
            case 2:
              return g[v] === n.OPS.setTextMatrix;
            case 3:
              if (g[v] !== n.OPS.showText)
                return !1;
              const d = O.iCurr - 3, A = b[d][0], I = b[d][1];
              return !(b[v][0] !== A || b[v][1] !== I);
            case 4:
              return g[v] === n.OPS.endText;
          }
          throw new Error(`iterateShowTextGroup - invalid pos: ${P}`);
        }, function(U, O) {
          const b = U.fnArray, i = U.argsArray, P = U.iCurr, d = P - 4, A = P - 3, I = P - 2, E = P - 1, k = P, H = i[A][0], x = i[A][1];
          let R = Math.min(Math.floor((O - d) / 5), 1e3);
          if (R < 3)
            return O - (O - d) % 5;
          let f = d;
          d >= 4 && b[d - 4] === b[A] && b[d - 3] === b[I] && b[d - 2] === b[E] && b[d - 1] === b[k] && i[d - 4][0] === H && i[d - 4][1] === x && (R++, f -= 5);
          let c = f + 4;
          for (let N = 1; N < R; N++)
            b.splice(c, 3), i.splice(c, 3), c += 2;
          return c + 1;
        });
        class e {
          constructor(O) {
            this.queue = O;
          }
          _optimize() {
          }
          push(O, v) {
            this.queue.fnArray.push(O), this.queue.argsArray.push(v), this._optimize();
          }
          flush() {
          }
          reset() {
          }
        }
        class t extends e {
          constructor(O) {
            super(O), this.state = null, this.context = {
              iCurr: 0,
              fnArray: O.fnArray,
              argsArray: O.argsArray,
              isOffscreenCanvasSupported: !1
            }, this.match = null, this.lastProcessed = 0;
          }
          set isOffscreenCanvasSupported(O) {
            this.context.isOffscreenCanvasSupported = O;
          }
          _optimize() {
            const O = this.queue.fnArray;
            let v = this.lastProcessed, g = O.length, b = this.state, i = this.match;
            if (!b && !i && v + 1 === g && !C[O[v]]) {
              this.lastProcessed = g;
              return;
            }
            const P = this.context;
            for (; v < g; ) {
              if (i) {
                if ((0, i.iterateFn)(P, v)) {
                  v++;
                  continue;
                }
                if (v = (0, i.processFn)(P, v + 1), g = O.length, i = null, b = null, v >= g)
                  break;
              }
              if (b = (b || C)[O[v]], !b || Array.isArray(b)) {
                v++;
                continue;
              }
              if (P.iCurr = v, v++, b.checkFn && !(0, b.checkFn)(P)) {
                b = null;
                continue;
              }
              i = b, b = null;
            }
            this.state = b, this.match = i, this.lastProcessed = v;
          }
          flush() {
            for (; this.match; ) {
              const O = this.queue.fnArray.length;
              this.lastProcessed = (0, this.match.processFn)(this.context, O), this.match = null, this.state = null, this._optimize();
            }
          }
          reset() {
            this.state = null, this.match = null, this.lastProcessed = 0;
          }
        }
        const j = class j {
          constructor(O = 0, v) {
            this._streamSink = v, this.fnArray = [], this.argsArray = [], this.optimizer = v && !(O & n.RenderingIntentFlag.OPLIST) ? new t(this) : new e(this), this.dependencies = /* @__PURE__ */ new Set(), this._totalLength = 0, this.weight = 0, this._resolved = v ? null : Promise.resolve();
          }
          set isOffscreenCanvasSupported(O) {
            this.optimizer.isOffscreenCanvasSupported = O;
          }
          get length() {
            return this.argsArray.length;
          }
          get ready() {
            return this._resolved || this._streamSink.ready;
          }
          get totalLength() {
            return this._totalLength + this.length;
          }
          addOp(O, v) {
            this.optimizer.push(O, v), this.weight++, this._streamSink && (this.weight >= j.CHUNK_SIZE ? this.flush() : this.weight >= j.CHUNK_SIZE_ABOUT && (O === n.OPS.restore || O === n.OPS.endText) && this.flush());
          }
          addImageOps(O, v, g) {
            g !== void 0 && this.addOp(n.OPS.beginMarkedContentProps, ["OC", g]), this.addOp(O, v), g !== void 0 && this.addOp(n.OPS.endMarkedContent, []);
          }
          addDependency(O) {
            this.dependencies.has(O) || (this.dependencies.add(O), this.addOp(n.OPS.dependency, [O]));
          }
          addDependencies(O) {
            for (const v of O)
              this.addDependency(v);
          }
          addOpList(O) {
            if (!(O instanceof j)) {
              (0, n.warn)('addOpList - ignoring invalid "opList" parameter.');
              return;
            }
            for (const v of O.dependencies)
              this.dependencies.add(v);
            for (let v = 0, g = O.length; v < g; v++)
              this.addOp(O.fnArray[v], O.argsArray[v]);
          }
          getIR() {
            return {
              fnArray: this.fnArray,
              argsArray: this.argsArray,
              length: this.length
            };
          }
          get _transfers() {
            var i;
            const O = [], {
              fnArray: v,
              argsArray: g,
              length: b
            } = this;
            for (let P = 0; P < b; P++)
              switch (v[P]) {
                case n.OPS.paintInlineImageXObject:
                case n.OPS.paintInlineImageXObjectGroup:
                case n.OPS.paintImageMaskXObject:
                  const d = g[P][0];
                  !d.cached && ((i = d.data) == null ? void 0 : i.buffer) instanceof ArrayBuffer && O.push(d.data.buffer);
                  break;
              }
            return O;
          }
          flush(O = !1, v = null) {
            this.optimizer.flush();
            const g = this.length;
            this._totalLength += g, this._streamSink.enqueue({
              fnArray: this.fnArray,
              argsArray: this.argsArray,
              lastChunk: O,
              separateAnnots: v,
              length: g
            }, 1, this._transfers), this.dependencies.clear(), this.fnArray.length = 0, this.argsArray.length = 0, this.weight = 0, this.optimizer.reset();
          }
        };
        Ot(j, "CHUNK_SIZE", 1e3), Ot(j, "CHUNK_SIZE_ABOUT", j.CHUNK_SIZE - 5);
        let l = j;
        w.OperatorList = l;
      },
      /* 65 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.PDFImage = void 0;
        var n = V(2), F = V(28), C = V(5), e = V(12), t = V(18), l = V(62), j = V(26), U = V(30), O = V(4);
        function v(i, P, d, A) {
          return i = P + i * d, i < 0 ? i = 0 : i > A && (i = A), i;
        }
        function g(i, P, d, A, I, E) {
          const k = I * E;
          let H;
          P <= 8 ? H = new Uint8Array(k) : P <= 16 ? H = new Uint16Array(k) : H = new Uint32Array(k);
          const x = d / I, R = A / E;
          let f, c, N, u = 0, p;
          const S = new Uint16Array(I), B = d;
          for (f = 0; f < I; f++)
            S[f] = Math.floor(f * x);
          for (f = 0; f < E; f++)
            for (N = Math.floor(f * R) * B, c = 0; c < I; c++)
              p = N + S[c], H[u++] = i[p];
          return H;
        }
        class b {
          constructor({
            xref: P,
            res: d,
            image: A,
            isInline: I = !1,
            smask: E = null,
            mask: k = null,
            isMask: H = !1,
            pdfFunctionFactory: x,
            localColorSpaceCache: R
          }) {
            var B;
            this.image = A;
            const f = A.dict, c = f.get("F", "Filter");
            let N;
            if (c instanceof O.Name)
              N = c.name;
            else if (Array.isArray(c)) {
              const T = P.fetchIfRef(c[0]);
              T instanceof O.Name && (N = T.name);
            }
            switch (N) {
              case "JPXDecode":
                const T = new U.JpxImage();
                T.parseImageProperties(A.stream), A.stream.reset(), A.width = T.width, A.height = T.height, A.bitsPerComponent = T.bitsPerComponent, A.numComps = T.componentsCount;
                break;
              case "JBIG2Decode":
                A.bitsPerComponent = 1, A.numComps = 1;
                break;
            }
            let u = f.get("W", "Width"), p = f.get("H", "Height");
            if (Number.isInteger(A.width) && A.width > 0 && Number.isInteger(A.height) && A.height > 0 && (A.width !== u || A.height !== p) && ((0, n.warn)("PDFImage - using the Width/Height of the image data, rather than the image dictionary."), u = A.width, p = A.height), u < 1 || p < 1)
              throw new n.FormatError(`Invalid image width: ${u} or height: ${p}`);
            this.width = u, this.height = p, this.interpolate = f.get("I", "Interpolate"), this.imageMask = f.get("IM", "ImageMask") || !1, this.matte = f.get("Matte") || !1;
            let S = A.bitsPerComponent;
            if (!S && (S = f.get("BPC", "BitsPerComponent"), !S))
              if (this.imageMask)
                S = 1;
              else
                throw new n.FormatError(`Bits per component missing in image: ${this.imageMask}`);
            if (this.bpc = S, !this.imageMask) {
              let T = f.getRaw("CS") || f.getRaw("ColorSpace");
              if (!T)
                switch ((0, n.info)("JPX images (which do not require color spaces)"), A.numComps) {
                  case 1:
                    T = O.Name.get("DeviceGray");
                    break;
                  case 3:
                    T = O.Name.get("DeviceRGB");
                    break;
                  case 4:
                    T = O.Name.get("DeviceCMYK");
                    break;
                  default:
                    throw new Error(`JPX images with ${A.numComps} color components not supported.`);
                }
              this.colorSpace = e.ColorSpace.parse({
                cs: T,
                xref: P,
                resources: I ? d : null,
                pdfFunctionFactory: x,
                localColorSpaceCache: R
              }), this.numComps = this.colorSpace.numComps;
            }
            if (this.decode = f.getArray("D", "Decode"), this.needsDecode = !1, this.decode && (this.colorSpace && !this.colorSpace.isDefaultDecode(this.decode, S) || H && !e.ColorSpace.isDefaultDecode(this.decode, 1))) {
              this.needsDecode = !0;
              const T = (1 << S) - 1;
              this.decodeCoefficients = [], this.decodeAddends = [];
              const D = ((B = this.colorSpace) == null ? void 0 : B.name) === "Indexed";
              for (let K = 0, _ = 0; K < this.decode.length; K += 2, ++_) {
                const o = this.decode[K], m = this.decode[K + 1];
                this.decodeCoefficients[_] = D ? (m - o) / T : m - o, this.decodeAddends[_] = D ? o : T * o;
              }
            }
            E ? this.smask = new b({
              xref: P,
              res: d,
              image: E,
              isInline: I,
              pdfFunctionFactory: x,
              localColorSpaceCache: R
            }) : k && (k instanceof C.BaseStream ? k.dict.get("IM", "ImageMask") ? this.mask = new b({
              xref: P,
              res: d,
              image: k,
              isInline: I,
              isMask: !0,
              pdfFunctionFactory: x,
              localColorSpaceCache: R
            }) : (0, n.warn)("Ignoring /Mask in image without /ImageMask.") : this.mask = k);
          }
          static async buildImage({
            xref: P,
            res: d,
            image: A,
            isInline: I = !1,
            pdfFunctionFactory: E,
            localColorSpaceCache: k
          }) {
            const H = A;
            let x = null, R = null;
            const f = A.dict.get("SMask"), c = A.dict.get("Mask");
            return f ? f instanceof C.BaseStream ? x = f : (0, n.warn)("Unsupported /SMask format.") : c && (c instanceof C.BaseStream || Array.isArray(c) ? R = c : (0, n.warn)("Unsupported /Mask format.")), new b({
              xref: P,
              res: d,
              image: H,
              isInline: I,
              smask: x,
              mask: R,
              pdfFunctionFactory: E,
              localColorSpaceCache: k
            });
          }
          static createRawMask({
            imgArray: P,
            width: d,
            height: A,
            imageIsFromDecodeStream: I,
            inverseDecode: E,
            interpolate: k
          }) {
            const H = (d + 7 >> 3) * A, x = P.byteLength, R = H === x;
            let f, c;
            if (I && (!E || R) ? f = P : E ? (f = new Uint8Array(H), f.set(P), f.fill(255, x)) : f = new Uint8Array(P), E)
              for (c = 0; c < x; c++)
                f[c] ^= 255;
            return {
              data: f,
              width: d,
              height: A,
              interpolate: k
            };
          }
          static async createMask({
            imgArray: P,
            width: d,
            height: A,
            imageIsFromDecodeStream: I,
            inverseDecode: E,
            interpolate: k,
            isOffscreenCanvasSupported: H = !1
          }) {
            const x = d === 1 && A === 1 && E === (P.length === 0 || !!(P[0] & 128));
            if (x)
              return {
                isSingleOpaquePixel: x
              };
            if (H) {
              if (l.ImageResizer.needsToBeResized(d, A)) {
                const u = new Uint8ClampedArray(d * A * 4);
                return (0, F.convertBlackAndWhiteToRGBA)({
                  src: P,
                  dest: u,
                  width: d,
                  height: A,
                  nonBlackColor: 0,
                  inverseDecode: E
                }), l.ImageResizer.createImage({
                  kind: n.ImageKind.RGBA_32BPP,
                  data: u,
                  width: d,
                  height: A,
                  interpolate: k
                });
              }
              const R = new OffscreenCanvas(d, A), f = R.getContext("2d"), c = f.createImageData(d, A);
              (0, F.convertBlackAndWhiteToRGBA)({
                src: P,
                dest: c.data,
                width: d,
                height: A,
                nonBlackColor: 0,
                inverseDecode: E
              }), f.putImageData(c, 0, 0);
              const N = R.transferToImageBitmap();
              return {
                data: null,
                width: d,
                height: A,
                interpolate: k,
                bitmap: N
              };
            }
            return this.createRawMask({
              imgArray: P,
              width: d,
              height: A,
              inverseDecode: E,
              imageIsFromDecodeStream: I,
              interpolate: k
            });
          }
          get drawWidth() {
            var P, d;
            return Math.max(this.width, ((P = this.smask) == null ? void 0 : P.width) || 0, ((d = this.mask) == null ? void 0 : d.width) || 0);
          }
          get drawHeight() {
            var P, d;
            return Math.max(this.height, ((P = this.smask) == null ? void 0 : P.height) || 0, ((d = this.mask) == null ? void 0 : d.height) || 0);
          }
          decodeBuffer(P) {
            const d = this.bpc, A = this.numComps, I = this.decodeAddends, E = this.decodeCoefficients, k = (1 << d) - 1;
            let H, x;
            if (d === 1) {
              for (H = 0, x = P.length; H < x; H++)
                P[H] = +!P[H];
              return;
            }
            let R = 0;
            for (H = 0, x = this.width * this.height; H < x; H++)
              for (let f = 0; f < A; f++)
                P[R] = v(P[R], I[f], E[f], k), R++;
          }
          getComponents(P) {
            const d = this.bpc;
            if (d === 8)
              return P;
            const A = this.width, I = this.height, E = this.numComps, k = A * I * E;
            let H = 0, x;
            d <= 8 ? x = new Uint8Array(k) : d <= 16 ? x = new Uint16Array(k) : x = new Uint32Array(k);
            const R = A * E, f = (1 << d) - 1;
            let c = 0, N, u;
            if (d === 1) {
              let p, S, B;
              for (let T = 0; T < I; T++) {
                for (S = c + (R & -8), B = c + R; c < S; )
                  u = P[H++], x[c] = u >> 7 & 1, x[c + 1] = u >> 6 & 1, x[c + 2] = u >> 5 & 1, x[c + 3] = u >> 4 & 1, x[c + 4] = u >> 3 & 1, x[c + 5] = u >> 2 & 1, x[c + 6] = u >> 1 & 1, x[c + 7] = u & 1, c += 8;
                if (c < B)
                  for (u = P[H++], p = 128; c < B; )
                    x[c++] = +!!(u & p), p >>= 1;
              }
            } else {
              let p = 0;
              for (u = 0, c = 0, N = k; c < N; ++c) {
                for (c % R === 0 && (u = 0, p = 0); p < d; )
                  u = u << 8 | P[H++], p += 8;
                const S = p - d;
                let B = u >> S;
                B < 0 ? B = 0 : B > f && (B = f), x[c] = B, u &= (1 << S) - 1, p = S;
              }
            }
            return x;
          }
          fillOpacity(P, d, A, I, E) {
            const k = this.smask, H = this.mask;
            let x, R, f, c, N, u;
            if (k)
              R = k.width, f = k.height, x = new Uint8ClampedArray(R * f), k.fillGrayBuffer(x), (R !== d || f !== A) && (x = g(x, k.bpc, R, f, d, A));
            else if (H)
              if (H instanceof b) {
                for (R = H.width, f = H.height, x = new Uint8ClampedArray(R * f), H.numComps = 1, H.fillGrayBuffer(x), c = 0, N = R * f; c < N; ++c)
                  x[c] = 255 - x[c];
                (R !== d || f !== A) && (x = g(x, H.bpc, R, f, d, A));
              } else if (Array.isArray(H)) {
                x = new Uint8ClampedArray(d * A);
                const p = this.numComps;
                for (c = 0, N = d * A; c < N; ++c) {
                  let S = 0;
                  const B = c * p;
                  for (u = 0; u < p; ++u) {
                    const T = E[B + u], D = u * 2;
                    if (T < H[D] || T > H[D + 1]) {
                      S = 255;
                      break;
                    }
                  }
                  x[c] = S;
                }
              } else
                throw new n.FormatError("Unknown mask format.");
            if (x)
              for (c = 0, u = 3, N = d * I; c < N; ++c, u += 4)
                P[u] = x[c];
            else
              for (c = 0, u = 3, N = d * I; c < N; ++c, u += 4)
                P[u] = 255;
          }
          undoPreblend(P, d, A) {
            var f;
            const I = (f = this.smask) == null ? void 0 : f.matte;
            if (!I)
              return;
            const E = this.colorSpace.getRgb(I, 0), k = E[0], H = E[1], x = E[2], R = d * A * 4;
            for (let c = 0; c < R; c += 4) {
              const N = P[c + 3];
              if (N === 0) {
                P[c] = 255, P[c + 1] = 255, P[c + 2] = 255;
                continue;
              }
              const u = 255 / N;
              P[c] = (P[c] - k) * u + k, P[c + 1] = (P[c + 1] - H) * u + H, P[c + 2] = (P[c + 2] - x) * u + x;
            }
          }
          async createImageData(P = !1, d = !1) {
            const A = this.drawWidth, I = this.drawHeight, E = {
              width: A,
              height: I,
              interpolate: this.interpolate,
              kind: 0,
              data: null
            }, k = this.numComps, H = this.width, x = this.height, R = this.bpc, f = H * k * R + 7 >> 3, c = d && l.ImageResizer.needsToBeResized(A, I);
            if (!P) {
              let o;
              if (this.colorSpace.name === "DeviceGray" && R === 1 ? o = n.ImageKind.GRAYSCALE_1BPP : this.colorSpace.name === "DeviceRGB" && R === 8 && !this.needsDecode && (o = n.ImageKind.RGB_24BPP), o && !this.smask && !this.mask && A === H && I === x) {
                const m = this.getImageBytes(x * f, {});
                if (d)
                  return c ? l.ImageResizer.createImage({
                    data: m,
                    kind: o,
                    width: A,
                    height: I,
                    interpolate: this.interpolate
                  }, this.needsDecode) : this.createBitmap(o, H, x, m);
                if (E.kind = o, E.data = m, this.needsDecode) {
                  (0, n.assert)(o === n.ImageKind.GRAYSCALE_1BPP, "PDFImage.createImageData: The image must be grayscale.");
                  const s = E.data;
                  for (let r = 0, y = s.length; r < y; r++)
                    s[r] ^= 255;
                }
                return E;
              }
              if (this.image instanceof j.JpegStream && !this.smask && !this.mask && !this.needsDecode) {
                let m = x * f;
                if (d && !c) {
                  let s = !1;
                  switch (this.colorSpace.name) {
                    case "DeviceGray":
                      m *= 4, s = !0;
                      break;
                    case "DeviceRGB":
                      m = m / 3 * 4, s = !0;
                      break;
                    case "DeviceCMYK":
                      s = !0;
                      break;
                  }
                  if (s) {
                    const r = this.getImageBytes(m, {
                      drawWidth: A,
                      drawHeight: I,
                      forceRGBA: !0
                    });
                    return this.createBitmap(n.ImageKind.RGBA_32BPP, A, I, r);
                  }
                } else
                  switch (this.colorSpace.name) {
                    case "DeviceGray":
                      m *= 3;
                    case "DeviceRGB":
                    case "DeviceCMYK":
                      return E.kind = n.ImageKind.RGB_24BPP, E.data = this.getImageBytes(m, {
                        drawWidth: A,
                        drawHeight: I,
                        forceRGB: !0
                      }), c ? l.ImageResizer.createImage(E) : E;
                  }
              }
            }
            const N = this.getImageBytes(x * f, {
              internal: !0
            }), u = 0 | N.length / f * I / x, p = this.getComponents(N);
            let S, B, T, D, K, _;
            if (d && !c && (T = new OffscreenCanvas(A, I), D = T.getContext("2d"), K = D.createImageData(A, I), _ = K.data), E.kind = n.ImageKind.RGBA_32BPP, !P && !this.smask && !this.mask ? (!d || c ? (E.kind = n.ImageKind.RGB_24BPP, _ = new Uint8ClampedArray(A * I * 3), S = 0) : (new Uint32Array(_.buffer).fill(n.FeatureTest.isLittleEndian ? 4278190080 : 255), S = 1), B = !1) : ((!d || c) && (_ = new Uint8ClampedArray(A * I * 4)), S = 1, B = !0, this.fillOpacity(_, A, I, u, p)), this.needsDecode && this.decodeBuffer(p), this.colorSpace.fillRgb(_, H, x, A, I, u, R, p, S), B && this.undoPreblend(_, A, u), d && !c) {
              D.putImageData(K, 0, 0);
              const o = T.transferToImageBitmap();
              return {
                data: null,
                width: A,
                height: I,
                bitmap: o,
                interpolate: this.interpolate
              };
            }
            return E.data = _, c ? l.ImageResizer.createImage(E) : E;
          }
          fillGrayBuffer(P) {
            const d = this.numComps;
            if (d !== 1)
              throw new n.FormatError(`Reading gray scale from a color image: ${d}`);
            const A = this.width, I = this.height, E = this.bpc, k = A * d * E + 7 >> 3, H = this.getImageBytes(I * k, {
              internal: !0
            }), x = this.getComponents(H);
            let R, f;
            if (E === 1) {
              if (f = A * I, this.needsDecode)
                for (R = 0; R < f; ++R)
                  P[R] = x[R] - 1 & 255;
              else
                for (R = 0; R < f; ++R)
                  P[R] = -x[R] & 255;
              return;
            }
            this.needsDecode && this.decodeBuffer(x), f = A * I;
            const c = 255 / ((1 << E) - 1);
            for (R = 0; R < f; ++R)
              P[R] = c * x[R];
          }
          createBitmap(P, d, A, I) {
            const E = new OffscreenCanvas(d, A), k = E.getContext("2d");
            let H;
            P === n.ImageKind.RGBA_32BPP ? H = new ImageData(I, d, A) : (H = k.createImageData(d, A), (0, F.convertToRGBA)({
              kind: P,
              src: I,
              dest: new Uint32Array(H.data.buffer),
              width: d,
              height: A,
              inverseDecode: this.needsDecode
            })), k.putImageData(H, 0, 0);
            const x = E.transferToImageBitmap();
            return {
              data: null,
              width: d,
              height: A,
              bitmap: x,
              interpolate: this.interpolate
            };
          }
          getImageBytes(P, {
            drawWidth: d,
            drawHeight: A,
            forceRGBA: I = !1,
            forceRGB: E = !1,
            internal: k = !1
          }) {
            this.image.reset(), this.image.drawWidth = d || this.width, this.image.drawHeight = A || this.height, this.image.forceRGBA = !!I, this.image.forceRGB = !!E;
            const H = this.image.getBytes(P);
            return k || this.image instanceof t.DecodeStream ? H : ((0, n.assert)(H instanceof Uint8Array, 'PDFImage.getImageBytes: Unsupported "imageBytes" type.'), new Uint8Array(H));
          }
        }
        w.PDFImage = b;
      },
      /* 66 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.Catalog = void 0;
        var n = V(3), F = V(2), C = V(4), e = V(67), t = V(5), l = V(68), j = V(12), U = V(69), O = V(59), v = V(70), g = V(72);
        function b(P) {
          return P instanceof C.Dict && (P = P.get("D")), Array.isArray(P) ? P : null;
        }
        class i {
          constructor(d, A) {
            if (this.pdfManager = d, this.xref = A, this._catDict = A.getCatalogObj(), !(this._catDict instanceof C.Dict))
              throw new F.FormatError("Catalog object is not a dictionary.");
            this.toplevelPagesDict, this._actualNumPages = null, this.fontCache = new C.RefSetCache(), this.builtInCMapCache = /* @__PURE__ */ new Map(), this.standardFontDataCache = /* @__PURE__ */ new Map(), this.globalImageCache = new O.GlobalImageCache(), this.pageKidsCountCache = new C.RefSetCache(), this.pageIndexCache = new C.RefSetCache(), this.nonBlendModesSet = new C.RefSet(), this.systemFontCache = /* @__PURE__ */ new Map();
          }
          cloneDict() {
            return this._catDict.clone();
          }
          get version() {
            const d = this._catDict.get("Version");
            if (d instanceof C.Name) {
              if (n.PDF_VERSION_REGEXP.test(d.name))
                return (0, F.shadow)(this, "version", d.name);
              (0, F.warn)(`Invalid PDF catalog version: ${d.name}`);
            }
            return (0, F.shadow)(this, "version", null);
          }
          get lang() {
            const d = this._catDict.get("Lang");
            return (0, F.shadow)(this, "lang", typeof d == "string" ? (0, F.stringToPDFString)(d) : null);
          }
          get needsRendering() {
            const d = this._catDict.get("NeedsRendering");
            return (0, F.shadow)(this, "needsRendering", typeof d == "boolean" ? d : !1);
          }
          get collection() {
            let d = null;
            try {
              const A = this._catDict.get("Collection");
              A instanceof C.Dict && A.size > 0 && (d = A);
            } catch (A) {
              if (A instanceof n.MissingDataException)
                throw A;
              (0, F.info)("Cannot fetch Collection entry; assuming no collection is present.");
            }
            return (0, F.shadow)(this, "collection", d);
          }
          get acroForm() {
            let d = null;
            try {
              const A = this._catDict.get("AcroForm");
              A instanceof C.Dict && A.size > 0 && (d = A);
            } catch (A) {
              if (A instanceof n.MissingDataException)
                throw A;
              (0, F.info)("Cannot fetch AcroForm entry; assuming no forms are present.");
            }
            return (0, F.shadow)(this, "acroForm", d);
          }
          get acroFormRef() {
            const d = this._catDict.getRaw("AcroForm");
            return (0, F.shadow)(this, "acroFormRef", d instanceof C.Ref ? d : null);
          }
          get metadata() {
            var I;
            const d = this._catDict.getRaw("Metadata");
            if (!(d instanceof C.Ref))
              return (0, F.shadow)(this, "metadata", null);
            let A = null;
            try {
              const E = this.xref.fetch(d, !((I = this.xref.encrypt) != null && I.encryptMetadata));
              if (E instanceof t.BaseStream && E.dict instanceof C.Dict) {
                const k = E.dict.get("Type"), H = E.dict.get("Subtype");
                if ((0, C.isName)(k, "Metadata") && (0, C.isName)(H, "XML")) {
                  const x = (0, F.stringToUTF8String)(E.getString());
                  x && (A = new v.MetadataParser(x).serializable);
                }
              }
            } catch (E) {
              if (E instanceof n.MissingDataException)
                throw E;
              (0, F.info)(`Skipping invalid Metadata: "${E}".`);
            }
            return (0, F.shadow)(this, "metadata", A);
          }
          get markInfo() {
            let d = null;
            try {
              d = this._readMarkInfo();
            } catch (A) {
              if (A instanceof n.MissingDataException)
                throw A;
              (0, F.warn)("Unable to read mark info.");
            }
            return (0, F.shadow)(this, "markInfo", d);
          }
          _readMarkInfo() {
            const d = this._catDict.get("MarkInfo");
            if (!(d instanceof C.Dict))
              return null;
            const A = {
              Marked: !1,
              UserProperties: !1,
              Suspects: !1
            };
            for (const I in A) {
              const E = d.get(I);
              typeof E == "boolean" && (A[I] = E);
            }
            return A;
          }
          get structTreeRoot() {
            let d = null;
            try {
              d = this._readStructTreeRoot();
            } catch (A) {
              if (A instanceof n.MissingDataException)
                throw A;
              (0, F.warn)("Unable read to structTreeRoot info.");
            }
            return (0, F.shadow)(this, "structTreeRoot", d);
          }
          _readStructTreeRoot() {
            const d = this._catDict.getRaw("StructTreeRoot"), A = this.xref.fetchIfRef(d);
            if (!(A instanceof C.Dict))
              return null;
            const I = new g.StructTreeRoot(A, d);
            return I.init(), I;
          }
          get toplevelPagesDict() {
            const d = this._catDict.get("Pages");
            if (!(d instanceof C.Dict))
              throw new F.FormatError("Invalid top-level pages dictionary.");
            return (0, F.shadow)(this, "toplevelPagesDict", d);
          }
          get documentOutline() {
            let d = null;
            try {
              d = this._readDocumentOutline();
            } catch (A) {
              if (A instanceof n.MissingDataException)
                throw A;
              (0, F.warn)("Unable to read document outline.");
            }
            return (0, F.shadow)(this, "documentOutline", d);
          }
          _readDocumentOutline() {
            let d = this._catDict.get("Outlines");
            if (!(d instanceof C.Dict) || (d = d.getRaw("First"), !(d instanceof C.Ref)))
              return null;
            const A = {
              items: []
            }, I = [{
              obj: d,
              parent: A
            }], E = new C.RefSet();
            E.put(d);
            const k = this.xref, H = new Uint8ClampedArray(3);
            for (; I.length > 0; ) {
              const x = I.shift(), R = k.fetchIfRef(x.obj);
              if (R === null)
                continue;
              if (!R.has("Title"))
                throw new F.FormatError("Invalid outline item encountered.");
              const f = {
                url: null,
                dest: null,
                action: null
              };
              i.parseDestDictionary({
                destDict: R,
                resultObj: f,
                docBaseUrl: this.baseUrl,
                docAttachments: this.attachments
              });
              const c = R.get("Title"), N = R.get("F") || 0, u = R.getArray("C"), p = R.get("Count");
              let S = H;
              Array.isArray(u) && u.length === 3 && (u[0] !== 0 || u[1] !== 0 || u[2] !== 0) && (S = j.ColorSpace.singletons.rgb.getRgb(u, 0));
              const B = {
                action: f.action,
                attachment: f.attachment,
                dest: f.dest,
                url: f.url,
                unsafeUrl: f.unsafeUrl,
                newWindow: f.newWindow,
                setOCGState: f.setOCGState,
                title: (0, F.stringToPDFString)(c),
                color: S,
                count: Number.isInteger(p) ? p : void 0,
                bold: !!(N & 2),
                italic: !!(N & 1),
                items: []
              };
              x.parent.items.push(B), d = R.getRaw("First"), d instanceof C.Ref && !E.has(d) && (I.push({
                obj: d,
                parent: B
              }), E.put(d)), d = R.getRaw("Next"), d instanceof C.Ref && !E.has(d) && (I.push({
                obj: d,
                parent: x.parent
              }), E.put(d));
            }
            return A.items.length > 0 ? A.items : null;
          }
          get permissions() {
            let d = null;
            try {
              d = this._readPermissions();
            } catch (A) {
              if (A instanceof n.MissingDataException)
                throw A;
              (0, F.warn)("Unable to read permissions.");
            }
            return (0, F.shadow)(this, "permissions", d);
          }
          _readPermissions() {
            const d = this.xref.trailer.get("Encrypt");
            if (!(d instanceof C.Dict))
              return null;
            let A = d.get("P");
            if (typeof A != "number")
              return null;
            A += 4294967296;
            const I = [];
            for (const E in F.PermissionFlag) {
              const k = F.PermissionFlag[E];
              A & k && I.push(k);
            }
            return I;
          }
          get optionalContentConfig() {
            let d = null;
            try {
              const A = this._catDict.get("OCProperties");
              if (!A)
                return (0, F.shadow)(this, "optionalContentConfig", null);
              const I = A.get("D");
              if (!I)
                return (0, F.shadow)(this, "optionalContentConfig", null);
              const E = A.get("OCGs");
              if (!Array.isArray(E))
                return (0, F.shadow)(this, "optionalContentConfig", null);
              const k = [], H = [];
              for (const x of E) {
                if (!(x instanceof C.Ref))
                  continue;
                H.push(x);
                const R = this.xref.fetchIfRef(x);
                k.push({
                  id: x.toString(),
                  name: typeof R.get("Name") == "string" ? (0, F.stringToPDFString)(R.get("Name")) : null,
                  intent: typeof R.get("Intent") == "string" ? (0, F.stringToPDFString)(R.get("Intent")) : null
                });
              }
              d = this._readOptionalContentConfig(I, H), d.groups = k;
            } catch (A) {
              if (A instanceof n.MissingDataException)
                throw A;
              (0, F.warn)(`Unable to read optional content config: ${A}`);
            }
            return (0, F.shadow)(this, "optionalContentConfig", d);
          }
          _readOptionalContentConfig(d, A) {
            function I(f) {
              const c = [];
              if (Array.isArray(f))
                for (const N of f)
                  N instanceof C.Ref && A.includes(N) && c.push(N.toString());
              return c;
            }
            function E(f, c = 0) {
              if (!Array.isArray(f))
                return null;
              const N = [];
              for (const p of f) {
                if (p instanceof C.Ref && A.includes(p)) {
                  x.put(p), N.push(p.toString());
                  continue;
                }
                const S = k(p, c);
                S && N.push(S);
              }
              if (c > 0)
                return N;
              const u = [];
              for (const p of A)
                x.has(p) || u.push(p.toString());
              return u.length && N.push({
                name: null,
                order: u
              }), N;
            }
            function k(f, c) {
              if (++c > R)
                return (0, F.warn)("parseNestedOrder - reached MAX_NESTED_LEVELS."), null;
              const N = H.fetchIfRef(f);
              if (!Array.isArray(N))
                return null;
              const u = H.fetchIfRef(N[0]);
              if (typeof u != "string")
                return null;
              const p = E(N.slice(1), c);
              return !p || !p.length ? null : {
                name: (0, F.stringToPDFString)(u),
                order: p
              };
            }
            const H = this.xref, x = new C.RefSet(), R = 10;
            return {
              name: typeof d.get("Name") == "string" ? (0, F.stringToPDFString)(d.get("Name")) : null,
              creator: typeof d.get("Creator") == "string" ? (0, F.stringToPDFString)(d.get("Creator")) : null,
              baseState: d.get("BaseState") instanceof C.Name ? d.get("BaseState").name : null,
              on: I(d.get("ON")),
              off: I(d.get("OFF")),
              order: E(d.get("Order")),
              groups: null
            };
          }
          setActualNumPages(d = null) {
            this._actualNumPages = d;
          }
          get hasActualNumPages() {
            return this._actualNumPages !== null;
          }
          get _pagesCount() {
            const d = this.toplevelPagesDict.get("Count");
            if (!Number.isInteger(d))
              throw new F.FormatError("Page count in top-level pages dictionary is not an integer.");
            return (0, F.shadow)(this, "_pagesCount", d);
          }
          get numPages() {
            return this.hasActualNumPages ? this._actualNumPages : this._pagesCount;
          }
          get destinations() {
            const d = this._readDests(), A = /* @__PURE__ */ Object.create(null);
            if (d instanceof e.NameTree)
              for (const [I, E] of d.getAll()) {
                const k = b(E);
                k && (A[(0, F.stringToPDFString)(I)] = k);
              }
            else
              d instanceof C.Dict && d.forEach(function(I, E) {
                const k = b(E);
                k && (A[I] = k);
              });
            return (0, F.shadow)(this, "destinations", A);
          }
          getDestination(d) {
            const A = this._readDests();
            if (A instanceof e.NameTree) {
              const I = b(A.get(d));
              if (I)
                return I;
              const E = this.destinations[d];
              if (E)
                return (0, F.warn)(`Found "${d}" at an incorrect position in the NameTree.`), E;
            } else if (A instanceof C.Dict) {
              const I = b(A.get(d));
              if (I)
                return I;
            }
            return null;
          }
          _readDests() {
            const d = this._catDict.get("Names");
            if (d != null && d.has("Dests"))
              return new e.NameTree(d.getRaw("Dests"), this.xref);
            if (this._catDict.has("Dests"))
              return this._catDict.get("Dests");
          }
          get pageLabels() {
            let d = null;
            try {
              d = this._readPageLabels();
            } catch (A) {
              if (A instanceof n.MissingDataException)
                throw A;
              (0, F.warn)("Unable to read page labels.");
            }
            return (0, F.shadow)(this, "pageLabels", d);
          }
          _readPageLabels() {
            const d = this._catDict.getRaw("PageLabels");
            if (!d)
              return null;
            const A = new Array(this.numPages);
            let I = null, E = "";
            const H = new e.NumberTree(d, this.xref).getAll();
            let x = "", R = 1;
            for (let f = 0, c = this.numPages; f < c; f++) {
              const N = H.get(f);
              if (N !== void 0) {
                if (!(N instanceof C.Dict))
                  throw new F.FormatError("PageLabel is not a dictionary.");
                if (N.has("Type") && !(0, C.isName)(N.get("Type"), "PageLabel"))
                  throw new F.FormatError("Invalid type in PageLabel dictionary.");
                if (N.has("S")) {
                  const u = N.get("S");
                  if (!(u instanceof C.Name))
                    throw new F.FormatError("Invalid style in PageLabel dictionary.");
                  I = u.name;
                } else
                  I = null;
                if (N.has("P")) {
                  const u = N.get("P");
                  if (typeof u != "string")
                    throw new F.FormatError("Invalid prefix in PageLabel dictionary.");
                  E = (0, F.stringToPDFString)(u);
                } else
                  E = "";
                if (N.has("St")) {
                  const u = N.get("St");
                  if (!(Number.isInteger(u) && u >= 1))
                    throw new F.FormatError("Invalid start in PageLabel dictionary.");
                  R = u;
                } else
                  R = 1;
              }
              switch (I) {
                case "D":
                  x = R;
                  break;
                case "R":
                case "r":
                  x = (0, n.toRomanNumerals)(R, I === "r");
                  break;
                case "A":
                case "a":
                  const u = 26, B = I === "a" ? 97 : 65, T = R - 1;
                  x = String.fromCharCode(B + T % u).repeat(Math.floor(T / u) + 1);
                  break;
                default:
                  if (I)
                    throw new F.FormatError(`Invalid style "${I}" in PageLabel dictionary.`);
                  x = "";
              }
              A[f] = E + x, R++;
            }
            return A;
          }
          get pageLayout() {
            const d = this._catDict.get("PageLayout");
            let A = "";
            if (d instanceof C.Name)
              switch (d.name) {
                case "SinglePage":
                case "OneColumn":
                case "TwoColumnLeft":
                case "TwoColumnRight":
                case "TwoPageLeft":
                case "TwoPageRight":
                  A = d.name;
              }
            return (0, F.shadow)(this, "pageLayout", A);
          }
          get pageMode() {
            const d = this._catDict.get("PageMode");
            let A = "UseNone";
            if (d instanceof C.Name)
              switch (d.name) {
                case "UseNone":
                case "UseOutlines":
                case "UseThumbs":
                case "FullScreen":
                case "UseOC":
                case "UseAttachments":
                  A = d.name;
              }
            return (0, F.shadow)(this, "pageMode", A);
          }
          get viewerPreferences() {
            const d = this._catDict.get("ViewerPreferences");
            if (!(d instanceof C.Dict))
              return (0, F.shadow)(this, "viewerPreferences", null);
            let A = null;
            for (const I of d.getKeys()) {
              const E = d.get(I);
              let k;
              switch (I) {
                case "HideToolbar":
                case "HideMenubar":
                case "HideWindowUI":
                case "FitWindow":
                case "CenterWindow":
                case "DisplayDocTitle":
                case "PickTrayByPDFSize":
                  typeof E == "boolean" && (k = E);
                  break;
                case "NonFullScreenPageMode":
                  if (E instanceof C.Name)
                    switch (E.name) {
                      case "UseNone":
                      case "UseOutlines":
                      case "UseThumbs":
                      case "UseOC":
                        k = E.name;
                        break;
                      default:
                        k = "UseNone";
                    }
                  break;
                case "Direction":
                  if (E instanceof C.Name)
                    switch (E.name) {
                      case "L2R":
                      case "R2L":
                        k = E.name;
                        break;
                      default:
                        k = "L2R";
                    }
                  break;
                case "ViewArea":
                case "ViewClip":
                case "PrintArea":
                case "PrintClip":
                  if (E instanceof C.Name)
                    switch (E.name) {
                      case "MediaBox":
                      case "CropBox":
                      case "BleedBox":
                      case "TrimBox":
                      case "ArtBox":
                        k = E.name;
                        break;
                      default:
                        k = "CropBox";
                    }
                  break;
                case "PrintScaling":
                  if (E instanceof C.Name)
                    switch (E.name) {
                      case "None":
                      case "AppDefault":
                        k = E.name;
                        break;
                      default:
                        k = "AppDefault";
                    }
                  break;
                case "Duplex":
                  if (E instanceof C.Name)
                    switch (E.name) {
                      case "Simplex":
                      case "DuplexFlipShortEdge":
                      case "DuplexFlipLongEdge":
                        k = E.name;
                        break;
                      default:
                        k = "None";
                    }
                  break;
                case "PrintPageRange":
                  Array.isArray(E) && E.length % 2 === 0 && E.every((x, R, f) => Number.isInteger(x) && x > 0 && (R === 0 || x >= f[R - 1]) && x <= this.numPages) && (k = E);
                  break;
                case "NumCopies":
                  Number.isInteger(E) && E > 0 && (k = E);
                  break;
                default:
                  (0, F.warn)(`Ignoring non-standard key in ViewerPreferences: ${I}.`);
                  continue;
              }
              if (k === void 0) {
                (0, F.warn)(`Bad value, for key "${I}", in ViewerPreferences: ${E}.`);
                continue;
              }
              A || (A = /* @__PURE__ */ Object.create(null)), A[I] = k;
            }
            return (0, F.shadow)(this, "viewerPreferences", A);
          }
          get openAction() {
            const d = this._catDict.get("OpenAction"), A = /* @__PURE__ */ Object.create(null);
            if (d instanceof C.Dict) {
              const I = new C.Dict(this.xref);
              I.set("A", d);
              const E = {
                url: null,
                dest: null,
                action: null
              };
              i.parseDestDictionary({
                destDict: I,
                resultObj: E
              }), Array.isArray(E.dest) ? A.dest = E.dest : E.action && (A.action = E.action);
            } else
              Array.isArray(d) && (A.dest = d);
            return (0, F.shadow)(this, "openAction", (0, F.objectSize)(A) > 0 ? A : null);
          }
          get attachments() {
            const d = this._catDict.get("Names");
            let A = null;
            if (d instanceof C.Dict && d.has("EmbeddedFiles")) {
              const I = new e.NameTree(d.getRaw("EmbeddedFiles"), this.xref);
              for (const [E, k] of I.getAll()) {
                const H = new U.FileSpec(k, this.xref);
                A || (A = /* @__PURE__ */ Object.create(null)), A[(0, F.stringToPDFString)(E)] = H.serializable;
              }
            }
            return (0, F.shadow)(this, "attachments", A);
          }
          get xfaImages() {
            const d = this._catDict.get("Names");
            let A = null;
            if (d instanceof C.Dict && d.has("XFAImages")) {
              const I = new e.NameTree(d.getRaw("XFAImages"), this.xref);
              for (const [E, k] of I.getAll())
                A || (A = new C.Dict(this.xref)), A.set((0, F.stringToPDFString)(E), k);
            }
            return (0, F.shadow)(this, "xfaImages", A);
          }
          _collectJavaScript() {
            const d = this._catDict.get("Names");
            let A = null;
            function I(k, H) {
              if (!(H instanceof C.Dict) || !(0, C.isName)(H.get("S"), "JavaScript"))
                return;
              let x = H.get("JS");
              if (x instanceof t.BaseStream)
                x = x.getString();
              else if (typeof x != "string")
                return;
              x = (0, F.stringToPDFString)(x).replaceAll("\0", ""), x && (A || (A = /* @__PURE__ */ new Map())).set(k, x);
            }
            if (d instanceof C.Dict && d.has("JavaScript")) {
              const k = new e.NameTree(d.getRaw("JavaScript"), this.xref);
              for (const [H, x] of k.getAll())
                I((0, F.stringToPDFString)(H), x);
            }
            const E = this._catDict.get("OpenAction");
            return E && I("OpenAction", E), A;
          }
          get jsActions() {
            const d = this._collectJavaScript();
            let A = (0, n.collectActions)(this.xref, this._catDict, F.DocumentActionEventType);
            if (d) {
              A || (A = /* @__PURE__ */ Object.create(null));
              for (const [I, E] of d)
                I in A ? A[I].push(E) : A[I] = [E];
            }
            return (0, F.shadow)(this, "jsActions", A);
          }
          async fontFallback(d, A) {
            const I = await Promise.all(this.fontCache);
            for (const E of I)
              if (E.loadedName === d) {
                E.fallback(A);
                return;
              }
          }
          async cleanup(d = !1) {
            (0, l.clearGlobalCaches)(), this.globalImageCache.clear(d), this.pageKidsCountCache.clear(), this.pageIndexCache.clear(), this.nonBlendModesSet.clear();
            const A = await Promise.all(this.fontCache);
            for (const {
              dict: I
            } of A)
              delete I.cacheKey;
            this.fontCache.clear(), this.builtInCMapCache.clear(), this.standardFontDataCache.clear(), this.systemFontCache.clear();
          }
          async getPageDict(d) {
            const A = [this.toplevelPagesDict], I = new C.RefSet(), E = this._catDict.getRaw("Pages");
            E instanceof C.Ref && I.put(E);
            const k = this.xref, H = this.pageKidsCountCache, x = this.pageIndexCache;
            let R = 0;
            for (; A.length; ) {
              const f = A.pop();
              if (f instanceof C.Ref) {
                const p = H.get(f);
                if (p >= 0 && R + p <= d) {
                  R += p;
                  continue;
                }
                if (I.has(f))
                  throw new F.FormatError("Pages tree contains circular reference.");
                I.put(f);
                const S = await k.fetchAsync(f);
                if (S instanceof C.Dict) {
                  let B = S.getRaw("Type");
                  if (B instanceof C.Ref && (B = await k.fetchAsync(B)), (0, C.isName)(B, "Page") || !S.has("Kids")) {
                    if (H.has(f) || H.put(f, 1), x.has(f) || x.put(f, R), R === d)
                      return [S, f];
                    R++;
                    continue;
                  }
                }
                A.push(S);
                continue;
              }
              if (!(f instanceof C.Dict))
                throw new F.FormatError("Page dictionary kid reference points to wrong type of object.");
              const {
                objId: c
              } = f;
              let N = f.getRaw("Count");
              if (N instanceof C.Ref && (N = await k.fetchAsync(N)), Number.isInteger(N) && N >= 0 && (c && !H.has(c) && H.put(c, N), R + N <= d)) {
                R += N;
                continue;
              }
              let u = f.getRaw("Kids");
              if (u instanceof C.Ref && (u = await k.fetchAsync(u)), !Array.isArray(u)) {
                let p = f.getRaw("Type");
                if (p instanceof C.Ref && (p = await k.fetchAsync(p)), (0, C.isName)(p, "Page") || !f.has("Kids")) {
                  if (R === d)
                    return [f, null];
                  R++;
                  continue;
                }
                throw new F.FormatError("Page dictionary kids object is not an array.");
              }
              for (let p = u.length - 1; p >= 0; p--)
                A.push(u[p]);
            }
            throw new Error(`Page index ${d} not found.`);
          }
          async getAllPageDicts(d = !1) {
            const {
              ignoreErrors: A
            } = this.pdfManager.evaluatorOptions, I = [{
              currentNode: this.toplevelPagesDict,
              posInKids: 0
            }], E = new C.RefSet(), k = this._catDict.getRaw("Pages");
            k instanceof C.Ref && E.put(k);
            const H = /* @__PURE__ */ new Map(), x = this.xref, R = this.pageIndexCache;
            let f = 0;
            function c(u, p) {
              p && !R.has(p) && R.put(p, f), H.set(f++, [u, p]);
            }
            function N(u) {
              if (u instanceof n.XRefEntryException && !d)
                throw u;
              d && A && f === 0 && ((0, F.warn)(`getAllPageDicts - Skipping invalid first page: "${u}".`), u = C.Dict.empty), H.set(f++, [u, null]);
            }
            for (; I.length > 0; ) {
              const u = I.at(-1), {
                currentNode: p,
                posInKids: S
              } = u;
              let B = p.getRaw("Kids");
              if (B instanceof C.Ref)
                try {
                  B = await x.fetchAsync(B);
                } catch (_) {
                  N(_);
                  break;
                }
              if (!Array.isArray(B)) {
                N(new F.FormatError("Page dictionary kids object is not an array."));
                break;
              }
              if (S >= B.length) {
                I.pop();
                continue;
              }
              const T = B[S];
              let D;
              if (T instanceof C.Ref) {
                if (E.has(T)) {
                  N(new F.FormatError("Pages tree contains circular reference."));
                  break;
                }
                E.put(T);
                try {
                  D = await x.fetchAsync(T);
                } catch (_) {
                  N(_);
                  break;
                }
              } else
                D = T;
              if (!(D instanceof C.Dict)) {
                N(new F.FormatError("Page dictionary kid reference points to wrong type of object."));
                break;
              }
              let K = D.getRaw("Type");
              if (K instanceof C.Ref)
                try {
                  K = await x.fetchAsync(K);
                } catch (_) {
                  N(_);
                  break;
                }
              (0, C.isName)(K, "Page") || !D.has("Kids") ? c(D, T instanceof C.Ref ? T : null) : I.push({
                currentNode: D,
                posInKids: 0
              }), u.posInKids++;
            }
            return H;
          }
          getPageIndex(d) {
            const A = this.pageIndexCache.get(d);
            if (A !== void 0)
              return Promise.resolve(A);
            const I = this.xref;
            function E(x) {
              let R = 0, f;
              return I.fetchAsync(x).then(function(c) {
                if ((0, C.isRefsEqual)(x, d) && !(0, C.isDict)(c, "Page") && !(c instanceof C.Dict && !c.has("Type") && c.has("Contents")))
                  throw new F.FormatError("The reference does not point to a /Page dictionary.");
                if (!c)
                  return null;
                if (!(c instanceof C.Dict))
                  throw new F.FormatError("Node must be a dictionary.");
                return f = c.getRaw("Parent"), c.getAsync("Parent");
              }).then(function(c) {
                if (!c)
                  return null;
                if (!(c instanceof C.Dict))
                  throw new F.FormatError("Parent must be a dictionary.");
                return c.getAsync("Kids");
              }).then(function(c) {
                if (!c)
                  return null;
                const N = [];
                let u = !1;
                for (const p of c) {
                  if (!(p instanceof C.Ref))
                    throw new F.FormatError("Kid must be a reference.");
                  if ((0, C.isRefsEqual)(p, x)) {
                    u = !0;
                    break;
                  }
                  N.push(I.fetchAsync(p).then(function(S) {
                    if (!(S instanceof C.Dict))
                      throw new F.FormatError("Kid node must be a dictionary.");
                    S.has("Count") ? R += S.get("Count") : R++;
                  }));
                }
                if (!u)
                  throw new F.FormatError("Kid reference not found in parent's kids.");
                return Promise.all(N).then(function() {
                  return [R, f];
                });
              });
            }
            let k = 0;
            const H = (x) => E(x).then((R) => {
              if (!R)
                return this.pageIndexCache.put(d, k), k;
              const [f, c] = R;
              return k += f, H(c);
            });
            return H(d);
          }
          get baseUrl() {
            const d = this._catDict.get("URI");
            if (d instanceof C.Dict) {
              const A = d.get("Base");
              if (typeof A == "string") {
                const I = (0, F.createValidAbsoluteUrl)(A, null, {
                  tryConvertEncoding: !0
                });
                if (I)
                  return (0, F.shadow)(this, "baseUrl", I.href);
              }
            }
            return (0, F.shadow)(this, "baseUrl", this.pdfManager.docBaseUrl);
          }
          static parseDestDictionary({
            destDict: d,
            resultObj: A,
            docBaseUrl: I = null,
            docAttachments: E = null
          }) {
            if (!(d instanceof C.Dict)) {
              (0, F.warn)("parseDestDictionary: `destDict` must be a dictionary.");
              return;
            }
            let k = d.get("A"), H, x;
            if (k instanceof C.Dict || (d.has("Dest") ? k = d.get("Dest") : (k = d.get("AA"), k instanceof C.Dict && (k.has("D") ? k = k.get("D") : k.has("U") && (k = k.get("U"))))), k instanceof C.Dict) {
              const R = k.get("S");
              if (!(R instanceof C.Name)) {
                (0, F.warn)("parseDestDictionary: Invalid type in Action dictionary.");
                return;
              }
              const f = R.name;
              switch (f) {
                case "ResetForm":
                  const c = k.get("Flags"), N = ((typeof c == "number" ? c : 0) & 1) === 0, u = [], p = [];
                  for (const $ of k.get("Fields") || [])
                    $ instanceof C.Ref ? p.push($.toString()) : typeof $ == "string" && u.push((0, F.stringToPDFString)($));
                  A.resetForm = {
                    fields: u,
                    refs: p,
                    include: N
                  };
                  break;
                case "URI":
                  H = k.get("URI"), H instanceof C.Name && (H = "/" + H.name);
                  break;
                case "GoTo":
                  x = k.get("D");
                  break;
                case "Launch":
                case "GoToR":
                  const S = k.get("F");
                  S instanceof C.Dict ? H = S.get("F") || null : typeof S == "string" && (H = S);
                  let B = k.get("D");
                  if (B && (B instanceof C.Name && (B = B.name), typeof H == "string")) {
                    const $ = H.split("#")[0];
                    typeof B == "string" ? H = $ + "#" + B : Array.isArray(B) && (H = $ + "#" + JSON.stringify(B));
                  }
                  const T = k.get("NewWindow");
                  typeof T == "boolean" && (A.newWindow = T);
                  break;
                case "GoToE":
                  const D = k.get("T");
                  let K;
                  if (E && D instanceof C.Dict) {
                    const $ = D.get("R"), G = D.get("N");
                    (0, C.isName)($, "C") && typeof G == "string" && (K = E[(0, F.stringToPDFString)(G)]);
                  }
                  K ? A.attachment = K : (0, F.warn)('parseDestDictionary - unimplemented "GoToE" action.');
                  break;
                case "Named":
                  const _ = k.get("N");
                  _ instanceof C.Name && (A.action = _.name);
                  break;
                case "SetOCGState":
                  const o = k.get("State"), m = k.get("PreserveRB");
                  if (!Array.isArray(o) || o.length === 0)
                    break;
                  const s = [];
                  for (const $ of o)
                    if ($ instanceof C.Name)
                      switch ($.name) {
                        case "ON":
                        case "OFF":
                        case "Toggle":
                          s.push($.name);
                          break;
                      }
                    else
                      $ instanceof C.Ref && s.push($.toString());
                  if (s.length !== o.length)
                    break;
                  A.setOCGState = {
                    state: s,
                    preserveRB: typeof m == "boolean" ? m : !0
                  };
                  break;
                case "JavaScript":
                  const r = k.get("JS");
                  let y;
                  r instanceof t.BaseStream ? y = r.getString() : typeof r == "string" && (y = r);
                  const M = y && (0, n.recoverJsURL)((0, F.stringToPDFString)(y));
                  if (M) {
                    H = M.url, A.newWindow = M.newWindow;
                    break;
                  }
                default:
                  if (f === "JavaScript" || f === "SubmitForm")
                    break;
                  (0, F.warn)(`parseDestDictionary - unsupported action: "${f}".`);
                  break;
              }
            } else
              d.has("Dest") && (x = d.get("Dest"));
            if (typeof H == "string") {
              const R = (0, F.createValidAbsoluteUrl)(H, I, {
                addDefaultProtocol: !0,
                tryConvertEncoding: !0
              });
              R && (A.url = R.href), A.unsafeUrl = H;
            }
            x && (x instanceof C.Name && (x = x.name), typeof x == "string" ? A.dest = (0, F.stringToPDFString)(x) : Array.isArray(x) && (A.dest = x));
          }
        }
        w.Catalog = i;
      },
      /* 67 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.NumberTree = w.NameTree = void 0;
        var n = V(4), F = V(2);
        class C {
          constructor(j, U, O) {
            this.constructor === C && (0, F.unreachable)("Cannot initialize NameOrNumberTree."), this.root = j, this.xref = U, this._type = O;
          }
          getAll() {
            const j = /* @__PURE__ */ new Map();
            if (!this.root)
              return j;
            const U = this.xref, O = new n.RefSet();
            O.put(this.root);
            const v = [this.root];
            for (; v.length > 0; ) {
              const g = U.fetchIfRef(v.shift());
              if (!(g instanceof n.Dict))
                continue;
              if (g.has("Kids")) {
                const i = g.get("Kids");
                if (!Array.isArray(i))
                  continue;
                for (const P of i) {
                  if (O.has(P))
                    throw new F.FormatError(`Duplicate entry in "${this._type}" tree.`);
                  v.push(P), O.put(P);
                }
                continue;
              }
              const b = g.get(this._type);
              if (Array.isArray(b))
                for (let i = 0, P = b.length; i < P; i += 2)
                  j.set(U.fetchIfRef(b[i]), U.fetchIfRef(b[i + 1]));
            }
            return j;
          }
          get(j) {
            if (!this.root)
              return null;
            const U = this.xref;
            let O = U.fetchIfRef(this.root), v = 0;
            const g = 10;
            for (; O.has("Kids"); ) {
              if (++v > g)
                return (0, F.warn)(`Search depth limit reached for "${this._type}" tree.`), null;
              const i = O.get("Kids");
              if (!Array.isArray(i))
                return null;
              let P = 0, d = i.length - 1;
              for (; P <= d; ) {
                const A = P + d >> 1, I = U.fetchIfRef(i[A]), E = I.get("Limits");
                if (j < U.fetchIfRef(E[0]))
                  d = A - 1;
                else if (j > U.fetchIfRef(E[1]))
                  P = A + 1;
                else {
                  O = I;
                  break;
                }
              }
              if (P > d)
                return null;
            }
            const b = O.get(this._type);
            if (Array.isArray(b)) {
              let i = 0, P = b.length - 2;
              for (; i <= P; ) {
                const d = i + P >> 1, A = d + (d & 1), I = U.fetchIfRef(b[A]);
                if (j < I)
                  P = A - 2;
                else if (j > I)
                  i = A + 2;
                else
                  return U.fetchIfRef(b[A + 1]);
              }
            }
            return null;
          }
        }
        class e extends C {
          constructor(j, U) {
            super(j, U, "Names");
          }
        }
        w.NameTree = e;
        class t extends C {
          constructor(j, U) {
            super(j, U, "Nums");
          }
        }
        w.NumberTree = t;
      },
      /* 68 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.clearGlobalCaches = e;
        var n = V(50), F = V(4), C = V(40);
        function e() {
          (0, n.clearPatternCaches)(), (0, F.clearPrimitiveCaches)(), (0, C.clearUnicodeCaches)();
        }
      },
      /* 69 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.FileSpec = void 0;
        var n = V(2), F = V(5), C = V(4);
        function e(l) {
          return l.has("UF") ? l.get("UF") : l.has("F") ? l.get("F") : l.has("Unix") ? l.get("Unix") : l.has("Mac") ? l.get("Mac") : l.has("DOS") ? l.get("DOS") : null;
        }
        class t {
          constructor(j, U) {
            j instanceof C.Dict && (this.xref = U, this.root = j, j.has("FS") && (this.fs = j.get("FS")), this.description = j.has("Desc") ? (0, n.stringToPDFString)(j.get("Desc")) : "", j.has("RF") && (0, n.warn)("Related file specifications are not supported"), this.contentAvailable = !0, j.has("EF") || (this.contentAvailable = !1, (0, n.warn)("Non-embedded file specifications are not supported")));
          }
          get filename() {
            if (!this._filename && this.root) {
              const j = e(this.root) || "unnamed";
              this._filename = (0, n.stringToPDFString)(j).replaceAll("\\\\", "\\").replaceAll("\\/", "/").replaceAll("\\", "/");
            }
            return this._filename;
          }
          get content() {
            if (!this.contentAvailable)
              return null;
            !this.contentRef && this.root && (this.contentRef = e(this.root.get("EF")));
            let j = null;
            if (this.contentRef) {
              const U = this.xref.fetchIfRef(this.contentRef);
              U instanceof F.BaseStream ? j = U.getBytes() : (0, n.warn)("Embedded file specification points to non-existing/invalid content");
            } else
              (0, n.warn)("Embedded file specification does not have a content");
            return j;
          }
          get serializable() {
            return {
              filename: this.filename,
              content: this.content
            };
          }
        }
        w.FileSpec = t;
      },
      /* 70 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.MetadataParser = void 0;
        var n = V(71);
        class F {
          constructor(e) {
            e = this._repair(e);
            const l = new n.SimpleXMLParser({
              lowerCaseName: !0
            }).parseFromString(e);
            this._metadataMap = /* @__PURE__ */ new Map(), this._data = e, l && this._parse(l);
          }
          _repair(e) {
            return e.replace(/^[^<]+/, "").replaceAll(/>\\376\\377([^<]+)/g, function(t, l) {
              const j = l.replaceAll(/\\([0-3])([0-7])([0-7])/g, function(O, v, g, b) {
                return String.fromCharCode(v * 64 + g * 8 + b * 1);
              }).replaceAll(/&(amp|apos|gt|lt|quot);/g, function(O, v) {
                switch (v) {
                  case "amp":
                    return "&";
                  case "apos":
                    return "'";
                  case "gt":
                    return ">";
                  case "lt":
                    return "<";
                  case "quot":
                    return '"';
                }
                throw new Error(`_repair: ${v} isn't defined.`);
              }), U = [">"];
              for (let O = 0, v = j.length; O < v; O += 2) {
                const g = j.charCodeAt(O) * 256 + j.charCodeAt(O + 1);
                g >= 32 && g < 127 && g !== 60 && g !== 62 && g !== 38 ? U.push(String.fromCharCode(g)) : U.push("&#x" + (65536 + g).toString(16).substring(1) + ";");
              }
              return U.join("");
            });
          }
          _getSequence(e) {
            const t = e.nodeName;
            return t !== "rdf:bag" && t !== "rdf:seq" && t !== "rdf:alt" ? null : e.childNodes.filter((l) => l.nodeName === "rdf:li");
          }
          _parseArray(e) {
            if (!e.hasChildNodes())
              return;
            const [t] = e.childNodes, l = this._getSequence(t) || [];
            this._metadataMap.set(e.nodeName, l.map((j) => j.textContent.trim()));
          }
          _parse(e) {
            let t = e.documentElement;
            if (t.nodeName !== "rdf:rdf")
              for (t = t.firstChild; t && t.nodeName !== "rdf:rdf"; )
                t = t.nextSibling;
            if (!(!t || t.nodeName !== "rdf:rdf" || !t.hasChildNodes())) {
              for (const l of t.childNodes)
                if (l.nodeName === "rdf:description")
                  for (const j of l.childNodes) {
                    const U = j.nodeName;
                    switch (U) {
                      case "#text":
                        continue;
                      case "dc:creator":
                      case "dc:subject":
                        this._parseArray(j);
                        continue;
                    }
                    this._metadataMap.set(U, j.textContent.trim());
                  }
            }
          }
          get serializable() {
            return {
              parsedData: this._metadataMap,
              rawData: this._data
            };
          }
        }
        w.MetadataParser = F;
      },
      /* 71 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.XMLParserErrorCode = w.XMLParserBase = w.SimpleXMLParser = w.SimpleDOMNode = void 0;
        var n = V(3);
        const F = {
          NoError: 0,
          EndOfDocument: -1,
          UnterminatedCdat: -2,
          UnterminatedXmlDeclaration: -3,
          UnterminatedDoctypeDeclaration: -4,
          UnterminatedComment: -5,
          MalformedElement: -6,
          OutOfMemory: -7,
          UnterminatedAttributeValue: -8,
          UnterminatedElement: -9,
          ElementNeverBegun: -10
        };
        w.XMLParserErrorCode = F;
        function C(U, O) {
          const v = U[O];
          return v === " " || v === `
` || v === "\r" || v === "	";
        }
        function e(U) {
          for (let O = 0, v = U.length; O < v; O++)
            if (!C(U, O))
              return !1;
          return !0;
        }
        class t {
          _resolveEntities(O) {
            return O.replaceAll(/&([^;]+);/g, (v, g) => {
              if (g.substring(0, 2) === "#x")
                return String.fromCodePoint(parseInt(g.substring(2), 16));
              if (g.substring(0, 1) === "#")
                return String.fromCodePoint(parseInt(g.substring(1), 10));
              switch (g) {
                case "lt":
                  return "<";
                case "gt":
                  return ">";
                case "amp":
                  return "&";
                case "quot":
                  return '"';
                case "apos":
                  return "'";
              }
              return this.onResolveEntity(g);
            });
          }
          _parseContent(O, v) {
            const g = [];
            let b = v;
            function i() {
              for (; b < O.length && C(O, b); )
                ++b;
            }
            for (; b < O.length && !C(O, b) && O[b] !== ">" && O[b] !== "/"; )
              ++b;
            const P = O.substring(v, b);
            for (i(); b < O.length && O[b] !== ">" && O[b] !== "/" && O[b] !== "?"; ) {
              i();
              let d = "", A = "";
              for (; b < O.length && !C(O, b) && O[b] !== "="; )
                d += O[b], ++b;
              if (i(), O[b] !== "=")
                return null;
              ++b, i();
              const I = O[b];
              if (I !== '"' && I !== "'")
                return null;
              const E = O.indexOf(I, ++b);
              if (E < 0)
                return null;
              A = O.substring(b, E), g.push({
                name: d,
                value: this._resolveEntities(A)
              }), b = E + 1, i();
            }
            return {
              name: P,
              attributes: g,
              parsed: b - v
            };
          }
          _parseProcessingInstruction(O, v) {
            let g = v;
            function b() {
              for (; g < O.length && C(O, g); )
                ++g;
            }
            for (; g < O.length && !C(O, g) && O[g] !== ">" && O[g] !== "?" && O[g] !== "/"; )
              ++g;
            const i = O.substring(v, g);
            b();
            const P = g;
            for (; g < O.length && (O[g] !== "?" || O[g + 1] !== ">"); )
              ++g;
            const d = O.substring(P, g);
            return {
              name: i,
              value: d,
              parsed: g - v
            };
          }
          parseXml(O) {
            let v = 0;
            for (; v < O.length; ) {
              const g = O[v];
              let b = v;
              if (g === "<") {
                ++b;
                const i = O[b];
                let P;
                switch (i) {
                  case "/":
                    if (++b, P = O.indexOf(">", b), P < 0) {
                      this.onError(F.UnterminatedElement);
                      return;
                    }
                    this.onEndElement(O.substring(b, P)), b = P + 1;
                    break;
                  case "?":
                    ++b;
                    const d = this._parseProcessingInstruction(O, b);
                    if (O.substring(b + d.parsed, b + d.parsed + 2) !== "?>") {
                      this.onError(F.UnterminatedXmlDeclaration);
                      return;
                    }
                    this.onPi(d.name, d.value), b += d.parsed + 2;
                    break;
                  case "!":
                    if (O.substring(b + 1, b + 3) === "--") {
                      if (P = O.indexOf("-->", b + 3), P < 0) {
                        this.onError(F.UnterminatedComment);
                        return;
                      }
                      this.onComment(O.substring(b + 3, P)), b = P + 3;
                    } else if (O.substring(b + 1, b + 8) === "[CDATA[") {
                      if (P = O.indexOf("]]>", b + 8), P < 0) {
                        this.onError(F.UnterminatedCdat);
                        return;
                      }
                      this.onCdata(O.substring(b + 8, P)), b = P + 3;
                    } else if (O.substring(b + 1, b + 8) === "DOCTYPE") {
                      const E = O.indexOf("[", b + 8);
                      let k = !1;
                      if (P = O.indexOf(">", b + 8), P < 0) {
                        this.onError(F.UnterminatedDoctypeDeclaration);
                        return;
                      }
                      if (E > 0 && P > E) {
                        if (P = O.indexOf("]>", b + 8), P < 0) {
                          this.onError(F.UnterminatedDoctypeDeclaration);
                          return;
                        }
                        k = !0;
                      }
                      const H = O.substring(b + 8, P + (k ? 1 : 0));
                      this.onDoctype(H), b = P + (k ? 2 : 1);
                    } else {
                      this.onError(F.MalformedElement);
                      return;
                    }
                    break;
                  default:
                    const A = this._parseContent(O, b);
                    if (A === null) {
                      this.onError(F.MalformedElement);
                      return;
                    }
                    let I = !1;
                    if (O.substring(b + A.parsed, b + A.parsed + 2) === "/>")
                      I = !0;
                    else if (O.substring(b + A.parsed, b + A.parsed + 1) !== ">") {
                      this.onError(F.UnterminatedElement);
                      return;
                    }
                    this.onBeginElement(A.name, A.attributes, I), b += A.parsed + (I ? 2 : 1);
                    break;
                }
              } else {
                for (; b < O.length && O[b] !== "<"; )
                  b++;
                const i = O.substring(v, b);
                this.onText(this._resolveEntities(i));
              }
              v = b;
            }
          }
          onResolveEntity(O) {
            return `&${O};`;
          }
          onPi(O, v) {
          }
          onComment(O) {
          }
          onCdata(O) {
          }
          onDoctype(O) {
          }
          onText(O) {
          }
          onBeginElement(O, v, g) {
          }
          onEndElement(O) {
          }
          onError(O) {
          }
        }
        w.XMLParserBase = t;
        class l {
          constructor(O, v) {
            this.nodeName = O, this.nodeValue = v, Object.defineProperty(this, "parentNode", {
              value: null,
              writable: !0
            });
          }
          get firstChild() {
            var O;
            return (O = this.childNodes) == null ? void 0 : O[0];
          }
          get nextSibling() {
            const O = this.parentNode.childNodes;
            if (!O)
              return;
            const v = O.indexOf(this);
            if (v !== -1)
              return O[v + 1];
          }
          get textContent() {
            return this.childNodes ? this.childNodes.map(function(O) {
              return O.textContent;
            }).join("") : this.nodeValue || "";
          }
          get children() {
            return this.childNodes || [];
          }
          hasChildNodes() {
            var O;
            return ((O = this.childNodes) == null ? void 0 : O.length) > 0;
          }
          searchNode(O, v) {
            var P;
            if (v >= O.length)
              return this;
            const g = O[v];
            if (g.name.startsWith("#") && v < O.length - 1)
              return this.searchNode(O, v + 1);
            const b = [];
            let i = this;
            for (; ; ) {
              if (g.name === i.nodeName)
                if (g.pos === 0) {
                  const d = i.searchNode(O, v + 1);
                  if (d !== null)
                    return d;
                } else {
                  if (b.length === 0)
                    return null;
                  {
                    const [d] = b.pop();
                    let A = 0;
                    for (const I of d.childNodes)
                      if (g.name === I.nodeName) {
                        if (A === g.pos)
                          return I.searchNode(O, v + 1);
                        A++;
                      }
                    return i.searchNode(O, v + 1);
                  }
                }
              if (((P = i.childNodes) == null ? void 0 : P.length) > 0)
                b.push([i, 0]), i = i.childNodes[0];
              else {
                if (b.length === 0)
                  return null;
                for (; b.length !== 0; ) {
                  const [d, A] = b.pop(), I = A + 1;
                  if (I < d.childNodes.length) {
                    b.push([d, I]), i = d.childNodes[I];
                    break;
                  }
                }
                if (b.length === 0)
                  return null;
              }
            }
          }
          dump(O) {
            if (this.nodeName === "#text") {
              O.push((0, n.encodeToXmlString)(this.nodeValue));
              return;
            }
            if (O.push(`<${this.nodeName}`), this.attributes)
              for (const v of this.attributes)
                O.push(` ${v.name}="${(0, n.encodeToXmlString)(v.value)}"`);
            if (this.hasChildNodes()) {
              O.push(">");
              for (const v of this.childNodes)
                v.dump(O);
              O.push(`</${this.nodeName}>`);
            } else
              this.nodeValue ? O.push(`>${(0, n.encodeToXmlString)(this.nodeValue)}</${this.nodeName}>`) : O.push("/>");
          }
        }
        w.SimpleDOMNode = l;
        class j extends t {
          constructor({
            hasAttributes: O = !1,
            lowerCaseName: v = !1
          }) {
            super(), this._currentFragment = null, this._stack = null, this._errorCode = F.NoError, this._hasAttributes = O, this._lowerCaseName = v;
          }
          parseFromString(O) {
            if (this._currentFragment = [], this._stack = [], this._errorCode = F.NoError, this.parseXml(O), this._errorCode !== F.NoError)
              return;
            const [v] = this._currentFragment;
            if (v)
              return {
                documentElement: v
              };
          }
          onText(O) {
            if (e(O))
              return;
            const v = new l("#text", O);
            this._currentFragment.push(v);
          }
          onCdata(O) {
            const v = new l("#text", O);
            this._currentFragment.push(v);
          }
          onBeginElement(O, v, g) {
            this._lowerCaseName && (O = O.toLowerCase());
            const b = new l(O);
            b.childNodes = [], this._hasAttributes && (b.attributes = v), this._currentFragment.push(b), !g && (this._stack.push(this._currentFragment), this._currentFragment = b.childNodes);
          }
          onEndElement(O) {
            this._currentFragment = this._stack.pop() || [];
            const v = this._currentFragment.at(-1);
            if (!v)
              return null;
            for (const g of v.childNodes)
              g.parentNode = v;
            return v;
          }
          onError(O) {
            this._errorCode = O;
          }
        }
        w.SimpleXMLParser = j;
      },
      /* 72 */
      /***/
      (fe, w, V) => {
        var g, Fa, i, Bi, d, Ta, I, Ea;
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.StructTreeRoot = w.StructTreePage = void 0;
        var n = V(2), F = V(4), C = V(67), e = V(73);
        const t = 40, l = {
          PAGE_CONTENT: 1,
          STREAM_CONTENT: 2,
          OBJECT: 3,
          ANNOTATION: 4,
          ELEMENT: 5
        }, k = class k {
          constructor(x, R) {
            Me(this, g);
            this.dict = x, this.ref = R instanceof F.Ref ? R : null, this.roleMap = /* @__PURE__ */ new Map(), this.structParentIds = null;
          }
          init() {
            this.readRoleMap();
          }
          addAnnotationIdToPage(x, R) {
            De(this, g, Fa).call(this, x, R, l.ANNOTATION);
          }
          readRoleMap() {
            const x = this.dict.get("RoleMap");
            x instanceof F.Dict && x.forEach((R, f) => {
              f instanceof F.Name && this.roleMap.set(R, f.name);
            });
          }
          static async canCreateStructureTree({
            catalogRef: x,
            pdfManager: R,
            newAnnotationsByPage: f
          }) {
            var u;
            if (!(x instanceof F.Ref))
              return (0, n.warn)("Cannot save the struct tree: no catalog reference."), !1;
            let c = 0, N = !0;
            for (const [p, S] of f) {
              const {
                ref: B
              } = await R.getPage(p);
              if (!(B instanceof F.Ref)) {
                (0, n.warn)(`Cannot save the struct tree: page ${p} has no ref.`), N = !0;
                break;
              }
              for (const T of S)
                (u = T.accessibilityData) != null && u.type && (T.parentTreeId = c++, N = !1);
            }
            if (N) {
              for (const p of f.values())
                for (const S of p)
                  delete S.parentTreeId;
              return !1;
            }
            return !0;
          }
          static async createStructureTree({
            newAnnotationsByPage: x,
            xref: R,
            catalogRef: f,
            pdfManager: c,
            newRefs: N
          }) {
            const u = c.catalog.cloneDict(), p = R.getNewTemporaryRef();
            u.set("StructTreeRoot", p);
            const S = [];
            await (0, e.writeObject)(f, u, S, R), N.push({
              ref: f,
              data: S.join("")
            });
            const B = new F.Dict(R);
            B.set("Type", F.Name.get("StructTreeRoot"));
            const T = R.getNewTemporaryRef();
            B.set("ParentTree", T);
            const D = [];
            B.set("K", D);
            const K = new F.Dict(R), _ = [];
            K.set("Nums", _);
            const o = await De(this, i, Bi).call(this, {
              newAnnotationsByPage: x,
              structTreeRootRef: p,
              kids: D,
              nums: _,
              xref: R,
              pdfManager: c,
              newRefs: N,
              buffer: S
            });
            B.set("ParentTreeNextKey", o), S.length = 0, await (0, e.writeObject)(T, K, S, R), N.push({
              ref: T,
              data: S.join("")
            }), S.length = 0, await (0, e.writeObject)(p, B, S, R), N.push({
              ref: p,
              data: S.join("")
            });
          }
          async canUpdateStructTree({
            pdfManager: x,
            newAnnotationsByPage: R
          }) {
            var S, B;
            if (!this.ref)
              return (0, n.warn)("Cannot update the struct tree: no root reference."), !1;
            let f = this.dict.get("ParentTreeNextKey");
            if (!Number.isInteger(f) || f < 0)
              return (0, n.warn)("Cannot update the struct tree: invalid next key."), !1;
            const c = this.dict.get("ParentTree");
            if (!(c instanceof F.Dict))
              return (0, n.warn)("Cannot update the struct tree: ParentTree isn't a dict."), !1;
            const N = c.get("Nums");
            if (!Array.isArray(N))
              return (0, n.warn)("Cannot update the struct tree: nums isn't an array."), !1;
            const {
              numPages: u
            } = x.catalog;
            for (const T of R.keys()) {
              const {
                pageDict: D,
                ref: K
              } = await x.getPage(T);
              if (!(K instanceof F.Ref))
                return (0, n.warn)(`Cannot save the struct tree: page ${T} has no ref.`), !1;
              const _ = D.get("StructParents");
              if (!Number.isInteger(_) || _ < 0 || _ >= u)
                return (0, n.warn)(`Cannot save the struct tree: page ${T} has no id.`), !1;
            }
            let p = !0;
            for (const [T, D] of R) {
              const {
                pageDict: K
              } = await x.getPage(T);
              De(S = k, d, Ta).call(S, {
                elements: D,
                xref: this.dict.xref,
                pageDict: K,
                parentTree: c
              });
              for (const _ of D)
                (B = _.accessibilityData) != null && B.type && (_.parentTreeId = f++, p = !1);
            }
            if (p) {
              for (const T of R.values())
                for (const D of T)
                  delete D.parentTreeId, delete D.structTreeParent;
              return !1;
            }
            return !0;
          }
          async updateStructureTree({
            newAnnotationsByPage: x,
            pdfManager: R,
            newRefs: f
          }) {
            var m;
            const c = this.dict.xref, N = this.dict.clone(), u = this.ref;
            let p = N.getRaw("ParentTree"), S;
            p instanceof F.Ref ? S = c.fetch(p) : (S = p, p = c.getNewTemporaryRef(), N.set("ParentTree", p)), S = S.clone();
            let B = S.getRaw("Nums"), T = null;
            B instanceof F.Ref && (T = B, B = c.fetch(T)), B = B.slice(), T || S.set("Nums", B);
            let D = N.getRaw("K"), K = null;
            D instanceof F.Ref ? (K = D, D = c.fetch(K)) : (K = c.getNewTemporaryRef(), N.set("K", K)), D = Array.isArray(D) ? D.slice() : [D];
            const _ = [], o = await De(m = k, i, Bi).call(m, {
              newAnnotationsByPage: x,
              structTreeRootRef: u,
              kids: D,
              nums: B,
              xref: c,
              pdfManager: R,
              newRefs: f,
              buffer: _
            });
            N.set("ParentTreeNextKey", o), _.length = 0, await (0, e.writeObject)(K, D, _, c), f.push({
              ref: K,
              data: _.join("")
            }), T && (_.length = 0, await (0, e.writeObject)(T, B, _, c), f.push({
              ref: T,
              data: _.join("")
            })), _.length = 0, await (0, e.writeObject)(p, S, _, c), f.push({
              ref: p,
              data: _.join("")
            }), _.length = 0, await (0, e.writeObject)(u, N, _, c), f.push({
              ref: u,
              data: _.join("")
            });
          }
        };
        g = new WeakSet(), Fa = function(x, R, f) {
          if (!(x instanceof F.Ref) || R < 0)
            return;
          this.structParentIds || (this.structParentIds = new F.RefSetCache());
          let c = this.structParentIds.get(x);
          c || (c = [], this.structParentIds.put(x, c)), c.push([R, f]);
        }, i = new WeakSet(), Bi = async function({
          newAnnotationsByPage: x,
          structTreeRootRef: R,
          kids: f,
          nums: c,
          xref: N,
          pdfManager: u,
          newRefs: p,
          buffer: S
        }) {
          const B = F.Name.get("OBJR");
          let T = -1 / 0;
          for (const [D, K] of x) {
            const {
              ref: _
            } = await u.getPage(D);
            for (const {
              accessibilityData: {
                type: o,
                title: m,
                lang: s,
                alt: r,
                expanded: y,
                actualText: M
              },
              ref: $,
              parentTreeId: G,
              structTreeParent: ce
            } of K) {
              T = Math.max(T, G);
              const q = N.getNewTemporaryRef(), re = new F.Dict(N);
              re.set("S", F.Name.get(o)), m && re.set("T", m), s && re.set("Lang", s), r && re.set("Alt", r), y && re.set("E", y), M && re.set("ActualText", M), ce ? await De(this, I, Ea).call(this, {
                structTreeParent: ce,
                tagDict: re,
                newTagRef: q,
                fallbackRef: R,
                xref: N,
                newRefs: p,
                buffer: S
              }) : re.set("P", R);
              const Z = new F.Dict(N);
              re.set("K", Z), Z.set("Type", B), Z.set("Pg", _), Z.set("Obj", $), S.length = 0, await (0, e.writeObject)(q, re, S, N), p.push({
                ref: q,
                data: S.join("")
              }), c.push(G, q), f.push(q);
            }
          }
          return T + 1;
        }, d = new WeakSet(), Ta = function({
          elements: x,
          xref: R,
          pageDict: f,
          parentTree: c
        }) {
          const N = /* @__PURE__ */ new Map();
          for (const T of x)
            if (T.structTreeParentId) {
              const D = parseInt(T.structTreeParentId.split("_mc")[1], 10);
              N.set(D, T);
            }
          const u = f.get("StructParents"), S = new C.NumberTree(c, R).get(u);
          if (!Array.isArray(S))
            return;
          const B = (T, D, K) => {
            const _ = N.get(T);
            if (_) {
              const o = D.getRaw("P"), m = R.fetchIfRef(o);
              return o instanceof F.Ref && m instanceof F.Dict && (_.structTreeParent = {
                ref: K,
                dict: D
              }), !0;
            }
            return !1;
          };
          for (const T of S) {
            if (!(T instanceof F.Ref))
              continue;
            const D = R.fetch(T), K = D.get("K");
            if (Number.isInteger(K)) {
              B(K, D, T);
              continue;
            }
            if (Array.isArray(K)) {
              for (let _ of K)
                if (_ = R.fetchIfRef(_), Number.isInteger(_) && B(_, D, T))
                  break;
            }
          }
        }, I = new WeakSet(), Ea = async function({
          structTreeParent: {
            ref: x,
            dict: R
          },
          tagDict: f,
          newTagRef: c,
          fallbackRef: N,
          xref: u,
          newRefs: p,
          buffer: S
        }) {
          const B = R.getRaw("P");
          let T = u.fetchIfRef(B);
          f.set("P", B);
          let D = !1, K, _ = T.getRaw("K");
          if (_ instanceof F.Ref ? K = u.fetch(_) : (K = _, _ = u.getNewTemporaryRef(), T = T.clone(), T.set("K", _), D = !0), Array.isArray(K)) {
            const o = K.indexOf(x);
            if (o >= 0)
              K = K.slice(), K.splice(o + 1, 0, c);
            else {
              (0, n.warn)("Cannot update the struct tree: parent kid not found."), f.set("P", N);
              return;
            }
          } else
            K instanceof F.Dict && (K = [_, c], _ = u.getNewTemporaryRef(), T.set("K", _), D = !0);
          S.length = 0, await (0, e.writeObject)(_, K, S, u), p.push({
            ref: _,
            data: S.join("")
          }), D && (S.length = 0, await (0, e.writeObject)(B, T, S, u), p.push({
            ref: B,
            data: S.join("")
          }));
        }, Me(k, i), Me(k, d), Me(k, I);
        let j = k;
        w.StructTreeRoot = j;
        class U {
          constructor(x, R) {
            this.tree = x, this.dict = R, this.kids = [], this.parseKids();
          }
          get role() {
            const x = this.dict.get("S"), R = x instanceof F.Name ? x.name : "", {
              root: f
            } = this.tree;
            return f.roleMap.has(R) ? f.roleMap.get(R) : R;
          }
          parseKids() {
            let x = null;
            const R = this.dict.getRaw("Pg");
            R instanceof F.Ref && (x = R.toString());
            const f = this.dict.get("K");
            if (Array.isArray(f))
              for (const c of f) {
                const N = this.parseKid(x, c);
                N && this.kids.push(N);
              }
            else {
              const c = this.parseKid(x, f);
              c && this.kids.push(c);
            }
          }
          parseKid(x, R) {
            if (Number.isInteger(R))
              return this.tree.pageDict.objId !== x ? null : new O({
                type: l.PAGE_CONTENT,
                mcid: R,
                pageObjId: x
              });
            let f = null;
            if (R instanceof F.Ref ? f = this.dict.xref.fetch(R) : R instanceof F.Dict && (f = R), !f)
              return null;
            const c = f.getRaw("Pg");
            c instanceof F.Ref && (x = c.toString());
            const N = f.get("Type") instanceof F.Name ? f.get("Type").name : null;
            if (N === "MCR") {
              if (this.tree.pageDict.objId !== x)
                return null;
              const u = f.getRaw("Stm");
              return new O({
                type: l.STREAM_CONTENT,
                refObjId: u instanceof F.Ref ? u.toString() : null,
                pageObjId: x,
                mcid: f.get("MCID")
              });
            }
            if (N === "OBJR") {
              if (this.tree.pageDict.objId !== x)
                return null;
              const u = f.getRaw("Obj");
              return new O({
                type: l.OBJECT,
                refObjId: u instanceof F.Ref ? u.toString() : null,
                pageObjId: x
              });
            }
            return new O({
              type: l.ELEMENT,
              dict: f
            });
          }
        }
        class O {
          constructor({
            type: x,
            dict: R = null,
            mcid: f = null,
            pageObjId: c = null,
            refObjId: N = null
          }) {
            this.type = x, this.dict = R, this.mcid = f, this.pageObjId = c, this.refObjId = N, this.parentNode = null;
          }
        }
        class v {
          constructor(x, R) {
            this.root = x, this.rootDict = x ? x.dict : null, this.pageDict = R, this.nodes = [];
          }
          parse(x) {
            var p, S;
            if (!this.root || !this.rootDict)
              return;
            const R = this.rootDict.get("ParentTree");
            if (!R)
              return;
            const f = this.pageDict.get("StructParents"), c = x instanceof F.Ref && ((p = this.root.structParentIds) == null ? void 0 : p.get(x));
            if (!Number.isInteger(f) && !c)
              return;
            const N = /* @__PURE__ */ new Map(), u = new C.NumberTree(R, this.rootDict.xref);
            if (Number.isInteger(f)) {
              const B = u.get(f);
              if (Array.isArray(B))
                for (const T of B)
                  T instanceof F.Ref && this.addNode(this.rootDict.xref.fetch(T), N);
            }
            if (c)
              for (const [B, T] of c) {
                const D = u.get(B);
                if (D) {
                  const K = this.addNode(this.rootDict.xref.fetchIfRef(D), N);
                  ((S = K == null ? void 0 : K.kids) == null ? void 0 : S.length) === 1 && K.kids[0].type === l.OBJECT && (K.kids[0].type = T);
                }
              }
          }
          addNode(x, R, f = 0) {
            if (f > t)
              return (0, n.warn)("StructTree MAX_DEPTH reached."), null;
            if (R.has(x))
              return R.get(x);
            const c = new U(this, x);
            R.set(x, c);
            const N = x.get("P");
            if (!N || (0, F.isName)(N.get("Type"), "StructTreeRoot"))
              return this.addTopLevelNode(x, c) || R.delete(x), c;
            const u = this.addNode(N, R, f + 1);
            if (!u)
              return c;
            let p = !1;
            for (const S of u.kids)
              S.type === l.ELEMENT && S.dict === x && (S.parentNode = c, p = !0);
            return p || R.delete(x), c;
          }
          addTopLevelNode(x, R) {
            const f = this.rootDict.get("K");
            if (!f)
              return !1;
            if (f instanceof F.Dict)
              return f.objId !== x.objId ? !1 : (this.nodes[0] = R, !0);
            if (!Array.isArray(f))
              return !0;
            let c = !1;
            for (let N = 0; N < f.length; N++) {
              const u = f[N];
              (u == null ? void 0 : u.toString()) === x.objId && (this.nodes[N] = R, c = !0);
            }
            return c;
          }
          get serializable() {
            function x(f, c, N = 0) {
              if (N > t) {
                (0, n.warn)("StructTree too deep to be fully serialized.");
                return;
              }
              const u = /* @__PURE__ */ Object.create(null);
              u.role = f.role, u.children = [], c.children.push(u);
              const p = f.dict.get("Alt");
              typeof p == "string" && (u.alt = (0, n.stringToPDFString)(p));
              const S = f.dict.get("Lang");
              typeof S == "string" && (u.lang = (0, n.stringToPDFString)(S));
              for (const B of f.kids) {
                const T = B.type === l.ELEMENT ? B.parentNode : null;
                if (T) {
                  x(T, u, N + 1);
                  continue;
                } else
                  B.type === l.PAGE_CONTENT || B.type === l.STREAM_CONTENT ? u.children.push({
                    type: "content",
                    id: `p${B.pageObjId}_mc${B.mcid}`
                  }) : B.type === l.OBJECT ? u.children.push({
                    type: "object",
                    id: B.refObjId
                  }) : B.type === l.ANNOTATION && u.children.push({
                    type: "annotation",
                    id: `${n.AnnotationPrefix}${B.refObjId}`
                  });
              }
            }
            const R = /* @__PURE__ */ Object.create(null);
            R.children = [], R.role = "Root";
            for (const f of this.nodes)
              f && x(f, R);
            return R;
          }
        }
        w.StructTreePage = v;
      },
      /* 73 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.incrementalUpdate = E, w.writeDict = U, w.writeObject = j;
        var n = V(2), F = V(4), C = V(3), e = V(71), t = V(5), l = V(74);
        async function j(k, H, x, {
          encrypt: R = null
        }) {
          const f = R == null ? void 0 : R.createCipherTransform(k.num, k.gen);
          x.push(`${k.num} ${k.gen} obj
`), H instanceof F.Dict ? await U(H, x, f) : H instanceof t.BaseStream ? await O(H, x, f) : Array.isArray(H) && await v(H, x, f), x.push(`
endobj
`);
        }
        async function U(k, H, x) {
          H.push("<<");
          for (const R of k.getKeys())
            H.push(` /${(0, C.escapePDFName)(R)} `), await g(k.getRaw(R), H, x);
          H.push(">>");
        }
        async function O(k, H, x) {
          let R = k.getString();
          const {
            dict: f
          } = k, [c, N] = await Promise.all([f.getAsync("Filter"), f.getAsync("DecodeParms")]), u = Array.isArray(c) ? await f.xref.fetchIfRefAsync(c[0]) : c, p = (0, F.isName)(u, "FlateDecode");
          if (typeof CompressionStream < "u" && (R.length >= 256 || p))
            try {
              const B = (0, n.stringToBytes)(R), T = new CompressionStream("deflate"), D = T.writable.getWriter();
              D.write(B), D.close();
              const K = await new Response(T.readable).arrayBuffer();
              R = (0, n.bytesToString)(new Uint8Array(K));
              let _, o;
              c ? p || (_ = Array.isArray(c) ? [F.Name.get("FlateDecode"), ...c] : [F.Name.get("FlateDecode"), c], N && (o = Array.isArray(N) ? [null, ...N] : [null, N])) : _ = F.Name.get("FlateDecode"), _ && f.set("Filter", _), o && f.set("DecodeParms", o);
            } catch (B) {
              (0, n.info)(`writeStream - cannot compress data: "${B}".`);
            }
          x && (R = x.encryptString(R)), f.set("Length", R.length), await U(f, H, x), H.push(` stream
`, R, `
endstream`);
        }
        async function v(k, H, x) {
          H.push("[");
          let R = !0;
          for (const f of k)
            R ? R = !1 : H.push(" "), await g(f, H, x);
          H.push("]");
        }
        async function g(k, H, x) {
          k instanceof F.Name ? H.push(`/${(0, C.escapePDFName)(k.name)}`) : k instanceof F.Ref ? H.push(`${k.num} ${k.gen} R`) : Array.isArray(k) ? await v(k, H, x) : typeof k == "string" ? (x && (k = x.encryptString(k)), H.push(`(${(0, C.escapeString)(k)})`)) : typeof k == "number" ? H.push((0, C.numberToString)(k)) : typeof k == "boolean" ? H.push(k.toString()) : k instanceof F.Dict ? await U(k, H, x) : k instanceof t.BaseStream ? await O(k, H, x) : k === null ? H.push("null") : (0, n.warn)(`Unhandled value in writer: ${typeof k}, please file a bug.`);
        }
        function b(k, H, x, R) {
          for (let f = H + x - 1; f > x - 1; f--)
            R[f] = k & 255, k >>= 8;
          return x + H;
        }
        function i(k, H, x) {
          for (let R = 0, f = k.length; R < f; R++)
            x[H + R] = k.charCodeAt(R) & 255;
        }
        function P(k, H) {
          const x = Math.floor(Date.now() / 1e3), R = H.filename || "", f = [x.toString(), R, k.toString()];
          let c = f.reduce((p, S) => p + S.length, 0);
          for (const p of Object.values(H.info))
            f.push(p), c += p.length;
          const N = new Uint8Array(c);
          let u = 0;
          for (const p of f)
            i(p, u, N), u += p.length;
          return (0, n.bytesToString)((0, l.calculateMD5)(N));
        }
        function d(k, H) {
          const x = new e.SimpleXMLParser({
            hasAttributes: !0
          }).parseFromString(k);
          for (const {
            xfa: f
          } of H) {
            if (!f)
              continue;
            const {
              path: c,
              value: N
            } = f;
            if (!c)
              continue;
            const u = (0, C.parseXFAPath)(c);
            let p = x.documentElement.searchNode(u, 0);
            !p && u.length > 1 && (p = x.documentElement.searchNode([u.at(-1)], 0)), p ? p.childNodes = Array.isArray(N) ? N.map((S) => new e.SimpleDOMNode("value", S)) : [new e.SimpleDOMNode("#text", N)] : (0, n.warn)(`Node not found for path: ${c}`);
          }
          const R = [];
          return x.documentElement.dump(R), R.join("");
        }
        async function A({
          xref: k,
          acroForm: H,
          acroFormRef: x,
          hasXfa: R,
          hasXfaDatasetsEntry: f,
          xfaDatasetsRef: c,
          needAppearances: N,
          newRefs: u
        }) {
          if (R && !f && !c && (0, n.warn)("XFA - Cannot save it"), !N && (!R || !c || f))
            return;
          const p = H.clone();
          if (R && !f) {
            const B = H.get("XFA").slice();
            B.splice(2, 0, "datasets"), B.splice(3, 0, c), p.set("XFA", B);
          }
          N && p.set("NeedAppearances", !0);
          const S = [];
          await j(x, p, S, k), u.push({
            ref: x,
            data: S.join("")
          });
        }
        function I({
          xfaData: k,
          xfaDatasetsRef: H,
          newRefs: x,
          xref: R
        }) {
          if (k === null) {
            const N = R.fetchIfRef(H);
            k = d(N.getString(), x);
          }
          const f = R.encrypt;
          f && (k = f.createCipherTransform(H.num, H.gen).encryptString(k));
          const c = `${H.num} ${H.gen} obj
<< /Type /EmbeddedFile /Length ${k.length}>>
stream
` + k + `
endstream
endobj
`;
          x.push({
            ref: H,
            data: c
          });
        }
        async function E({
          originalData: k,
          xrefInfo: H,
          newRefs: x,
          xref: R = null,
          hasXfa: f = !1,
          xfaDatasetsRef: c = null,
          hasXfaDatasetsEntry: N = !1,
          needAppearances: u,
          acroFormRef: p = null,
          acroForm: S = null,
          xfaData: B = null
        }) {
          await A({
            xref: R,
            acroForm: S,
            acroFormRef: p,
            hasXfa: f,
            hasXfaDatasetsEntry: N,
            xfaDatasetsRef: c,
            needAppearances: u,
            newRefs: x
          }), f && I({
            xfaData: B,
            xfaDatasetsRef: c,
            newRefs: x,
            xref: R
          });
          const T = new F.Dict(null), D = H.newRef;
          let K, _;
          const o = k.at(-1);
          o === 10 || o === 13 ? (K = [], _ = k.length) : (K = [`
`], _ = k.length + 1), T.set("Size", D.num + 1), T.set("Prev", H.startXRef), T.set("Type", F.Name.get("XRef")), H.rootRef !== null && T.set("Root", H.rootRef), H.infoRef !== null && T.set("Info", H.infoRef), H.encryptRef !== null && T.set("Encrypt", H.encryptRef), x.push({
            ref: D,
            data: ""
          }), x = x.sort((te, L) => te.ref.num - L.ref.num);
          const m = [[0, 1, 65535]], s = [0, 1];
          let r = 0;
          for (const {
            ref: te,
            data: L
          } of x)
            r = Math.max(r, _), m.push([1, _, Math.min(te.gen, 65535)]), _ += L.length, s.push(te.num, 1), K.push(L);
          if (T.set("Index", s), Array.isArray(H.fileIds) && H.fileIds.length > 0) {
            const te = P(_, H);
            T.set("ID", [H.fileIds[0], te]);
          }
          const M = [1, Math.ceil(Math.log2(r) / 8), 2], G = (M[0] + M[1] + M[2]) * m.length;
          T.set("W", M), T.set("Length", G), K.push(`${D.num} ${D.gen} obj
`), await U(T, K, null), K.push(` stream
`);
          const ce = K.reduce((te, L) => te + L.length, 0), q = `
endstream
endobj
startxref
${_}
%%EOF
`, re = new Uint8Array(k.length + ce + G + q.length);
          re.set(k);
          let Z = k.length;
          for (const te of K)
            i(te, Z, re), Z += te.length;
          for (const [te, L, X] of m)
            Z = b(te, M[0], Z, re), Z = b(L, M[1], Z, re), Z = b(X, M[2], Z, re);
          return i(q, Z, re), re;
        }
      },
      /* 74 */
      /***/
      (fe, w, V) => {
        var E, k, Ia, x, $i, f, Oa, N, Gn, p, ji;
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.calculateSHA256 = w.calculateMD5 = w.PDF20 = w.PDF17 = w.CipherTransformFactory = w.ARCFourCipher = w.AES256Cipher = w.AES128Cipher = void 0, w.calculateSHA384 = O, w.calculateSHA512 = void 0;
        var n = V(2), F = V(4), C = V(75);
        class e {
          constructor(D) {
            this.a = 0, this.b = 0;
            const K = new Uint8Array(256), _ = D.length;
            for (let o = 0; o < 256; ++o)
              K[o] = o;
            for (let o = 0, m = 0; o < 256; ++o) {
              const s = K[o];
              m = m + s + D[o % _] & 255, K[o] = K[m], K[m] = s;
            }
            this.s = K;
          }
          encryptBlock(D) {
            let K = this.a, _ = this.b;
            const o = this.s, m = D.length, s = new Uint8Array(m);
            for (let r = 0; r < m; ++r) {
              K = K + 1 & 255;
              const y = o[K];
              _ = _ + y & 255;
              const M = o[_];
              o[K] = M, o[_] = y, s[r] = D[r] ^ o[y + M & 255];
            }
            return this.a = K, this.b = _, s;
          }
          decryptBlock(D) {
            return this.encryptBlock(D);
          }
          encrypt(D) {
            return this.encryptBlock(D);
          }
        }
        w.ARCFourCipher = e;
        const t = function() {
          const D = new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]), K = new Int32Array([-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162, 1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632, 643717713, -373897302, -701558691, 38016083, -660478335, -405537848, 568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784, 1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556, -1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222, -722521979, 76029189, -640364487, -421815835, 530742520, -995338651, -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606, -1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649, -145523070, -1120210379, 718787259, -343485551]);
          function _(o, m, s) {
            let r = 1732584193, y = -271733879, M = -1732584194, $ = 271733878;
            const G = s + 72 & -64, ce = new Uint8Array(G);
            let q, re;
            for (q = 0; q < s; ++q)
              ce[q] = o[m++];
            ce[q++] = 128;
            const Z = G - 8;
            for (; q < Z; )
              ce[q++] = 0;
            ce[q++] = s << 3 & 255, ce[q++] = s >> 5 & 255, ce[q++] = s >> 13 & 255, ce[q++] = s >> 21 & 255, ce[q++] = s >>> 29 & 255, ce[q++] = 0, ce[q++] = 0, ce[q++] = 0;
            const te = new Int32Array(16);
            for (q = 0; q < G; ) {
              for (re = 0; re < 16; ++re, q += 4)
                te[re] = ce[q] | ce[q + 1] << 8 | ce[q + 2] << 16 | ce[q + 3] << 24;
              let L = r, X = y, J = M, Y = $, ae, se;
              for (re = 0; re < 64; ++re) {
                re < 16 ? (ae = X & J | ~X & Y, se = re) : re < 32 ? (ae = Y & X | ~Y & J, se = 5 * re + 1 & 15) : re < 48 ? (ae = X ^ J ^ Y, se = 3 * re + 5 & 15) : (ae = J ^ (X | ~Y), se = 7 * re & 15);
                const Q = Y, z = L + ae + K[re] + te[se] | 0, ie = D[re];
                Y = J, J = X, X = X + (z << ie | z >>> 32 - ie) | 0, L = Q;
              }
              r = r + L | 0, y = y + X | 0, M = M + J | 0, $ = $ + Y | 0;
            }
            return new Uint8Array([r & 255, r >> 8 & 255, r >> 16 & 255, r >>> 24 & 255, y & 255, y >> 8 & 255, y >> 16 & 255, y >>> 24 & 255, M & 255, M >> 8 & 255, M >> 16 & 255, M >>> 24 & 255, $ & 255, $ >> 8 & 255, $ >> 16 & 255, $ >>> 24 & 255]);
          }
          return _;
        }();
        w.calculateMD5 = t;
        class l {
          constructor(D, K) {
            this.high = D | 0, this.low = K | 0;
          }
          and(D) {
            this.high &= D.high, this.low &= D.low;
          }
          xor(D) {
            this.high ^= D.high, this.low ^= D.low;
          }
          or(D) {
            this.high |= D.high, this.low |= D.low;
          }
          shiftRight(D) {
            D >= 32 ? (this.low = this.high >>> D - 32 | 0, this.high = 0) : (this.low = this.low >>> D | this.high << 32 - D, this.high = this.high >>> D | 0);
          }
          shiftLeft(D) {
            D >= 32 ? (this.high = this.low << D - 32, this.low = 0) : (this.high = this.high << D | this.low >>> 32 - D, this.low <<= D);
          }
          rotateRight(D) {
            let K, _;
            D & 32 ? (_ = this.low, K = this.high) : (K = this.low, _ = this.high), D &= 31, this.low = K >>> D | _ << 32 - D, this.high = _ >>> D | K << 32 - D;
          }
          not() {
            this.high = ~this.high, this.low = ~this.low;
          }
          add(D) {
            const K = (this.low >>> 0) + (D.low >>> 0);
            let _ = (this.high >>> 0) + (D.high >>> 0);
            K > 4294967295 && (_ += 1), this.low = K | 0, this.high = _ | 0;
          }
          copyTo(D, K) {
            D[K] = this.high >>> 24 & 255, D[K + 1] = this.high >> 16 & 255, D[K + 2] = this.high >> 8 & 255, D[K + 3] = this.high & 255, D[K + 4] = this.low >>> 24 & 255, D[K + 5] = this.low >> 16 & 255, D[K + 6] = this.low >> 8 & 255, D[K + 7] = this.low & 255;
          }
          assign(D) {
            this.high = D.high, this.low = D.low;
          }
        }
        const j = /* @__PURE__ */ function() {
          function D($, G) {
            return $ >>> G | $ << 32 - G;
          }
          function K($, G, ce) {
            return $ & G ^ ~$ & ce;
          }
          function _($, G, ce) {
            return $ & G ^ $ & ce ^ G & ce;
          }
          function o($) {
            return D($, 2) ^ D($, 13) ^ D($, 22);
          }
          function m($) {
            return D($, 6) ^ D($, 11) ^ D($, 25);
          }
          function s($) {
            return D($, 7) ^ D($, 18) ^ $ >>> 3;
          }
          function r($) {
            return D($, 17) ^ D($, 19) ^ $ >>> 10;
          }
          const y = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
          function M($, G, ce) {
            let q = 1779033703, re = 3144134277, Z = 1013904242, te = 2773480762, L = 1359893119, X = 2600822924, J = 528734635, Y = 1541459225;
            const ae = Math.ceil((ce + 9) / 64) * 64, se = new Uint8Array(ae);
            let Q, z;
            for (Q = 0; Q < ce; ++Q)
              se[Q] = $[G++];
            se[Q++] = 128;
            const ie = ae - 8;
            for (; Q < ie; )
              se[Q++] = 0;
            se[Q++] = 0, se[Q++] = 0, se[Q++] = 0, se[Q++] = ce >>> 29 & 255, se[Q++] = ce >> 21 & 255, se[Q++] = ce >> 13 & 255, se[Q++] = ce >> 5 & 255, se[Q++] = ce << 3 & 255;
            const ne = new Uint32Array(64);
            for (Q = 0; Q < ae; ) {
              for (z = 0; z < 16; ++z)
                ne[z] = se[Q] << 24 | se[Q + 1] << 16 | se[Q + 2] << 8 | se[Q + 3], Q += 4;
              for (z = 16; z < 64; ++z)
                ne[z] = r(ne[z - 2]) + ne[z - 7] + s(ne[z - 15]) + ne[z - 16] | 0;
              let W = q, oe = re, ue = Z, pe = te, ve = L, Ce = X, Fe = J, Pe = Y, be, me;
              for (z = 0; z < 64; ++z)
                be = Pe + m(ve) + K(ve, Ce, Fe) + y[z] + ne[z], me = o(W) + _(W, oe, ue), Pe = Fe, Fe = Ce, Ce = ve, ve = pe + be | 0, pe = ue, ue = oe, oe = W, W = be + me | 0;
              q = q + W | 0, re = re + oe | 0, Z = Z + ue | 0, te = te + pe | 0, L = L + ve | 0, X = X + Ce | 0, J = J + Fe | 0, Y = Y + Pe | 0;
            }
            return new Uint8Array([q >> 24 & 255, q >> 16 & 255, q >> 8 & 255, q & 255, re >> 24 & 255, re >> 16 & 255, re >> 8 & 255, re & 255, Z >> 24 & 255, Z >> 16 & 255, Z >> 8 & 255, Z & 255, te >> 24 & 255, te >> 16 & 255, te >> 8 & 255, te & 255, L >> 24 & 255, L >> 16 & 255, L >> 8 & 255, L & 255, X >> 24 & 255, X >> 16 & 255, X >> 8 & 255, X & 255, J >> 24 & 255, J >> 16 & 255, J >> 8 & 255, J & 255, Y >> 24 & 255, Y >> 16 & 255, Y >> 8 & 255, Y & 255]);
          }
          return M;
        }();
        w.calculateSHA256 = j;
        const U = function() {
          function D(M, $, G, ce, q) {
            M.assign($), M.and(G), q.assign($), q.not(), q.and(ce), M.xor(q);
          }
          function K(M, $, G, ce, q) {
            M.assign($), M.and(G), q.assign($), q.and(ce), M.xor(q), q.assign(G), q.and(ce), M.xor(q);
          }
          function _(M, $, G) {
            M.assign($), M.rotateRight(28), G.assign($), G.rotateRight(34), M.xor(G), G.assign($), G.rotateRight(39), M.xor(G);
          }
          function o(M, $, G) {
            M.assign($), M.rotateRight(14), G.assign($), G.rotateRight(18), M.xor(G), G.assign($), G.rotateRight(41), M.xor(G);
          }
          function m(M, $, G) {
            M.assign($), M.rotateRight(1), G.assign($), G.rotateRight(8), M.xor(G), G.assign($), G.shiftRight(7), M.xor(G);
          }
          function s(M, $, G) {
            M.assign($), M.rotateRight(19), G.assign($), G.rotateRight(61), M.xor(G), G.assign($), G.shiftRight(6), M.xor(G);
          }
          const r = [new l(1116352408, 3609767458), new l(1899447441, 602891725), new l(3049323471, 3964484399), new l(3921009573, 2173295548), new l(961987163, 4081628472), new l(1508970993, 3053834265), new l(2453635748, 2937671579), new l(2870763221, 3664609560), new l(3624381080, 2734883394), new l(310598401, 1164996542), new l(607225278, 1323610764), new l(1426881987, 3590304994), new l(1925078388, 4068182383), new l(2162078206, 991336113), new l(2614888103, 633803317), new l(3248222580, 3479774868), new l(3835390401, 2666613458), new l(4022224774, 944711139), new l(264347078, 2341262773), new l(604807628, 2007800933), new l(770255983, 1495990901), new l(1249150122, 1856431235), new l(1555081692, 3175218132), new l(1996064986, 2198950837), new l(2554220882, 3999719339), new l(2821834349, 766784016), new l(2952996808, 2566594879), new l(3210313671, 3203337956), new l(3336571891, 1034457026), new l(3584528711, 2466948901), new l(113926993, 3758326383), new l(338241895, 168717936), new l(666307205, 1188179964), new l(773529912, 1546045734), new l(1294757372, 1522805485), new l(1396182291, 2643833823), new l(1695183700, 2343527390), new l(1986661051, 1014477480), new l(2177026350, 1206759142), new l(2456956037, 344077627), new l(2730485921, 1290863460), new l(2820302411, 3158454273), new l(3259730800, 3505952657), new l(3345764771, 106217008), new l(3516065817, 3606008344), new l(3600352804, 1432725776), new l(4094571909, 1467031594), new l(275423344, 851169720), new l(430227734, 3100823752), new l(506948616, 1363258195), new l(659060556, 3750685593), new l(883997877, 3785050280), new l(958139571, 3318307427), new l(1322822218, 3812723403), new l(1537002063, 2003034995), new l(1747873779, 3602036899), new l(1955562222, 1575990012), new l(2024104815, 1125592928), new l(2227730452, 2716904306), new l(2361852424, 442776044), new l(2428436474, 593698344), new l(2756734187, 3733110249), new l(3204031479, 2999351573), new l(3329325298, 3815920427), new l(3391569614, 3928383900), new l(3515267271, 566280711), new l(3940187606, 3454069534), new l(4118630271, 4000239992), new l(116418474, 1914138554), new l(174292421, 2731055270), new l(289380356, 3203993006), new l(460393269, 320620315), new l(685471733, 587496836), new l(852142971, 1086792851), new l(1017036298, 365543100), new l(1126000580, 2618297676), new l(1288033470, 3409855158), new l(1501505948, 4234509866), new l(1607167915, 987167468), new l(1816402316, 1246189591)];
          function y(M, $, G, ce = !1) {
            let q, re, Z, te, L, X, J, Y;
            ce ? (q = new l(3418070365, 3238371032), re = new l(1654270250, 914150663), Z = new l(2438529370, 812702999), te = new l(355462360, 4144912697), L = new l(1731405415, 4290775857), X = new l(2394180231, 1750603025), J = new l(3675008525, 1694076839), Y = new l(1203062813, 3204075428)) : (q = new l(1779033703, 4089235720), re = new l(3144134277, 2227873595), Z = new l(1013904242, 4271175723), te = new l(2773480762, 1595750129), L = new l(1359893119, 2917565137), X = new l(2600822924, 725511199), J = new l(528734635, 4215389547), Y = new l(1541459225, 327033209));
            const ae = Math.ceil((G + 17) / 128) * 128, se = new Uint8Array(ae);
            let Q, z;
            for (Q = 0; Q < G; ++Q)
              se[Q] = M[$++];
            se[Q++] = 128;
            const ie = ae - 16;
            for (; Q < ie; )
              se[Q++] = 0;
            se[Q++] = 0, se[Q++] = 0, se[Q++] = 0, se[Q++] = 0, se[Q++] = 0, se[Q++] = 0, se[Q++] = 0, se[Q++] = 0, se[Q++] = 0, se[Q++] = 0, se[Q++] = 0, se[Q++] = G >>> 29 & 255, se[Q++] = G >> 21 & 255, se[Q++] = G >> 13 & 255, se[Q++] = G >> 5 & 255, se[Q++] = G << 3 & 255;
            const ne = new Array(80);
            for (Q = 0; Q < 80; Q++)
              ne[Q] = new l(0, 0);
            let W = new l(0, 0), oe = new l(0, 0), ue = new l(0, 0), pe = new l(0, 0), ve = new l(0, 0), Ce = new l(0, 0), Fe = new l(0, 0), Pe = new l(0, 0);
            const be = new l(0, 0), me = new l(0, 0), we = new l(0, 0), _e = new l(0, 0);
            let Se;
            for (Q = 0; Q < ae; ) {
              for (z = 0; z < 16; ++z)
                ne[z].high = se[Q] << 24 | se[Q + 1] << 16 | se[Q + 2] << 8 | se[Q + 3], ne[z].low = se[Q + 4] << 24 | se[Q + 5] << 16 | se[Q + 6] << 8 | se[Q + 7], Q += 8;
              for (z = 16; z < 80; ++z)
                Se = ne[z], s(Se, ne[z - 2], _e), Se.add(ne[z - 7]), m(we, ne[z - 15], _e), Se.add(we), Se.add(ne[z - 16]);
              for (W.assign(q), oe.assign(re), ue.assign(Z), pe.assign(te), ve.assign(L), Ce.assign(X), Fe.assign(J), Pe.assign(Y), z = 0; z < 80; ++z)
                be.assign(Pe), o(we, ve, _e), be.add(we), D(we, ve, Ce, Fe, _e), be.add(we), be.add(r[z]), be.add(ne[z]), _(me, W, _e), K(we, W, oe, ue, _e), me.add(we), Se = Pe, Pe = Fe, Fe = Ce, Ce = ve, pe.add(be), ve = pe, pe = ue, ue = oe, oe = W, Se.assign(be), Se.add(me), W = Se;
              q.add(W), re.add(oe), Z.add(ue), te.add(pe), L.add(ve), X.add(Ce), J.add(Fe), Y.add(Pe);
            }
            let Ae;
            return ce ? (Ae = new Uint8Array(48), q.copyTo(Ae, 0), re.copyTo(Ae, 8), Z.copyTo(Ae, 16), te.copyTo(Ae, 24), L.copyTo(Ae, 32), X.copyTo(Ae, 40)) : (Ae = new Uint8Array(64), q.copyTo(Ae, 0), re.copyTo(Ae, 8), Z.copyTo(Ae, 16), te.copyTo(Ae, 24), L.copyTo(Ae, 32), X.copyTo(Ae, 40), J.copyTo(Ae, 48), Y.copyTo(Ae, 56)), Ae;
          }
          return y;
        }();
        w.calculateSHA512 = U;
        function O(T, D, K) {
          return U(T, D, K, !0);
        }
        class v {
          decryptBlock(D) {
            return D;
          }
          encrypt(D) {
            return D;
          }
        }
        class g {
          constructor() {
            this.constructor === g && (0, n.unreachable)("Cannot initialize AESBaseCipher."), this._s = new Uint8Array([99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]), this._inv_s = new Uint8Array([82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125]), this._mix = new Uint32Array([0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795]), this._mixCol = new Uint8Array(256);
            for (let D = 0; D < 256; D++)
              this._mixCol[D] = D < 128 ? D << 1 : D << 1 ^ 27;
            this.buffer = new Uint8Array(16), this.bufferPosition = 0;
          }
          _expandKey(D) {
            (0, n.unreachable)("Cannot call `_expandKey` on the base class");
          }
          _decrypt(D, K) {
            let _, o, m;
            const s = new Uint8Array(16);
            s.set(D);
            for (let r = 0, y = this._keySize; r < 16; ++r, ++y)
              s[r] ^= K[y];
            for (let r = this._cyclesOfRepetition - 1; r >= 1; --r) {
              _ = s[13], s[13] = s[9], s[9] = s[5], s[5] = s[1], s[1] = _, _ = s[14], o = s[10], s[14] = s[6], s[10] = s[2], s[6] = _, s[2] = o, _ = s[15], o = s[11], m = s[7], s[15] = s[3], s[11] = _, s[7] = o, s[3] = m;
              for (let y = 0; y < 16; ++y)
                s[y] = this._inv_s[s[y]];
              for (let y = 0, M = r * 16; y < 16; ++y, ++M)
                s[y] ^= K[M];
              for (let y = 0; y < 16; y += 4) {
                const M = this._mix[s[y]], $ = this._mix[s[y + 1]], G = this._mix[s[y + 2]], ce = this._mix[s[y + 3]];
                _ = M ^ $ >>> 8 ^ $ << 24 ^ G >>> 16 ^ G << 16 ^ ce >>> 24 ^ ce << 8, s[y] = _ >>> 24 & 255, s[y + 1] = _ >> 16 & 255, s[y + 2] = _ >> 8 & 255, s[y + 3] = _ & 255;
              }
            }
            _ = s[13], s[13] = s[9], s[9] = s[5], s[5] = s[1], s[1] = _, _ = s[14], o = s[10], s[14] = s[6], s[10] = s[2], s[6] = _, s[2] = o, _ = s[15], o = s[11], m = s[7], s[15] = s[3], s[11] = _, s[7] = o, s[3] = m;
            for (let r = 0; r < 16; ++r)
              s[r] = this._inv_s[s[r]], s[r] ^= K[r];
            return s;
          }
          _encrypt(D, K) {
            const _ = this._s;
            let o, m, s;
            const r = new Uint8Array(16);
            r.set(D);
            for (let y = 0; y < 16; ++y)
              r[y] ^= K[y];
            for (let y = 1; y < this._cyclesOfRepetition; y++) {
              for (let M = 0; M < 16; ++M)
                r[M] = _[r[M]];
              s = r[1], r[1] = r[5], r[5] = r[9], r[9] = r[13], r[13] = s, s = r[2], m = r[6], r[2] = r[10], r[6] = r[14], r[10] = s, r[14] = m, s = r[3], m = r[7], o = r[11], r[3] = r[15], r[7] = s, r[11] = m, r[15] = o;
              for (let M = 0; M < 16; M += 4) {
                const $ = r[M + 0], G = r[M + 1], ce = r[M + 2], q = r[M + 3];
                o = $ ^ G ^ ce ^ q, r[M + 0] ^= o ^ this._mixCol[$ ^ G], r[M + 1] ^= o ^ this._mixCol[G ^ ce], r[M + 2] ^= o ^ this._mixCol[ce ^ q], r[M + 3] ^= o ^ this._mixCol[q ^ $];
              }
              for (let M = 0, $ = y * 16; M < 16; ++M, ++$)
                r[M] ^= K[$];
            }
            for (let y = 0; y < 16; ++y)
              r[y] = _[r[y]];
            s = r[1], r[1] = r[5], r[5] = r[9], r[9] = r[13], r[13] = s, s = r[2], m = r[6], r[2] = r[10], r[6] = r[14], r[10] = s, r[14] = m, s = r[3], m = r[7], o = r[11], r[3] = r[15], r[7] = s, r[11] = m, r[15] = o;
            for (let y = 0, M = this._keySize; y < 16; ++y, ++M)
              r[y] ^= K[M];
            return r;
          }
          _decryptBlock2(D, K) {
            const _ = D.length;
            let o = this.buffer, m = this.bufferPosition;
            const s = [];
            let r = this.iv;
            for (let $ = 0; $ < _; ++$) {
              if (o[m] = D[$], ++m, m < 16)
                continue;
              const G = this._decrypt(o, this._key);
              for (let ce = 0; ce < 16; ++ce)
                G[ce] ^= r[ce];
              r = o, s.push(G), o = new Uint8Array(16), m = 0;
            }
            if (this.buffer = o, this.bufferLength = m, this.iv = r, s.length === 0)
              return new Uint8Array(0);
            let y = 16 * s.length;
            if (K) {
              const $ = s.at(-1);
              let G = $[15];
              if (G <= 16) {
                for (let ce = 15, q = 16 - G; ce >= q; --ce)
                  if ($[ce] !== G) {
                    G = 0;
                    break;
                  }
                y -= G, s[s.length - 1] = $.subarray(0, 16 - G);
              }
            }
            const M = new Uint8Array(y);
            for (let $ = 0, G = 0, ce = s.length; $ < ce; ++$, G += 16)
              M.set(s[$], G);
            return M;
          }
          decryptBlock(D, K, _ = null) {
            const o = D.length, m = this.buffer;
            let s = this.bufferPosition;
            if (_)
              this.iv = _;
            else {
              for (let r = 0; s < 16 && r < o; ++r, ++s)
                m[s] = D[r];
              if (s < 16)
                return this.bufferLength = s, new Uint8Array(0);
              this.iv = m, D = D.subarray(16);
            }
            return this.buffer = new Uint8Array(16), this.bufferLength = 0, this.decryptBlock = this._decryptBlock2, this.decryptBlock(D, K);
          }
          encrypt(D, K) {
            const _ = D.length;
            let o = this.buffer, m = this.bufferPosition;
            const s = [];
            K || (K = new Uint8Array(16));
            for (let M = 0; M < _; ++M) {
              if (o[m] = D[M], ++m, m < 16)
                continue;
              for (let G = 0; G < 16; ++G)
                o[G] ^= K[G];
              const $ = this._encrypt(o, this._key);
              K = $, s.push($), o = new Uint8Array(16), m = 0;
            }
            if (this.buffer = o, this.bufferLength = m, this.iv = K, s.length === 0)
              return new Uint8Array(0);
            const r = 16 * s.length, y = new Uint8Array(r);
            for (let M = 0, $ = 0, G = s.length; M < G; ++M, $ += 16)
              y.set(s[M], $);
            return y;
          }
        }
        class b extends g {
          constructor(D) {
            super(), this._cyclesOfRepetition = 10, this._keySize = 160, this._rcon = new Uint8Array([141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141]), this._key = this._expandKey(D);
          }
          _expandKey(D) {
            const _ = this._s, o = this._rcon, m = new Uint8Array(176);
            m.set(D);
            for (let s = 16, r = 1; s < 176; ++r) {
              let y = m[s - 3], M = m[s - 2], $ = m[s - 1], G = m[s - 4];
              y = _[y], M = _[M], $ = _[$], G = _[G], y ^= o[r];
              for (let ce = 0; ce < 4; ++ce)
                m[s] = y ^= m[s - 16], s++, m[s] = M ^= m[s - 16], s++, m[s] = $ ^= m[s - 16], s++, m[s] = G ^= m[s - 16], s++;
            }
            return m;
          }
        }
        w.AES128Cipher = b;
        class i extends g {
          constructor(D) {
            super(), this._cyclesOfRepetition = 14, this._keySize = 224, this._key = this._expandKey(D);
          }
          _expandKey(D) {
            const _ = this._s, o = new Uint8Array(240);
            o.set(D);
            let m = 1, s, r, y, M;
            for (let $ = 32, G = 1; $ < 240; ++G) {
              $ % 32 === 16 ? (s = _[s], r = _[r], y = _[y], M = _[M]) : $ % 32 === 0 && (s = o[$ - 3], r = o[$ - 2], y = o[$ - 1], M = o[$ - 4], s = _[s], r = _[r], y = _[y], M = _[M], s ^= m, (m <<= 1) >= 256 && (m = (m ^ 27) & 255));
              for (let ce = 0; ce < 4; ++ce)
                o[$] = s ^= o[$ - 32], $++, o[$] = r ^= o[$ - 32], $++, o[$] = y ^= o[$ - 32], $++, o[$] = M ^= o[$ - 32], $++;
            }
            return o;
          }
        }
        w.AES256Cipher = i;
        class P {
          checkOwnerPassword(D, K, _, o) {
            const m = new Uint8Array(D.length + 56);
            m.set(D, 0), m.set(K, D.length), m.set(_, D.length + K.length);
            const s = j(m, 0, m.length);
            return (0, n.isArrayEqual)(s, o);
          }
          checkUserPassword(D, K, _) {
            const o = new Uint8Array(D.length + 8);
            o.set(D, 0), o.set(K, D.length);
            const m = j(o, 0, o.length);
            return (0, n.isArrayEqual)(m, _);
          }
          getOwnerKey(D, K, _, o) {
            const m = new Uint8Array(D.length + 56);
            m.set(D, 0), m.set(K, D.length), m.set(_, D.length + K.length);
            const s = j(m, 0, m.length);
            return new i(s).decryptBlock(o, !1, new Uint8Array(16));
          }
          getUserKey(D, K, _) {
            const o = new Uint8Array(D.length + 8);
            o.set(D, 0), o.set(K, D.length);
            const m = j(o, 0, o.length);
            return new i(m).decryptBlock(_, !1, new Uint8Array(16));
          }
        }
        w.PDF17 = P;
        class d {
          _hash(D, K, _) {
            let o = j(K, 0, K.length).subarray(0, 32), m = [0], s = 0;
            for (; s < 64 || m.at(-1) > s - 32; ) {
              const r = D.length + o.length + _.length, y = new Uint8Array(r);
              let M = 0;
              y.set(D, M), M += D.length, y.set(o, M), M += o.length, y.set(_, M);
              const $ = new Uint8Array(r * 64);
              for (let q = 0, re = 0; q < 64; q++, re += r)
                $.set(y, re);
              m = new b(o.subarray(0, 16)).encrypt($, o.subarray(16, 32));
              const ce = m.slice(0, 16).reduce((q, re) => q + re, 0) % 3;
              ce === 0 ? o = j(m, 0, m.length) : ce === 1 ? o = O(m, 0, m.length) : ce === 2 && (o = U(m, 0, m.length)), s++;
            }
            return o.subarray(0, 32);
          }
          checkOwnerPassword(D, K, _, o) {
            const m = new Uint8Array(D.length + 56);
            m.set(D, 0), m.set(K, D.length), m.set(_, D.length + K.length);
            const s = this._hash(D, m, _);
            return (0, n.isArrayEqual)(s, o);
          }
          checkUserPassword(D, K, _) {
            const o = new Uint8Array(D.length + 8);
            o.set(D, 0), o.set(K, D.length);
            const m = this._hash(D, o, []);
            return (0, n.isArrayEqual)(m, _);
          }
          getOwnerKey(D, K, _, o) {
            const m = new Uint8Array(D.length + 56);
            m.set(D, 0), m.set(K, D.length), m.set(_, D.length + K.length);
            const s = this._hash(D, m, _);
            return new i(s).decryptBlock(o, !1, new Uint8Array(16));
          }
          getUserKey(D, K, _) {
            const o = new Uint8Array(D.length + 8);
            o.set(D, 0), o.set(K, D.length);
            const m = this._hash(D, o, []);
            return new i(m).decryptBlock(_, !1, new Uint8Array(16));
          }
        }
        w.PDF20 = d;
        class A {
          constructor(D, K) {
            this.StringCipherConstructor = D, this.StreamCipherConstructor = K;
          }
          createStream(D, K) {
            const _ = new this.StreamCipherConstructor();
            return new C.DecryptStream(D, K, function(m, s) {
              return _.decryptBlock(m, s);
            });
          }
          decryptString(D) {
            const K = new this.StringCipherConstructor();
            let _ = (0, n.stringToBytes)(D);
            return _ = K.decryptBlock(_, !0), (0, n.bytesToString)(_);
          }
          encryptString(D) {
            const K = new this.StringCipherConstructor();
            if (K instanceof g) {
              const m = 16 - D.length % 16;
              D += String.fromCharCode(m).repeat(m);
              const s = new Uint8Array(16);
              if (typeof crypto < "u")
                crypto.getRandomValues(s);
              else
                for (let M = 0; M < 16; M++)
                  s[M] = Math.floor(256 * Math.random());
              let r = (0, n.stringToBytes)(D);
              r = K.encrypt(r, s);
              const y = new Uint8Array(16 + r.length);
              return y.set(s), y.set(r, 16), (0, n.bytesToString)(y);
            }
            let _ = (0, n.stringToBytes)(D);
            return _ = K.encrypt(_), (0, n.bytesToString)(_);
          }
        }
        const B = class B {
          constructor(D, K, _) {
            Me(this, k);
            Me(this, x);
            Me(this, f);
            Me(this, N);
            Me(this, p);
            const o = D.get("Filter");
            if (!(0, F.isName)(o, "Standard"))
              throw new n.FormatError("unknown encryption method");
            this.filterName = o.name, this.dict = D;
            const m = D.get("V");
            if (!Number.isInteger(m) || m !== 1 && m !== 2 && m !== 4 && m !== 5)
              throw new n.FormatError("unsupported encryption algorithm");
            this.algorithm = m;
            let s = D.get("Length");
            if (!s)
              if (m <= 3)
                s = 40;
              else {
                const L = D.get("CF"), X = D.get("StmF");
                if (L instanceof F.Dict && X instanceof F.Name) {
                  L.suppressEncryption = !0;
                  const J = L.get(X.name);
                  s = (J == null ? void 0 : J.get("Length")) || 128, s < 40 && (s <<= 3);
                }
              }
            if (!Number.isInteger(s) || s < 40 || s % 8 !== 0)
              throw new n.FormatError("invalid key length");
            const r = (0, n.stringToBytes)(D.get("O")), y = (0, n.stringToBytes)(D.get("U")), M = r.subarray(0, 32), $ = y.subarray(0, 32), G = D.get("P"), ce = D.get("R"), q = (m === 4 || m === 5) && D.get("EncryptMetadata") !== !1;
            this.encryptMetadata = q;
            const re = (0, n.stringToBytes)(K);
            let Z;
            if (_) {
              if (ce === 6)
                try {
                  _ = (0, n.utf8StringToString)(_);
                } catch {
                  (0, n.warn)("CipherTransformFactory: Unable to convert UTF8 encoded password.");
                }
              Z = (0, n.stringToBytes)(_);
            }
            let te;
            if (m !== 5)
              te = De(this, x, $i).call(this, re, Z, M, $, G, ce, s, q);
            else {
              const L = r.subarray(32, 40), X = r.subarray(40, 48), J = y.subarray(0, 48), Y = y.subarray(32, 40), ae = y.subarray(40, 48), se = (0, n.stringToBytes)(D.get("OE")), Q = (0, n.stringToBytes)(D.get("UE")), z = (0, n.stringToBytes)(D.get("Perms"));
              te = De(this, k, Ia).call(this, ce, Z, M, L, X, J, $, Y, ae, se, Q, z);
            }
            if (!te && !_)
              throw new n.PasswordException("No password given", n.PasswordResponses.NEED_PASSWORD);
            if (!te && _) {
              const L = De(this, f, Oa).call(this, Z, M, ce, s);
              te = De(this, x, $i).call(this, re, L, M, $, G, ce, s, q);
            }
            if (!te)
              throw new n.PasswordException("Incorrect Password", n.PasswordResponses.INCORRECT_PASSWORD);
            if (this.encryptionKey = te, m >= 4) {
              const L = D.get("CF");
              L instanceof F.Dict && (L.suppressEncryption = !0), this.cf = L, this.stmf = D.get("StmF") || F.Name.get("Identity"), this.strf = D.get("StrF") || F.Name.get("Identity"), this.eff = D.get("EFF") || this.stmf;
            }
          }
          createCipherTransform(D, K) {
            if (this.algorithm === 4 || this.algorithm === 5)
              return new A(De(this, p, ji).call(this, this.cf, this.strf, D, K, this.encryptionKey), De(this, p, ji).call(this, this.cf, this.stmf, D, K, this.encryptionKey));
            const _ = De(this, N, Gn).call(this, D, K, this.encryptionKey, !1), o = function() {
              return new e(_);
            };
            return new A(o, o);
          }
        };
        E = new WeakMap(), k = new WeakSet(), Ia = function(D, K, _, o, m, s, r, y, M, $, G, ce) {
          if (K) {
            const re = Math.min(127, K.length);
            K = K.subarray(0, re);
          } else
            K = [];
          const q = D === 6 ? new d() : new P();
          return q.checkUserPassword(K, y, r) ? q.getUserKey(K, M, G) : K.length && q.checkOwnerPassword(K, o, s, _) ? q.getOwnerKey(K, m, s, $) : null;
        }, x = new WeakSet(), $i = function(D, K, _, o, m, s, r, y) {
          const M = 40 + _.length + D.length, $ = new Uint8Array(M);
          let G = 0, ce, q;
          if (K)
            for (q = Math.min(32, K.length); G < q; ++G)
              $[G] = K[G];
          for (ce = 0; G < 32; )
            $[G++] = le(B, E)[ce++];
          for (ce = 0, q = _.length; ce < q; ++ce)
            $[G++] = _[ce];
          for ($[G++] = m & 255, $[G++] = m >> 8 & 255, $[G++] = m >> 16 & 255, $[G++] = m >>> 24 & 255, ce = 0, q = D.length; ce < q; ++ce)
            $[G++] = D[ce];
          s >= 4 && !y && ($[G++] = 255, $[G++] = 255, $[G++] = 255, $[G++] = 255);
          let re = t($, 0, G);
          const Z = r >> 3;
          if (s >= 3)
            for (ce = 0; ce < 50; ++ce)
              re = t(re, 0, Z);
          const te = re.subarray(0, Z);
          let L, X;
          if (s >= 3) {
            for (G = 0; G < 32; ++G)
              $[G] = le(B, E)[G];
            for (ce = 0, q = D.length; ce < q; ++ce)
              $[G++] = D[ce];
            L = new e(te), X = L.encryptBlock(t($, 0, G)), q = te.length;
            const J = new Uint8Array(q);
            for (ce = 1; ce <= 19; ++ce) {
              for (let Y = 0; Y < q; ++Y)
                J[Y] = te[Y] ^ ce;
              L = new e(J), X = L.encryptBlock(X);
            }
            for (ce = 0, q = X.length; ce < q; ++ce)
              if (o[ce] !== X[ce])
                return null;
          } else
            for (L = new e(te), X = L.encryptBlock(le(B, E)), ce = 0, q = X.length; ce < q; ++ce)
              if (o[ce] !== X[ce])
                return null;
          return te;
        }, f = new WeakSet(), Oa = function(D, K, _, o) {
          const m = new Uint8Array(32);
          let s = 0;
          const r = Math.min(32, D.length);
          for (; s < r; ++s)
            m[s] = D[s];
          let y = 0;
          for (; s < 32; )
            m[s++] = le(B, E)[y++];
          let M = t(m, 0, s);
          const $ = o >> 3;
          if (_ >= 3)
            for (y = 0; y < 50; ++y)
              M = t(M, 0, M.length);
          let G, ce;
          if (_ >= 3) {
            ce = K;
            const q = new Uint8Array($);
            for (y = 19; y >= 0; y--) {
              for (let re = 0; re < $; ++re)
                q[re] = M[re] ^ y;
              G = new e(q), ce = G.encryptBlock(ce);
            }
          } else
            G = new e(M.subarray(0, $)), ce = G.encryptBlock(K);
          return ce;
        }, N = new WeakSet(), Gn = function(D, K, _, o = !1) {
          const m = new Uint8Array(_.length + 9), s = _.length;
          let r;
          for (r = 0; r < s; ++r)
            m[r] = _[r];
          return m[r++] = D & 255, m[r++] = D >> 8 & 255, m[r++] = D >> 16 & 255, m[r++] = K & 255, m[r++] = K >> 8 & 255, o && (m[r++] = 115, m[r++] = 65, m[r++] = 108, m[r++] = 84), t(m, 0, r).subarray(0, Math.min(_.length + 5, 16));
        }, p = new WeakSet(), ji = function(D, K, _, o, m) {
          if (!(K instanceof F.Name))
            throw new n.FormatError("Invalid crypt filter name.");
          const s = this, r = D.get(K.name), y = r == null ? void 0 : r.get("CFM");
          if (!y || y.name === "None")
            return function() {
              return new v();
            };
          if (y.name === "V2")
            return function() {
              var M;
              return new e(De(M = s, N, Gn).call(M, _, o, m, !1));
            };
          if (y.name === "AESV2")
            return function() {
              var M;
              return new b(De(M = s, N, Gn).call(M, _, o, m, !0));
            };
          if (y.name === "AESV3")
            return function() {
              return new i(m);
            };
          throw new n.FormatError("Unknown crypto method");
        }, Me(B, E, new Uint8Array([40, 191, 78, 94, 78, 117, 138, 65, 100, 0, 78, 86, 255, 250, 1, 8, 46, 46, 0, 182, 208, 104, 62, 128, 47, 12, 169, 254, 100, 83, 105, 122]));
        let I = B;
        w.CipherTransformFactory = I;
      },
      /* 75 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.DecryptStream = void 0;
        var n = V(18);
        const F = 512;
        class C extends n.DecodeStream {
          constructor(t, l, j) {
            super(l), this.str = t, this.dict = t.dict, this.decrypt = j, this.nextChunk = null, this.initialized = !1;
          }
          readBlock() {
            var g;
            let t;
            if (this.initialized ? t = this.nextChunk : (t = this.str.getBytes(F), this.initialized = !0), !t || t.length === 0) {
              this.eof = !0;
              return;
            }
            this.nextChunk = this.str.getBytes(F);
            const l = ((g = this.nextChunk) == null ? void 0 : g.length) > 0, j = this.decrypt;
            t = j(t, !l);
            const U = this.bufferLength, O = U + t.length;
            this.ensureBuffer(O).set(t, U), this.bufferLength = O;
          }
        }
        w.DecryptStream = C;
      },
      /* 76 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.ObjectLoader = void 0;
        var n = V(4), F = V(5), C = V(3), e = V(2);
        function t(U) {
          return U instanceof n.Ref || U instanceof n.Dict || U instanceof F.BaseStream || Array.isArray(U);
        }
        function l(U, O) {
          if (U instanceof n.Dict)
            U = U.getRawValues();
          else if (U instanceof F.BaseStream)
            U = U.dict.getRawValues();
          else if (!Array.isArray(U))
            return;
          for (const v of U)
            t(v) && O.push(v);
        }
        class j {
          constructor(O, v, g) {
            this.dict = O, this.keys = v, this.xref = g, this.refSet = null;
          }
          async load() {
            if (this.xref.stream.isDataLoaded)
              return;
            const {
              keys: O,
              dict: v
            } = this;
            this.refSet = new n.RefSet();
            const g = [];
            for (const b of O) {
              const i = v.getRaw(b);
              i !== void 0 && g.push(i);
            }
            return this._walk(g);
          }
          async _walk(O) {
            const v = [], g = [];
            for (; O.length; ) {
              let b = O.pop();
              if (b instanceof n.Ref) {
                if (this.refSet.has(b))
                  continue;
                try {
                  this.refSet.put(b), b = this.xref.fetch(b);
                } catch (i) {
                  if (!(i instanceof C.MissingDataException)) {
                    (0, e.warn)(`ObjectLoader._walk - requesting all data: "${i}".`), this.refSet = null;
                    const {
                      manager: P
                    } = this.xref.stream;
                    return P.requestAllChunks();
                  }
                  v.push(b), g.push({
                    begin: i.begin,
                    end: i.end
                  });
                }
              }
              if (b instanceof F.BaseStream) {
                const i = b.getBaseStreams();
                if (i) {
                  let P = !1;
                  for (const d of i)
                    d.isDataLoaded || (P = !0, g.push({
                      begin: d.start,
                      end: d.end
                    }));
                  P && v.push(b);
                }
              }
              l(b, O);
            }
            if (g.length) {
              await this.xref.stream.manager.requestRanges(g);
              for (const b of v)
                b instanceof n.Ref && this.refSet.remove(b);
              return this._walk(v);
            }
            this.refSet = null;
          }
        }
        w.ObjectLoader = j;
      },
      /* 77 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.XFAFactory = void 0;
        var n = V(78), F = V(79), C = V(89), e = V(85), t = V(84), l = V(2), j = V(90), U = V(100);
        class O {
          constructor(g) {
            try {
              this.root = new j.XFAParser().parse(O._createDocument(g));
              const b = new F.Binder(this.root);
              this.form = b.bind(), this.dataHandler = new C.DataHandler(this.root, b.getData()), this.form[n.$globalData].template = this.form;
            } catch (b) {
              (0, l.warn)(`XFA - an error occurred during parsing and binding: ${b}`);
            }
          }
          isValid() {
            return this.root && this.form;
          }
          _createPagesHelper() {
            const g = this.form[n.$toPages]();
            return new Promise((b, i) => {
              const P = () => {
                try {
                  const d = g.next();
                  d.done ? b(d.value) : setTimeout(P, 0);
                } catch (d) {
                  i(d);
                }
              };
              setTimeout(P, 0);
            });
          }
          async _createPages() {
            try {
              this.pages = await this._createPagesHelper(), this.dims = this.pages.children.map((g) => {
                const {
                  width: b,
                  height: i
                } = g.attributes.style;
                return [0, 0, parseInt(b), parseInt(i)];
              });
            } catch (g) {
              (0, l.warn)(`XFA - an error occurred during layout: ${g}`);
            }
          }
          getBoundingBox(g) {
            return this.dims[g];
          }
          async getNumPages() {
            return this.pages || await this._createPages(), this.dims.length;
          }
          setImages(g) {
            this.form[n.$globalData].images = g;
          }
          setFonts(g) {
            this.form[n.$globalData].fontFinder = new e.FontFinder(g);
            const b = [];
            for (let i of this.form[n.$globalData].usedTypefaces)
              i = (0, t.stripQuotes)(i), this.form[n.$globalData].fontFinder.find(i) || b.push(i);
            return b.length > 0 ? b : null;
          }
          appendFonts(g, b) {
            this.form[n.$globalData].fontFinder.add(g, b);
          }
          async getPages() {
            this.pages || await this._createPages();
            const g = this.pages;
            return this.pages = null, g;
          }
          serializeData(g) {
            return this.dataHandler.serialize(g);
          }
          static _createDocument(g) {
            return g["/xdp:xdp"] ? Object.values(g).join("") : g["xdp:xdp"];
          }
          static getRichTextAsHtml(g) {
            if (!g || typeof g != "string")
              return null;
            try {
              let b = new j.XFAParser(U.XhtmlNamespace, !0).parse(g);
              if (!["body", "xhtml"].includes(b[n.$nodeName])) {
                const A = U.XhtmlNamespace.body({});
                A[n.$appendChild](b), b = A;
              }
              const i = b[n.$toHTML]();
              if (!i.success)
                return null;
              const {
                html: P
              } = i, {
                attributes: d
              } = P;
              return d && (d.class && (d.class = d.class.filter((A) => !A.startsWith("xfa"))), d.dir = "auto"), {
                html: P,
                str: b[n.$text]()
              };
            } catch (b) {
              (0, l.warn)(`XFA - an error occurred during parsing of rich text: ${b}`);
            }
            return null;
          }
        }
        w.XFAFactory = O;
      },
      /* 78 */
      /***/
      (fe, w) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.$uid = w.$toStyle = w.$toString = w.$toPages = w.$toHTML = w.$text = w.$tabIndex = w.$setValue = w.$setSetAttributes = w.$setId = w.$searchNode = w.$root = w.$resolvePrototypes = w.$removeChild = w.$pushPara = w.$pushGlyphs = w.$popPara = w.$onText = w.$onChildCheck = w.$onChild = w.$nsAttributes = w.$nodeName = w.$namespaceId = w.$lastAttribute = w.$isUsable = w.$isTransparent = w.$isThereMoreWidth = w.$isSplittable = w.$isNsAgnostic = w.$isDescendent = w.$isDataValue = w.$isCDATAXml = w.$isBindable = w.$insertAt = w.$indexOf = w.$ids = w.$hasSettableValue = w.$globalData = w.$getTemplateRoot = w.$getSubformParent = w.$getRealChildrenByNameIt = w.$getParent = w.$getNextPage = w.$getExtra = w.$getDataValue = w.$getContainedChildren = w.$getChildrenByNameIt = w.$getChildrenByName = w.$getChildrenByClass = w.$getChildren = w.$getAvailableSpace = w.$getAttributes = w.$getAttributeIt = w.$flushHTML = w.$finalize = w.$extra = w.$dump = w.$data = w.$content = w.$consumed = w.$clone = w.$cleanup = w.$cleanPage = w.$clean = w.$childrenToHTML = w.$appendChild = w.$addHTML = w.$acceptWhitespace = void 0;
        const V = Symbol();
        w.$acceptWhitespace = V;
        const n = Symbol();
        w.$addHTML = n;
        const F = Symbol();
        w.$appendChild = F;
        const C = Symbol();
        w.$childrenToHTML = C;
        const e = Symbol();
        w.$clean = e;
        const t = Symbol();
        w.$cleanPage = t;
        const l = Symbol();
        w.$cleanup = l;
        const j = Symbol();
        w.$clone = j;
        const U = Symbol();
        w.$consumed = U;
        const O = Symbol("content");
        w.$content = O;
        const v = Symbol("data");
        w.$data = v;
        const g = Symbol();
        w.$dump = g;
        const b = Symbol("extra");
        w.$extra = b;
        const i = Symbol();
        w.$finalize = i;
        const P = Symbol();
        w.$flushHTML = P;
        const d = Symbol();
        w.$getAttributeIt = d;
        const A = Symbol();
        w.$getAttributes = A;
        const I = Symbol();
        w.$getAvailableSpace = I;
        const E = Symbol();
        w.$getChildrenByClass = E;
        const k = Symbol();
        w.$getChildrenByName = k;
        const H = Symbol();
        w.$getChildrenByNameIt = H;
        const x = Symbol();
        w.$getDataValue = x;
        const R = Symbol();
        w.$getExtra = R;
        const f = Symbol();
        w.$getRealChildrenByNameIt = f;
        const c = Symbol();
        w.$getChildren = c;
        const N = Symbol();
        w.$getContainedChildren = N;
        const u = Symbol();
        w.$getNextPage = u;
        const p = Symbol();
        w.$getSubformParent = p;
        const S = Symbol();
        w.$getParent = S;
        const B = Symbol();
        w.$getTemplateRoot = B;
        const T = Symbol();
        w.$globalData = T;
        const D = Symbol();
        w.$hasSettableValue = D;
        const K = Symbol();
        w.$ids = K;
        const _ = Symbol();
        w.$indexOf = _;
        const o = Symbol();
        w.$insertAt = o;
        const m = Symbol();
        w.$isCDATAXml = m;
        const s = Symbol();
        w.$isBindable = s;
        const r = Symbol();
        w.$isDataValue = r;
        const y = Symbol();
        w.$isDescendent = y;
        const M = Symbol();
        w.$isNsAgnostic = M;
        const $ = Symbol();
        w.$isSplittable = $;
        const G = Symbol();
        w.$isThereMoreWidth = G;
        const ce = Symbol();
        w.$isTransparent = ce;
        const q = Symbol();
        w.$isUsable = q;
        const re = Symbol();
        w.$lastAttribute = re;
        const Z = Symbol("namespaceId");
        w.$namespaceId = Z;
        const te = Symbol("nodeName");
        w.$nodeName = te;
        const L = Symbol();
        w.$nsAttributes = L;
        const X = Symbol();
        w.$onChild = X;
        const J = Symbol();
        w.$onChildCheck = J;
        const Y = Symbol();
        w.$onText = Y;
        const ae = Symbol();
        w.$pushGlyphs = ae;
        const se = Symbol();
        w.$popPara = se;
        const Q = Symbol();
        w.$pushPara = Q;
        const z = Symbol();
        w.$removeChild = z;
        const ie = Symbol("root");
        w.$root = ie;
        const ne = Symbol();
        w.$resolvePrototypes = ne;
        const W = Symbol();
        w.$searchNode = W;
        const oe = Symbol();
        w.$setId = oe;
        const ue = Symbol();
        w.$setSetAttributes = ue;
        const pe = Symbol();
        w.$setValue = pe;
        const ve = Symbol();
        w.$tabIndex = ve;
        const Ce = Symbol();
        w.$text = Ce;
        const Fe = Symbol();
        w.$toPages = Fe;
        const Pe = Symbol();
        w.$toHTML = Pe;
        const be = Symbol();
        w.$toString = be;
        const me = Symbol();
        w.$toStyle = me;
        const we = Symbol("uid");
        w.$uid = we;
      },
      /* 79 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.Binder = void 0;
        var n = V(78), F = V(80), C = V(88), e = V(87), t = V(81), l = V(2);
        const j = t.NamespaceIds.datasets.id;
        function U(v) {
          const g = new F.Text({});
          return g[n.$content] = v, g;
        }
        class O {
          constructor(g) {
            var b;
            this.root = g, this.datasets = g.datasets, this.data = ((b = g.datasets) == null ? void 0 : b.data) || new e.XmlObject(t.NamespaceIds.datasets.id, "data"), this.emptyMerge = this.data[n.$getChildren]().length === 0, this.root.form = this.form = g.template[n.$clone]();
          }
          _isConsumeData() {
            return !this.emptyMerge && this._mergeMode;
          }
          _isMatchTemplate() {
            return !this._isConsumeData();
          }
          bind() {
            return this._bindElement(this.form, this.data), this.form;
          }
          getData() {
            return this.data;
          }
          _bindValue(g, b, i) {
            var P, d;
            if (g[n.$data] = b, g[n.$hasSettableValue]())
              if (b[n.$isDataValue]()) {
                const A = b[n.$getDataValue]();
                g[n.$setValue](U(A));
              } else if (g instanceof F.Field && ((d = (P = g.ui) == null ? void 0 : P.choiceList) == null ? void 0 : d.open) === "multiSelect") {
                const A = b[n.$getChildren]().map((I) => I[n.$content].trim()).join(`
`);
                g[n.$setValue](U(A));
              } else
                this._isConsumeData() && (0, l.warn)("XFA - Nodes haven't the same type.");
            else
              !b[n.$isDataValue]() || this._isMatchTemplate() ? this._bindElement(g, b) : (0, l.warn)("XFA - Nodes haven't the same type.");
          }
          _findDataByNameToConsume(g, b, i, P) {
            if (!g)
              return null;
            let d, A;
            for (let I = 0; I < 3; I++) {
              for (d = i[n.$getRealChildrenByNameIt](g, !1, !0); A = d.next().value, !!A; )
                if (b === A[n.$isDataValue]())
                  return A;
              if (i[n.$namespaceId] === t.NamespaceIds.datasets.id && i[n.$nodeName] === "data")
                break;
              i = i[n.$getParent]();
            }
            return P ? (d = this.data[n.$getRealChildrenByNameIt](g, !0, !1), A = d.next().value, A || (d = this.data[n.$getAttributeIt](g, !0), A = d.next().value, A != null && A[n.$isDataValue]()) ? A : null) : null;
          }
          _setProperties(g, b) {
            if (g.hasOwnProperty("setProperty"))
              for (const {
                ref: i,
                target: P,
                connection: d
              } of g.setProperty.children) {
                if (d || !i)
                  continue;
                const A = (0, C.searchNode)(this.root, b, i, !1, !1);
                if (!A) {
                  (0, l.warn)(`XFA - Invalid reference: ${i}.`);
                  continue;
                }
                const [I] = A;
                if (!I[n.$isDescendent](this.data)) {
                  (0, l.warn)("XFA - Invalid node: must be a data node.");
                  continue;
                }
                const E = (0, C.searchNode)(this.root, g, P, !1, !1);
                if (!E) {
                  (0, l.warn)(`XFA - Invalid target: ${P}.`);
                  continue;
                }
                const [k] = E;
                if (!k[n.$isDescendent](g)) {
                  (0, l.warn)("XFA - Invalid target: must be a property or subproperty.");
                  continue;
                }
                const H = k[n.$getParent]();
                if (k instanceof F.SetProperty || H instanceof F.SetProperty) {
                  (0, l.warn)("XFA - Invalid target: cannot be a setProperty or one of its properties.");
                  continue;
                }
                if (k instanceof F.BindItems || H instanceof F.BindItems) {
                  (0, l.warn)("XFA - Invalid target: cannot be a bindItems or one of its properties.");
                  continue;
                }
                const x = I[n.$text](), R = k[n.$nodeName];
                if (k instanceof e.XFAAttribute) {
                  const f = /* @__PURE__ */ Object.create(null);
                  f[R] = x;
                  const c = Reflect.construct(Object.getPrototypeOf(H).constructor, [f]);
                  H[R] = c[R];
                  continue;
                }
                if (!k.hasOwnProperty(n.$content)) {
                  (0, l.warn)("XFA - Invalid node to use in setProperty");
                  continue;
                }
                k[n.$data] = I, k[n.$content] = x, k[n.$finalize]();
              }
          }
          _bindItems(g, b) {
            if (!g.hasOwnProperty("items") || !g.hasOwnProperty("bindItems") || g.bindItems.isEmpty())
              return;
            for (const d of g.items.children)
              g[n.$removeChild](d);
            g.items.clear();
            const i = new F.Items({}), P = new F.Items({});
            g[n.$appendChild](i), g.items.push(i), g[n.$appendChild](P), g.items.push(P);
            for (const {
              ref: d,
              labelRef: A,
              valueRef: I,
              connection: E
            } of g.bindItems.children) {
              if (E || !d)
                continue;
              const k = (0, C.searchNode)(this.root, b, d, !1, !1);
              if (!k) {
                (0, l.warn)(`XFA - Invalid reference: ${d}.`);
                continue;
              }
              for (const H of k) {
                if (!H[n.$isDescendent](this.datasets)) {
                  (0, l.warn)(`XFA - Invalid ref (${d}): must be a datasets child.`);
                  continue;
                }
                const x = (0, C.searchNode)(this.root, H, A, !0, !1);
                if (!x) {
                  (0, l.warn)(`XFA - Invalid label: ${A}.`);
                  continue;
                }
                const [R] = x;
                if (!R[n.$isDescendent](this.datasets)) {
                  (0, l.warn)("XFA - Invalid label: must be a datasets child.");
                  continue;
                }
                const f = (0, C.searchNode)(this.root, H, I, !0, !1);
                if (!f) {
                  (0, l.warn)(`XFA - Invalid value: ${I}.`);
                  continue;
                }
                const [c] = f;
                if (!c[n.$isDescendent](this.datasets)) {
                  (0, l.warn)("XFA - Invalid value: must be a datasets child.");
                  continue;
                }
                const N = U(R[n.$text]()), u = U(c[n.$text]());
                i[n.$appendChild](N), i.text.push(N), P[n.$appendChild](u), P.text.push(u);
              }
            }
          }
          _bindOccurrences(g, b, i) {
            let P;
            if (b.length > 1 && (P = g[n.$clone](), P[n.$removeChild](P.occur), P.occur = null), this._bindValue(g, b[0], i), this._setProperties(g, b[0]), this._bindItems(g, b[0]), b.length === 1)
              return;
            const d = g[n.$getParent](), A = g[n.$nodeName], I = d[n.$indexOf](g);
            for (let E = 1, k = b.length; E < k; E++) {
              const H = b[E], x = P[n.$clone]();
              d[A].push(x), d[n.$insertAt](I + E, x), this._bindValue(x, H, i), this._setProperties(x, H), this._bindItems(x, H);
            }
          }
          _createOccurrences(g) {
            if (!this.emptyMerge)
              return;
            const {
              occur: b
            } = g;
            if (!b || b.initial <= 1)
              return;
            const i = g[n.$getParent](), P = g[n.$nodeName];
            if (!(i[P] instanceof e.XFAObjectArray))
              return;
            let d;
            g.name ? d = i[P].children.filter((E) => E.name === g.name).length : d = i[P].children.length;
            const A = i[n.$indexOf](g) + 1, I = b.initial - d;
            if (I) {
              const E = g[n.$clone]();
              E[n.$removeChild](E.occur), E.occur = null, i[P].push(E), i[n.$insertAt](A, E);
              for (let k = 1; k < I; k++) {
                const H = E[n.$clone]();
                i[P].push(H), i[n.$insertAt](A + k, H);
              }
            }
          }
          _getOccurInfo(g) {
            const {
              name: b,
              occur: i
            } = g;
            if (!i || !b)
              return [1, 1];
            const P = i.max === -1 ? 1 / 0 : i.max;
            return [i.min, P];
          }
          _setAndBind(g, b) {
            this._setProperties(g, b), this._bindItems(g, b), this._bindElement(g, b);
          }
          _bindElement(g, b) {
            const i = [];
            this._createOccurrences(g);
            for (const P of g[n.$getChildren]()) {
              if (P[n.$data])
                continue;
              if (this._mergeMode === void 0 && P[n.$nodeName] === "subform") {
                this._mergeMode = P.mergeMode === "consumeData";
                const x = b[n.$getChildren]();
                if (x.length > 0)
                  this._bindOccurrences(P, [x[0]], null);
                else if (this.emptyMerge) {
                  const R = b[n.$namespaceId] === j ? -1 : b[n.$namespaceId], f = P[n.$data] = new e.XmlObject(R, P.name || "root");
                  b[n.$appendChild](f), this._bindElement(P, f);
                }
                continue;
              }
              if (!P[n.$isBindable]())
                continue;
              let d = !1, A = null, I = null, E = null;
              if (P.bind) {
                switch (P.bind.match) {
                  case "none":
                    this._setAndBind(P, b);
                    continue;
                  case "global":
                    d = !0;
                    break;
                  case "dataRef":
                    if (!P.bind.ref) {
                      (0, l.warn)(`XFA - ref is empty in node ${P[n.$nodeName]}.`), this._setAndBind(P, b);
                      continue;
                    }
                    I = P.bind.ref;
                    break;
                }
                P.bind.picture && (A = P.bind.picture[n.$content]);
              }
              const [k, H] = this._getOccurInfo(P);
              if (I)
                if (E = (0, C.searchNode)(this.root, b, I, !0, !1), E === null) {
                  if (E = (0, C.createDataNode)(this.data, b, I), !E)
                    continue;
                  this._isConsumeData() && (E[n.$consumed] = !0), this._setAndBind(P, E);
                  continue;
                } else
                  this._isConsumeData() && (E = E.filter((x) => !x[n.$consumed])), E.length > H ? E = E.slice(0, H) : E.length === 0 && (E = null), E && this._isConsumeData() && E.forEach((x) => {
                    x[n.$consumed] = !0;
                  });
              else {
                if (!P.name) {
                  this._setAndBind(P, b);
                  continue;
                }
                if (this._isConsumeData()) {
                  const x = [];
                  for (; x.length < H; ) {
                    const R = this._findDataByNameToConsume(P.name, P[n.$hasSettableValue](), b, d);
                    if (!R)
                      break;
                    R[n.$consumed] = !0, x.push(R);
                  }
                  E = x.length > 0 ? x : null;
                } else {
                  if (E = b[n.$getRealChildrenByNameIt](P.name, !1, this.emptyMerge).next().value, !E) {
                    if (k === 0) {
                      i.push(P);
                      continue;
                    }
                    const x = b[n.$namespaceId] === j ? -1 : b[n.$namespaceId];
                    E = P[n.$data] = new e.XmlObject(x, P.name), this.emptyMerge && (E[n.$consumed] = !0), b[n.$appendChild](E), this._setAndBind(P, E);
                    continue;
                  }
                  this.emptyMerge && (E[n.$consumed] = !0), E = [E];
                }
              }
              E ? this._bindOccurrences(P, E, A) : k > 0 ? this._setAndBind(P, b) : i.push(P);
            }
            i.forEach((P) => P[n.$getParent]()[n.$removeChild](P));
          }
        }
        w.Binder = O;
      },
      /* 80 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.Value = w.Text = w.TemplateNamespace = w.Template = w.SetProperty = w.Items = w.Field = w.BindItems = void 0;
        var n = V(78), F = V(81), C = V(82), e = V(83), t = V(87), l = V(84), j = V(2), U = V(85), O = V(3), v = V(88);
        const g = F.NamespaceIds.template.id, b = "http://www.w3.org/2000/svg", i = 2, P = 3, d = 5e3, A = /^H(\d+)$/, I = /* @__PURE__ */ new Set(["image/gif", "image/jpeg", "image/jpg", "image/pjpeg", "image/png", "image/apng", "image/x-png", "image/bmp", "image/x-ms-bmp", "image/tiff", "image/tif", "application/octet-stream"]), E = [[[66, 77], "image/bmp"], [[255, 216, 255], "image/jpeg"], [[73, 73, 42, 0], "image/tiff"], [[77, 77, 0, 42], "image/tiff"], [[71, 73, 70, 56, 57, 97], "image/gif"], [[137, 80, 78, 71, 13, 10, 26, 10], "image/png"]];
        function k(Ke) {
          if (!Ke || !Ke.border)
            return {
              w: 0,
              h: 0
            };
          const a = Ke.border[n.$getExtra]();
          return a ? {
            w: a.widths[0] + a.widths[2] + a.insets[0] + a.insets[2],
            h: a.widths[1] + a.widths[3] + a.insets[1] + a.insets[3]
          } : {
            w: 0,
            h: 0
          };
        }
        function H(Ke) {
          return Ke.margin && (Ke.margin.topInset || Ke.margin.rightInset || Ke.margin.bottomInset || Ke.margin.leftInset);
        }
        function x(Ke, a) {
          if (!Ke.value) {
            const ee = new gn({});
            Ke[n.$appendChild](ee), Ke.value = ee;
          }
          Ke.value[n.$setValue](a);
        }
        function* R(Ke) {
          for (const a of Ke[n.$getChildren]()) {
            if (a instanceof Tn) {
              yield* a[n.$getContainedChildren]();
              continue;
            }
            yield a;
          }
        }
        function f(Ke) {
          var a;
          return ((a = Ke.validate) == null ? void 0 : a.nullTest) === "error";
        }
        function c(Ke) {
          for (; Ke; ) {
            if (!Ke.traversal) {
              Ke[n.$tabIndex] = Ke[n.$getParent]()[n.$tabIndex];
              return;
            }
            if (Ke[n.$tabIndex])
              return;
            let a = null;
            for (const Ze of Ke.traversal[n.$getChildren]())
              if (Ze.operation === "next") {
                a = Ze;
                break;
              }
            if (!a || !a.ref) {
              Ke[n.$tabIndex] = Ke[n.$getParent]()[n.$tabIndex];
              return;
            }
            const ee = Ke[n.$getTemplateRoot]();
            Ke[n.$tabIndex] = ++ee[n.$tabIndex];
            const He = ee[n.$searchNode](a.ref, Ke);
            if (!He)
              return;
            Ke = He[0];
          }
        }
        function N(Ke, a) {
          var He;
          const ee = Ke.assist;
          if (ee) {
            const Ze = ee[n.$toHTML]();
            Ze && (a.title = Ze);
            const dt = ee.role.match(A);
            if (dt) {
              const xt = "heading", yt = dt[1];
              a.role = xt, a["aria-level"] = yt;
            }
          }
          if (Ke.layout === "table")
            a.role = "table";
          else if (Ke.layout === "row")
            a.role = "row";
          else {
            const Ze = Ke[n.$getParent]();
            Ze.layout === "row" && (a.role = ((He = Ze.assist) == null ? void 0 : He.role) === "TH" ? "columnheader" : "cell");
          }
        }
        function u(Ke) {
          if (!Ke.assist)
            return null;
          const a = Ke.assist;
          return a.speak && a.speak[n.$content] !== "" ? a.speak[n.$content] : a.toolTip ? a.toolTip[n.$content] : null;
        }
        function p(Ke) {
          return l.HTMLResult.success({
            name: "div",
            attributes: {
              class: ["xfaRich"],
              style: /* @__PURE__ */ Object.create(null)
            },
            children: [{
              name: "span",
              attributes: {
                style: /* @__PURE__ */ Object.create(null)
              },
              value: Ke
            }]
          });
        }
        function S(Ke) {
          const a = Ke[n.$getTemplateRoot]();
          a[n.$extra].firstUnsplittable === null && (a[n.$extra].firstUnsplittable = Ke, a[n.$extra].noLayoutFailure = !0);
        }
        function B(Ke) {
          const a = Ke[n.$getTemplateRoot]();
          a[n.$extra].firstUnsplittable === Ke && (a[n.$extra].noLayoutFailure = !1);
        }
        function T(Ke) {
          if (Ke[n.$extra] || (Ke[n.$extra] = /* @__PURE__ */ Object.create(null), Ke.targetType === "auto"))
            return !1;
          const a = Ke[n.$getTemplateRoot]();
          let ee = null;
          if (Ke.target) {
            if (ee = a[n.$searchNode](Ke.target, Ke[n.$getParent]()), !ee)
              return !1;
            ee = ee[0];
          }
          const {
            currentPageArea: He,
            currentContentArea: Ze
          } = a[n.$extra];
          if (Ke.targetType === "pageArea")
            return ee instanceof At || (ee = null), Ke.startNew ? (Ke[n.$extra].target = ee || He, !0) : ee && ee !== He ? (Ke[n.$extra].target = ee, !0) : !1;
          ee instanceof ie || (ee = null);
          const it = ee && ee[n.$getParent]();
          let dt, xt = it;
          if (Ke.startNew)
            if (ee) {
              const yt = it.contentArea.children, It = yt.indexOf(Ze), Rt = yt.indexOf(ee);
              It !== -1 && It < Rt && (xt = null), dt = Rt - 1;
            } else
              dt = He.contentArea.children.indexOf(Ze);
          else if (ee && ee !== Ze)
            dt = it.contentArea.children.indexOf(ee) - 1, xt = it === He ? null : it;
          else
            return !1;
          return Ke[n.$extra].target = xt, Ke[n.$extra].index = dt, !0;
        }
        function D(Ke, a, ee) {
          const He = Ke[n.$getTemplateRoot](), Ze = He[n.$extra].noLayoutFailure, it = a[n.$getSubformParent];
          a[n.$getSubformParent] = () => Ke, He[n.$extra].noLayoutFailure = !0;
          const dt = a[n.$toHTML](ee);
          Ke[n.$addHTML](dt.html, dt.bbox), He[n.$extra].noLayoutFailure = Ze, a[n.$getSubformParent] = it;
        }
        class K extends t.StringObject {
          constructor(a) {
            super(g, "appearanceFilter"), this.id = a.id || "", this.type = (0, l.getStringOption)(a.type, ["optional", "required"]), this.use = a.use || "", this.usehref = a.usehref || "";
          }
        }
        class _ extends t.XFAObject {
          constructor(a) {
            super(g, "arc", !0), this.circular = (0, l.getInteger)({
              data: a.circular,
              defaultValue: 0,
              validate: (ee) => ee === 1
            }), this.hand = (0, l.getStringOption)(a.hand, ["even", "left", "right"]), this.id = a.id || "", this.startAngle = (0, l.getFloat)({
              data: a.startAngle,
              defaultValue: 0,
              validate: (ee) => !0
            }), this.sweepAngle = (0, l.getFloat)({
              data: a.sweepAngle,
              defaultValue: 360,
              validate: (ee) => !0
            }), this.use = a.use || "", this.usehref = a.usehref || "", this.edge = null, this.fill = null;
          }
          [n.$toHTML]() {
            var yt;
            const a = this.edge || new me({}), ee = a[n.$toStyle](), He = /* @__PURE__ */ Object.create(null);
            ((yt = this.fill) == null ? void 0 : yt.presence) === "visible" ? Object.assign(He, this.fill[n.$toStyle]()) : He.fill = "transparent", He.strokeWidth = (0, e.measureToString)(a.presence === "visible" ? a.thickness : 0), He.stroke = ee.color;
            let Ze;
            const it = {
              xmlns: b,
              style: {
                width: "100%",
                height: "100%",
                overflow: "visible"
              }
            };
            if (this.sweepAngle === 360)
              Ze = {
                name: "ellipse",
                attributes: {
                  xmlns: b,
                  cx: "50%",
                  cy: "50%",
                  rx: "50%",
                  ry: "50%",
                  style: He
                }
              };
            else {
              const It = this.startAngle * Math.PI / 180, Rt = this.sweepAngle * Math.PI / 180, Bt = this.sweepAngle > 180 ? 1 : 0, [Nt, $t, Ht, Pt] = [50 * (1 + Math.cos(It)), 50 * (1 - Math.sin(It)), 50 * (1 + Math.cos(It + Rt)), 50 * (1 - Math.sin(It + Rt))];
              Ze = {
                name: "path",
                attributes: {
                  xmlns: b,
                  d: `M ${Nt} ${$t} A 50 50 0 ${Bt} 0 ${Ht} ${Pt}`,
                  vectorEffect: "non-scaling-stroke",
                  style: He
                }
              }, Object.assign(it, {
                viewBox: "0 0 100 100",
                preserveAspectRatio: "none"
              });
            }
            const dt = {
              name: "svg",
              children: [Ze],
              attributes: it
            }, xt = this[n.$getParent]()[n.$getParent]();
            return H(xt) ? l.HTMLResult.success({
              name: "div",
              attributes: {
                style: {
                  display: "inline",
                  width: "100%",
                  height: "100%"
                }
              },
              children: [dt]
            }) : (dt.attributes.style.position = "absolute", l.HTMLResult.success(dt));
          }
        }
        class o extends t.XFAObject {
          constructor(a) {
            super(g, "area", !0), this.colSpan = (0, l.getInteger)({
              data: a.colSpan,
              defaultValue: 1,
              validate: (ee) => ee >= 1 || ee === -1
            }), this.id = a.id || "", this.name = a.name || "", this.relevant = (0, l.getRelevant)(a.relevant), this.use = a.use || "", this.usehref = a.usehref || "", this.x = (0, l.getMeasurement)(a.x, "0pt"), this.y = (0, l.getMeasurement)(a.y, "0pt"), this.desc = null, this.extras = null, this.area = new t.XFAObjectArray(), this.draw = new t.XFAObjectArray(), this.exObject = new t.XFAObjectArray(), this.exclGroup = new t.XFAObjectArray(), this.field = new t.XFAObjectArray(), this.subform = new t.XFAObjectArray(), this.subformSet = new t.XFAObjectArray();
          }
          *[n.$getContainedChildren]() {
            yield* R(this);
          }
          [n.$isTransparent]() {
            return !0;
          }
          [n.$isBindable]() {
            return !0;
          }
          [n.$addHTML](a, ee) {
            const [He, Ze, it, dt] = ee;
            this[n.$extra].width = Math.max(this[n.$extra].width, He + it), this[n.$extra].height = Math.max(this[n.$extra].height, Ze + dt), this[n.$extra].children.push(a);
          }
          [n.$getAvailableSpace]() {
            return this[n.$extra].availableSpace;
          }
          [n.$toHTML](a) {
            const ee = (0, e.toStyle)(this, "position"), He = {
              style: ee,
              id: this[n.$uid],
              class: ["xfaArea"]
            };
            (0, e.isPrintOnly)(this) && He.class.push("xfaPrintOnly"), this.name && (He.xfaName = this.name);
            const Ze = [];
            this[n.$extra] = {
              children: Ze,
              width: 0,
              height: 0,
              availableSpace: a
            };
            const it = this[n.$childrenToHTML]({
              filter: /* @__PURE__ */ new Set(["area", "draw", "field", "exclGroup", "subform", "subformSet"]),
              include: !0
            });
            if (!it.success)
              return it.isBreak() ? it : (delete this[n.$extra], l.HTMLResult.FAILURE);
            ee.width = (0, e.measureToString)(this[n.$extra].width), ee.height = (0, e.measureToString)(this[n.$extra].height);
            const dt = {
              name: "div",
              attributes: He,
              children: Ze
            }, xt = [this.x, this.y, this[n.$extra].width, this[n.$extra].height];
            return delete this[n.$extra], l.HTMLResult.success(dt, xt);
          }
        }
        class m extends t.XFAObject {
          constructor(a) {
            super(g, "assist", !0), this.id = a.id || "", this.role = a.role || "", this.use = a.use || "", this.usehref = a.usehref || "", this.speak = null, this.toolTip = null;
          }
          [n.$toHTML]() {
            var a;
            return ((a = this.toolTip) == null ? void 0 : a[n.$content]) || null;
          }
        }
        class s extends t.XFAObject {
          constructor(a) {
            super(g, "barcode", !0), this.charEncoding = (0, l.getKeyword)({
              data: a.charEncoding ? a.charEncoding.toLowerCase() : "",
              defaultValue: "",
              validate: (ee) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(ee) || ee.match(/iso-8859-\d{2}/)
            }), this.checksum = (0, l.getStringOption)(a.checksum, ["none", "1mod10", "1mod10_1mod11", "2mod10", "auto"]), this.dataColumnCount = (0, l.getInteger)({
              data: a.dataColumnCount,
              defaultValue: -1,
              validate: (ee) => ee >= 0
            }), this.dataLength = (0, l.getInteger)({
              data: a.dataLength,
              defaultValue: -1,
              validate: (ee) => ee >= 0
            }), this.dataPrep = (0, l.getStringOption)(a.dataPrep, ["none", "flateCompress"]), this.dataRowCount = (0, l.getInteger)({
              data: a.dataRowCount,
              defaultValue: -1,
              validate: (ee) => ee >= 0
            }), this.endChar = a.endChar || "", this.errorCorrectionLevel = (0, l.getInteger)({
              data: a.errorCorrectionLevel,
              defaultValue: -1,
              validate: (ee) => ee >= 0 && ee <= 8
            }), this.id = a.id || "", this.moduleHeight = (0, l.getMeasurement)(a.moduleHeight, "5mm"), this.moduleWidth = (0, l.getMeasurement)(a.moduleWidth, "0.25mm"), this.printCheckDigit = (0, l.getInteger)({
              data: a.printCheckDigit,
              defaultValue: 0,
              validate: (ee) => ee === 1
            }), this.rowColumnRatio = (0, l.getRatio)(a.rowColumnRatio), this.startChar = a.startChar || "", this.textLocation = (0, l.getStringOption)(a.textLocation, ["below", "above", "aboveEmbedded", "belowEmbedded", "none"]), this.truncate = (0, l.getInteger)({
              data: a.truncate,
              defaultValue: 0,
              validate: (ee) => ee === 1
            }), this.type = (0, l.getStringOption)(a.type ? a.type.toLowerCase() : "", ["aztec", "codabar", "code2of5industrial", "code2of5interleaved", "code2of5matrix", "code2of5standard", "code3of9", "code3of9extended", "code11", "code49", "code93", "code128", "code128a", "code128b", "code128c", "code128sscc", "datamatrix", "ean8", "ean8add2", "ean8add5", "ean13", "ean13add2", "ean13add5", "ean13pwcd", "fim", "logmars", "maxicode", "msi", "pdf417", "pdf417macro", "plessey", "postauscust2", "postauscust3", "postausreplypaid", "postausstandard", "postukrm4scc", "postusdpbc", "postusimb", "postusstandard", "postus5zip", "qrcode", "rfid", "rss14", "rss14expanded", "rss14limited", "rss14stacked", "rss14stackedomni", "rss14truncated", "telepen", "ucc128", "ucc128random", "ucc128sscc", "upca", "upcaadd2", "upcaadd5", "upcapwcd", "upce", "upceadd2", "upceadd5", "upcean2", "upcean5", "upsmaxicode"]), this.upsMode = (0, l.getStringOption)(a.upsMode, ["usCarrier", "internationalCarrier", "secureSymbol", "standardSymbol"]), this.use = a.use || "", this.usehref = a.usehref || "", this.wideNarrowRatio = (0, l.getRatio)(a.wideNarrowRatio), this.encrypt = null, this.extras = null;
          }
        }
        class r extends t.XFAObject {
          constructor(a) {
            super(g, "bind", !0), this.match = (0, l.getStringOption)(a.match, ["once", "dataRef", "global", "none"]), this.ref = a.ref || "", this.picture = null;
          }
        }
        class y extends t.XFAObject {
          constructor(a) {
            super(g, "bindItems"), this.connection = a.connection || "", this.labelRef = a.labelRef || "", this.ref = a.ref || "", this.valueRef = a.valueRef || "";
          }
        }
        w.BindItems = y;
        class M extends t.XFAObject {
          constructor(a) {
            super(g, "bookend"), this.id = a.id || "", this.leader = a.leader || "", this.trailer = a.trailer || "", this.use = a.use || "", this.usehref = a.usehref || "";
          }
        }
        class $ extends t.Option01 {
          constructor(a) {
            super(g, "boolean"), this.id = a.id || "", this.name = a.name || "", this.use = a.use || "", this.usehref = a.usehref || "";
          }
          [n.$toHTML](a) {
            return p(this[n.$content] === 1 ? "1" : "0");
          }
        }
        class G extends t.XFAObject {
          constructor(a) {
            super(g, "border", !0), this.break = (0, l.getStringOption)(a.break, ["close", "open"]), this.hand = (0, l.getStringOption)(a.hand, ["even", "left", "right"]), this.id = a.id || "", this.presence = (0, l.getStringOption)(a.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = (0, l.getRelevant)(a.relevant), this.use = a.use || "", this.usehref = a.usehref || "", this.corner = new t.XFAObjectArray(4), this.edge = new t.XFAObjectArray(4), this.extras = null, this.fill = null, this.margin = null;
          }
          [n.$getExtra]() {
            if (!this[n.$extra]) {
              const a = this.edge.children.slice();
              if (a.length < 4) {
                const Ze = a.at(-1) || new me({});
                for (let it = a.length; it < 4; it++)
                  a.push(Ze);
              }
              const ee = a.map((Ze) => Ze.thickness), He = [0, 0, 0, 0];
              this.margin && (He[0] = this.margin.topInset, He[1] = this.margin.rightInset, He[2] = this.margin.bottomInset, He[3] = this.margin.leftInset), this[n.$extra] = {
                widths: ee,
                insets: He,
                edges: a
              };
            }
            return this[n.$extra];
          }
          [n.$toStyle]() {
            var Ze;
            const {
              edges: a
            } = this[n.$getExtra](), ee = a.map((it) => {
              const dt = it[n.$toStyle]();
              return dt.color || (dt.color = "#000000"), dt;
            }), He = /* @__PURE__ */ Object.create(null);
            if (this.margin && Object.assign(He, this.margin[n.$toStyle]()), ((Ze = this.fill) == null ? void 0 : Ze.presence) === "visible" && Object.assign(He, this.fill[n.$toStyle]()), this.corner.children.some((it) => it.radius !== 0)) {
              const it = this.corner.children.map((dt) => dt[n.$toStyle]());
              if (it.length === 2 || it.length === 3) {
                const dt = it.at(-1);
                for (let xt = it.length; xt < 4; xt++)
                  it.push(dt);
              }
              He.borderRadius = it.map((dt) => dt.radius).join(" ");
            }
            switch (this.presence) {
              case "invisible":
              case "hidden":
                He.borderStyle = "";
                break;
              case "inactive":
                He.borderStyle = "none";
                break;
              default:
                He.borderStyle = ee.map((it) => it.style).join(" ");
                break;
            }
            return He.borderWidth = ee.map((it) => it.width).join(" "), He.borderColor = ee.map((it) => it.color).join(" "), He;
          }
        }
        class ce extends t.XFAObject {
          constructor(a) {
            super(g, "break", !0), this.after = (0, l.getStringOption)(a.after, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]), this.afterTarget = a.afterTarget || "", this.before = (0, l.getStringOption)(a.before, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]), this.beforeTarget = a.beforeTarget || "", this.bookendLeader = a.bookendLeader || "", this.bookendTrailer = a.bookendTrailer || "", this.id = a.id || "", this.overflowLeader = a.overflowLeader || "", this.overflowTarget = a.overflowTarget || "", this.overflowTrailer = a.overflowTrailer || "", this.startNew = (0, l.getInteger)({
              data: a.startNew,
              defaultValue: 0,
              validate: (ee) => ee === 1
            }), this.use = a.use || "", this.usehref = a.usehref || "", this.extras = null;
          }
        }
        class q extends t.XFAObject {
          constructor(a) {
            super(g, "breakAfter", !0), this.id = a.id || "", this.leader = a.leader || "", this.startNew = (0, l.getInteger)({
              data: a.startNew,
              defaultValue: 0,
              validate: (ee) => ee === 1
            }), this.target = a.target || "", this.targetType = (0, l.getStringOption)(a.targetType, ["auto", "contentArea", "pageArea"]), this.trailer = a.trailer || "", this.use = a.use || "", this.usehref = a.usehref || "", this.script = null;
          }
        }
        class re extends t.XFAObject {
          constructor(a) {
            super(g, "breakBefore", !0), this.id = a.id || "", this.leader = a.leader || "", this.startNew = (0, l.getInteger)({
              data: a.startNew,
              defaultValue: 0,
              validate: (ee) => ee === 1
            }), this.target = a.target || "", this.targetType = (0, l.getStringOption)(a.targetType, ["auto", "contentArea", "pageArea"]), this.trailer = a.trailer || "", this.use = a.use || "", this.usehref = a.usehref || "", this.script = null;
          }
          [n.$toHTML](a) {
            return this[n.$extra] = {}, l.HTMLResult.FAILURE;
          }
        }
        class Z extends t.XFAObject {
          constructor(a) {
            super(g, "button", !0), this.highlight = (0, l.getStringOption)(a.highlight, ["inverted", "none", "outline", "push"]), this.id = a.id || "", this.use = a.use || "", this.usehref = a.usehref || "", this.extras = null;
          }
          [n.$toHTML](a) {
            const He = this[n.$getParent]()[n.$getParent](), Ze = {
              name: "button",
              attributes: {
                id: this[n.$uid],
                class: ["xfaButton"],
                style: {}
              },
              children: []
            };
            for (const it of He.event.children) {
              if (it.activity !== "click" || !it.script)
                continue;
              const dt = (0, O.recoverJsURL)(it.script[n.$content]);
              if (!dt)
                continue;
              const xt = (0, e.fixURL)(dt.url);
              xt && Ze.children.push({
                name: "a",
                attributes: {
                  id: "link" + this[n.$uid],
                  href: xt,
                  newWindow: dt.newWindow,
                  class: ["xfaLink"],
                  style: {}
                },
                children: []
              });
            }
            return l.HTMLResult.success(Ze);
          }
        }
        class te extends t.XFAObject {
          constructor(a) {
            super(g, "calculate", !0), this.id = a.id || "", this.override = (0, l.getStringOption)(a.override, ["disabled", "error", "ignore", "warning"]), this.use = a.use || "", this.usehref = a.usehref || "", this.extras = null, this.message = null, this.script = null;
          }
        }
        class L extends t.XFAObject {
          constructor(a) {
            super(g, "caption", !0), this.id = a.id || "", this.placement = (0, l.getStringOption)(a.placement, ["left", "bottom", "inline", "right", "top"]), this.presence = (0, l.getStringOption)(a.presence, ["visible", "hidden", "inactive", "invisible"]), this.reserve = Math.ceil((0, l.getMeasurement)(a.reserve)), this.use = a.use || "", this.usehref = a.usehref || "", this.extras = null, this.font = null, this.margin = null, this.para = null, this.value = null;
          }
          [n.$setValue](a) {
            x(this, a);
          }
          [n.$getExtra](a) {
            if (!this[n.$extra]) {
              let {
                width: ee,
                height: He
              } = a;
              switch (this.placement) {
                case "left":
                case "right":
                case "inline":
                  ee = this.reserve <= 0 ? ee : this.reserve;
                  break;
                case "top":
                case "bottom":
                  He = this.reserve <= 0 ? He : this.reserve;
                  break;
              }
              this[n.$extra] = (0, e.layoutNode)(this, {
                width: ee,
                height: He
              });
            }
            return this[n.$extra];
          }
          [n.$toHTML](a) {
            if (!this.value)
              return l.HTMLResult.EMPTY;
            this[n.$pushPara]();
            const ee = this.value[n.$toHTML](a).html;
            if (!ee)
              return this[n.$popPara](), l.HTMLResult.EMPTY;
            const He = this.reserve;
            if (this.reserve <= 0) {
              const {
                w: dt,
                h: xt
              } = this[n.$getExtra](a);
              switch (this.placement) {
                case "left":
                case "right":
                case "inline":
                  this.reserve = dt;
                  break;
                case "top":
                case "bottom":
                  this.reserve = xt;
                  break;
              }
            }
            const Ze = [];
            typeof ee == "string" ? Ze.push({
              name: "#text",
              value: ee
            }) : Ze.push(ee);
            const it = (0, e.toStyle)(this, "font", "margin", "visibility");
            switch (this.placement) {
              case "left":
              case "right":
                this.reserve > 0 && (it.width = (0, e.measureToString)(this.reserve));
                break;
              case "top":
              case "bottom":
                this.reserve > 0 && (it.height = (0, e.measureToString)(this.reserve));
                break;
            }
            return (0, e.setPara)(this, null, ee), this[n.$popPara](), this.reserve = He, l.HTMLResult.success({
              name: "div",
              attributes: {
                style: it,
                class: ["xfaCaption"]
              },
              children: Ze
            });
          }
        }
        class X extends t.StringObject {
          constructor(a) {
            super(g, "certificate"), this.id = a.id || "", this.name = a.name || "", this.use = a.use || "", this.usehref = a.usehref || "";
          }
        }
        class J extends t.XFAObject {
          constructor(a) {
            super(g, "certificates", !0), this.credentialServerPolicy = (0, l.getStringOption)(a.credentialServerPolicy, ["optional", "required"]), this.id = a.id || "", this.url = a.url || "", this.urlPolicy = a.urlPolicy || "", this.use = a.use || "", this.usehref = a.usehref || "", this.encryption = null, this.issuers = null, this.keyUsage = null, this.oids = null, this.signing = null, this.subjectDNs = null;
          }
        }
        class Y extends t.XFAObject {
          constructor(a) {
            super(g, "checkButton", !0), this.id = a.id || "", this.mark = (0, l.getStringOption)(a.mark, ["default", "check", "circle", "cross", "diamond", "square", "star"]), this.shape = (0, l.getStringOption)(a.shape, ["square", "round"]), this.size = (0, l.getMeasurement)(a.size, "10pt"), this.use = a.use || "", this.usehref = a.usehref || "", this.border = null, this.extras = null, this.margin = null;
          }
          [n.$toHTML](a) {
            var zt, Ut, Kt;
            const ee = (0, e.toStyle)("margin"), He = (0, e.measureToString)(this.size);
            ee.width = ee.height = He;
            let Ze, it, dt;
            const xt = this[n.$getParent]()[n.$getParent](), yt = xt.items.children.length && xt.items.children[0][n.$toHTML]().html || [], It = {
              on: (yt[0] !== void 0 ? yt[0] : "on").toString(),
              off: (yt[1] !== void 0 ? yt[1] : "off").toString()
            }, Bt = (((zt = xt.value) == null ? void 0 : zt[n.$text]()) || "off") === It.on || void 0, Nt = xt[n.$getSubformParent](), $t = xt[n.$uid];
            let Ht;
            Nt instanceof $e ? (dt = Nt[n.$uid], Ze = "radio", it = "xfaRadio", Ht = ((Ut = Nt[n.$data]) == null ? void 0 : Ut[n.$uid]) || Nt[n.$uid]) : (Ze = "checkbox", it = "xfaCheckbox", Ht = ((Kt = xt[n.$data]) == null ? void 0 : Kt[n.$uid]) || xt[n.$uid]);
            const Pt = {
              name: "input",
              attributes: {
                class: [it],
                style: ee,
                fieldId: $t,
                dataId: Ht,
                type: Ze,
                checked: Bt,
                xfaOn: It.on,
                xfaOff: It.off,
                "aria-label": u(xt),
                "aria-required": !1
              }
            };
            return dt && (Pt.attributes.name = dt), f(xt) && (Pt.attributes["aria-required"] = !0, Pt.attributes.required = !0), l.HTMLResult.success({
              name: "label",
              attributes: {
                class: ["xfaLabel"]
              },
              children: [Pt]
            });
          }
        }
        class ae extends t.XFAObject {
          constructor(a) {
            super(g, "choiceList", !0), this.commitOn = (0, l.getStringOption)(a.commitOn, ["select", "exit"]), this.id = a.id || "", this.open = (0, l.getStringOption)(a.open, ["userControl", "always", "multiSelect", "onEntry"]), this.textEntry = (0, l.getInteger)({
              data: a.textEntry,
              defaultValue: 0,
              validate: (ee) => ee === 1
            }), this.use = a.use || "", this.usehref = a.usehref || "", this.border = null, this.extras = null, this.margin = null;
          }
          [n.$toHTML](a) {
            var It, Rt, Bt;
            const ee = (0, e.toStyle)(this, "border", "margin"), Ze = this[n.$getParent]()[n.$getParent](), dt = {
              fontSize: `calc(${((It = Ze.font) == null ? void 0 : It.size) || 10}px * var(--scale-factor))`
            }, xt = [];
            if (Ze.items.children.length > 0) {
              const Nt = Ze.items;
              let $t = 0, Ht = 0;
              Nt.children.length === 2 && ($t = Nt.children[0].save, Ht = 1 - $t);
              const Pt = Nt.children[$t][n.$toHTML]().html, zt = Nt.children[Ht][n.$toHTML]().html;
              let Ut = !1;
              const Kt = ((Rt = Ze.value) == null ? void 0 : Rt[n.$text]()) || "";
              for (let Gt = 0, Dt = Pt.length; Gt < Dt; Gt++) {
                const wt = {
                  name: "option",
                  attributes: {
                    value: zt[Gt] || Pt[Gt],
                    style: dt
                  },
                  value: Pt[Gt]
                };
                zt[Gt] === Kt && (wt.attributes.selected = Ut = !0), xt.push(wt);
              }
              Ut || xt.splice(0, 0, {
                name: "option",
                attributes: {
                  hidden: !0,
                  selected: !0
                },
                value: " "
              });
            }
            const yt = {
              class: ["xfaSelect"],
              fieldId: Ze[n.$uid],
              dataId: ((Bt = Ze[n.$data]) == null ? void 0 : Bt[n.$uid]) || Ze[n.$uid],
              style: ee,
              "aria-label": u(Ze),
              "aria-required": !1
            };
            return f(Ze) && (yt["aria-required"] = !0, yt.required = !0), this.open === "multiSelect" && (yt.multiple = !0), l.HTMLResult.success({
              name: "label",
              attributes: {
                class: ["xfaLabel"]
              },
              children: [{
                name: "select",
                children: xt,
                attributes: yt
              }]
            });
          }
        }
        class se extends t.XFAObject {
          constructor(a) {
            super(g, "color", !0), this.cSpace = (0, l.getStringOption)(a.cSpace, ["SRGB"]), this.id = a.id || "", this.use = a.use || "", this.usehref = a.usehref || "", this.value = a.value ? (0, l.getColor)(a.value) : "", this.extras = null;
          }
          [n.$hasSettableValue]() {
            return !1;
          }
          [n.$toStyle]() {
            return this.value ? j.Util.makeHexColor(this.value.r, this.value.g, this.value.b) : null;
          }
        }
        class Q extends t.XFAObject {
          constructor(a) {
            super(g, "comb"), this.id = a.id || "", this.numberOfCells = (0, l.getInteger)({
              data: a.numberOfCells,
              defaultValue: 0,
              validate: (ee) => ee >= 0
            }), this.use = a.use || "", this.usehref = a.usehref || "";
          }
        }
        class z extends t.XFAObject {
          constructor(a) {
            super(g, "connect", !0), this.connection = a.connection || "", this.id = a.id || "", this.ref = a.ref || "", this.usage = (0, l.getStringOption)(a.usage, ["exportAndImport", "exportOnly", "importOnly"]), this.use = a.use || "", this.usehref = a.usehref || "", this.picture = null;
          }
        }
        class ie extends t.XFAObject {
          constructor(a) {
            super(g, "contentArea", !0), this.h = (0, l.getMeasurement)(a.h), this.id = a.id || "", this.name = a.name || "", this.relevant = (0, l.getRelevant)(a.relevant), this.use = a.use || "", this.usehref = a.usehref || "", this.w = (0, l.getMeasurement)(a.w), this.x = (0, l.getMeasurement)(a.x, "0pt"), this.y = (0, l.getMeasurement)(a.y, "0pt"), this.desc = null, this.extras = null;
          }
          [n.$toHTML](a) {
            const ee = (0, e.measureToString)(this.x), He = (0, e.measureToString)(this.y), Ze = {
              left: ee,
              top: He,
              width: (0, e.measureToString)(this.w),
              height: (0, e.measureToString)(this.h)
            }, it = ["xfaContentarea"];
            return (0, e.isPrintOnly)(this) && it.push("xfaPrintOnly"), l.HTMLResult.success({
              name: "div",
              children: [],
              attributes: {
                style: Ze,
                class: it,
                id: this[n.$uid]
              }
            });
          }
        }
        class ne extends t.XFAObject {
          constructor(a) {
            super(g, "corner", !0), this.id = a.id || "", this.inverted = (0, l.getInteger)({
              data: a.inverted,
              defaultValue: 0,
              validate: (ee) => ee === 1
            }), this.join = (0, l.getStringOption)(a.join, ["square", "round"]), this.presence = (0, l.getStringOption)(a.presence, ["visible", "hidden", "inactive", "invisible"]), this.radius = (0, l.getMeasurement)(a.radius), this.stroke = (0, l.getStringOption)(a.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]), this.thickness = (0, l.getMeasurement)(a.thickness, "0.5pt"), this.use = a.use || "", this.usehref = a.usehref || "", this.color = null, this.extras = null;
          }
          [n.$toStyle]() {
            const a = (0, e.toStyle)(this, "visibility");
            return a.radius = (0, e.measureToString)(this.join === "square" ? 0 : this.radius), a;
          }
        }
        class W extends t.ContentObject {
          constructor(a) {
            super(g, "date"), this.id = a.id || "", this.name = a.name || "", this.use = a.use || "", this.usehref = a.usehref || "";
          }
          [n.$finalize]() {
            const a = this[n.$content].trim();
            this[n.$content] = a ? new Date(a) : null;
          }
          [n.$toHTML](a) {
            return p(this[n.$content] ? this[n.$content].toString() : "");
          }
        }
        class oe extends t.ContentObject {
          constructor(a) {
            super(g, "dateTime"), this.id = a.id || "", this.name = a.name || "", this.use = a.use || "", this.usehref = a.usehref || "";
          }
          [n.$finalize]() {
            const a = this[n.$content].trim();
            this[n.$content] = a ? new Date(a) : null;
          }
          [n.$toHTML](a) {
            return p(this[n.$content] ? this[n.$content].toString() : "");
          }
        }
        class ue extends t.XFAObject {
          constructor(a) {
            super(g, "dateTimeEdit", !0), this.hScrollPolicy = (0, l.getStringOption)(a.hScrollPolicy, ["auto", "off", "on"]), this.id = a.id || "", this.picker = (0, l.getStringOption)(a.picker, ["host", "none"]), this.use = a.use || "", this.usehref = a.usehref || "", this.border = null, this.comb = null, this.extras = null, this.margin = null;
          }
          [n.$toHTML](a) {
            var it;
            const ee = (0, e.toStyle)(this, "border", "font", "margin"), He = this[n.$getParent]()[n.$getParent](), Ze = {
              name: "input",
              attributes: {
                type: "text",
                fieldId: He[n.$uid],
                dataId: ((it = He[n.$data]) == null ? void 0 : it[n.$uid]) || He[n.$uid],
                class: ["xfaTextfield"],
                style: ee,
                "aria-label": u(He),
                "aria-required": !1
              }
            };
            return f(He) && (Ze.attributes["aria-required"] = !0, Ze.attributes.required = !0), l.HTMLResult.success({
              name: "label",
              attributes: {
                class: ["xfaLabel"]
              },
              children: [Ze]
            });
          }
        }
        class pe extends t.ContentObject {
          constructor(a) {
            super(g, "decimal"), this.fracDigits = (0, l.getInteger)({
              data: a.fracDigits,
              defaultValue: 2,
              validate: (ee) => !0
            }), this.id = a.id || "", this.leadDigits = (0, l.getInteger)({
              data: a.leadDigits,
              defaultValue: -1,
              validate: (ee) => !0
            }), this.name = a.name || "", this.use = a.use || "", this.usehref = a.usehref || "";
          }
          [n.$finalize]() {
            const a = parseFloat(this[n.$content].trim());
            this[n.$content] = isNaN(a) ? null : a;
          }
          [n.$toHTML](a) {
            return p(this[n.$content] !== null ? this[n.$content].toString() : "");
          }
        }
        class ve extends t.XFAObject {
          constructor(a) {
            super(g, "defaultUi", !0), this.id = a.id || "", this.use = a.use || "", this.usehref = a.usehref || "", this.extras = null;
          }
        }
        class Ce extends t.XFAObject {
          constructor(a) {
            super(g, "desc", !0), this.id = a.id || "", this.use = a.use || "", this.usehref = a.usehref || "", this.boolean = new t.XFAObjectArray(), this.date = new t.XFAObjectArray(), this.dateTime = new t.XFAObjectArray(), this.decimal = new t.XFAObjectArray(), this.exData = new t.XFAObjectArray(), this.float = new t.XFAObjectArray(), this.image = new t.XFAObjectArray(), this.integer = new t.XFAObjectArray(), this.text = new t.XFAObjectArray(), this.time = new t.XFAObjectArray();
          }
        }
        class Fe extends t.OptionObject {
          constructor(a) {
            super(g, "digestMethod", ["", "SHA1", "SHA256", "SHA512", "RIPEMD160"]), this.id = a.id || "", this.use = a.use || "", this.usehref = a.usehref || "";
          }
        }
        class Pe extends t.XFAObject {
          constructor(a) {
            super(g, "digestMethods", !0), this.id = a.id || "", this.type = (0, l.getStringOption)(a.type, ["optional", "required"]), this.use = a.use || "", this.usehref = a.usehref || "", this.digestMethod = new t.XFAObjectArray();
          }
        }
        class be extends t.XFAObject {
          constructor(a) {
            super(g, "draw", !0), this.anchorType = (0, l.getStringOption)(a.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = (0, l.getInteger)({
              data: a.colSpan,
              defaultValue: 1,
              validate: (ee) => ee >= 1 || ee === -1
            }), this.h = a.h ? (0, l.getMeasurement)(a.h) : "", this.hAlign = (0, l.getStringOption)(a.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = a.id || "", this.locale = a.locale || "", this.maxH = (0, l.getMeasurement)(a.maxH, "0pt"), this.maxW = (0, l.getMeasurement)(a.maxW, "0pt"), this.minH = (0, l.getMeasurement)(a.minH, "0pt"), this.minW = (0, l.getMeasurement)(a.minW, "0pt"), this.name = a.name || "", this.presence = (0, l.getStringOption)(a.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = (0, l.getRelevant)(a.relevant), this.rotate = (0, l.getInteger)({
              data: a.rotate,
              defaultValue: 0,
              validate: (ee) => ee % 90 === 0
            }), this.use = a.use || "", this.usehref = a.usehref || "", this.w = a.w ? (0, l.getMeasurement)(a.w) : "", this.x = (0, l.getMeasurement)(a.x, "0pt"), this.y = (0, l.getMeasurement)(a.y, "0pt"), this.assist = null, this.border = null, this.caption = null, this.desc = null, this.extras = null, this.font = null, this.keep = null, this.margin = null, this.para = null, this.traversal = null, this.ui = null, this.value = null, this.setProperty = new t.XFAObjectArray();
          }
          [n.$setValue](a) {
            x(this, a);
          }
          [n.$toHTML](a) {
            if (c(this), this.presence === "hidden" || this.presence === "inactive")
              return l.HTMLResult.EMPTY;
            (0, e.fixDimensions)(this), this[n.$pushPara]();
            const ee = this.w, He = this.h, {
              w: Ze,
              h: it,
              isBroken: dt
            } = (0, e.layoutNode)(this, a);
            if (Ze && this.w === "") {
              if (dt && this[n.$getSubformParent]()[n.$isThereMoreWidth]())
                return this[n.$popPara](), l.HTMLResult.FAILURE;
              this.w = Ze;
            }
            if (it && this.h === "" && (this.h = it), S(this), !(0, C.checkDimensions)(this, a))
              return this.w = ee, this.h = He, this[n.$popPara](), l.HTMLResult.FAILURE;
            B(this);
            const xt = (0, e.toStyle)(this, "font", "hAlign", "dimensions", "position", "presence", "rotate", "anchorType", "border", "margin");
            (0, e.setMinMaxDimensions)(this, xt), xt.margin && (xt.padding = xt.margin, delete xt.margin);
            const yt = ["xfaDraw"];
            this.font && yt.push("xfaFont"), (0, e.isPrintOnly)(this) && yt.push("xfaPrintOnly");
            const It = {
              style: xt,
              id: this[n.$uid],
              class: yt
            };
            this.name && (It.xfaName = this.name);
            const Rt = {
              name: "div",
              attributes: It,
              children: []
            };
            N(this, It);
            const Bt = (0, e.computeBbox)(this, Rt, a), Nt = this.value ? this.value[n.$toHTML](a).html : null;
            return Nt === null ? (this.w = ee, this.h = He, this[n.$popPara](), l.HTMLResult.success((0, e.createWrapper)(this, Rt), Bt)) : (Rt.children.push(Nt), (0, e.setPara)(this, xt, Nt), this.w = ee, this.h = He, this[n.$popPara](), l.HTMLResult.success((0, e.createWrapper)(this, Rt), Bt));
          }
        }
        class me extends t.XFAObject {
          constructor(a) {
            super(g, "edge", !0), this.cap = (0, l.getStringOption)(a.cap, ["square", "butt", "round"]), this.id = a.id || "", this.presence = (0, l.getStringOption)(a.presence, ["visible", "hidden", "inactive", "invisible"]), this.stroke = (0, l.getStringOption)(a.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]), this.thickness = (0, l.getMeasurement)(a.thickness, "0.5pt"), this.use = a.use || "", this.usehref = a.usehref || "", this.color = null, this.extras = null;
          }
          [n.$toStyle]() {
            const a = (0, e.toStyle)(this, "visibility");
            if (Object.assign(a, {
              linecap: this.cap,
              width: (0, e.measureToString)(this.thickness),
              color: this.color ? this.color[n.$toStyle]() : "#000000",
              style: ""
            }), this.presence !== "visible")
              a.style = "none";
            else
              switch (this.stroke) {
                case "solid":
                  a.style = "solid";
                  break;
                case "dashDot":
                  a.style = "dashed";
                  break;
                case "dashDotDot":
                  a.style = "dashed";
                  break;
                case "dashed":
                  a.style = "dashed";
                  break;
                case "dotted":
                  a.style = "dotted";
                  break;
                case "embossed":
                  a.style = "ridge";
                  break;
                case "etched":
                  a.style = "groove";
                  break;
                case "lowered":
                  a.style = "inset";
                  break;
                case "raised":
                  a.style = "outset";
                  break;
              }
            return a;
          }
        }
        class we extends t.OptionObject {
          constructor(a) {
            super(g, "encoding", ["adbe.x509.rsa_sha1", "adbe.pkcs7.detached", "adbe.pkcs7.sha1"]), this.id = a.id || "", this.use = a.use || "", this.usehref = a.usehref || "";
          }
        }
        class _e extends t.XFAObject {
          constructor(a) {
            super(g, "encodings", !0), this.id = a.id || "", this.type = (0, l.getStringOption)(a.type, ["optional", "required"]), this.use = a.use || "", this.usehref = a.usehref || "", this.encoding = new t.XFAObjectArray();
          }
        }
        class Se extends t.XFAObject {
          constructor(a) {
            super(g, "encrypt", !0), this.id = a.id || "", this.use = a.use || "", this.usehref = a.usehref || "", this.certificate = null;
          }
        }
        class Ae extends t.XFAObject {
          constructor(a) {
            super(g, "encryptData", !0), this.id = a.id || "", this.operation = (0, l.getStringOption)(a.operation, ["encrypt", "decrypt"]), this.target = a.target || "", this.use = a.use || "", this.usehref = a.usehref || "", this.filter = null, this.manifest = null;
          }
        }
        class Te extends t.XFAObject {
          constructor(a) {
            super(g, "encryption", !0), this.id = a.id || "", this.type = (0, l.getStringOption)(a.type, ["optional", "required"]), this.use = a.use || "", this.usehref = a.usehref || "", this.certificate = new t.XFAObjectArray();
          }
        }
        class ke extends t.OptionObject {
          constructor(a) {
            super(g, "encryptionMethod", ["", "AES256-CBC", "TRIPLEDES-CBC", "AES128-CBC", "AES192-CBC"]), this.id = a.id || "", this.use = a.use || "", this.usehref = a.usehref || "";
          }
        }
        class Ee extends t.XFAObject {
          constructor(a) {
            super(g, "encryptionMethods", !0), this.id = a.id || "", this.type = (0, l.getStringOption)(a.type, ["optional", "required"]), this.use = a.use || "", this.usehref = a.usehref || "", this.encryptionMethod = new t.XFAObjectArray();
          }
        }
        class Ve extends t.XFAObject {
          constructor(a) {
            super(g, "event", !0), this.activity = (0, l.getStringOption)(a.activity, ["click", "change", "docClose", "docReady", "enter", "exit", "full", "indexChange", "initialize", "mouseDown", "mouseEnter", "mouseExit", "mouseUp", "postExecute", "postOpen", "postPrint", "postSave", "postSign", "postSubmit", "preExecute", "preOpen", "prePrint", "preSave", "preSign", "preSubmit", "ready", "validationState"]), this.id = a.id || "", this.listen = (0, l.getStringOption)(a.listen, ["refOnly", "refAndDescendents"]), this.name = a.name || "", this.ref = a.ref || "", this.use = a.use || "", this.usehref = a.usehref || "", this.extras = null, this.encryptData = null, this.execute = null, this.script = null, this.signData = null, this.submit = null;
          }
        }
        class je extends t.ContentObject {
          constructor(a) {
            super(g, "exData"), this.contentType = a.contentType || "", this.href = a.href || "", this.id = a.id || "", this.maxLength = (0, l.getInteger)({
              data: a.maxLength,
              defaultValue: -1,
              validate: (ee) => ee >= -1
            }), this.name = a.name || "", this.rid = a.rid || "", this.transferEncoding = (0, l.getStringOption)(a.transferEncoding, ["none", "base64", "package"]), this.use = a.use || "", this.usehref = a.usehref || "";
          }
          [n.$isCDATAXml]() {
            return this.contentType === "text/html";
          }
          [n.$onChild](a) {
            return this.contentType === "text/html" && a[n.$namespaceId] === F.NamespaceIds.xhtml.id ? (this[n.$content] = a, !0) : this.contentType === "text/xml" ? (this[n.$content] = a, !0) : !1;
          }
          [n.$toHTML](a) {
            return this.contentType !== "text/html" || !this[n.$content] ? l.HTMLResult.EMPTY : this[n.$content][n.$toHTML](a);
          }
        }
        class at extends t.XFAObject {
          constructor(a) {
            super(g, "exObject", !0), this.archive = a.archive || "", this.classId = a.classId || "", this.codeBase = a.codeBase || "", this.codeType = a.codeType || "", this.id = a.id || "", this.name = a.name || "", this.use = a.use || "", this.usehref = a.usehref || "", this.extras = null, this.boolean = new t.XFAObjectArray(), this.date = new t.XFAObjectArray(), this.dateTime = new t.XFAObjectArray(), this.decimal = new t.XFAObjectArray(), this.exData = new t.XFAObjectArray(), this.exObject = new t.XFAObjectArray(), this.float = new t.XFAObjectArray(), this.image = new t.XFAObjectArray(), this.integer = new t.XFAObjectArray(), this.text = new t.XFAObjectArray(), this.time = new t.XFAObjectArray();
          }
        }
        class $e extends t.XFAObject {
          constructor(a) {
            super(g, "exclGroup", !0), this.access = (0, l.getStringOption)(a.access, ["open", "nonInteractive", "protected", "readOnly"]), this.accessKey = a.accessKey || "", this.anchorType = (0, l.getStringOption)(a.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = (0, l.getInteger)({
              data: a.colSpan,
              defaultValue: 1,
              validate: (ee) => ee >= 1 || ee === -1
            }), this.h = a.h ? (0, l.getMeasurement)(a.h) : "", this.hAlign = (0, l.getStringOption)(a.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = a.id || "", this.layout = (0, l.getStringOption)(a.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]), this.maxH = (0, l.getMeasurement)(a.maxH, "0pt"), this.maxW = (0, l.getMeasurement)(a.maxW, "0pt"), this.minH = (0, l.getMeasurement)(a.minH, "0pt"), this.minW = (0, l.getMeasurement)(a.minW, "0pt"), this.name = a.name || "", this.presence = (0, l.getStringOption)(a.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = (0, l.getRelevant)(a.relevant), this.use = a.use || "", this.usehref = a.usehref || "", this.w = a.w ? (0, l.getMeasurement)(a.w) : "", this.x = (0, l.getMeasurement)(a.x, "0pt"), this.y = (0, l.getMeasurement)(a.y, "0pt"), this.assist = null, this.bind = null, this.border = null, this.calculate = null, this.caption = null, this.desc = null, this.extras = null, this.margin = null, this.para = null, this.traversal = null, this.validate = null, this.connect = new t.XFAObjectArray(), this.event = new t.XFAObjectArray(), this.field = new t.XFAObjectArray(), this.setProperty = new t.XFAObjectArray();
          }
          [n.$isBindable]() {
            return !0;
          }
          [n.$hasSettableValue]() {
            return !0;
          }
          [n.$setValue](a) {
            for (const ee of this.field.children) {
              if (!ee.value) {
                const He = new gn({});
                ee[n.$appendChild](He), ee.value = He;
              }
              ee.value[n.$setValue](a);
            }
          }
          [n.$isThereMoreWidth]() {
            return this.layout.endsWith("-tb") && this[n.$extra].attempt === 0 && this[n.$extra].numberInLine > 0 || this[n.$getParent]()[n.$isThereMoreWidth]();
          }
          [n.$isSplittable]() {
            var ee;
            const a = this[n.$getSubformParent]();
            return a[n.$isSplittable]() ? this[n.$extra]._isSplittable !== void 0 ? this[n.$extra]._isSplittable : this.layout === "position" || this.layout.includes("row") ? (this[n.$extra]._isSplittable = !1, !1) : (ee = a.layout) != null && ee.endsWith("-tb") && a[n.$extra].numberInLine !== 0 ? !1 : (this[n.$extra]._isSplittable = !0, !0) : !1;
          }
          [n.$flushHTML]() {
            return (0, C.flushHTML)(this);
          }
          [n.$addHTML](a, ee) {
            (0, C.addHTML)(this, a, ee);
          }
          [n.$getAvailableSpace]() {
            return (0, C.getAvailableSpace)(this);
          }
          [n.$toHTML](a) {
            if (c(this), this.presence === "hidden" || this.presence === "inactive" || this.h === 0 || this.w === 0)
              return l.HTMLResult.EMPTY;
            (0, e.fixDimensions)(this);
            const ee = [], He = {
              id: this[n.$uid],
              class: []
            };
            (0, e.setAccess)(this, He.class), this[n.$extra] || (this[n.$extra] = /* @__PURE__ */ Object.create(null)), Object.assign(this[n.$extra], {
              children: ee,
              attributes: He,
              attempt: 0,
              line: null,
              numberInLine: 0,
              availableSpace: {
                width: Math.min(this.w || 1 / 0, a.width),
                height: Math.min(this.h || 1 / 0, a.height)
              },
              width: 0,
              height: 0,
              prevHeight: 0,
              currentWidth: 0
            });
            const Ze = this[n.$isSplittable]();
            if (Ze || S(this), !(0, C.checkDimensions)(this, a))
              return l.HTMLResult.FAILURE;
            const it = /* @__PURE__ */ new Set(["field"]);
            if (this.layout.includes("row")) {
              const Ut = this[n.$getSubformParent]().columnWidths;
              Array.isArray(Ut) && Ut.length > 0 && (this[n.$extra].columnWidths = Ut, this[n.$extra].currentColumn = 0);
            }
            const dt = (0, e.toStyle)(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), xt = ["xfaExclgroup"], yt = (0, e.layoutClass)(this);
            yt && xt.push(yt), (0, e.isPrintOnly)(this) && xt.push("xfaPrintOnly"), He.style = dt, He.class = xt, this.name && (He.xfaName = this.name), this[n.$pushPara]();
            const It = this.layout === "lr-tb" || this.layout === "rl-tb", Rt = It ? i : 1;
            for (; this[n.$extra].attempt < Rt; this[n.$extra].attempt++) {
              It && this[n.$extra].attempt === i - 1 && (this[n.$extra].numberInLine = 0);
              const Ut = this[n.$childrenToHTML]({
                filter: it,
                include: !0
              });
              if (Ut.success)
                break;
              if (Ut.isBreak())
                return this[n.$popPara](), Ut;
              if (It && this[n.$extra].attempt === 0 && this[n.$extra].numberInLine === 0 && !this[n.$getTemplateRoot]()[n.$extra].noLayoutFailure) {
                this[n.$extra].attempt = Rt;
                break;
              }
            }
            if (this[n.$popPara](), Ze || B(this), this[n.$extra].attempt === Rt)
              return Ze || delete this[n.$extra], l.HTMLResult.FAILURE;
            let Bt = 0, Nt = 0;
            this.margin && (Bt = this.margin.leftInset + this.margin.rightInset, Nt = this.margin.topInset + this.margin.bottomInset);
            const $t = Math.max(this[n.$extra].width + Bt, this.w || 0), Ht = Math.max(this[n.$extra].height + Nt, this.h || 0), Pt = [this.x, this.y, $t, Ht];
            this.w === "" && (dt.width = (0, e.measureToString)($t)), this.h === "" && (dt.height = (0, e.measureToString)(Ht));
            const zt = {
              name: "div",
              attributes: He,
              children: ee
            };
            return N(this, He), delete this[n.$extra], l.HTMLResult.success((0, e.createWrapper)(this, zt), Pt);
          }
        }
        class ct extends t.XFAObject {
          constructor(a) {
            super(g, "execute"), this.connection = a.connection || "", this.executeType = (0, l.getStringOption)(a.executeType, ["import", "remerge"]), this.id = a.id || "", this.runAt = (0, l.getStringOption)(a.runAt, ["client", "both", "server"]), this.use = a.use || "", this.usehref = a.usehref || "";
          }
        }
        class ze extends t.XFAObject {
          constructor(a) {
            super(g, "extras", !0), this.id = a.id || "", this.name = a.name || "", this.use = a.use || "", this.usehref = a.usehref || "", this.boolean = new t.XFAObjectArray(), this.date = new t.XFAObjectArray(), this.dateTime = new t.XFAObjectArray(), this.decimal = new t.XFAObjectArray(), this.exData = new t.XFAObjectArray(), this.extras = new t.XFAObjectArray(), this.float = new t.XFAObjectArray(), this.image = new t.XFAObjectArray(), this.integer = new t.XFAObjectArray(), this.text = new t.XFAObjectArray(), this.time = new t.XFAObjectArray();
          }
        }
        class Ye extends t.XFAObject {
          constructor(a) {
            super(g, "field", !0), this.access = (0, l.getStringOption)(a.access, ["open", "nonInteractive", "protected", "readOnly"]), this.accessKey = a.accessKey || "", this.anchorType = (0, l.getStringOption)(a.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = (0, l.getInteger)({
              data: a.colSpan,
              defaultValue: 1,
              validate: (ee) => ee >= 1 || ee === -1
            }), this.h = a.h ? (0, l.getMeasurement)(a.h) : "", this.hAlign = (0, l.getStringOption)(a.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = a.id || "", this.locale = a.locale || "", this.maxH = (0, l.getMeasurement)(a.maxH, "0pt"), this.maxW = (0, l.getMeasurement)(a.maxW, "0pt"), this.minH = (0, l.getMeasurement)(a.minH, "0pt"), this.minW = (0, l.getMeasurement)(a.minW, "0pt"), this.name = a.name || "", this.presence = (0, l.getStringOption)(a.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = (0, l.getRelevant)(a.relevant), this.rotate = (0, l.getInteger)({
              data: a.rotate,
              defaultValue: 0,
              validate: (ee) => ee % 90 === 0
            }), this.use = a.use || "", this.usehref = a.usehref || "", this.w = a.w ? (0, l.getMeasurement)(a.w) : "", this.x = (0, l.getMeasurement)(a.x, "0pt"), this.y = (0, l.getMeasurement)(a.y, "0pt"), this.assist = null, this.bind = null, this.border = null, this.calculate = null, this.caption = null, this.desc = null, this.extras = null, this.font = null, this.format = null, this.items = new t.XFAObjectArray(2), this.keep = null, this.margin = null, this.para = null, this.traversal = null, this.ui = null, this.validate = null, this.value = null, this.bindItems = new t.XFAObjectArray(), this.connect = new t.XFAObjectArray(), this.event = new t.XFAObjectArray(), this.setProperty = new t.XFAObjectArray();
          }
          [n.$isBindable]() {
            return !0;
          }
          [n.$setValue](a) {
            x(this, a);
          }
          [n.$toHTML](a) {
            var Ut, Kt, Gt;
            if (c(this), !this.ui) {
              this.ui = new In({}), this.ui[n.$globalData] = this[n.$globalData], this[n.$appendChild](this.ui);
              let Dt;
              switch (this.items.children.length) {
                case 0:
                  Dt = new jn({}), this.ui.textEdit = Dt;
                  break;
                case 1:
                  Dt = new Y({}), this.ui.checkButton = Dt;
                  break;
                case 2:
                  Dt = new ae({}), this.ui.choiceList = Dt;
                  break;
              }
              this.ui[n.$appendChild](Dt);
            }
            if (!this.ui || this.presence === "hidden" || this.presence === "inactive" || this.h === 0 || this.w === 0)
              return l.HTMLResult.EMPTY;
            this.caption && delete this.caption[n.$extra], this[n.$pushPara]();
            const ee = this.caption ? this.caption[n.$toHTML](a).html : null, He = this.w, Ze = this.h;
            let it = 0, dt = 0;
            this.margin && (it = this.margin.leftInset + this.margin.rightInset, dt = this.margin.topInset + this.margin.bottomInset);
            let xt = null;
            if (this.w === "" || this.h === "") {
              let Dt = null, wt = null, Qt = 0, Yt = 0;
              if (this.ui.checkButton)
                Qt = Yt = this.ui.checkButton.size;
              else {
                const {
                  w: hn,
                  h: nn
                } = (0, e.layoutNode)(this, a);
                hn !== null ? (Qt = hn, Yt = nn) : Yt = (0, U.getMetrics)(this.font, !0).lineNoGap;
              }
              if (xt = k(this.ui[n.$getExtra]()), Qt += xt.w, Yt += xt.h, this.caption) {
                const {
                  w: hn,
                  h: nn,
                  isBroken: Wt
                } = this.caption[n.$getExtra](a);
                if (Wt && this[n.$getSubformParent]()[n.$isThereMoreWidth]())
                  return this[n.$popPara](), l.HTMLResult.FAILURE;
                switch (Dt = hn, wt = nn, this.caption.placement) {
                  case "left":
                  case "right":
                  case "inline":
                    Dt += Qt;
                    break;
                  case "top":
                  case "bottom":
                    wt += Yt;
                    break;
                }
              } else
                Dt = Qt, wt = Yt;
              Dt && this.w === "" && (Dt += it, this.w = Math.min(this.maxW <= 0 ? 1 / 0 : this.maxW, this.minW + 1 < Dt ? Dt : this.minW)), wt && this.h === "" && (wt += dt, this.h = Math.min(this.maxH <= 0 ? 1 / 0 : this.maxH, this.minH + 1 < wt ? wt : this.minH));
            }
            if (this[n.$popPara](), (0, e.fixDimensions)(this), S(this), !(0, C.checkDimensions)(this, a))
              return this.w = He, this.h = Ze, this[n.$popPara](), l.HTMLResult.FAILURE;
            B(this);
            const yt = (0, e.toStyle)(this, "font", "dimensions", "position", "rotate", "anchorType", "presence", "margin", "hAlign");
            (0, e.setMinMaxDimensions)(this, yt);
            const It = ["xfaField"];
            this.font && It.push("xfaFont"), (0, e.isPrintOnly)(this) && It.push("xfaPrintOnly");
            const Rt = {
              style: yt,
              id: this[n.$uid],
              class: It
            };
            yt.margin && (yt.padding = yt.margin, delete yt.margin), (0, e.setAccess)(this, It), this.name && (Rt.xfaName = this.name);
            const Bt = [], Nt = {
              name: "div",
              attributes: Rt,
              children: Bt
            };
            N(this, Rt);
            const $t = this.border ? this.border[n.$toStyle]() : null, Ht = (0, e.computeBbox)(this, Nt, a), Pt = this.ui[n.$toHTML]().html;
            if (!Pt)
              return Object.assign(yt, $t), l.HTMLResult.success((0, e.createWrapper)(this, Nt), Ht);
            this[n.$tabIndex] && ((Ut = Pt.children) != null && Ut[0] ? Pt.children[0].attributes.tabindex = this[n.$tabIndex] : Pt.attributes.tabindex = this[n.$tabIndex]), Pt.attributes.style || (Pt.attributes.style = /* @__PURE__ */ Object.create(null));
            let zt = null;
            if (this.ui.button ? (Pt.children.length === 1 && ([zt] = Pt.children.splice(0, 1)), Object.assign(Pt.attributes.style, $t)) : Object.assign(yt, $t), Bt.push(Pt), this.value) {
              if (this.ui.imageEdit)
                Pt.children.push(this.value[n.$toHTML]().html);
              else if (!this.ui.button) {
                let Dt = "";
                if (this.value.exData)
                  Dt = this.value.exData[n.$text]();
                else if (this.value.text)
                  Dt = this.value.text[n.$getExtra]();
                else {
                  const wt = this.value[n.$toHTML]().html;
                  wt !== null && (Dt = wt.children[0].value);
                }
                this.ui.textEdit && ((Kt = this.value.text) != null && Kt.maxChars) && (Pt.children[0].attributes.maxLength = this.value.text.maxChars), Dt && (this.ui.numericEdit && (Dt = parseFloat(Dt), Dt = isNaN(Dt) ? "" : Dt.toString()), Pt.children[0].name === "textarea" ? Pt.children[0].attributes.textContent = Dt : Pt.children[0].attributes.value = Dt);
              }
            }
            if (!this.ui.imageEdit && ((Gt = Pt.children) != null && Gt[0]) && this.h) {
              xt = xt || k(this.ui[n.$getExtra]());
              let Dt = 0;
              if (this.caption && ["top", "bottom"].includes(this.caption.placement)) {
                Dt = this.caption.reserve, Dt <= 0 && (Dt = this.caption[n.$getExtra](a).h);
                const wt = this.h - Dt - dt - xt.h;
                Pt.children[0].attributes.style.height = (0, e.measureToString)(wt);
              } else
                Pt.children[0].attributes.style.height = "100%";
            }
            if (zt && Pt.children.push(zt), !ee)
              return Pt.attributes.class && Pt.attributes.class.push("xfaLeft"), this.w = He, this.h = Ze, l.HTMLResult.success((0, e.createWrapper)(this, Nt), Ht);
            if (this.ui.button)
              return yt.padding && delete yt.padding, ee.name === "div" && (ee.name = "span"), Pt.children.push(ee), l.HTMLResult.success(Nt, Ht);
            switch (this.ui.checkButton && (ee.attributes.class[0] = "xfaCaptionForCheckButton"), Pt.attributes.class || (Pt.attributes.class = []), Pt.children.splice(0, 0, ee), this.caption.placement) {
              case "left":
                Pt.attributes.class.push("xfaLeft");
                break;
              case "right":
                Pt.attributes.class.push("xfaRight");
                break;
              case "top":
                Pt.attributes.class.push("xfaTop");
                break;
              case "bottom":
                Pt.attributes.class.push("xfaBottom");
                break;
              case "inline":
                Pt.attributes.class.push("xfaLeft");
                break;
            }
            return this.w = He, this.h = Ze, l.HTMLResult.success((0, e.createWrapper)(this, Nt), Ht);
          }
        }
        w.Field = Ye;
        class Qe extends t.XFAObject {
          constructor(a) {
            super(g, "fill", !0), this.id = a.id || "", this.presence = (0, l.getStringOption)(a.presence, ["visible", "hidden", "inactive", "invisible"]), this.use = a.use || "", this.usehref = a.usehref || "", this.color = null, this.extras = null, this.linear = null, this.pattern = null, this.radial = null, this.solid = null, this.stipple = null;
          }
          [n.$toStyle]() {
            var xt;
            const a = this[n.$getParent](), He = a[n.$getParent]()[n.$getParent](), Ze = /* @__PURE__ */ Object.create(null);
            let it = "color", dt = it;
            a instanceof G && (it = "background-color", dt = "background", He instanceof In && (Ze.backgroundColor = "white")), (a instanceof Ft || a instanceof _) && (it = dt = "fill", Ze.fill = "white");
            for (const yt of Object.getOwnPropertyNames(this)) {
              if (yt === "extras" || yt === "color")
                continue;
              const It = this[yt];
              if (!(It instanceof t.XFAObject))
                continue;
              const Rt = It[n.$toStyle](this.color);
              return Rt && (Ze[Rt.startsWith("#") ? it : dt] = Rt), Ze;
            }
            if ((xt = this.color) != null && xt.value) {
              const yt = this.color[n.$toStyle]();
              Ze[yt.startsWith("#") ? it : dt] = yt;
            }
            return Ze;
          }
        }
        class Oe extends t.XFAObject {
          constructor(a) {
            super(g, "filter", !0), this.addRevocationInfo = (0, l.getStringOption)(a.addRevocationInfo, ["", "required", "optional", "none"]), this.id = a.id || "", this.name = a.name || "", this.use = a.use || "", this.usehref = a.usehref || "", this.version = (0, l.getInteger)({
              data: this.version,
              defaultValue: 5,
              validate: (ee) => ee >= 1 && ee <= 5
            }), this.appearanceFilter = null, this.certificates = null, this.digestMethods = null, this.encodings = null, this.encryptionMethods = null, this.handler = null, this.lockDocument = null, this.mdp = null, this.reasons = null, this.timeStamp = null;
          }
        }
        class he extends t.ContentObject {
          constructor(a) {
            super(g, "float"), this.id = a.id || "", this.name = a.name || "", this.use = a.use || "", this.usehref = a.usehref || "";
          }
          [n.$finalize]() {
            const a = parseFloat(this[n.$content].trim());
            this[n.$content] = isNaN(a) ? null : a;
          }
          [n.$toHTML](a) {
            return p(this[n.$content] !== null ? this[n.$content].toString() : "");
          }
        }
        class ye extends t.XFAObject {
          constructor(a) {
            super(g, "font", !0), this.baselineShift = (0, l.getMeasurement)(a.baselineShift), this.fontHorizontalScale = (0, l.getFloat)({
              data: a.fontHorizontalScale,
              defaultValue: 100,
              validate: (ee) => ee >= 0
            }), this.fontVerticalScale = (0, l.getFloat)({
              data: a.fontVerticalScale,
              defaultValue: 100,
              validate: (ee) => ee >= 0
            }), this.id = a.id || "", this.kerningMode = (0, l.getStringOption)(a.kerningMode, ["none", "pair"]), this.letterSpacing = (0, l.getMeasurement)(a.letterSpacing, "0"), this.lineThrough = (0, l.getInteger)({
              data: a.lineThrough,
              defaultValue: 0,
              validate: (ee) => ee === 1 || ee === 2
            }), this.lineThroughPeriod = (0, l.getStringOption)(a.lineThroughPeriod, ["all", "word"]), this.overline = (0, l.getInteger)({
              data: a.overline,
              defaultValue: 0,
              validate: (ee) => ee === 1 || ee === 2
            }), this.overlinePeriod = (0, l.getStringOption)(a.overlinePeriod, ["all", "word"]), this.posture = (0, l.getStringOption)(a.posture, ["normal", "italic"]), this.size = (0, l.getMeasurement)(a.size, "10pt"), this.typeface = a.typeface || "Courier", this.underline = (0, l.getInteger)({
              data: a.underline,
              defaultValue: 0,
              validate: (ee) => ee === 1 || ee === 2
            }), this.underlinePeriod = (0, l.getStringOption)(a.underlinePeriod, ["all", "word"]), this.use = a.use || "", this.usehref = a.usehref || "", this.weight = (0, l.getStringOption)(a.weight, ["normal", "bold"]), this.extras = null, this.fill = null;
          }
          [n.$clean](a) {
            super[n.$clean](a), this[n.$globalData].usedTypefaces.add(this.typeface);
          }
          [n.$toStyle]() {
            const a = (0, e.toStyle)(this, "fill"), ee = a.color;
            return ee && (ee === "#000000" ? delete a.color : ee.startsWith("#") || (a.background = ee, a.backgroundClip = "text", a.color = "transparent")), this.baselineShift && (a.verticalAlign = (0, e.measureToString)(this.baselineShift)), a.fontKerning = this.kerningMode === "none" ? "none" : "normal", a.letterSpacing = (0, e.measureToString)(this.letterSpacing), this.lineThrough !== 0 && (a.textDecoration = "line-through", this.lineThrough === 2 && (a.textDecorationStyle = "double")), this.overline !== 0 && (a.textDecoration = "overline", this.overline === 2 && (a.textDecorationStyle = "double")), a.fontStyle = this.posture, a.fontSize = (0, e.measureToString)(0.99 * this.size), (0, e.setFontFamily)(this, this, this[n.$globalData].fontFinder, a), this.underline !== 0 && (a.textDecoration = "underline", this.underline === 2 && (a.textDecorationStyle = "double")), a.fontWeight = this.weight, a;
          }
        }
        class Ie extends t.XFAObject {
          constructor(a) {
            super(g, "format", !0), this.id = a.id || "", this.use = a.use || "", this.usehref = a.usehref || "", this.extras = null, this.picture = null;
          }
        }
        class Le extends t.StringObject {
          constructor(a) {
            super(g, "handler"), this.id = a.id || "", this.type = (0, l.getStringOption)(a.type, ["optional", "required"]), this.use = a.use || "", this.usehref = a.usehref || "";
          }
        }
        class Be extends t.XFAObject {
          constructor(a) {
            super(g, "hyphenation"), this.excludeAllCaps = (0, l.getInteger)({
              data: a.excludeAllCaps,
              defaultValue: 0,
              validate: (ee) => ee === 1
            }), this.excludeInitialCap = (0, l.getInteger)({
              data: a.excludeInitialCap,
              defaultValue: 0,
              validate: (ee) => ee === 1
            }), this.hyphenate = (0, l.getInteger)({
              data: a.hyphenate,
              defaultValue: 0,
              validate: (ee) => ee === 1
            }), this.id = a.id || "", this.pushCharacterCount = (0, l.getInteger)({
              data: a.pushCharacterCount,
              defaultValue: 3,
              validate: (ee) => ee >= 0
            }), this.remainCharacterCount = (0, l.getInteger)({
              data: a.remainCharacterCount,
              defaultValue: 3,
              validate: (ee) => ee >= 0
            }), this.use = a.use || "", this.usehref = a.usehref || "", this.wordCharacterCount = (0, l.getInteger)({
              data: a.wordCharacterCount,
              defaultValue: 7,
              validate: (ee) => ee >= 0
            });
          }
        }
        class Ne extends t.StringObject {
          constructor(a) {
            super(g, "image"), this.aspect = (0, l.getStringOption)(a.aspect, ["fit", "actual", "height", "none", "width"]), this.contentType = a.contentType || "", this.href = a.href || "", this.id = a.id || "", this.name = a.name || "", this.transferEncoding = (0, l.getStringOption)(a.transferEncoding, ["base64", "none", "package"]), this.use = a.use || "", this.usehref = a.usehref || "";
          }
          [n.$toHTML]() {
            if (this.contentType && !I.has(this.contentType.toLowerCase()))
              return l.HTMLResult.EMPTY;
            let a = this[n.$globalData].images && this[n.$globalData].images.get(this.href);
            if (!a && (this.href || !this[n.$content]) || (!a && this.transferEncoding === "base64" && (a = (0, j.stringToBytes)(atob(this[n.$content]))), !a))
              return l.HTMLResult.EMPTY;
            if (!this.contentType) {
              for (const [it, dt] of E)
                if (a.length > it.length && it.every((xt, yt) => xt === a[yt])) {
                  this.contentType = dt;
                  break;
                }
              if (!this.contentType)
                return l.HTMLResult.EMPTY;
            }
            const ee = new Blob([a], {
              type: this.contentType
            });
            let He;
            switch (this.aspect) {
              case "fit":
              case "actual":
                break;
              case "height":
                He = {
                  height: "100%",
                  objectFit: "fill"
                };
                break;
              case "none":
                He = {
                  width: "100%",
                  height: "100%",
                  objectFit: "fill"
                };
                break;
              case "width":
                He = {
                  width: "100%",
                  objectFit: "fill"
                };
                break;
            }
            const Ze = this[n.$getParent]();
            return l.HTMLResult.success({
              name: "img",
              attributes: {
                class: ["xfaImage"],
                style: He,
                src: URL.createObjectURL(ee),
                alt: Ze ? u(Ze[n.$getParent]()) : null
              }
            });
          }
        }
        class Ue extends t.XFAObject {
          constructor(a) {
            super(g, "imageEdit", !0), this.data = (0, l.getStringOption)(a.data, ["link", "embed"]), this.id = a.id || "", this.use = a.use || "", this.usehref = a.usehref || "", this.border = null, this.extras = null, this.margin = null;
          }
          [n.$toHTML](a) {
            return this.data === "embed" ? l.HTMLResult.success({
              name: "div",
              children: [],
              attributes: {}
            }) : l.HTMLResult.EMPTY;
          }
        }
        class qe extends t.ContentObject {
          constructor(a) {
            super(g, "integer"), this.id = a.id || "", this.name = a.name || "", this.use = a.use || "", this.usehref = a.usehref || "";
          }
          [n.$finalize]() {
            const a = parseInt(this[n.$content].trim(), 10);
            this[n.$content] = isNaN(a) ? null : a;
          }
          [n.$toHTML](a) {
            return p(this[n.$content] !== null ? this[n.$content].toString() : "");
          }
        }
        class tt extends t.XFAObject {
          constructor(a) {
            super(g, "issuers", !0), this.id = a.id || "", this.type = (0, l.getStringOption)(a.type, ["optional", "required"]), this.use = a.use || "", this.usehref = a.usehref || "", this.certificate = new t.XFAObjectArray();
          }
        }
        class ht extends t.XFAObject {
          constructor(a) {
            super(g, "items", !0), this.id = a.id || "", this.name = a.name || "", this.presence = (0, l.getStringOption)(a.presence, ["visible", "hidden", "inactive", "invisible"]), this.ref = a.ref || "", this.save = (0, l.getInteger)({
              data: a.save,
              defaultValue: 0,
              validate: (ee) => ee === 1
            }), this.use = a.use || "", this.usehref = a.usehref || "", this.boolean = new t.XFAObjectArray(), this.date = new t.XFAObjectArray(), this.dateTime = new t.XFAObjectArray(), this.decimal = new t.XFAObjectArray(), this.exData = new t.XFAObjectArray(), this.float = new t.XFAObjectArray(), this.image = new t.XFAObjectArray(), this.integer = new t.XFAObjectArray(), this.text = new t.XFAObjectArray(), this.time = new t.XFAObjectArray();
          }
          [n.$toHTML]() {
            const a = [];
            for (const ee of this[n.$getChildren]())
              a.push(ee[n.$text]());
            return l.HTMLResult.success(a);
          }
        }
        w.Items = ht;
        class rt extends t.XFAObject {
          constructor(a) {
            super(g, "keep", !0), this.id = a.id || "";
            const ee = ["none", "contentArea", "pageArea"];
            this.intact = (0, l.getStringOption)(a.intact, ee), this.next = (0, l.getStringOption)(a.next, ee), this.previous = (0, l.getStringOption)(a.previous, ee), this.use = a.use || "", this.usehref = a.usehref || "", this.extras = null;
          }
        }
        class nt extends t.XFAObject {
          constructor(a) {
            super(g, "keyUsage");
            const ee = ["", "yes", "no"];
            this.crlSign = (0, l.getStringOption)(a.crlSign, ee), this.dataEncipherment = (0, l.getStringOption)(a.dataEncipherment, ee), this.decipherOnly = (0, l.getStringOption)(a.decipherOnly, ee), this.digitalSignature = (0, l.getStringOption)(a.digitalSignature, ee), this.encipherOnly = (0, l.getStringOption)(a.encipherOnly, ee), this.id = a.id || "", this.keyAgreement = (0, l.getStringOption)(a.keyAgreement, ee), this.keyCertSign = (0, l.getStringOption)(a.keyCertSign, ee), this.keyEncipherment = (0, l.getStringOption)(a.keyEncipherment, ee), this.nonRepudiation = (0, l.getStringOption)(a.nonRepudiation, ee), this.type = (0, l.getStringOption)(a.type, ["optional", "required"]), this.use = a.use || "", this.usehref = a.usehref || "";
          }
        }
        class ut extends t.XFAObject {
          constructor(a) {
            super(g, "line", !0), this.hand = (0, l.getStringOption)(a.hand, ["even", "left", "right"]), this.id = a.id || "", this.slope = (0, l.getStringOption)(a.slope, ["\\", "/"]), this.use = a.use || "", this.usehref = a.usehref || "", this.edge = null;
          }
          [n.$toHTML]() {
            const a = this[n.$getParent]()[n.$getParent](), ee = this.edge || new me({}), He = ee[n.$toStyle](), Ze = /* @__PURE__ */ Object.create(null), it = ee.presence === "visible" ? ee.thickness : 0;
            Ze.strokeWidth = (0, e.measureToString)(it), Ze.stroke = He.color;
            let dt, xt, yt, It, Rt = "100%", Bt = "100%";
            a.w <= it ? ([dt, xt, yt, It] = ["50%", 0, "50%", "100%"], Rt = Ze.strokeWidth) : a.h <= it ? ([dt, xt, yt, It] = [0, "50%", "100%", "50%"], Bt = Ze.strokeWidth) : this.slope === "\\" ? [dt, xt, yt, It] = [0, 0, "100%", "100%"] : [dt, xt, yt, It] = [0, "100%", "100%", 0];
            const $t = {
              name: "svg",
              children: [{
                name: "line",
                attributes: {
                  xmlns: b,
                  x1: dt,
                  y1: xt,
                  x2: yt,
                  y2: It,
                  style: Ze
                }
              }],
              attributes: {
                xmlns: b,
                width: Rt,
                height: Bt,
                style: {
                  overflow: "visible"
                }
              }
            };
            return H(a) ? l.HTMLResult.success({
              name: "div",
              attributes: {
                style: {
                  display: "inline",
                  width: "100%",
                  height: "100%"
                }
              },
              children: [$t]
            }) : ($t.attributes.style.position = "absolute", l.HTMLResult.success($t));
          }
        }
        class bt extends t.XFAObject {
          constructor(a) {
            super(g, "linear", !0), this.id = a.id || "", this.type = (0, l.getStringOption)(a.type, ["toRight", "toBottom", "toLeft", "toTop"]), this.use = a.use || "", this.usehref = a.usehref || "", this.color = null, this.extras = null;
          }
          [n.$toStyle](a) {
            a = a ? a[n.$toStyle]() : "#FFFFFF";
            const ee = this.type.replace(/([RBLT])/, " $1").toLowerCase(), He = this.color ? this.color[n.$toStyle]() : "#000000";
            return `linear-gradient(${ee}, ${a}, ${He})`;
          }
        }
        class Ge extends t.ContentObject {
          constructor(a) {
            super(g, "lockDocument"), this.id = a.id || "", this.type = (0, l.getStringOption)(a.type, ["optional", "required"]), this.use = a.use || "", this.usehref = a.usehref || "";
          }
          [n.$finalize]() {
            this[n.$content] = (0, l.getStringOption)(this[n.$content], ["auto", "0", "1"]);
          }
        }
        class We extends t.XFAObject {
          constructor(a) {
            super(g, "manifest", !0), this.action = (0, l.getStringOption)(a.action, ["include", "all", "exclude"]), this.id = a.id || "", this.name = a.name || "", this.use = a.use || "", this.usehref = a.usehref || "", this.extras = null, this.ref = new t.XFAObjectArray();
          }
        }
        class Je extends t.XFAObject {
          constructor(a) {
            super(g, "margin", !0), this.bottomInset = (0, l.getMeasurement)(a.bottomInset, "0"), this.id = a.id || "", this.leftInset = (0, l.getMeasurement)(a.leftInset, "0"), this.rightInset = (0, l.getMeasurement)(a.rightInset, "0"), this.topInset = (0, l.getMeasurement)(a.topInset, "0"), this.use = a.use || "", this.usehref = a.usehref || "", this.extras = null;
          }
          [n.$toStyle]() {
            return {
              margin: (0, e.measureToString)(this.topInset) + " " + (0, e.measureToString)(this.rightInset) + " " + (0, e.measureToString)(this.bottomInset) + " " + (0, e.measureToString)(this.leftInset)
            };
          }
        }
        class et extends t.XFAObject {
          constructor(a) {
            super(g, "mdp"), this.id = a.id || "", this.permissions = (0, l.getInteger)({
              data: a.permissions,
              defaultValue: 2,
              validate: (ee) => ee === 1 || ee === 3
            }), this.signatureType = (0, l.getStringOption)(a.signatureType, ["filler", "author"]), this.use = a.use || "", this.usehref = a.usehref || "";
          }
        }
        class lt extends t.XFAObject {
          constructor(a) {
            super(g, "medium"), this.id = a.id || "", this.imagingBBox = (0, l.getBBox)(a.imagingBBox), this.long = (0, l.getMeasurement)(a.long), this.orientation = (0, l.getStringOption)(a.orientation, ["portrait", "landscape"]), this.short = (0, l.getMeasurement)(a.short), this.stock = a.stock || "", this.trayIn = (0, l.getStringOption)(a.trayIn, ["auto", "delegate", "pageFront"]), this.trayOut = (0, l.getStringOption)(a.trayOut, ["auto", "delegate"]), this.use = a.use || "", this.usehref = a.usehref || "";
          }
        }
        class pt extends t.XFAObject {
          constructor(a) {
            super(g, "message", !0), this.id = a.id || "", this.use = a.use || "", this.usehref = a.usehref || "", this.text = new t.XFAObjectArray();
          }
        }
        class ot extends t.XFAObject {
          constructor(a) {
            super(g, "numericEdit", !0), this.hScrollPolicy = (0, l.getStringOption)(a.hScrollPolicy, ["auto", "off", "on"]), this.id = a.id || "", this.use = a.use || "", this.usehref = a.usehref || "", this.border = null, this.comb = null, this.extras = null, this.margin = null;
          }
          [n.$toHTML](a) {
            var it;
            const ee = (0, e.toStyle)(this, "border", "font", "margin"), He = this[n.$getParent]()[n.$getParent](), Ze = {
              name: "input",
              attributes: {
                type: "text",
                fieldId: He[n.$uid],
                dataId: ((it = He[n.$data]) == null ? void 0 : it[n.$uid]) || He[n.$uid],
                class: ["xfaTextfield"],
                style: ee,
                "aria-label": u(He),
                "aria-required": !1
              }
            };
            return f(He) && (Ze.attributes["aria-required"] = !0, Ze.attributes.required = !0), l.HTMLResult.success({
              name: "label",
              attributes: {
                class: ["xfaLabel"]
              },
              children: [Ze]
            });
          }
        }
        class st extends t.XFAObject {
          constructor(a) {
            super(g, "occur", !0), this.id = a.id || "", this.initial = a.initial !== "" ? (0, l.getInteger)({
              data: a.initial,
              defaultValue: "",
              validate: (ee) => !0
            }) : "", this.max = a.max !== "" ? (0, l.getInteger)({
              data: a.max,
              defaultValue: 1,
              validate: (ee) => !0
            }) : "", this.min = a.min !== "" ? (0, l.getInteger)({
              data: a.min,
              defaultValue: 1,
              validate: (ee) => !0
            }) : "", this.use = a.use || "", this.usehref = a.usehref || "", this.extras = null;
          }
          [n.$clean]() {
            const a = this[n.$getParent](), ee = this.min;
            this.min === "" && (this.min = a instanceof At || a instanceof St ? 0 : 1), this.max === "" && (ee === "" ? this.max = a instanceof At || a instanceof St ? -1 : 1 : this.max = this.min), this.max !== -1 && this.max < this.min && (this.max = this.min), this.initial === "" && (this.initial = a instanceof En ? 1 : this.min);
          }
        }
        class gt extends t.StringObject {
          constructor(a) {
            super(g, "oid"), this.id = a.id || "", this.name = a.name || "", this.use = a.use || "", this.usehref = a.usehref || "";
          }
        }
        class vt extends t.XFAObject {
          constructor(a) {
            super(g, "oids", !0), this.id = a.id || "", this.type = (0, l.getStringOption)(a.type, ["optional", "required"]), this.use = a.use || "", this.usehref = a.usehref || "", this.oid = new t.XFAObjectArray();
          }
        }
        class Mt extends t.XFAObject {
          constructor(a) {
            super(g, "overflow"), this.id = a.id || "", this.leader = a.leader || "", this.target = a.target || "", this.trailer = a.trailer || "", this.use = a.use || "", this.usehref = a.usehref || "";
          }
          [n.$getExtra]() {
            if (!this[n.$extra]) {
              const a = this[n.$getParent](), ee = this[n.$getTemplateRoot](), He = ee[n.$searchNode](this.target, a), Ze = ee[n.$searchNode](this.leader, a), it = ee[n.$searchNode](this.trailer, a);
              this[n.$extra] = {
                target: (He == null ? void 0 : He[0]) || null,
                leader: (Ze == null ? void 0 : Ze[0]) || null,
                trailer: (it == null ? void 0 : it[0]) || null,
                addLeader: !1,
                addTrailer: !1
              };
            }
            return this[n.$extra];
          }
        }
        class At extends t.XFAObject {
          constructor(a) {
            super(g, "pageArea", !0), this.blankOrNotBlank = (0, l.getStringOption)(a.blankOrNotBlank, ["any", "blank", "notBlank"]), this.id = a.id || "", this.initialNumber = (0, l.getInteger)({
              data: a.initialNumber,
              defaultValue: 1,
              validate: (ee) => !0
            }), this.name = a.name || "", this.numbered = (0, l.getInteger)({
              data: a.numbered,
              defaultValue: 1,
              validate: (ee) => !0
            }), this.oddOrEven = (0, l.getStringOption)(a.oddOrEven, ["any", "even", "odd"]), this.pagePosition = (0, l.getStringOption)(a.pagePosition, ["any", "first", "last", "only", "rest"]), this.relevant = (0, l.getRelevant)(a.relevant), this.use = a.use || "", this.usehref = a.usehref || "", this.desc = null, this.extras = null, this.medium = null, this.occur = null, this.area = new t.XFAObjectArray(), this.contentArea = new t.XFAObjectArray(), this.draw = new t.XFAObjectArray(), this.exclGroup = new t.XFAObjectArray(), this.field = new t.XFAObjectArray(), this.subform = new t.XFAObjectArray();
          }
          [n.$isUsable]() {
            return this[n.$extra] ? !this.occur || this.occur.max === -1 || this[n.$extra].numberOfUse < this.occur.max : (this[n.$extra] = {
              numberOfUse: 0
            }, !0);
          }
          [n.$cleanPage]() {
            delete this[n.$extra];
          }
          [n.$getNextPage]() {
            this[n.$extra] || (this[n.$extra] = {
              numberOfUse: 0
            });
            const a = this[n.$getParent]();
            return a.relation === "orderedOccurrence" && this[n.$isUsable]() ? (this[n.$extra].numberOfUse += 1, this) : a[n.$getNextPage]();
          }
          [n.$getAvailableSpace]() {
            return this[n.$extra].space || {
              width: 0,
              height: 0
            };
          }
          [n.$toHTML]() {
            this[n.$extra] || (this[n.$extra] = {
              numberOfUse: 1
            });
            const a = [];
            this[n.$extra].children = a;
            const ee = /* @__PURE__ */ Object.create(null);
            if (this.medium && this.medium.short && this.medium.long) {
              if (ee.width = (0, e.measureToString)(this.medium.short), ee.height = (0, e.measureToString)(this.medium.long), this[n.$extra].space = {
                width: this.medium.short,
                height: this.medium.long
              }, this.medium.orientation === "landscape") {
                const He = ee.width;
                ee.width = ee.height, ee.height = He, this[n.$extra].space = {
                  width: this.medium.long,
                  height: this.medium.short
                };
              }
            } else
              (0, j.warn)("XFA - No medium specified in pageArea: please file a bug.");
            return this[n.$childrenToHTML]({
              filter: /* @__PURE__ */ new Set(["area", "draw", "field", "subform"]),
              include: !0
            }), this[n.$childrenToHTML]({
              filter: /* @__PURE__ */ new Set(["contentArea"]),
              include: !0
            }), l.HTMLResult.success({
              name: "div",
              children: a,
              attributes: {
                class: ["xfaPage"],
                id: this[n.$uid],
                style: ee,
                xfaName: this.name
              }
            });
          }
        }
        class St extends t.XFAObject {
          constructor(a) {
            super(g, "pageSet", !0), this.duplexImposition = (0, l.getStringOption)(a.duplexImposition, ["longEdge", "shortEdge"]), this.id = a.id || "", this.name = a.name || "", this.relation = (0, l.getStringOption)(a.relation, ["orderedOccurrence", "duplexPaginated", "simplexPaginated"]), this.relevant = (0, l.getRelevant)(a.relevant), this.use = a.use || "", this.usehref = a.usehref || "", this.extras = null, this.occur = null, this.pageArea = new t.XFAObjectArray(), this.pageSet = new t.XFAObjectArray();
          }
          [n.$cleanPage]() {
            for (const a of this.pageArea.children)
              a[n.$cleanPage]();
            for (const a of this.pageSet.children)
              a[n.$cleanPage]();
          }
          [n.$isUsable]() {
            return !this.occur || this.occur.max === -1 || this[n.$extra].numberOfUse < this.occur.max;
          }
          [n.$getNextPage]() {
            if (this[n.$extra] || (this[n.$extra] = {
              numberOfUse: 1,
              pageIndex: -1,
              pageSetIndex: -1
            }), this.relation === "orderedOccurrence") {
              if (this[n.$extra].pageIndex + 1 < this.pageArea.children.length)
                return this[n.$extra].pageIndex += 1, this.pageArea.children[this[n.$extra].pageIndex][n.$getNextPage]();
              if (this[n.$extra].pageSetIndex + 1 < this.pageSet.children.length)
                return this[n.$extra].pageSetIndex += 1, this.pageSet.children[this[n.$extra].pageSetIndex][n.$getNextPage]();
              if (this[n.$isUsable]())
                return this[n.$extra].numberOfUse += 1, this[n.$extra].pageIndex = -1, this[n.$extra].pageSetIndex = -1, this[n.$getNextPage]();
              const it = this[n.$getParent]();
              return it instanceof St ? it[n.$getNextPage]() : (this[n.$cleanPage](), this[n.$getNextPage]());
            }
            const a = this[n.$getTemplateRoot]()[n.$extra].pageNumber, ee = a % 2 === 0 ? "even" : "odd", He = a === 0 ? "first" : "rest";
            let Ze = this.pageArea.children.find((it) => it.oddOrEven === ee && it.pagePosition === He);
            return Ze || (Ze = this.pageArea.children.find((it) => it.oddOrEven === "any" && it.pagePosition === He), Ze) || (Ze = this.pageArea.children.find((it) => it.oddOrEven === "any" && it.pagePosition === "any"), Ze) ? Ze : this.pageArea.children[0];
          }
        }
        class Et extends t.XFAObject {
          constructor(a) {
            super(g, "para", !0), this.hAlign = (0, l.getStringOption)(a.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = a.id || "", this.lineHeight = a.lineHeight ? (0, l.getMeasurement)(a.lineHeight, "0pt") : "", this.marginLeft = a.marginLeft ? (0, l.getMeasurement)(a.marginLeft, "0pt") : "", this.marginRight = a.marginRight ? (0, l.getMeasurement)(a.marginRight, "0pt") : "", this.orphans = (0, l.getInteger)({
              data: a.orphans,
              defaultValue: 0,
              validate: (ee) => ee >= 0
            }), this.preserve = a.preserve || "", this.radixOffset = a.radixOffset ? (0, l.getMeasurement)(a.radixOffset, "0pt") : "", this.spaceAbove = a.spaceAbove ? (0, l.getMeasurement)(a.spaceAbove, "0pt") : "", this.spaceBelow = a.spaceBelow ? (0, l.getMeasurement)(a.spaceBelow, "0pt") : "", this.tabDefault = a.tabDefault ? (0, l.getMeasurement)(this.tabDefault) : "", this.tabStops = (a.tabStops || "").trim().split(/\s+/).map((ee, He) => He % 2 === 1 ? (0, l.getMeasurement)(ee) : ee), this.textIndent = a.textIndent ? (0, l.getMeasurement)(a.textIndent, "0pt") : "", this.use = a.use || "", this.usehref = a.usehref || "", this.vAlign = (0, l.getStringOption)(a.vAlign, ["top", "bottom", "middle"]), this.widows = (0, l.getInteger)({
              data: a.widows,
              defaultValue: 0,
              validate: (ee) => ee >= 0
            }), this.hyphenation = null;
          }
          [n.$toStyle]() {
            const a = (0, e.toStyle)(this, "hAlign");
            return this.marginLeft !== "" && (a.paddingLeft = (0, e.measureToString)(this.marginLeft)), this.marginRight !== "" && (a.paddingight = (0, e.measureToString)(this.marginRight)), this.spaceAbove !== "" && (a.paddingTop = (0, e.measureToString)(this.spaceAbove)), this.spaceBelow !== "" && (a.paddingBottom = (0, e.measureToString)(this.spaceBelow)), this.textIndent !== "" && (a.textIndent = (0, e.measureToString)(this.textIndent), (0, e.fixTextIndent)(a)), this.lineHeight > 0 && (a.lineHeight = (0, e.measureToString)(this.lineHeight)), this.tabDefault !== "" && (a.tabSize = (0, e.measureToString)(this.tabDefault)), this.tabStops.length > 0, this.hyphenatation && Object.assign(a, this.hyphenatation[n.$toStyle]()), a;
          }
        }
        class mt extends t.XFAObject {
          constructor(a) {
            super(g, "passwordEdit", !0), this.hScrollPolicy = (0, l.getStringOption)(a.hScrollPolicy, ["auto", "off", "on"]), this.id = a.id || "", this.passwordChar = a.passwordChar || "*", this.use = a.use || "", this.usehref = a.usehref || "", this.border = null, this.extras = null, this.margin = null;
          }
        }
        class Ct extends t.XFAObject {
          constructor(a) {
            super(g, "pattern", !0), this.id = a.id || "", this.type = (0, l.getStringOption)(a.type, ["crossHatch", "crossDiagonal", "diagonalLeft", "diagonalRight", "horizontal", "vertical"]), this.use = a.use || "", this.usehref = a.usehref || "", this.color = null, this.extras = null;
          }
          [n.$toStyle](a) {
            a = a ? a[n.$toStyle]() : "#FFFFFF";
            const ee = this.color ? this.color[n.$toStyle]() : "#000000", He = 5, Ze = "repeating-linear-gradient", it = `${a},${a} ${He}px,${ee} ${He}px,${ee} ${2 * He}px`;
            switch (this.type) {
              case "crossHatch":
                return `${Ze}(to top,${it}) ${Ze}(to right,${it})`;
              case "crossDiagonal":
                return `${Ze}(45deg,${it}) ${Ze}(-45deg,${it})`;
              case "diagonalLeft":
                return `${Ze}(45deg,${it})`;
              case "diagonalRight":
                return `${Ze}(-45deg,${it})`;
              case "horizontal":
                return `${Ze}(to top,${it})`;
              case "vertical":
                return `${Ze}(to right,${it})`;
            }
            return "";
          }
        }
        class ft extends t.StringObject {
          constructor(a) {
            super(g, "picture"), this.id = a.id || "", this.use = a.use || "", this.usehref = a.usehref || "";
          }
        }
        class Tt extends t.XFAObject {
          constructor(a) {
            super(g, "proto", !0), this.appearanceFilter = new t.XFAObjectArray(), this.arc = new t.XFAObjectArray(), this.area = new t.XFAObjectArray(), this.assist = new t.XFAObjectArray(), this.barcode = new t.XFAObjectArray(), this.bindItems = new t.XFAObjectArray(), this.bookend = new t.XFAObjectArray(), this.boolean = new t.XFAObjectArray(), this.border = new t.XFAObjectArray(), this.break = new t.XFAObjectArray(), this.breakAfter = new t.XFAObjectArray(), this.breakBefore = new t.XFAObjectArray(), this.button = new t.XFAObjectArray(), this.calculate = new t.XFAObjectArray(), this.caption = new t.XFAObjectArray(), this.certificate = new t.XFAObjectArray(), this.certificates = new t.XFAObjectArray(), this.checkButton = new t.XFAObjectArray(), this.choiceList = new t.XFAObjectArray(), this.color = new t.XFAObjectArray(), this.comb = new t.XFAObjectArray(), this.connect = new t.XFAObjectArray(), this.contentArea = new t.XFAObjectArray(), this.corner = new t.XFAObjectArray(), this.date = new t.XFAObjectArray(), this.dateTime = new t.XFAObjectArray(), this.dateTimeEdit = new t.XFAObjectArray(), this.decimal = new t.XFAObjectArray(), this.defaultUi = new t.XFAObjectArray(), this.desc = new t.XFAObjectArray(), this.digestMethod = new t.XFAObjectArray(), this.digestMethods = new t.XFAObjectArray(), this.draw = new t.XFAObjectArray(), this.edge = new t.XFAObjectArray(), this.encoding = new t.XFAObjectArray(), this.encodings = new t.XFAObjectArray(), this.encrypt = new t.XFAObjectArray(), this.encryptData = new t.XFAObjectArray(), this.encryption = new t.XFAObjectArray(), this.encryptionMethod = new t.XFAObjectArray(), this.encryptionMethods = new t.XFAObjectArray(), this.event = new t.XFAObjectArray(), this.exData = new t.XFAObjectArray(), this.exObject = new t.XFAObjectArray(), this.exclGroup = new t.XFAObjectArray(), this.execute = new t.XFAObjectArray(), this.extras = new t.XFAObjectArray(), this.field = new t.XFAObjectArray(), this.fill = new t.XFAObjectArray(), this.filter = new t.XFAObjectArray(), this.float = new t.XFAObjectArray(), this.font = new t.XFAObjectArray(), this.format = new t.XFAObjectArray(), this.handler = new t.XFAObjectArray(), this.hyphenation = new t.XFAObjectArray(), this.image = new t.XFAObjectArray(), this.imageEdit = new t.XFAObjectArray(), this.integer = new t.XFAObjectArray(), this.issuers = new t.XFAObjectArray(), this.items = new t.XFAObjectArray(), this.keep = new t.XFAObjectArray(), this.keyUsage = new t.XFAObjectArray(), this.line = new t.XFAObjectArray(), this.linear = new t.XFAObjectArray(), this.lockDocument = new t.XFAObjectArray(), this.manifest = new t.XFAObjectArray(), this.margin = new t.XFAObjectArray(), this.mdp = new t.XFAObjectArray(), this.medium = new t.XFAObjectArray(), this.message = new t.XFAObjectArray(), this.numericEdit = new t.XFAObjectArray(), this.occur = new t.XFAObjectArray(), this.oid = new t.XFAObjectArray(), this.oids = new t.XFAObjectArray(), this.overflow = new t.XFAObjectArray(), this.pageArea = new t.XFAObjectArray(), this.pageSet = new t.XFAObjectArray(), this.para = new t.XFAObjectArray(), this.passwordEdit = new t.XFAObjectArray(), this.pattern = new t.XFAObjectArray(), this.picture = new t.XFAObjectArray(), this.radial = new t.XFAObjectArray(), this.reason = new t.XFAObjectArray(), this.reasons = new t.XFAObjectArray(), this.rectangle = new t.XFAObjectArray(), this.ref = new t.XFAObjectArray(), this.script = new t.XFAObjectArray(), this.setProperty = new t.XFAObjectArray(), this.signData = new t.XFAObjectArray(), this.signature = new t.XFAObjectArray(), this.signing = new t.XFAObjectArray(), this.solid = new t.XFAObjectArray(), this.speak = new t.XFAObjectArray(), this.stipple = new t.XFAObjectArray(), this.subform = new t.XFAObjectArray(), this.subformSet = new t.XFAObjectArray(), this.subjectDN = new t.XFAObjectArray(), this.subjectDNs = new t.XFAObjectArray(), this.submit = new t.XFAObjectArray(), this.text = new t.XFAObjectArray(), this.textEdit = new t.XFAObjectArray(), this.time = new t.XFAObjectArray(), this.timeStamp = new t.XFAObjectArray(), this.toolTip = new t.XFAObjectArray(), this.traversal = new t.XFAObjectArray(), this.traverse = new t.XFAObjectArray(), this.ui = new t.XFAObjectArray(), this.validate = new t.XFAObjectArray(), this.value = new t.XFAObjectArray(), this.variables = new t.XFAObjectArray();
          }
        }
        class _t extends t.XFAObject {
          constructor(a) {
            super(g, "radial", !0), this.id = a.id || "", this.type = (0, l.getStringOption)(a.type, ["toEdge", "toCenter"]), this.use = a.use || "", this.usehref = a.usehref || "", this.color = null, this.extras = null;
          }
          [n.$toStyle](a) {
            a = a ? a[n.$toStyle]() : "#FFFFFF";
            const ee = this.color ? this.color[n.$toStyle]() : "#000000";
            return `radial-gradient(circle at center, ${this.type === "toEdge" ? `${a},${ee}` : `${ee},${a}`})`;
          }
        }
        class Xt extends t.StringObject {
          constructor(a) {
            super(g, "reason"), this.id = a.id || "", this.name = a.name || "", this.use = a.use || "", this.usehref = a.usehref || "";
          }
        }
        class kt extends t.XFAObject {
          constructor(a) {
            super(g, "reasons", !0), this.id = a.id || "", this.type = (0, l.getStringOption)(a.type, ["optional", "required"]), this.use = a.use || "", this.usehref = a.usehref || "", this.reason = new t.XFAObjectArray();
          }
        }
        class Ft extends t.XFAObject {
          constructor(a) {
            super(g, "rectangle", !0), this.hand = (0, l.getStringOption)(a.hand, ["even", "left", "right"]), this.id = a.id || "", this.use = a.use || "", this.usehref = a.usehref || "", this.corner = new t.XFAObjectArray(4), this.edge = new t.XFAObjectArray(4), this.fill = null;
          }
          [n.$toHTML]() {
            var It;
            const a = this.edge.children.length ? this.edge.children[0] : new me({}), ee = a[n.$toStyle](), He = /* @__PURE__ */ Object.create(null);
            ((It = this.fill) == null ? void 0 : It.presence) === "visible" ? Object.assign(He, this.fill[n.$toStyle]()) : He.fill = "transparent", He.strokeWidth = (0, e.measureToString)(a.presence === "visible" ? a.thickness : 0), He.stroke = ee.color;
            const it = (this.corner.children.length ? this.corner.children[0] : new ne({}))[n.$toStyle](), xt = {
              name: "svg",
              children: [{
                name: "rect",
                attributes: {
                  xmlns: b,
                  width: "100%",
                  height: "100%",
                  x: 0,
                  y: 0,
                  rx: it.radius,
                  ry: it.radius,
                  style: He
                }
              }],
              attributes: {
                xmlns: b,
                style: {
                  overflow: "visible"
                },
                width: "100%",
                height: "100%"
              }
            }, yt = this[n.$getParent]()[n.$getParent]();
            return H(yt) ? l.HTMLResult.success({
              name: "div",
              attributes: {
                style: {
                  display: "inline",
                  width: "100%",
                  height: "100%"
                }
              },
              children: [xt]
            }) : (xt.attributes.style.position = "absolute", l.HTMLResult.success(xt));
          }
        }
        class Lt extends t.StringObject {
          constructor(a) {
            super(g, "ref"), this.id = a.id || "", this.use = a.use || "", this.usehref = a.usehref || "";
          }
        }
        class jt extends t.StringObject {
          constructor(a) {
            super(g, "script"), this.binding = a.binding || "", this.contentType = a.contentType || "", this.id = a.id || "", this.name = a.name || "", this.runAt = (0, l.getStringOption)(a.runAt, ["client", "both", "server"]), this.use = a.use || "", this.usehref = a.usehref || "";
          }
        }
        class qt extends t.XFAObject {
          constructor(a) {
            super(g, "setProperty"), this.connection = a.connection || "", this.ref = a.ref || "", this.target = a.target || "";
          }
        }
        w.SetProperty = qt;
        class dn extends t.XFAObject {
          constructor(a) {
            super(g, "signData", !0), this.id = a.id || "", this.operation = (0, l.getStringOption)(a.operation, ["sign", "clear", "verify"]), this.ref = a.ref || "", this.target = a.target || "", this.use = a.use || "", this.usehref = a.usehref || "", this.filter = null, this.manifest = null;
          }
        }
        class mi extends t.XFAObject {
          constructor(a) {
            super(g, "signature", !0), this.id = a.id || "", this.type = (0, l.getStringOption)(a.type, ["PDF1.3", "PDF1.6"]), this.use = a.use || "", this.usehref = a.usehref || "", this.border = null, this.extras = null, this.filter = null, this.manifest = null, this.margin = null;
          }
        }
        class xi extends t.XFAObject {
          constructor(a) {
            super(g, "signing", !0), this.id = a.id || "", this.type = (0, l.getStringOption)(a.type, ["optional", "required"]), this.use = a.use || "", this.usehref = a.usehref || "", this.certificate = new t.XFAObjectArray();
          }
        }
        class bi extends t.XFAObject {
          constructor(a) {
            super(g, "solid", !0), this.id = a.id || "", this.use = a.use || "", this.usehref = a.usehref || "", this.extras = null;
          }
          [n.$toStyle](a) {
            return a ? a[n.$toStyle]() : "#FFFFFF";
          }
        }
        class yi extends t.StringObject {
          constructor(a) {
            super(g, "speak"), this.disable = (0, l.getInteger)({
              data: a.disable,
              defaultValue: 0,
              validate: (ee) => ee === 1
            }), this.id = a.id || "", this.priority = (0, l.getStringOption)(a.priority, ["custom", "caption", "name", "toolTip"]), this.rid = a.rid || "", this.use = a.use || "", this.usehref = a.usehref || "";
          }
        }
        class wi extends t.XFAObject {
          constructor(a) {
            super(g, "stipple", !0), this.id = a.id || "", this.rate = (0, l.getInteger)({
              data: a.rate,
              defaultValue: 50,
              validate: (ee) => ee >= 0 && ee <= 100
            }), this.use = a.use || "", this.usehref = a.usehref || "", this.color = null, this.extras = null;
          }
          [n.$toStyle](a) {
            const ee = this.rate / 100;
            return j.Util.makeHexColor(Math.round(a.value.r * (1 - ee) + this.value.r * ee), Math.round(a.value.g * (1 - ee) + this.value.g * ee), Math.round(a.value.b * (1 - ee) + this.value.b * ee));
          }
        }
        class Bn extends t.XFAObject {
          constructor(a) {
            super(g, "subform", !0), this.access = (0, l.getStringOption)(a.access, ["open", "nonInteractive", "protected", "readOnly"]), this.allowMacro = (0, l.getInteger)({
              data: a.allowMacro,
              defaultValue: 0,
              validate: (ee) => ee === 1
            }), this.anchorType = (0, l.getStringOption)(a.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = (0, l.getInteger)({
              data: a.colSpan,
              defaultValue: 1,
              validate: (ee) => ee >= 1 || ee === -1
            }), this.columnWidths = (a.columnWidths || "").trim().split(/\s+/).map((ee) => ee === "-1" ? -1 : (0, l.getMeasurement)(ee)), this.h = a.h ? (0, l.getMeasurement)(a.h) : "", this.hAlign = (0, l.getStringOption)(a.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = a.id || "", this.layout = (0, l.getStringOption)(a.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]), this.locale = a.locale || "", this.maxH = (0, l.getMeasurement)(a.maxH, "0pt"), this.maxW = (0, l.getMeasurement)(a.maxW, "0pt"), this.mergeMode = (0, l.getStringOption)(a.mergeMode, ["consumeData", "matchTemplate"]), this.minH = (0, l.getMeasurement)(a.minH, "0pt"), this.minW = (0, l.getMeasurement)(a.minW, "0pt"), this.name = a.name || "", this.presence = (0, l.getStringOption)(a.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = (0, l.getRelevant)(a.relevant), this.restoreState = (0, l.getStringOption)(a.restoreState, ["manual", "auto"]), this.scope = (0, l.getStringOption)(a.scope, ["name", "none"]), this.use = a.use || "", this.usehref = a.usehref || "", this.w = a.w ? (0, l.getMeasurement)(a.w) : "", this.x = (0, l.getMeasurement)(a.x, "0pt"), this.y = (0, l.getMeasurement)(a.y, "0pt"), this.assist = null, this.bind = null, this.bookend = null, this.border = null, this.break = null, this.calculate = null, this.desc = null, this.extras = null, this.keep = null, this.margin = null, this.occur = null, this.overflow = null, this.pageSet = null, this.para = null, this.traversal = null, this.validate = null, this.variables = null, this.area = new t.XFAObjectArray(), this.breakAfter = new t.XFAObjectArray(), this.breakBefore = new t.XFAObjectArray(), this.connect = new t.XFAObjectArray(), this.draw = new t.XFAObjectArray(), this.event = new t.XFAObjectArray(), this.exObject = new t.XFAObjectArray(), this.exclGroup = new t.XFAObjectArray(), this.field = new t.XFAObjectArray(), this.proto = new t.XFAObjectArray(), this.setProperty = new t.XFAObjectArray(), this.subform = new t.XFAObjectArray(), this.subformSet = new t.XFAObjectArray();
          }
          [n.$getSubformParent]() {
            const a = this[n.$getParent]();
            return a instanceof Tn ? a[n.$getSubformParent]() : a;
          }
          [n.$isBindable]() {
            return !0;
          }
          [n.$isThereMoreWidth]() {
            return this.layout.endsWith("-tb") && this[n.$extra].attempt === 0 && this[n.$extra].numberInLine > 0 || this[n.$getParent]()[n.$isThereMoreWidth]();
          }
          *[n.$getContainedChildren]() {
            yield* R(this);
          }
          [n.$flushHTML]() {
            return (0, C.flushHTML)(this);
          }
          [n.$addHTML](a, ee) {
            (0, C.addHTML)(this, a, ee);
          }
          [n.$getAvailableSpace]() {
            return (0, C.getAvailableSpace)(this);
          }
          [n.$isSplittable]() {
            var ee;
            const a = this[n.$getSubformParent]();
            return a[n.$isSplittable]() ? this[n.$extra]._isSplittable !== void 0 ? this[n.$extra]._isSplittable : this.layout === "position" || this.layout.includes("row") ? (this[n.$extra]._isSplittable = !1, !1) : this.keep && this.keep.intact !== "none" ? (this[n.$extra]._isSplittable = !1, !1) : (ee = a.layout) != null && ee.endsWith("-tb") && a[n.$extra].numberInLine !== 0 ? !1 : (this[n.$extra]._isSplittable = !0, !0) : !1;
          }
          [n.$toHTML](a) {
            var Dt;
            if (c(this), this.break) {
              if (this.break.after !== "auto" || this.break.afterTarget !== "") {
                const wt = new q({
                  targetType: this.break.after,
                  target: this.break.afterTarget,
                  startNew: this.break.startNew.toString()
                });
                wt[n.$globalData] = this[n.$globalData], this[n.$appendChild](wt), this.breakAfter.push(wt);
              }
              if (this.break.before !== "auto" || this.break.beforeTarget !== "") {
                const wt = new re({
                  targetType: this.break.before,
                  target: this.break.beforeTarget,
                  startNew: this.break.startNew.toString()
                });
                wt[n.$globalData] = this[n.$globalData], this[n.$appendChild](wt), this.breakBefore.push(wt);
              }
              if (this.break.overflowTarget !== "") {
                const wt = new Mt({
                  target: this.break.overflowTarget,
                  leader: this.break.overflowLeader,
                  trailer: this.break.overflowTrailer
                });
                wt[n.$globalData] = this[n.$globalData], this[n.$appendChild](wt), this.overflow.push(wt);
              }
              this[n.$removeChild](this.break), this.break = null;
            }
            if (this.presence === "hidden" || this.presence === "inactive")
              return l.HTMLResult.EMPTY;
            if ((this.breakBefore.children.length > 1 || this.breakAfter.children.length > 1) && (0, j.warn)("XFA - Several breakBefore or breakAfter in subforms: please file a bug."), this.breakBefore.children.length >= 1) {
              const wt = this.breakBefore.children[0];
              if (T(wt))
                return l.HTMLResult.breakNode(wt);
            }
            if ((Dt = this[n.$extra]) != null && Dt.afterBreakAfter)
              return l.HTMLResult.EMPTY;
            (0, e.fixDimensions)(this);
            const ee = [], He = {
              id: this[n.$uid],
              class: []
            };
            (0, e.setAccess)(this, He.class), this[n.$extra] || (this[n.$extra] = /* @__PURE__ */ Object.create(null)), Object.assign(this[n.$extra], {
              children: ee,
              line: null,
              attributes: He,
              attempt: 0,
              numberInLine: 0,
              availableSpace: {
                width: Math.min(this.w || 1 / 0, a.width),
                height: Math.min(this.h || 1 / 0, a.height)
              },
              width: 0,
              height: 0,
              prevHeight: 0,
              currentWidth: 0
            });
            const Ze = this[n.$getTemplateRoot](), it = Ze[n.$extra].noLayoutFailure, dt = this[n.$isSplittable]();
            if (dt || S(this), !(0, C.checkDimensions)(this, a))
              return l.HTMLResult.FAILURE;
            const xt = /* @__PURE__ */ new Set(["area", "draw", "exclGroup", "field", "subform", "subformSet"]);
            if (this.layout.includes("row")) {
              const wt = this[n.$getSubformParent]().columnWidths;
              Array.isArray(wt) && wt.length > 0 && (this[n.$extra].columnWidths = wt, this[n.$extra].currentColumn = 0);
            }
            const yt = (0, e.toStyle)(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), It = ["xfaSubform"], Rt = (0, e.layoutClass)(this);
            if (Rt && It.push(Rt), He.style = yt, He.class = It, this.name && (He.xfaName = this.name), this.overflow) {
              const wt = this.overflow[n.$getExtra]();
              wt.addLeader && (wt.addLeader = !1, D(this, wt.leader, a));
            }
            this[n.$pushPara]();
            const Bt = this.layout === "lr-tb" || this.layout === "rl-tb", Nt = Bt ? i : 1;
            for (; this[n.$extra].attempt < Nt; this[n.$extra].attempt++) {
              Bt && this[n.$extra].attempt === i - 1 && (this[n.$extra].numberInLine = 0);
              const wt = this[n.$childrenToHTML]({
                filter: xt,
                include: !0
              });
              if (wt.success)
                break;
              if (wt.isBreak())
                return this[n.$popPara](), wt;
              if (Bt && this[n.$extra].attempt === 0 && this[n.$extra].numberInLine === 0 && !Ze[n.$extra].noLayoutFailure) {
                this[n.$extra].attempt = Nt;
                break;
              }
            }
            if (this[n.$popPara](), dt || B(this), Ze[n.$extra].noLayoutFailure = it, this[n.$extra].attempt === Nt)
              return this.overflow && (this[n.$getTemplateRoot]()[n.$extra].overflowNode = this.overflow), dt || delete this[n.$extra], l.HTMLResult.FAILURE;
            if (this.overflow) {
              const wt = this.overflow[n.$getExtra]();
              wt.addTrailer && (wt.addTrailer = !1, D(this, wt.trailer, a));
            }
            let $t = 0, Ht = 0;
            this.margin && ($t = this.margin.leftInset + this.margin.rightInset, Ht = this.margin.topInset + this.margin.bottomInset);
            const Pt = Math.max(this[n.$extra].width + $t, this.w || 0), zt = Math.max(this[n.$extra].height + Ht, this.h || 0), Ut = [this.x, this.y, Pt, zt];
            if (this.w === "" && (yt.width = (0, e.measureToString)(Pt)), this.h === "" && (yt.height = (0, e.measureToString)(zt)), (yt.width === "0px" || yt.height === "0px") && ee.length === 0)
              return l.HTMLResult.EMPTY;
            const Kt = {
              name: "div",
              attributes: He,
              children: ee
            };
            N(this, He);
            const Gt = l.HTMLResult.success((0, e.createWrapper)(this, Kt), Ut);
            if (this.breakAfter.children.length >= 1) {
              const wt = this.breakAfter.children[0];
              if (T(wt))
                return this[n.$extra].afterBreakAfter = Gt, l.HTMLResult.breakNode(wt);
            }
            return delete this[n.$extra], Gt;
          }
        }
        class Tn extends t.XFAObject {
          constructor(a) {
            super(g, "subformSet", !0), this.id = a.id || "", this.name = a.name || "", this.relation = (0, l.getStringOption)(a.relation, ["ordered", "choice", "unordered"]), this.relevant = (0, l.getRelevant)(a.relevant), this.use = a.use || "", this.usehref = a.usehref || "", this.bookend = null, this.break = null, this.desc = null, this.extras = null, this.occur = null, this.overflow = null, this.breakAfter = new t.XFAObjectArray(), this.breakBefore = new t.XFAObjectArray(), this.subform = new t.XFAObjectArray(), this.subformSet = new t.XFAObjectArray();
          }
          *[n.$getContainedChildren]() {
            yield* R(this);
          }
          [n.$getSubformParent]() {
            let a = this[n.$getParent]();
            for (; !(a instanceof Bn); )
              a = a[n.$getParent]();
            return a;
          }
          [n.$isBindable]() {
            return !0;
          }
        }
        class Ai extends t.ContentObject {
          constructor(a) {
            super(g, "subjectDN"), this.delimiter = a.delimiter || ",", this.id = a.id || "", this.name = a.name || "", this.use = a.use || "", this.usehref = a.usehref || "";
          }
          [n.$finalize]() {
            this[n.$content] = new Map(this[n.$content].split(this.delimiter).map((a) => (a = a.split("=", 2), a[0] = a[0].trim(), a)));
          }
        }
        class Si extends t.XFAObject {
          constructor(a) {
            super(g, "subjectDNs", !0), this.id = a.id || "", this.type = (0, l.getStringOption)(a.type, ["optional", "required"]), this.use = a.use || "", this.usehref = a.usehref || "", this.subjectDN = new t.XFAObjectArray();
          }
        }
        class vi extends t.XFAObject {
          constructor(a) {
            super(g, "submit", !0), this.embedPDF = (0, l.getInteger)({
              data: a.embedPDF,
              defaultValue: 0,
              validate: (ee) => ee === 1
            }), this.format = (0, l.getStringOption)(a.format, ["xdp", "formdata", "pdf", "urlencoded", "xfd", "xml"]), this.id = a.id || "", this.target = a.target || "", this.textEncoding = (0, l.getKeyword)({
              data: a.textEncoding ? a.textEncoding.toLowerCase() : "",
              defaultValue: "",
              validate: (ee) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(ee) || ee.match(/iso-8859-\d{2}/)
            }), this.use = a.use || "", this.usehref = a.usehref || "", this.xdpContent = a.xdpContent || "", this.encrypt = null, this.encryptData = new t.XFAObjectArray(), this.signData = new t.XFAObjectArray();
          }
        }
        class En extends t.XFAObject {
          constructor(a) {
            super(g, "template", !0), this.baseProfile = (0, l.getStringOption)(a.baseProfile, ["full", "interactiveForms"]), this.extras = null, this.subform = new t.XFAObjectArray();
          }
          [n.$finalize]() {
            this.subform.children.length === 0 && (0, j.warn)("XFA - No subforms in template node."), this.subform.children.length >= 2 && (0, j.warn)("XFA - Several subforms in template node: please file a bug."), this[n.$tabIndex] = d;
          }
          [n.$isSplittable]() {
            return !0;
          }
          [n.$searchNode](a, ee) {
            return a.startsWith("#") ? [this[n.$ids].get(a.slice(1))] : (0, v.searchNode)(this, ee, a, !0, !0);
          }
          *[n.$toPages]() {
            var Ht, Pt, zt;
            if (!this.subform.children.length)
              return l.HTMLResult.success({
                name: "div",
                children: []
              });
            this[n.$extra] = {
              overflowNode: null,
              firstUnsplittable: null,
              currentContentArea: null,
              currentPageArea: null,
              noLayoutFailure: !1,
              pageNumber: 1,
              pagePosition: "first",
              oddOrEven: "odd",
              blankOrNotBlank: "nonBlank",
              paraStack: []
            };
            const a = this.subform.children[0];
            a.pageSet[n.$cleanPage]();
            const ee = a.pageSet.pageArea.children, He = {
              name: "div",
              children: []
            };
            let Ze = null, it = null, dt = null;
            if (a.breakBefore.children.length >= 1 ? (it = a.breakBefore.children[0], dt = it.target) : a.subform.children.length >= 1 && a.subform.children[0].breakBefore.children.length >= 1 ? (it = a.subform.children[0].breakBefore.children[0], dt = it.target) : (Ht = a.break) != null && Ht.beforeTarget ? (it = a.break, dt = it.beforeTarget) : a.subform.children.length >= 1 && ((Pt = a.subform.children[0].break) != null && Pt.beforeTarget) && (it = a.subform.children[0].break, dt = it.beforeTarget), it) {
              const Ut = this[n.$searchNode](dt, it[n.$getParent]());
              Ut instanceof At && (Ze = Ut, it[n.$extra] = {});
            }
            Ze || (Ze = ee[0]), Ze[n.$extra] = {
              numberOfUse: 1
            };
            const xt = Ze[n.$getParent]();
            xt[n.$extra] = {
              numberOfUse: 1,
              pageIndex: xt.pageArea.children.indexOf(Ze),
              pageSetIndex: 0
            };
            let yt, It = null, Rt = null, Bt = !0, Nt = 0, $t = 0;
            for (; ; ) {
              if (Bt)
                Nt = 0;
              else if (He.children.pop(), ++Nt === P)
                return (0, j.warn)("XFA - Something goes wrong: please file a bug."), He;
              yt = null, this[n.$extra].currentPageArea = Ze;
              const Ut = Ze[n.$toHTML]().html;
              He.children.push(Ut), It && (this[n.$extra].noLayoutFailure = !0, Ut.children.push(It[n.$toHTML](Ze[n.$extra].space).html), It = null), Rt && (this[n.$extra].noLayoutFailure = !0, Ut.children.push(Rt[n.$toHTML](Ze[n.$extra].space).html), Rt = null);
              const Kt = Ze.contentArea.children, Gt = Ut.children.filter((wt) => wt.attributes.class.includes("xfaContentarea"));
              Bt = !1, this[n.$extra].firstUnsplittable = null, this[n.$extra].noLayoutFailure = !1;
              const Dt = (wt) => {
                var Yt;
                const Qt = a[n.$flushHTML]();
                Qt && (Bt || (Bt = ((Yt = Qt.children) == null ? void 0 : Yt.length) > 0), Gt[wt].children.push(Qt));
              };
              for (let wt = $t, Qt = Kt.length; wt < Qt; wt++) {
                const Yt = this[n.$extra].currentContentArea = Kt[wt], hn = {
                  width: Yt.w,
                  height: Yt.h
                };
                $t = 0, It && (Gt[wt].children.push(It[n.$toHTML](hn).html), It = null), Rt && (Gt[wt].children.push(Rt[n.$toHTML](hn).html), Rt = null);
                const nn = a[n.$toHTML](hn);
                if (nn.success)
                  return nn.html ? (Bt || (Bt = ((zt = nn.html.children) == null ? void 0 : zt.length) > 0), Gt[wt].children.push(nn.html)) : !Bt && He.children.length > 1 && He.children.pop(), He;
                if (nn.isBreak()) {
                  const Wt = nn.breakNode;
                  if (Dt(wt), Wt.targetType === "auto")
                    continue;
                  Wt.leader && (It = this[n.$searchNode](Wt.leader, Wt[n.$getParent]()), It = It ? It[0] : null), Wt.trailer && (Rt = this[n.$searchNode](Wt.trailer, Wt[n.$getParent]()), Rt = Rt ? Rt[0] : null), Wt.targetType === "pageArea" ? (yt = Wt[n.$extra].target, wt = 1 / 0) : Wt[n.$extra].target ? (yt = Wt[n.$extra].target, $t = Wt[n.$extra].index + 1, wt = 1 / 0) : wt = Wt[n.$extra].index;
                  continue;
                }
                if (this[n.$extra].overflowNode) {
                  const Wt = this[n.$extra].overflowNode;
                  this[n.$extra].overflowNode = null;
                  const On = Wt[n.$getExtra](), mn = On.target;
                  On.addLeader = On.leader !== null, On.addTrailer = On.trailer !== null, Dt(wt);
                  const ws = wt;
                  if (wt = 1 / 0, mn instanceof At)
                    yt = mn;
                  else if (mn instanceof ie) {
                    const Un = Kt.indexOf(mn);
                    Un !== -1 ? Un > ws ? wt = Un - 1 : $t = Un : (yt = mn[n.$getParent](), $t = yt.contentArea.children.indexOf(mn));
                  }
                  continue;
                }
                Dt(wt);
              }
              this[n.$extra].pageNumber += 1, yt && (yt[n.$isUsable]() ? yt[n.$extra].numberOfUse += 1 : yt = null), Ze = yt || Ze[n.$getNextPage](), yield null;
            }
          }
        }
        w.Template = En;
        class $n extends t.ContentObject {
          constructor(a) {
            super(g, "text"), this.id = a.id || "", this.maxChars = (0, l.getInteger)({
              data: a.maxChars,
              defaultValue: 0,
              validate: (ee) => ee >= 0
            }), this.name = a.name || "", this.rid = a.rid || "", this.use = a.use || "", this.usehref = a.usehref || "";
          }
          [n.$acceptWhitespace]() {
            return !0;
          }
          [n.$onChild](a) {
            return a[n.$namespaceId] === F.NamespaceIds.xhtml.id ? (this[n.$content] = a, !0) : ((0, j.warn)(`XFA - Invalid content in Text: ${a[n.$nodeName]}.`), !1);
          }
          [n.$onText](a) {
            this[n.$content] instanceof t.XFAObject || super[n.$onText](a);
          }
          [n.$finalize]() {
            typeof this[n.$content] == "string" && (this[n.$content] = this[n.$content].replaceAll(`\r
`, `
`));
          }
          [n.$getExtra]() {
            return typeof this[n.$content] == "string" ? this[n.$content].split(/[\u2029\u2028\n]/).reduce((a, ee) => (ee && a.push(ee), a), []).join(`
`) : this[n.$content][n.$text]();
          }
          [n.$toHTML](a) {
            if (typeof this[n.$content] == "string") {
              const ee = p(this[n.$content]).html;
              return this[n.$content].includes("\u2029") ? (ee.name = "div", ee.children = [], this[n.$content].split("\u2029").map((He) => He.split(/[\u2028\n]/).reduce((Ze, it) => (Ze.push({
                name: "span",
                value: it
              }, {
                name: "br"
              }), Ze), [])).forEach((He) => {
                ee.children.push({
                  name: "p",
                  children: He
                });
              })) : /[\u2028\n]/.test(this[n.$content]) && (ee.name = "div", ee.children = [], this[n.$content].split(/[\u2028\n]/).forEach((He) => {
                ee.children.push({
                  name: "span",
                  value: He
                }, {
                  name: "br"
                });
              })), l.HTMLResult.success(ee);
            }
            return this[n.$content][n.$toHTML](a);
          }
        }
        w.Text = $n;
        class jn extends t.XFAObject {
          constructor(a) {
            super(g, "textEdit", !0), this.allowRichText = (0, l.getInteger)({
              data: a.allowRichText,
              defaultValue: 0,
              validate: (ee) => ee === 1
            }), this.hScrollPolicy = (0, l.getStringOption)(a.hScrollPolicy, ["auto", "off", "on"]), this.id = a.id || "", this.multiLine = (0, l.getInteger)({
              data: a.multiLine,
              defaultValue: "",
              validate: (ee) => ee === 0 || ee === 1
            }), this.use = a.use || "", this.usehref = a.usehref || "", this.vScrollPolicy = (0, l.getStringOption)(a.vScrollPolicy, ["auto", "off", "on"]), this.border = null, this.comb = null, this.extras = null, this.margin = null;
          }
          [n.$toHTML](a) {
            var it, dt;
            const ee = (0, e.toStyle)(this, "border", "font", "margin");
            let He;
            const Ze = this[n.$getParent]()[n.$getParent]();
            return this.multiLine === "" && (this.multiLine = Ze instanceof be ? 1 : 0), this.multiLine === 1 ? He = {
              name: "textarea",
              attributes: {
                dataId: ((it = Ze[n.$data]) == null ? void 0 : it[n.$uid]) || Ze[n.$uid],
                fieldId: Ze[n.$uid],
                class: ["xfaTextfield"],
                style: ee,
                "aria-label": u(Ze),
                "aria-required": !1
              }
            } : He = {
              name: "input",
              attributes: {
                type: "text",
                dataId: ((dt = Ze[n.$data]) == null ? void 0 : dt[n.$uid]) || Ze[n.$uid],
                fieldId: Ze[n.$uid],
                class: ["xfaTextfield"],
                style: ee,
                "aria-label": u(Ze),
                "aria-required": !1
              }
            }, f(Ze) && (He.attributes["aria-required"] = !0, He.attributes.required = !0), l.HTMLResult.success({
              name: "label",
              attributes: {
                class: ["xfaLabel"]
              },
              children: [He]
            });
          }
        }
        class Ci extends t.StringObject {
          constructor(a) {
            super(g, "time"), this.id = a.id || "", this.name = a.name || "", this.use = a.use || "", this.usehref = a.usehref || "";
          }
          [n.$finalize]() {
            const a = this[n.$content].trim();
            this[n.$content] = a ? new Date(a) : null;
          }
          [n.$toHTML](a) {
            return p(this[n.$content] ? this[n.$content].toString() : "");
          }
        }
        class ki extends t.XFAObject {
          constructor(a) {
            super(g, "timeStamp"), this.id = a.id || "", this.server = a.server || "", this.type = (0, l.getStringOption)(a.type, ["optional", "required"]), this.use = a.use || "", this.usehref = a.usehref || "";
          }
        }
        class Fi extends t.StringObject {
          constructor(a) {
            super(g, "toolTip"), this.id = a.id || "", this.rid = a.rid || "", this.use = a.use || "", this.usehref = a.usehref || "";
          }
        }
        class Ti extends t.XFAObject {
          constructor(a) {
            super(g, "traversal", !0), this.id = a.id || "", this.use = a.use || "", this.usehref = a.usehref || "", this.extras = null, this.traverse = new t.XFAObjectArray();
          }
        }
        class Ei extends t.XFAObject {
          constructor(a) {
            super(g, "traverse", !0), this.id = a.id || "", this.operation = (0, l.getStringOption)(a.operation, ["next", "back", "down", "first", "left", "right", "up"]), this.ref = a.ref || "", this.use = a.use || "", this.usehref = a.usehref || "", this.extras = null, this.script = null;
          }
          get name() {
            return this.operation;
          }
          [n.$isTransparent]() {
            return !1;
          }
        }
        class In extends t.XFAObject {
          constructor(a) {
            super(g, "ui", !0), this.id = a.id || "", this.use = a.use || "", this.usehref = a.usehref || "", this.extras = null, this.picture = null, this.barcode = null, this.button = null, this.checkButton = null, this.choiceList = null, this.dateTimeEdit = null, this.defaultUi = null, this.imageEdit = null, this.numericEdit = null, this.passwordEdit = null, this.signature = null, this.textEdit = null;
          }
          [n.$getExtra]() {
            if (this[n.$extra] === void 0) {
              for (const a of Object.getOwnPropertyNames(this)) {
                if (a === "extras" || a === "picture")
                  continue;
                const ee = this[a];
                if (ee instanceof t.XFAObject)
                  return this[n.$extra] = ee, ee;
              }
              this[n.$extra] = null;
            }
            return this[n.$extra];
          }
          [n.$toHTML](a) {
            const ee = this[n.$getExtra]();
            return ee ? ee[n.$toHTML](a) : l.HTMLResult.EMPTY;
          }
        }
        class Ii extends t.XFAObject {
          constructor(a) {
            super(g, "validate", !0), this.formatTest = (0, l.getStringOption)(a.formatTest, ["warning", "disabled", "error"]), this.id = a.id || "", this.nullTest = (0, l.getStringOption)(a.nullTest, ["disabled", "error", "warning"]), this.scriptTest = (0, l.getStringOption)(a.scriptTest, ["error", "disabled", "warning"]), this.use = a.use || "", this.usehref = a.usehref || "", this.extras = null, this.message = null, this.picture = null, this.script = null;
          }
        }
        class gn extends t.XFAObject {
          constructor(a) {
            super(g, "value", !0), this.id = a.id || "", this.override = (0, l.getInteger)({
              data: a.override,
              defaultValue: 0,
              validate: (ee) => ee === 1
            }), this.relevant = (0, l.getRelevant)(a.relevant), this.use = a.use || "", this.usehref = a.usehref || "", this.arc = null, this.boolean = null, this.date = null, this.dateTime = null, this.decimal = null, this.exData = null, this.float = null, this.image = null, this.integer = null, this.line = null, this.rectangle = null, this.text = null, this.time = null;
          }
          [n.$setValue](a) {
            var Ze;
            const ee = this[n.$getParent]();
            if (ee instanceof Ye && (Ze = ee.ui) != null && Ze.imageEdit) {
              this.image || (this.image = new Ne({}), this[n.$appendChild](this.image)), this.image[n.$content] = a[n.$content];
              return;
            }
            const He = a[n.$nodeName];
            if (this[He] !== null) {
              this[He][n.$content] = a[n.$content];
              return;
            }
            for (const it of Object.getOwnPropertyNames(this)) {
              const dt = this[it];
              dt instanceof t.XFAObject && (this[it] = null, this[n.$removeChild](dt));
            }
            this[a[n.$nodeName]] = a, this[n.$appendChild](a);
          }
          [n.$text]() {
            if (this.exData)
              return typeof this.exData[n.$content] == "string" ? this.exData[n.$content].trim() : this.exData[n.$content][n.$text]().trim();
            for (const a of Object.getOwnPropertyNames(this)) {
              if (a === "image")
                continue;
              const ee = this[a];
              if (ee instanceof t.XFAObject)
                return (ee[n.$content] || "").toString().trim();
            }
            return null;
          }
          [n.$toHTML](a) {
            for (const ee of Object.getOwnPropertyNames(this)) {
              const He = this[ee];
              if (He instanceof t.XFAObject)
                return He[n.$toHTML](a);
            }
            return l.HTMLResult.EMPTY;
          }
        }
        w.Value = gn;
        class Oi extends t.XFAObject {
          constructor(a) {
            super(g, "variables", !0), this.id = a.id || "", this.use = a.use || "", this.usehref = a.usehref || "", this.boolean = new t.XFAObjectArray(), this.date = new t.XFAObjectArray(), this.dateTime = new t.XFAObjectArray(), this.decimal = new t.XFAObjectArray(), this.exData = new t.XFAObjectArray(), this.float = new t.XFAObjectArray(), this.image = new t.XFAObjectArray(), this.integer = new t.XFAObjectArray(), this.manifest = new t.XFAObjectArray(), this.script = new t.XFAObjectArray(), this.text = new t.XFAObjectArray(), this.time = new t.XFAObjectArray();
          }
          [n.$isTransparent]() {
            return !0;
          }
        }
        class pn {
          static [F.$buildXFAObject](a, ee) {
            if (pn.hasOwnProperty(a)) {
              const He = pn[a](ee);
              return He[n.$setSetAttributes](ee), He;
            }
          }
          static appearanceFilter(a) {
            return new K(a);
          }
          static arc(a) {
            return new _(a);
          }
          static area(a) {
            return new o(a);
          }
          static assist(a) {
            return new m(a);
          }
          static barcode(a) {
            return new s(a);
          }
          static bind(a) {
            return new r(a);
          }
          static bindItems(a) {
            return new y(a);
          }
          static bookend(a) {
            return new M(a);
          }
          static boolean(a) {
            return new $(a);
          }
          static border(a) {
            return new G(a);
          }
          static break(a) {
            return new ce(a);
          }
          static breakAfter(a) {
            return new q(a);
          }
          static breakBefore(a) {
            return new re(a);
          }
          static button(a) {
            return new Z(a);
          }
          static calculate(a) {
            return new te(a);
          }
          static caption(a) {
            return new L(a);
          }
          static certificate(a) {
            return new X(a);
          }
          static certificates(a) {
            return new J(a);
          }
          static checkButton(a) {
            return new Y(a);
          }
          static choiceList(a) {
            return new ae(a);
          }
          static color(a) {
            return new se(a);
          }
          static comb(a) {
            return new Q(a);
          }
          static connect(a) {
            return new z(a);
          }
          static contentArea(a) {
            return new ie(a);
          }
          static corner(a) {
            return new ne(a);
          }
          static date(a) {
            return new W(a);
          }
          static dateTime(a) {
            return new oe(a);
          }
          static dateTimeEdit(a) {
            return new ue(a);
          }
          static decimal(a) {
            return new pe(a);
          }
          static defaultUi(a) {
            return new ve(a);
          }
          static desc(a) {
            return new Ce(a);
          }
          static digestMethod(a) {
            return new Fe(a);
          }
          static digestMethods(a) {
            return new Pe(a);
          }
          static draw(a) {
            return new be(a);
          }
          static edge(a) {
            return new me(a);
          }
          static encoding(a) {
            return new we(a);
          }
          static encodings(a) {
            return new _e(a);
          }
          static encrypt(a) {
            return new Se(a);
          }
          static encryptData(a) {
            return new Ae(a);
          }
          static encryption(a) {
            return new Te(a);
          }
          static encryptionMethod(a) {
            return new ke(a);
          }
          static encryptionMethods(a) {
            return new Ee(a);
          }
          static event(a) {
            return new Ve(a);
          }
          static exData(a) {
            return new je(a);
          }
          static exObject(a) {
            return new at(a);
          }
          static exclGroup(a) {
            return new $e(a);
          }
          static execute(a) {
            return new ct(a);
          }
          static extras(a) {
            return new ze(a);
          }
          static field(a) {
            return new Ye(a);
          }
          static fill(a) {
            return new Qe(a);
          }
          static filter(a) {
            return new Oe(a);
          }
          static float(a) {
            return new he(a);
          }
          static font(a) {
            return new ye(a);
          }
          static format(a) {
            return new Ie(a);
          }
          static handler(a) {
            return new Le(a);
          }
          static hyphenation(a) {
            return new Be(a);
          }
          static image(a) {
            return new Ne(a);
          }
          static imageEdit(a) {
            return new Ue(a);
          }
          static integer(a) {
            return new qe(a);
          }
          static issuers(a) {
            return new tt(a);
          }
          static items(a) {
            return new ht(a);
          }
          static keep(a) {
            return new rt(a);
          }
          static keyUsage(a) {
            return new nt(a);
          }
          static line(a) {
            return new ut(a);
          }
          static linear(a) {
            return new bt(a);
          }
          static lockDocument(a) {
            return new Ge(a);
          }
          static manifest(a) {
            return new We(a);
          }
          static margin(a) {
            return new Je(a);
          }
          static mdp(a) {
            return new et(a);
          }
          static medium(a) {
            return new lt(a);
          }
          static message(a) {
            return new pt(a);
          }
          static numericEdit(a) {
            return new ot(a);
          }
          static occur(a) {
            return new st(a);
          }
          static oid(a) {
            return new gt(a);
          }
          static oids(a) {
            return new vt(a);
          }
          static overflow(a) {
            return new Mt(a);
          }
          static pageArea(a) {
            return new At(a);
          }
          static pageSet(a) {
            return new St(a);
          }
          static para(a) {
            return new Et(a);
          }
          static passwordEdit(a) {
            return new mt(a);
          }
          static pattern(a) {
            return new Ct(a);
          }
          static picture(a) {
            return new ft(a);
          }
          static proto(a) {
            return new Tt(a);
          }
          static radial(a) {
            return new _t(a);
          }
          static reason(a) {
            return new Xt(a);
          }
          static reasons(a) {
            return new kt(a);
          }
          static rectangle(a) {
            return new Ft(a);
          }
          static ref(a) {
            return new Lt(a);
          }
          static script(a) {
            return new jt(a);
          }
          static setProperty(a) {
            return new qt(a);
          }
          static signData(a) {
            return new dn(a);
          }
          static signature(a) {
            return new mi(a);
          }
          static signing(a) {
            return new xi(a);
          }
          static solid(a) {
            return new bi(a);
          }
          static speak(a) {
            return new yi(a);
          }
          static stipple(a) {
            return new wi(a);
          }
          static subform(a) {
            return new Bn(a);
          }
          static subformSet(a) {
            return new Tn(a);
          }
          static subjectDN(a) {
            return new Ai(a);
          }
          static subjectDNs(a) {
            return new Si(a);
          }
          static submit(a) {
            return new vi(a);
          }
          static template(a) {
            return new En(a);
          }
          static text(a) {
            return new $n(a);
          }
          static textEdit(a) {
            return new jn(a);
          }
          static time(a) {
            return new Ci(a);
          }
          static timeStamp(a) {
            return new ki(a);
          }
          static toolTip(a) {
            return new Fi(a);
          }
          static traversal(a) {
            return new Ti(a);
          }
          static traverse(a) {
            return new Ei(a);
          }
          static ui(a) {
            return new In(a);
          }
          static validate(a) {
            return new Ii(a);
          }
          static value(a) {
            return new gn(a);
          }
          static variables(a) {
            return new Oi(a);
          }
        }
        w.TemplateNamespace = pn;
      },
      /* 81 */
      /***/
      (fe, w) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.NamespaceIds = w.$buildXFAObject = void 0;
        const V = Symbol();
        w.$buildXFAObject = V;
        const n = {
          config: {
            id: 0,
            check: (F) => F.startsWith("http://www.xfa.org/schema/xci/")
          },
          connectionSet: {
            id: 1,
            check: (F) => F.startsWith("http://www.xfa.org/schema/xfa-connection-set/")
          },
          datasets: {
            id: 2,
            check: (F) => F.startsWith("http://www.xfa.org/schema/xfa-data/")
          },
          form: {
            id: 3,
            check: (F) => F.startsWith("http://www.xfa.org/schema/xfa-form/")
          },
          localeSet: {
            id: 4,
            check: (F) => F.startsWith("http://www.xfa.org/schema/xfa-locale-set/")
          },
          pdf: {
            id: 5,
            check: (F) => F === "http://ns.adobe.com/xdp/pdf/"
          },
          signature: {
            id: 6,
            check: (F) => F === "http://www.w3.org/2000/09/xmldsig#"
          },
          sourceSet: {
            id: 7,
            check: (F) => F.startsWith("http://www.xfa.org/schema/xfa-source-set/")
          },
          stylesheet: {
            id: 8,
            check: (F) => F === "http://www.w3.org/1999/XSL/Transform"
          },
          template: {
            id: 9,
            check: (F) => F.startsWith("http://www.xfa.org/schema/xfa-template/")
          },
          xdc: {
            id: 10,
            check: (F) => F.startsWith("http://www.xfa.org/schema/xdc/")
          },
          xdp: {
            id: 11,
            check: (F) => F === "http://ns.adobe.com/xdp/"
          },
          xfdf: {
            id: 12,
            check: (F) => F === "http://ns.adobe.com/xfdf/"
          },
          xhtml: {
            id: 13,
            check: (F) => F === "http://www.w3.org/1999/xhtml"
          },
          xmpmeta: {
            id: 14,
            check: (F) => F === "http://ns.adobe.com/xmpmeta/"
          }
        };
        w.NamespaceIds = n;
      },
      /* 82 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.addHTML = t, w.checkDimensions = U, w.flushHTML = e, w.getAvailableSpace = l;
        var n = V(78), F = V(83);
        function C(O, v) {
          return {
            name: "div",
            attributes: {
              class: [O.layout === "lr-tb" ? "xfaLr" : "xfaRl"]
            },
            children: v
          };
        }
        function e(O) {
          if (!O[n.$extra])
            return null;
          const g = {
            name: "div",
            attributes: O[n.$extra].attributes,
            children: O[n.$extra].children
          };
          if (O[n.$extra].failingNode) {
            const b = O[n.$extra].failingNode[n.$flushHTML]();
            b && (O.layout.endsWith("-tb") ? g.children.push(C(O, [b])) : g.children.push(b));
          }
          return g.children.length === 0 ? null : g;
        }
        function t(O, v, g) {
          const b = O[n.$extra], i = b.availableSpace, [P, d, A, I] = g;
          switch (O.layout) {
            case "position": {
              b.width = Math.max(b.width, P + A), b.height = Math.max(b.height, d + I), b.children.push(v);
              break;
            }
            case "lr-tb":
            case "rl-tb":
              (!b.line || b.attempt === 1) && (b.line = C(O, []), b.children.push(b.line), b.numberInLine = 0), b.numberInLine += 1, b.line.children.push(v), b.attempt === 0 ? (b.currentWidth += A, b.height = Math.max(b.height, b.prevHeight + I)) : (b.currentWidth = A, b.prevHeight = b.height, b.height += I, b.attempt = 0), b.width = Math.max(b.width, b.currentWidth);
              break;
            case "rl-row":
            case "row": {
              b.children.push(v), b.width += A, b.height = Math.max(b.height, I);
              const E = (0, F.measureToString)(b.height);
              for (const k of b.children)
                k.attributes.style.height = E;
              break;
            }
            case "table": {
              b.width = Math.min(i.width, Math.max(b.width, A)), b.height += I, b.children.push(v);
              break;
            }
            case "tb": {
              b.width = Math.min(i.width, Math.max(b.width, A)), b.height += I, b.children.push(v);
              break;
            }
          }
        }
        function l(O) {
          const v = O[n.$extra].availableSpace, g = O.margin ? O.margin.topInset + O.margin.bottomInset : 0, b = O.margin ? O.margin.leftInset + O.margin.rightInset : 0;
          switch (O.layout) {
            case "lr-tb":
            case "rl-tb":
              return O[n.$extra].attempt === 0 ? {
                width: v.width - b - O[n.$extra].currentWidth,
                height: v.height - g - O[n.$extra].prevHeight
              } : {
                width: v.width - b,
                height: v.height - g - O[n.$extra].height
              };
            case "rl-row":
            case "row":
              return {
                width: O[n.$extra].columnWidths.slice(O[n.$extra].currentColumn).reduce((P, d) => P + d),
                height: v.height - b
              };
            case "table":
            case "tb":
              return {
                width: v.width - b,
                height: v.height - g - O[n.$extra].height
              };
            case "position":
            default:
              return v;
          }
        }
        function j(O) {
          let v = O.w === "" ? NaN : O.w, g = O.h === "" ? NaN : O.h, [b, i] = [0, 0];
          switch (O.anchorType || "") {
            case "bottomCenter":
              [b, i] = [v / 2, g];
              break;
            case "bottomLeft":
              [b, i] = [0, g];
              break;
            case "bottomRight":
              [b, i] = [v, g];
              break;
            case "middleCenter":
              [b, i] = [v / 2, g / 2];
              break;
            case "middleLeft":
              [b, i] = [0, g / 2];
              break;
            case "middleRight":
              [b, i] = [v, g / 2];
              break;
            case "topCenter":
              [b, i] = [v / 2, 0];
              break;
            case "topRight":
              [b, i] = [v, 0];
              break;
          }
          let P, d;
          switch (O.rotate || 0) {
            case 0:
              [P, d] = [-b, -i];
              break;
            case 90:
              [P, d] = [-i, b], [v, g] = [g, -v];
              break;
            case 180:
              [P, d] = [b, i], [v, g] = [-v, -g];
              break;
            case 270:
              [P, d] = [i, -b], [v, g] = [-g, v];
              break;
          }
          return [O.x + P + Math.min(0, v), O.y + d + Math.min(0, g), Math.abs(v), Math.abs(g)];
        }
        function U(O, v) {
          var I;
          if (O[n.$getTemplateRoot]()[n.$extra].firstUnsplittable === null || O.w === 0 || O.h === 0)
            return !0;
          const g = 2, b = O[n.$getSubformParent](), i = ((I = b[n.$extra]) == null ? void 0 : I.attempt) || 0, [, P, d, A] = j(O);
          switch (b.layout) {
            case "lr-tb":
            case "rl-tb":
              return i === 0 ? O[n.$getTemplateRoot]()[n.$extra].noLayoutFailure ? O.w !== "" ? Math.round(d - v.width) <= g : v.width > g : O.h !== "" && Math.round(A - v.height) > g ? !1 : O.w !== "" ? Math.round(d - v.width) <= g ? !0 : b[n.$extra].numberInLine === 0 ? v.height > g : !1 : v.width > g : O[n.$getTemplateRoot]()[n.$extra].noLayoutFailure ? !0 : O.h !== "" && Math.round(A - v.height) > g ? !1 : O.w === "" || Math.round(d - v.width) <= g ? v.height > g : b[n.$isThereMoreWidth]() ? !1 : v.height > g;
            case "table":
            case "tb":
              return O[n.$getTemplateRoot]()[n.$extra].noLayoutFailure ? !0 : O.h !== "" && !O[n.$isSplittable]() ? Math.round(A - v.height) <= g : O.w === "" || Math.round(d - v.width) <= g ? v.height > g : b[n.$isThereMoreWidth]() ? !1 : v.height > g;
            case "position":
              if (O[n.$getTemplateRoot]()[n.$extra].noLayoutFailure || O.h === "" || Math.round(A + P - v.height) <= g)
                return !0;
              const E = O[n.$getTemplateRoot]()[n.$extra].currentContentArea;
              return A + P > E.h;
            case "rl-row":
            case "row":
              return O[n.$getTemplateRoot]()[n.$extra].noLayoutFailure ? !0 : O.h !== "" ? Math.round(A - v.height) <= g : !0;
            default:
              return !0;
          }
        }
      },
      /* 83 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.computeBbox = b, w.createWrapper = A, w.fixDimensions = i, w.fixTextIndent = I, w.fixURL = f, w.isPrintOnly = k, w.layoutClass = P, w.layoutNode = g, w.measureToString = j, w.setAccess = E, w.setFontFamily = R, w.setMinMaxDimensions = O, w.setPara = x, w.toStyle = d;
        var n = V(78), F = V(2), C = V(84), e = V(85), t = V(86), l = V(87);
        function j(c) {
          return typeof c == "string" ? "0px" : Number.isInteger(c) ? `${c}px` : `${c.toFixed(2)}px`;
        }
        const U = {
          anchorType(c, N) {
            const u = c[n.$getSubformParent]();
            if (!(!u || u.layout && u.layout !== "position"))
              switch ("transform" in N || (N.transform = ""), c.anchorType) {
                case "bottomCenter":
                  N.transform += "translate(-50%, -100%)";
                  break;
                case "bottomLeft":
                  N.transform += "translate(0,-100%)";
                  break;
                case "bottomRight":
                  N.transform += "translate(-100%,-100%)";
                  break;
                case "middleCenter":
                  N.transform += "translate(-50%,-50%)";
                  break;
                case "middleLeft":
                  N.transform += "translate(0,-50%)";
                  break;
                case "middleRight":
                  N.transform += "translate(-100%,-50%)";
                  break;
                case "topCenter":
                  N.transform += "translate(-50%,0)";
                  break;
                case "topRight":
                  N.transform += "translate(-100%,0)";
                  break;
              }
          },
          dimensions(c, N) {
            var B;
            const u = c[n.$getSubformParent]();
            let p = c.w;
            const S = c.h;
            if ((B = u.layout) != null && B.includes("row")) {
              const T = u[n.$extra], D = c.colSpan;
              let K;
              D === -1 ? (K = T.columnWidths.slice(T.currentColumn).reduce((_, o) => _ + o, 0), T.currentColumn = 0) : (K = T.columnWidths.slice(T.currentColumn, T.currentColumn + D).reduce((_, o) => _ + o, 0), T.currentColumn = (T.currentColumn + c.colSpan) % T.columnWidths.length), isNaN(K) || (p = c.w = K);
            }
            N.width = p !== "" ? j(p) : "auto", N.height = S !== "" ? j(S) : "auto";
          },
          position(c, N) {
            const u = c[n.$getSubformParent]();
            u != null && u.layout && u.layout !== "position" || (N.position = "absolute", N.left = j(c.x), N.top = j(c.y));
          },
          rotate(c, N) {
            c.rotate && ("transform" in N || (N.transform = ""), N.transform += `rotate(-${c.rotate}deg)`, N.transformOrigin = "top left");
          },
          presence(c, N) {
            switch (c.presence) {
              case "invisible":
                N.visibility = "hidden";
                break;
              case "hidden":
              case "inactive":
                N.display = "none";
                break;
            }
          },
          hAlign(c, N) {
            if (c[n.$nodeName] === "para")
              switch (c.hAlign) {
                case "justifyAll":
                  N.textAlign = "justify-all";
                  break;
                case "radix":
                  N.textAlign = "left";
                  break;
                default:
                  N.textAlign = c.hAlign;
              }
            else
              switch (c.hAlign) {
                case "left":
                  N.alignSelf = "start";
                  break;
                case "center":
                  N.alignSelf = "center";
                  break;
                case "right":
                  N.alignSelf = "end";
                  break;
              }
          },
          margin(c, N) {
            c.margin && (N.margin = c.margin[n.$toStyle]().margin);
          }
        };
        function O(c, N) {
          c[n.$getSubformParent]().layout === "position" && (c.minW > 0 && (N.minWidth = j(c.minW)), c.maxW > 0 && (N.maxWidth = j(c.maxW)), c.minH > 0 && (N.minHeight = j(c.minH)), c.maxH > 0 && (N.maxHeight = j(c.maxH)));
        }
        function v(c, N, u, p, S, B) {
          const T = new t.TextMeasure(N, u, p, S);
          return typeof c == "string" ? T.addString(c) : c[n.$pushGlyphs](T), T.compute(B);
        }
        function g(c, N) {
          let u = null, p = null, S = !1;
          if ((!c.w || !c.h) && c.value) {
            let B = 0, T = 0;
            c.margin && (B = c.margin.leftInset + c.margin.rightInset, T = c.margin.topInset + c.margin.bottomInset);
            let D = null, K = null;
            c.para && (K = /* @__PURE__ */ Object.create(null), D = c.para.lineHeight === "" ? null : c.para.lineHeight, K.top = c.para.spaceAbove === "" ? 0 : c.para.spaceAbove, K.bottom = c.para.spaceBelow === "" ? 0 : c.para.spaceBelow, K.left = c.para.marginLeft === "" ? 0 : c.para.marginLeft, K.right = c.para.marginRight === "" ? 0 : c.para.marginRight);
            let _ = c.font;
            if (!_) {
              const s = c[n.$getTemplateRoot]();
              let r = c[n.$getParent]();
              for (; r && r !== s; ) {
                if (r.font) {
                  _ = r.font;
                  break;
                }
                r = r[n.$getParent]();
              }
            }
            const o = (c.w || N.width) - B, m = c[n.$globalData].fontFinder;
            if (c.value.exData && c.value.exData[n.$content] && c.value.exData.contentType === "text/html") {
              const s = v(c.value.exData[n.$content], _, K, D, m, o);
              p = s.width, u = s.height, S = s.isBroken;
            } else {
              const s = c.value[n.$text]();
              if (s) {
                const r = v(s, _, K, D, m, o);
                p = r.width, u = r.height, S = r.isBroken;
              }
            }
            p !== null && !c.w && (p += B), u !== null && !c.h && (u += T);
          }
          return {
            w: p,
            h: u,
            isBroken: S
          };
        }
        function b(c, N, u) {
          let p;
          if (c.w !== "" && c.h !== "")
            p = [c.x, c.y, c.w, c.h];
          else {
            if (!u)
              return null;
            let S = c.w;
            if (S === "") {
              if (c.maxW === 0) {
                const T = c[n.$getSubformParent]();
                S = T.layout === "position" && T.w !== "" ? 0 : c.minW;
              } else
                S = Math.min(c.maxW, u.width);
              N.attributes.style.width = j(S);
            }
            let B = c.h;
            if (B === "") {
              if (c.maxH === 0) {
                const T = c[n.$getSubformParent]();
                B = T.layout === "position" && T.h !== "" ? 0 : c.minH;
              } else
                B = Math.min(c.maxH, u.height);
              N.attributes.style.height = j(B);
            }
            p = [c.x, c.y, S, B];
          }
          return p;
        }
        function i(c) {
          var u;
          const N = c[n.$getSubformParent]();
          if ((u = N.layout) != null && u.includes("row")) {
            const p = N[n.$extra], S = c.colSpan;
            let B;
            S === -1 ? B = p.columnWidths.slice(p.currentColumn).reduce((T, D) => T + D, 0) : B = p.columnWidths.slice(p.currentColumn, p.currentColumn + S).reduce((T, D) => T + D, 0), isNaN(B) || (c.w = B);
          }
          N.layout && N.layout !== "position" && (c.x = c.y = 0), c.layout === "table" && c.w === "" && Array.isArray(c.columnWidths) && (c.w = c.columnWidths.reduce((p, S) => p + S, 0));
        }
        function P(c) {
          switch (c.layout) {
            case "position":
              return "xfaPosition";
            case "lr-tb":
              return "xfaLrTb";
            case "rl-row":
              return "xfaRlRow";
            case "rl-tb":
              return "xfaRlTb";
            case "row":
              return "xfaRow";
            case "table":
              return "xfaTable";
            case "tb":
              return "xfaTb";
            default:
              return "xfaPosition";
          }
        }
        function d(c, ...N) {
          const u = /* @__PURE__ */ Object.create(null);
          for (const p of N) {
            const S = c[p];
            if (S !== null) {
              if (U.hasOwnProperty(p)) {
                U[p](c, u);
                continue;
              }
              if (S instanceof l.XFAObject) {
                const B = S[n.$toStyle]();
                B ? Object.assign(u, B) : (0, F.warn)(`(DEBUG) - XFA - style for ${p} not implemented yet`);
              }
            }
          }
          return u;
        }
        function A(c, N) {
          const {
            attributes: u
          } = N, {
            style: p
          } = u, S = {
            name: "div",
            attributes: {
              class: ["xfaWrapper"],
              style: /* @__PURE__ */ Object.create(null)
            },
            children: []
          };
          if (u.class.push("xfaWrapped"), c.border) {
            const {
              widths: B,
              insets: T
            } = c.border[n.$extra];
            let D, K, _ = T[0], o = T[3];
            const m = T[0] + T[2], s = T[1] + T[3];
            switch (c.border.hand) {
              case "even":
                _ -= B[0] / 2, o -= B[3] / 2, D = `calc(100% + ${(B[1] + B[3]) / 2 - s}px)`, K = `calc(100% + ${(B[0] + B[2]) / 2 - m}px)`;
                break;
              case "left":
                _ -= B[0], o -= B[3], D = `calc(100% + ${B[1] + B[3] - s}px)`, K = `calc(100% + ${B[0] + B[2] - m}px)`;
                break;
              case "right":
                D = s ? `calc(100% - ${s}px)` : "100%", K = m ? `calc(100% - ${m}px)` : "100%";
                break;
            }
            const r = ["xfaBorder"];
            k(c.border) && r.push("xfaPrintOnly");
            const y = {
              name: "div",
              attributes: {
                class: r,
                style: {
                  top: `${_}px`,
                  left: `${o}px`,
                  width: D,
                  height: K
                }
              },
              children: []
            };
            for (const M of ["border", "borderWidth", "borderColor", "borderRadius", "borderStyle"])
              p[M] !== void 0 && (y.attributes.style[M] = p[M], delete p[M]);
            S.children.push(y, N);
          } else
            S.children.push(N);
          for (const B of ["background", "backgroundClip", "top", "left", "width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "transform", "transformOrigin", "visibility"])
            p[B] !== void 0 && (S.attributes.style[B] = p[B], delete p[B]);
          return S.attributes.style.position = p.position === "absolute" ? "absolute" : "relative", delete p.position, p.alignSelf && (S.attributes.style.alignSelf = p.alignSelf, delete p.alignSelf), S;
        }
        function I(c) {
          const N = (0, C.getMeasurement)(c.textIndent, "0px");
          if (N >= 0)
            return;
          const p = "padding" + ((c.textAlign === "right" ? "right" : "left") === "left" ? "Left" : "Right"), S = (0, C.getMeasurement)(c[p], "0px");
          c[p] = `${S - N}px`;
        }
        function E(c, N) {
          switch (c.access) {
            case "nonInteractive":
              N.push("xfaNonInteractive");
              break;
            case "readOnly":
              N.push("xfaReadOnly");
              break;
            case "protected":
              N.push("xfaDisabled");
              break;
          }
        }
        function k(c) {
          return c.relevant.length > 0 && !c.relevant[0].excluded && c.relevant[0].viewname === "print";
        }
        function H(c) {
          const N = c[n.$getTemplateRoot]()[n.$extra].paraStack;
          return N.length ? N.at(-1) : null;
        }
        function x(c, N, u) {
          var p;
          if ((p = u.attributes.class) != null && p.includes("xfaRich")) {
            N && (c.h === "" && (N.height = "auto"), c.w === "" && (N.width = "auto"));
            const S = H(c);
            if (S) {
              const B = u.attributes.style;
              switch (B.display = "flex", B.flexDirection = "column", S.vAlign) {
                case "top":
                  B.justifyContent = "start";
                  break;
                case "bottom":
                  B.justifyContent = "end";
                  break;
                case "middle":
                  B.justifyContent = "center";
                  break;
              }
              const T = S[n.$toStyle]();
              for (const [D, K] of Object.entries(T))
                D in B || (B[D] = K);
            }
          }
        }
        function R(c, N, u, p) {
          if (!u) {
            delete p.fontFamily;
            return;
          }
          const S = (0, C.stripQuotes)(c.typeface);
          p.fontFamily = `"${S}"`;
          const B = u.find(S);
          if (B) {
            const {
              fontFamily: T
            } = B.regular.cssFontInfo;
            T !== S && (p.fontFamily = `"${T}"`);
            const D = H(N);
            if (D && D.lineHeight !== "" || p.lineHeight)
              return;
            const K = (0, e.selectFont)(c, B);
            K && (p.lineHeight = Math.max(1.2, K.lineHeight));
          }
        }
        function f(c) {
          const N = (0, F.createValidAbsoluteUrl)(c, null, {
            addDefaultProtocol: !0,
            tryConvertEncoding: !0
          });
          return N ? N.href : null;
        }
      },
      /* 84 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.HTMLResult = void 0, w.getBBox = i, w.getColor = b, w.getFloat = l, w.getInteger = t, w.getKeyword = j, w.getMeasurement = O, w.getRatio = v, w.getRelevant = g, w.getStringOption = U, w.stripQuotes = e;
        var n = V(2);
        const F = {
          pt: (d) => d,
          cm: (d) => d / 2.54 * 72,
          mm: (d) => d / (10 * 2.54) * 72,
          in: (d) => d * 72,
          px: (d) => d
        }, C = /([+-]?\d+\.?\d*)(.*)/;
        function e(d) {
          return d.startsWith("'") || d.startsWith('"') ? d.slice(1, -1) : d;
        }
        function t({
          data: d,
          defaultValue: A,
          validate: I
        }) {
          if (!d)
            return A;
          d = d.trim();
          const E = parseInt(d, 10);
          return !isNaN(E) && I(E) ? E : A;
        }
        function l({
          data: d,
          defaultValue: A,
          validate: I
        }) {
          if (!d)
            return A;
          d = d.trim();
          const E = parseFloat(d);
          return !isNaN(E) && I(E) ? E : A;
        }
        function j({
          data: d,
          defaultValue: A,
          validate: I
        }) {
          return d ? (d = d.trim(), I(d) ? d : A) : A;
        }
        function U(d, A) {
          return j({
            data: d,
            defaultValue: A[0],
            validate: (I) => A.includes(I)
          });
        }
        function O(d, A = "0") {
          if (A || (A = "0"), !d)
            return O(A);
          const I = d.trim().match(C);
          if (!I)
            return O(A);
          const [, E, k] = I, H = parseFloat(E);
          if (isNaN(H))
            return O(A);
          if (H === 0)
            return 0;
          const x = F[k];
          return x ? x(H) : H;
        }
        function v(d) {
          if (!d)
            return {
              num: 1,
              den: 1
            };
          const A = d.trim().split(/\s*:\s*/).map((k) => parseFloat(k)).filter((k) => !isNaN(k));
          if (A.length === 1 && A.push(1), A.length === 0)
            return {
              num: 1,
              den: 1
            };
          const [I, E] = A;
          return {
            num: I,
            den: E
          };
        }
        function g(d) {
          return d ? d.trim().split(/\s+/).map((A) => ({
            excluded: A[0] === "-",
            viewname: A.substring(1)
          })) : [];
        }
        function b(d, A = [0, 0, 0]) {
          let [I, E, k] = A;
          if (!d)
            return {
              r: I,
              g: E,
              b: k
            };
          const H = d.trim().split(/\s*,\s*/).map((x) => Math.min(Math.max(0, parseInt(x.trim(), 10)), 255)).map((x) => isNaN(x) ? 0 : x);
          return H.length < 3 ? {
            r: I,
            g: E,
            b: k
          } : ([I, E, k] = H, {
            r: I,
            g: E,
            b: k
          });
        }
        function i(d) {
          if (!d)
            return {
              x: -1,
              y: -1,
              width: -1,
              height: -1
            };
          const I = d.trim().split(/\s*,\s*/).map((R) => O(R, "-1"));
          if (I.length < 4 || I[2] < 0 || I[3] < 0)
            return {
              x: -1,
              y: -1,
              width: -1,
              height: -1
            };
          const [E, k, H, x] = I;
          return {
            x: E,
            y: k,
            width: H,
            height: x
          };
        }
        class P {
          static get FAILURE() {
            return (0, n.shadow)(this, "FAILURE", new P(!1, null, null, null));
          }
          static get EMPTY() {
            return (0, n.shadow)(this, "EMPTY", new P(!0, null, null, null));
          }
          constructor(A, I, E, k) {
            this.success = A, this.html = I, this.bbox = E, this.breakNode = k;
          }
          isBreak() {
            return !!this.breakNode;
          }
          static breakNode(A) {
            return new P(!1, null, null, A);
          }
          static success(A, I = null) {
            return new P(!0, A, I, null);
          }
        }
        w.HTMLResult = P;
      },
      /* 85 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.FontFinder = void 0, w.getMetrics = l, w.selectFont = t;
        var n = V(78), F = V(84), C = V(2);
        class e {
          constructor(U) {
            this.fonts = /* @__PURE__ */ new Map(), this.cache = /* @__PURE__ */ new Map(), this.warned = /* @__PURE__ */ new Set(), this.defaultFont = null, this.add(U);
          }
          add(U, O = null) {
            for (const g of U)
              this.addPdfFont(g);
            for (const g of this.fonts.values())
              g.regular || (g.regular = g.italic || g.bold || g.bolditalic);
            if (!O || O.size === 0)
              return;
            const v = this.fonts.get("PdfJS-Fallback-PdfJS-XFA");
            for (const g of O)
              this.fonts.set(g, v);
          }
          addPdfFont(U) {
            var P, d, A;
            const O = U.cssFontInfo, v = O.fontFamily;
            let g = this.fonts.get(v);
            g || (g = /* @__PURE__ */ Object.create(null), this.fonts.set(v, g), this.defaultFont || (this.defaultFont = g));
            let b = "";
            const i = parseFloat(O.fontWeight);
            parseFloat(O.italicAngle) !== 0 ? b = i >= 700 ? "bolditalic" : "italic" : i >= 700 && (b = "bold"), b || ((U.name.includes("Bold") || (P = U.psName) != null && P.includes("Bold")) && (b = "bold"), (U.name.includes("Italic") || U.name.endsWith("It") || (d = U.psName) != null && d.includes("Italic") || (A = U.psName) != null && A.endsWith("It")) && (b += "italic")), b || (b = "regular"), g[b] = U;
          }
          getDefault() {
            return this.defaultFont;
          }
          find(U, O = !0) {
            var P, d;
            let v = this.fonts.get(U) || this.cache.get(U);
            if (v)
              return v;
            const g = /,|-|_| |bolditalic|bold|italic|regular|it/gi;
            let b = U.replaceAll(g, "");
            if (v = this.fonts.get(b), v)
              return this.cache.set(U, v), v;
            b = b.toLowerCase();
            const i = [];
            for (const [A, I] of this.fonts.entries())
              A.replaceAll(g, "").toLowerCase().startsWith(b) && i.push(I);
            if (i.length === 0)
              for (const [, A] of this.fonts.entries())
                (P = A.regular.name) != null && P.replaceAll(g, "").toLowerCase().startsWith(b) && i.push(A);
            if (i.length === 0) {
              b = b.replaceAll(/psmt|mt/gi, "");
              for (const [A, I] of this.fonts.entries())
                A.replaceAll(g, "").toLowerCase().startsWith(b) && i.push(I);
            }
            if (i.length === 0)
              for (const A of this.fonts.values())
                (d = A.regular.name) != null && d.replaceAll(g, "").toLowerCase().startsWith(b) && i.push(A);
            return i.length >= 1 ? (i.length !== 1 && O && (0, C.warn)(`XFA - Too many choices to guess the correct font: ${U}`), this.cache.set(U, i[0]), i[0]) : (O && !this.warned.has(U) && (this.warned.add(U), (0, C.warn)(`XFA - Cannot find the font: ${U}`)), null);
          }
        }
        w.FontFinder = e;
        function t(j, U) {
          return j.posture === "italic" ? j.weight === "bold" ? U.bolditalic : U.italic : j.weight === "bold" ? U.bold : U.regular;
        }
        function l(j, U = !1) {
          let O = null;
          if (j) {
            const i = (0, F.stripQuotes)(j.typeface), P = j[n.$globalData].fontFinder.find(i);
            O = t(j, P);
          }
          if (!O)
            return {
              lineHeight: 12,
              lineGap: 2,
              lineNoGap: 10
            };
          const v = j.size || 10, g = O.lineHeight ? Math.max(U ? 0 : 1.2, O.lineHeight) : 1.2, b = O.lineGap === void 0 ? 0.2 : O.lineGap;
          return {
            lineHeight: g * v,
            lineGap: b * v,
            lineNoGap: Math.max(1, g - b) * v
          };
        }
      },
      /* 86 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.TextMeasure = void 0;
        var n = V(85);
        const F = 1.02;
        class C {
          constructor(j, U, O, v) {
            if (this.lineHeight = O, this.paraMargin = U || {
              top: 0,
              bottom: 0,
              left: 0,
              right: 0
            }, !j) {
              [this.pdfFont, this.xfaFont] = this.defaultFont(v);
              return;
            }
            this.xfaFont = {
              typeface: j.typeface,
              posture: j.posture,
              weight: j.weight,
              size: j.size,
              letterSpacing: j.letterSpacing
            };
            const g = v.find(j.typeface);
            if (!g) {
              [this.pdfFont, this.xfaFont] = this.defaultFont(v);
              return;
            }
            this.pdfFont = (0, n.selectFont)(j, g), this.pdfFont || ([this.pdfFont, this.xfaFont] = this.defaultFont(v));
          }
          defaultFont(j) {
            const U = j.find("Helvetica", !1) || j.find("Myriad Pro", !1) || j.find("Arial", !1) || j.getDefault();
            if (U != null && U.regular) {
              const v = U.regular, b = {
                typeface: v.cssFontInfo.fontFamily,
                posture: "normal",
                weight: "normal",
                size: 10,
                letterSpacing: 0
              };
              return [v, b];
            }
            return [null, {
              typeface: "Courier",
              posture: "normal",
              weight: "normal",
              size: 10,
              letterSpacing: 0
            }];
          }
        }
        class e {
          constructor(j, U, O, v) {
            this.fontFinder = v, this.stack = [new C(j, U, O, v)];
          }
          pushData(j, U, O) {
            const v = this.stack.at(-1);
            for (const b of ["typeface", "posture", "weight", "size", "letterSpacing"])
              j[b] || (j[b] = v.xfaFont[b]);
            for (const b of ["top", "bottom", "left", "right"])
              isNaN(U[b]) && (U[b] = v.paraMargin[b]);
            const g = new C(j, U, O || v.lineHeight, this.fontFinder);
            g.pdfFont || (g.pdfFont = v.pdfFont), this.stack.push(g);
          }
          popFont() {
            this.stack.pop();
          }
          topFont() {
            return this.stack.at(-1);
          }
        }
        class t {
          constructor(j, U, O, v) {
            this.glyphs = [], this.fontSelector = new e(j, U, O, v), this.extraHeight = 0;
          }
          pushData(j, U, O) {
            this.fontSelector.pushData(j, U, O);
          }
          popFont(j) {
            return this.fontSelector.popFont();
          }
          addPara() {
            const j = this.fontSelector.topFont();
            this.extraHeight += j.paraMargin.top + j.paraMargin.bottom;
          }
          addString(j) {
            if (!j)
              return;
            const U = this.fontSelector.topFont(), O = U.xfaFont.size;
            if (U.pdfFont) {
              const v = U.xfaFont.letterSpacing, g = U.pdfFont, b = g.lineHeight || 1.2, i = U.lineHeight || Math.max(1.2, b) * O, P = g.lineGap === void 0 ? 0.2 : g.lineGap, d = b - P, A = Math.max(1, d) * O, I = O / 1e3, E = g.defaultWidth || g.charsToGlyphs(" ")[0].width;
              for (const k of j.split(/[\u2029\n]/)) {
                const H = g.encodeString(k).join(""), x = g.charsToGlyphs(H);
                for (const R of x) {
                  const f = R.width || E;
                  this.glyphs.push([f * I + v, i, A, R.unicode, !1]);
                }
                this.glyphs.push([0, 0, 0, `
`, !0]);
              }
              this.glyphs.pop();
              return;
            }
            for (const v of j.split(/[\u2029\n]/)) {
              for (const g of v.split(""))
                this.glyphs.push([O, 1.2 * O, O, g, !1]);
              this.glyphs.push([0, 0, 0, `
`, !0]);
            }
            this.glyphs.pop();
          }
          compute(j) {
            let U = -1, O = 0, v = 0, g = 0, b = 0, i = 0, P = !1, d = !0;
            for (let A = 0, I = this.glyphs.length; A < I; A++) {
              const [E, k, H, x, R] = this.glyphs[A], f = x === " ", c = d ? H : k;
              if (R) {
                v = Math.max(v, b), b = 0, g += i, i = c, U = -1, O = 0, d = !1;
                continue;
              }
              if (f) {
                b + E > j ? (v = Math.max(v, b), b = 0, g += i, i = c, U = -1, O = 0, P = !0, d = !1) : (i = Math.max(c, i), O = b, b += E, U = A);
                continue;
              }
              if (b + E > j) {
                g += i, i = c, U !== -1 ? (A = U, v = Math.max(v, O), b = 0, U = -1, O = 0) : (v = Math.max(v, b), b = E), P = !0, d = !1;
                continue;
              }
              b += E, i = Math.max(c, i);
            }
            return v = Math.max(v, b), g += i + this.extraHeight, {
              width: F * v,
              height: g,
              isBroken: P
            };
          }
        }
        w.TextMeasure = t;
      },
      /* 87 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.XmlObject = w.XFAObjectArray = w.XFAObject = w.XFAAttribute = w.StringObject = w.OptionObject = w.Option10 = w.Option01 = w.IntegerObject = w.ContentObject = void 0;
        var n = V(78), F = V(84), C = V(2), e = V(3), t = V(81), l = V(88);
        const j = Symbol(), U = Symbol(), O = Symbol(), v = Symbol("_children"), g = Symbol(), b = Symbol(), i = Symbol(), P = Symbol(), d = Symbol(), A = Symbol(), I = Symbol(), E = Symbol(), k = Symbol(), H = Symbol("parent"), x = Symbol(), R = Symbol(), f = Symbol();
        let c = 0;
        const N = t.NamespaceIds.datasets.id;
        class u {
          constructor(r, y, M = !1) {
            this[n.$namespaceId] = r, this[n.$nodeName] = y, this[I] = M, this[H] = null, this[v] = [], this[n.$uid] = `${y}${c++}`, this[n.$globalData] = null;
          }
          get isXFAObject() {
            return !0;
          }
          get isXFAObjectArray() {
            return !1;
          }
          createNodes(r) {
            let y = this, M = null;
            for (const {
              name: $,
              index: G
            } of r) {
              for (let ce = 0, q = isFinite(G) ? G : 0; ce <= q; ce++) {
                const re = y[n.$namespaceId] === N ? -1 : y[n.$namespaceId];
                M = new B(re, $), y[n.$appendChild](M);
              }
              y = M;
            }
            return M;
          }
          [n.$onChild](r) {
            if (!this[I] || !this[n.$onChildCheck](r))
              return !1;
            const y = r[n.$nodeName], M = this[y];
            if (M instanceof p) {
              if (M.push(r))
                return this[n.$appendChild](r), !0;
            } else
              return M !== null && this[n.$removeChild](M), this[y] = r, this[n.$appendChild](r), !0;
            let $ = "";
            return this.id ? $ = ` (id: ${this.id})` : this.name && ($ = ` (name: ${this.name} ${this.h.value})`), (0, C.warn)(`XFA - node "${this[n.$nodeName]}"${$} has already enough "${y}"!`), !1;
          }
          [n.$onChildCheck](r) {
            return this.hasOwnProperty(r[n.$nodeName]) && r[n.$namespaceId] === this[n.$namespaceId];
          }
          [n.$isNsAgnostic]() {
            return !1;
          }
          [n.$acceptWhitespace]() {
            return !1;
          }
          [n.$isCDATAXml]() {
            return !1;
          }
          [n.$isBindable]() {
            return !1;
          }
          [n.$popPara]() {
            this.para && this[n.$getTemplateRoot]()[n.$extra].paraStack.pop();
          }
          [n.$pushPara]() {
            this[n.$getTemplateRoot]()[n.$extra].paraStack.push(this.para);
          }
          [n.$setId](r) {
            this.id && this[n.$namespaceId] === t.NamespaceIds.template.id && r.set(this.id, this);
          }
          [n.$getTemplateRoot]() {
            return this[n.$globalData].template;
          }
          [n.$isSplittable]() {
            return !1;
          }
          [n.$isThereMoreWidth]() {
            return !1;
          }
          [n.$appendChild](r) {
            r[H] = this, this[v].push(r), !r[n.$globalData] && this[n.$globalData] && (r[n.$globalData] = this[n.$globalData]);
          }
          [n.$removeChild](r) {
            const y = this[v].indexOf(r);
            this[v].splice(y, 1);
          }
          [n.$hasSettableValue]() {
            return this.hasOwnProperty("value");
          }
          [n.$setValue](r) {
          }
          [n.$onText](r) {
          }
          [n.$finalize]() {
          }
          [n.$clean](r) {
            delete this[I], this[n.$cleanup] && (r.clean(this[n.$cleanup]), delete this[n.$cleanup]);
          }
          [n.$indexOf](r) {
            return this[v].indexOf(r);
          }
          [n.$insertAt](r, y) {
            y[H] = this, this[v].splice(r, 0, y), !y[n.$globalData] && this[n.$globalData] && (y[n.$globalData] = this[n.$globalData]);
          }
          [n.$isTransparent]() {
            return !this.name;
          }
          [n.$lastAttribute]() {
            return "";
          }
          [n.$text]() {
            return this[v].length === 0 ? this[n.$content] : this[v].map((r) => r[n.$text]()).join("");
          }
          get [O]() {
            const r = Object.getPrototypeOf(this);
            if (!r._attributes) {
              const y = r._attributes = /* @__PURE__ */ new Set();
              for (const M of Object.getOwnPropertyNames(this)) {
                if (this[M] === null || this[M] instanceof u || this[M] instanceof p)
                  break;
                y.add(M);
              }
            }
            return (0, C.shadow)(this, O, r._attributes);
          }
          [n.$isDescendent](r) {
            let y = this;
            for (; y; ) {
              if (y === r)
                return !0;
              y = y[n.$getParent]();
            }
            return !1;
          }
          [n.$getParent]() {
            return this[H];
          }
          [n.$getSubformParent]() {
            return this[n.$getParent]();
          }
          [n.$getChildren](r = null) {
            return r ? this[r] : this[v];
          }
          [n.$dump]() {
            const r = /* @__PURE__ */ Object.create(null);
            this[n.$content] && (r.$content = this[n.$content]);
            for (const y of Object.getOwnPropertyNames(this)) {
              const M = this[y];
              M !== null && (M instanceof u ? r[y] = M[n.$dump]() : M instanceof p ? M.isEmpty() || (r[y] = M.dump()) : r[y] = M);
            }
            return r;
          }
          [n.$toStyle]() {
            return null;
          }
          [n.$toHTML]() {
            return F.HTMLResult.EMPTY;
          }
          *[n.$getContainedChildren]() {
            for (const r of this[n.$getChildren]())
              yield r;
          }
          *[P](r, y) {
            for (const M of this[n.$getContainedChildren]())
              if (!r || y === r.has(M[n.$nodeName])) {
                const $ = this[n.$getAvailableSpace](), G = M[n.$toHTML]($);
                G.success || (this[n.$extra].failingNode = M), yield G;
              }
          }
          [n.$flushHTML]() {
            return null;
          }
          [n.$addHTML](r, y) {
            this[n.$extra].children.push(r);
          }
          [n.$getAvailableSpace]() {
          }
          [n.$childrenToHTML]({
            filter: r = null,
            include: y = !0
          }) {
            if (!this[n.$extra].generator)
              this[n.$extra].generator = this[P](r, y);
            else {
              const M = this[n.$getAvailableSpace](), $ = this[n.$extra].failingNode[n.$toHTML](M);
              if (!$.success)
                return $;
              $.html && this[n.$addHTML]($.html, $.bbox), delete this[n.$extra].failingNode;
            }
            for (; ; ) {
              const M = this[n.$extra].generator.next();
              if (M.done)
                break;
              const $ = M.value;
              if (!$.success)
                return $;
              $.html && this[n.$addHTML]($.html, $.bbox);
            }
            return this[n.$extra].generator = null, F.HTMLResult.EMPTY;
          }
          [n.$setSetAttributes](r) {
            this[R] = new Set(Object.keys(r));
          }
          [A](r) {
            const y = this[O], M = this[R];
            return [...r].filter(($) => y.has($) && !M.has($));
          }
          [n.$resolvePrototypes](r, y = /* @__PURE__ */ new Set()) {
            for (const M of this[v])
              M[x](r, y);
          }
          [x](r, y) {
            const M = this[d](r, y);
            M ? this[j](M, r, y) : this[n.$resolvePrototypes](r, y);
          }
          [d](r, y) {
            const {
              use: M,
              usehref: $
            } = this;
            if (!M && !$)
              return null;
            let G = null, ce = null, q = null, re = M;
            if ($ ? (re = $, $.startsWith("#som(") && $.endsWith(")") ? ce = $.slice(5, -1) : $.startsWith(".#som(") && $.endsWith(")") ? ce = $.slice(6, -1) : $.startsWith("#") ? q = $.slice(1) : $.startsWith(".#") && (q = $.slice(2))) : M.startsWith("#") ? q = M.slice(1) : ce = M, this.use = this.usehref = "", q ? G = r.get(q) : (G = (0, l.searchNode)(r.get(n.$root), this, ce, !0, !1), G && (G = G[0])), !G)
              return (0, C.warn)(`XFA - Invalid prototype reference: ${re}.`), null;
            if (G[n.$nodeName] !== this[n.$nodeName])
              return (0, C.warn)(`XFA - Incompatible prototype: ${G[n.$nodeName]} !== ${this[n.$nodeName]}.`), null;
            if (y.has(G))
              return (0, C.warn)("XFA - Cycle detected in prototypes use."), null;
            y.add(G);
            const Z = G[d](r, y);
            return Z && G[j](Z, r, y), G[n.$resolvePrototypes](r, y), y.delete(G), G;
          }
          [j](r, y, M) {
            if (M.has(r)) {
              (0, C.warn)("XFA - Cycle detected in prototypes use.");
              return;
            }
            !this[n.$content] && r[n.$content] && (this[n.$content] = r[n.$content]), new Set(M).add(r);
            for (const G of this[A](r[R]))
              this[G] = r[G], this[R] && this[R].add(G);
            for (const G of Object.getOwnPropertyNames(this)) {
              if (this[O].has(G))
                continue;
              const ce = this[G], q = r[G];
              if (ce instanceof p) {
                for (const re of ce[v])
                  re[x](y, M);
                for (let re = ce[v].length, Z = q[v].length; re < Z; re++) {
                  const te = r[v][re][n.$clone]();
                  if (ce.push(te))
                    te[H] = this, this[v].push(te), te[x](y, M);
                  else
                    break;
                }
                continue;
              }
              if (ce !== null) {
                ce[n.$resolvePrototypes](y, M), q && ce[j](q, y, M);
                continue;
              }
              if (q !== null) {
                const re = q[n.$clone]();
                re[H] = this, this[G] = re, this[v].push(re), re[x](y, M);
              }
            }
          }
          static [g](r) {
            return Array.isArray(r) ? r.map((y) => u[g](y)) : typeof r == "object" && r !== null ? Object.assign({}, r) : r;
          }
          [n.$clone]() {
            const r = Object.create(Object.getPrototypeOf(this));
            for (const y of Object.getOwnPropertySymbols(this))
              try {
                r[y] = this[y];
              } catch {
                (0, C.shadow)(r, y, this[y]);
              }
            r[n.$uid] = `${r[n.$nodeName]}${c++}`, r[v] = [];
            for (const y of Object.getOwnPropertyNames(this)) {
              if (this[O].has(y)) {
                r[y] = u[g](this[y]);
                continue;
              }
              const M = this[y];
              r[y] = M instanceof p ? new p(M[E]) : null;
            }
            for (const y of this[v]) {
              const M = y[n.$nodeName], $ = y[n.$clone]();
              r[v].push($), $[H] = r, r[M] === null ? r[M] = $ : r[M][v].push($);
            }
            return r;
          }
          [n.$getChildren](r = null) {
            return r ? this[v].filter((y) => y[n.$nodeName] === r) : this[v];
          }
          [n.$getChildrenByClass](r) {
            return this[r];
          }
          [n.$getChildrenByName](r, y, M = !0) {
            return Array.from(this[n.$getChildrenByNameIt](r, y, M));
          }
          *[n.$getChildrenByNameIt](r, y, M = !0) {
            if (r === "parent") {
              yield this[H];
              return;
            }
            for (const $ of this[v])
              $[n.$nodeName] === r && (yield $), $.name === r && (yield $), (y || $[n.$isTransparent]()) && (yield* $[n.$getChildrenByNameIt](r, y, !1));
            M && this[O].has(r) && (yield new S(this, r, this[r]));
          }
        }
        w.XFAObject = u;
        class p {
          constructor(r = 1 / 0) {
            this[E] = r, this[v] = [];
          }
          get isXFAObject() {
            return !1;
          }
          get isXFAObjectArray() {
            return !0;
          }
          push(r) {
            return this[v].length <= this[E] ? (this[v].push(r), !0) : ((0, C.warn)(`XFA - node "${r[n.$nodeName]}" accepts no more than ${this[E]} children`), !1);
          }
          isEmpty() {
            return this[v].length === 0;
          }
          dump() {
            return this[v].length === 1 ? this[v][0][n.$dump]() : this[v].map((r) => r[n.$dump]());
          }
          [n.$clone]() {
            const r = new p(this[E]);
            return r[v] = this[v].map((y) => y[n.$clone]()), r;
          }
          get children() {
            return this[v];
          }
          clear() {
            this[v].length = 0;
          }
        }
        w.XFAObjectArray = p;
        class S {
          constructor(r, y, M) {
            this[H] = r, this[n.$nodeName] = y, this[n.$content] = M, this[n.$consumed] = !1, this[n.$uid] = `attribute${c++}`;
          }
          [n.$getParent]() {
            return this[H];
          }
          [n.$isDataValue]() {
            return !0;
          }
          [n.$getDataValue]() {
            return this[n.$content].trim();
          }
          [n.$setValue](r) {
            r = r.value || "", this[n.$content] = r.toString();
          }
          [n.$text]() {
            return this[n.$content];
          }
          [n.$isDescendent](r) {
            return this[H] === r || this[H][n.$isDescendent](r);
          }
        }
        w.XFAAttribute = S;
        class B extends u {
          constructor(r, y, M = {}) {
            if (super(r, y), this[n.$content] = "", this[b] = null, y !== "#text") {
              const $ = /* @__PURE__ */ new Map();
              this[U] = $;
              for (const [G, ce] of Object.entries(M))
                $.set(G, new S(this, G, ce));
              if (M.hasOwnProperty(n.$nsAttributes)) {
                const G = M[n.$nsAttributes].xfa.dataNode;
                G !== void 0 && (G === "dataGroup" ? this[b] = !1 : G === "dataValue" && (this[b] = !0));
              }
            }
            this[n.$consumed] = !1;
          }
          [n.$toString](r) {
            const y = this[n.$nodeName];
            if (y === "#text") {
              r.push((0, e.encodeToXmlString)(this[n.$content]));
              return;
            }
            const M = (0, C.utf8StringToString)(y), $ = this[n.$namespaceId] === N ? "xfa:" : "";
            r.push(`<${$}${M}`);
            for (const [G, ce] of this[U].entries()) {
              const q = (0, C.utf8StringToString)(G);
              r.push(` ${q}="${(0, e.encodeToXmlString)(ce[n.$content])}"`);
            }
            if (this[b] !== null && (this[b] ? r.push(' xfa:dataNode="dataValue"') : r.push(' xfa:dataNode="dataGroup"')), !this[n.$content] && this[v].length === 0) {
              r.push("/>");
              return;
            }
            if (r.push(">"), this[n.$content])
              typeof this[n.$content] == "string" ? r.push((0, e.encodeToXmlString)(this[n.$content])) : this[n.$content][n.$toString](r);
            else
              for (const G of this[v])
                G[n.$toString](r);
            r.push(`</${$}${M}>`);
          }
          [n.$onChild](r) {
            if (this[n.$content]) {
              const y = new B(this[n.$namespaceId], "#text");
              this[n.$appendChild](y), y[n.$content] = this[n.$content], this[n.$content] = "";
            }
            return this[n.$appendChild](r), !0;
          }
          [n.$onText](r) {
            this[n.$content] += r;
          }
          [n.$finalize]() {
            if (this[n.$content] && this[v].length > 0) {
              const r = new B(this[n.$namespaceId], "#text");
              this[n.$appendChild](r), r[n.$content] = this[n.$content], delete this[n.$content];
            }
          }
          [n.$toHTML]() {
            return this[n.$nodeName] === "#text" ? F.HTMLResult.success({
              name: "#text",
              value: this[n.$content]
            }) : F.HTMLResult.EMPTY;
          }
          [n.$getChildren](r = null) {
            return r ? this[v].filter((y) => y[n.$nodeName] === r) : this[v];
          }
          [n.$getAttributes]() {
            return this[U];
          }
          [n.$getChildrenByClass](r) {
            const y = this[U].get(r);
            return y !== void 0 ? y : this[n.$getChildren](r);
          }
          *[n.$getChildrenByNameIt](r, y) {
            const M = this[U].get(r);
            M && (yield M);
            for (const $ of this[v])
              $[n.$nodeName] === r && (yield $), y && (yield* $[n.$getChildrenByNameIt](r, y));
          }
          *[n.$getAttributeIt](r, y) {
            const M = this[U].get(r);
            M && (!y || !M[n.$consumed]) && (yield M);
            for (const $ of this[v])
              yield* $[n.$getAttributeIt](r, y);
          }
          *[n.$getRealChildrenByNameIt](r, y, M) {
            for (const $ of this[v])
              $[n.$nodeName] === r && (!M || !$[n.$consumed]) && (yield $), y && (yield* $[n.$getRealChildrenByNameIt](r, y, M));
          }
          [n.$isDataValue]() {
            return this[b] === null ? this[v].length === 0 || this[v][0][n.$namespaceId] === t.NamespaceIds.xhtml.id : this[b];
          }
          [n.$getDataValue]() {
            return this[b] === null ? this[v].length === 0 ? this[n.$content].trim() : this[v][0][n.$namespaceId] === t.NamespaceIds.xhtml.id ? this[v][0][n.$text]().trim() : null : this[n.$content].trim();
          }
          [n.$setValue](r) {
            r = r.value || "", this[n.$content] = r.toString();
          }
          [n.$dump](r = !1) {
            const y = /* @__PURE__ */ Object.create(null);
            r && (y.$ns = this[n.$namespaceId]), this[n.$content] && (y.$content = this[n.$content]), y.$name = this[n.$nodeName], y.children = [];
            for (const M of this[v])
              y.children.push(M[n.$dump](r));
            y.attributes = /* @__PURE__ */ Object.create(null);
            for (const [M, $] of this[U])
              y.attributes[M] = $[n.$content];
            return y;
          }
        }
        w.XmlObject = B;
        class T extends u {
          constructor(r, y) {
            super(r, y), this[n.$content] = "";
          }
          [n.$onText](r) {
            this[n.$content] += r;
          }
          [n.$finalize]() {
          }
        }
        w.ContentObject = T;
        class D extends T {
          constructor(r, y, M) {
            super(r, y), this[k] = M;
          }
          [n.$finalize]() {
            this[n.$content] = (0, F.getKeyword)({
              data: this[n.$content],
              defaultValue: this[k][0],
              validate: (r) => this[k].includes(r)
            });
          }
          [n.$clean](r) {
            super[n.$clean](r), delete this[k];
          }
        }
        w.OptionObject = D;
        class K extends T {
          [n.$finalize]() {
            this[n.$content] = this[n.$content].trim();
          }
        }
        w.StringObject = K;
        class _ extends T {
          constructor(r, y, M, $) {
            super(r, y), this[i] = M, this[f] = $;
          }
          [n.$finalize]() {
            this[n.$content] = (0, F.getInteger)({
              data: this[n.$content],
              defaultValue: this[i],
              validate: this[f]
            });
          }
          [n.$clean](r) {
            super[n.$clean](r), delete this[i], delete this[f];
          }
        }
        w.IntegerObject = _;
        class o extends _ {
          constructor(r, y) {
            super(r, y, 0, (M) => M === 1);
          }
        }
        w.Option01 = o;
        class m extends _ {
          constructor(r, y) {
            super(r, y, 1, (M) => M === 0);
          }
        }
        w.Option10 = m;
      },
      /* 88 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.createDataNode = g, w.searchNode = v;
        var n = V(78), F = V(2);
        const C = /^[^.[]+/, e = /^[^\]]+/, t = {
          dot: 0,
          dotDot: 1,
          dotHash: 2,
          dotBracket: 3,
          dotParen: 4
        }, l = /* @__PURE__ */ new Map([["$data", (b, i) => b.datasets ? b.datasets.data : b], ["$record", (b, i) => (b.datasets ? b.datasets.data : b)[n.$getChildren]()[0]], ["$template", (b, i) => b.template], ["$connectionSet", (b, i) => b.connectionSet], ["$form", (b, i) => b.form], ["$layout", (b, i) => b.layout], ["$host", (b, i) => b.host], ["$dataWindow", (b, i) => b.dataWindow], ["$event", (b, i) => b.event], ["!", (b, i) => b.datasets], ["$xfa", (b, i) => b], ["xfa", (b, i) => b], ["$", (b, i) => i]]), j = /* @__PURE__ */ new WeakMap();
        function U(b) {
          return b = b.trim(), b === "*" ? 1 / 0 : parseInt(b, 10) || 0;
        }
        function O(b, i, P = !0) {
          let d = b.match(C);
          if (!d)
            return null;
          let [A] = d;
          const I = [{
            name: A,
            cacheName: "." + A,
            index: 0,
            js: null,
            formCalc: null,
            operator: t.dot
          }];
          let E = A.length;
          for (; E < b.length; ) {
            const k = E;
            if (b.charAt(E++) === "[") {
              if (d = b.slice(E).match(e), !d)
                return (0, F.warn)("XFA - Invalid index in SOM expression"), null;
              I.at(-1).index = U(d[0]), E += d[0].length + 1;
              continue;
            }
            let x;
            switch (b.charAt(E)) {
              case ".":
                if (!i)
                  return null;
                E++, x = t.dotDot;
                break;
              case "#":
                E++, x = t.dotHash;
                break;
              case "[":
                if (P)
                  return (0, F.warn)("XFA - SOM expression contains a FormCalc subexpression which is not supported for now."), null;
                x = t.dotBracket;
                break;
              case "(":
                if (P)
                  return (0, F.warn)("XFA - SOM expression contains a JavaScript subexpression which is not supported for now."), null;
                x = t.dotParen;
                break;
              default:
                x = t.dot;
                break;
            }
            if (d = b.slice(E).match(C), !d)
              break;
            [A] = d, E += A.length, I.push({
              name: A,
              cacheName: b.slice(k, E),
              operator: x,
              index: 0,
              js: null,
              formCalc: null
            });
          }
          return I;
        }
        function v(b, i, P, d = !0, A = !0) {
          const I = O(P, d);
          if (!I)
            return null;
          const E = l.get(I[0].name);
          let k = 0, H;
          E ? (H = !0, b = [E(b, i)], k = 1) : (H = i === null, b = [i || b]);
          for (let x = I.length; k < x; k++) {
            const {
              name: R,
              cacheName: f,
              operator: c,
              index: N
            } = I[k], u = [];
            for (const p of b) {
              if (!p.isXFAObject)
                continue;
              let S, B;
              if (A && (B = j.get(p), B || (B = /* @__PURE__ */ new Map(), j.set(p, B)), S = B.get(f)), !S) {
                switch (c) {
                  case t.dot:
                    S = p[n.$getChildrenByName](R, !1);
                    break;
                  case t.dotDot:
                    S = p[n.$getChildrenByName](R, !0);
                    break;
                  case t.dotHash:
                    S = p[n.$getChildrenByClass](R), S = S.isXFAObjectArray ? S.children : [S];
                    break;
                }
                A && B.set(f, S);
              }
              S.length > 0 && u.push(S);
            }
            if (u.length === 0 && !H && k === 0) {
              if (i = i[n.$getParent](), !i)
                return null;
              k = -1, b = [i];
              continue;
            }
            b = isFinite(N) ? u.filter((p) => N < p.length).map((p) => p[N]) : u.flat();
          }
          return b.length === 0 ? null : b;
        }
        function g(b, i, P) {
          const d = O(P);
          if (!d || d.some((E) => E.operator === t.dotDot))
            return null;
          const A = l.get(d[0].name);
          let I = 0;
          A ? (b = A(b, i), I = 1) : b = i || b;
          for (let E = d.length; I < E; I++) {
            const {
              name: k,
              operator: H,
              index: x
            } = d[I];
            if (!isFinite(x))
              return d[I].index = 0, b.createNodes(d.slice(I));
            let R;
            switch (H) {
              case t.dot:
                R = b[n.$getChildrenByName](k, !1);
                break;
              case t.dotDot:
                R = b[n.$getChildrenByName](k, !0);
                break;
              case t.dotHash:
                R = b[n.$getChildrenByClass](k), R = R.isXFAObjectArray ? R.children : [R];
                break;
            }
            if (R.length === 0)
              return b.createNodes(d.slice(I));
            if (x < R.length) {
              const f = R[x];
              if (!f.isXFAObject)
                return (0, F.warn)("XFA - Cannot create a node."), null;
              b = f;
            } else
              return d[I].index = x - R.length, b.createNodes(d.slice(I));
          }
          return null;
        }
      },
      /* 89 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.DataHandler = void 0;
        var n = V(78);
        class F {
          constructor(e, t) {
            this.data = t, this.dataset = e.datasets || null;
          }
          serialize(e) {
            const t = [[-1, this.data[n.$getChildren]()]];
            for (; t.length > 0; ) {
              const j = t.at(-1), [U, O] = j;
              if (U + 1 === O.length) {
                t.pop();
                continue;
              }
              const v = O[++j[0]], g = e.get(v[n.$uid]);
              if (g)
                v[n.$setValue](g);
              else {
                const i = v[n.$getAttributes]();
                for (const P of i.values()) {
                  const d = e.get(P[n.$uid]);
                  if (d) {
                    P[n.$setValue](d);
                    break;
                  }
                }
              }
              const b = v[n.$getChildren]();
              b.length > 0 && t.push([-1, b]);
            }
            const l = ['<xfa:datasets xmlns:xfa="http://www.xfa.org/schema/xfa-data/1.0/">'];
            if (this.dataset)
              for (const j of this.dataset[n.$getChildren]())
                j[n.$nodeName] !== "data" && j[n.$toString](l);
            return this.data[n.$toString](l), l.push("</xfa:datasets>"), l.join("");
          }
        }
        w.DataHandler = F;
      },
      /* 90 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.XFAParser = void 0;
        var n = V(78), F = V(71), C = V(91), e = V(2);
        class t extends F.XMLParserBase {
          constructor(j = null, U = !1) {
            super(), this._builder = new C.Builder(j), this._stack = [], this._globalData = {
              usedTypefaces: /* @__PURE__ */ new Set()
            }, this._ids = /* @__PURE__ */ new Map(), this._current = this._builder.buildRoot(this._ids), this._errorCode = F.XMLParserErrorCode.NoError, this._whiteRegex = /^\s+$/, this._nbsps = /\xa0+/g, this._richText = U;
          }
          parse(j) {
            if (this.parseXml(j), this._errorCode === F.XMLParserErrorCode.NoError)
              return this._current[n.$finalize](), this._current.element;
          }
          onText(j) {
            if (j = j.replace(this._nbsps, (U) => U.slice(1) + " "), this._richText || this._current[n.$acceptWhitespace]()) {
              this._current[n.$onText](j, this._richText);
              return;
            }
            this._whiteRegex.test(j) || this._current[n.$onText](j.trim());
          }
          onCdata(j) {
            this._current[n.$onText](j);
          }
          _mkAttributes(j, U) {
            let O = null, v = null;
            const g = /* @__PURE__ */ Object.create({});
            for (const {
              name: b,
              value: i
            } of j)
              if (b === "xmlns")
                O ? (0, e.warn)(`XFA - multiple namespace definition in <${U}>`) : O = i;
              else if (b.startsWith("xmlns:")) {
                const P = b.substring(6);
                v || (v = []), v.push({
                  prefix: P,
                  value: i
                });
              } else {
                const P = b.indexOf(":");
                if (P === -1)
                  g[b] = i;
                else {
                  let d = g[n.$nsAttributes];
                  d || (d = g[n.$nsAttributes] = /* @__PURE__ */ Object.create(null));
                  const [A, I] = [b.slice(0, P), b.slice(P + 1)], E = d[A] || (d[A] = /* @__PURE__ */ Object.create(null));
                  E[I] = i;
                }
              }
            return [O, v, g];
          }
          _getNameAndPrefix(j, U) {
            const O = j.indexOf(":");
            return O === -1 ? [j, null] : [j.substring(O + 1), U ? "" : j.substring(0, O)];
          }
          onBeginElement(j, U, O) {
            const [v, g, b] = this._mkAttributes(U, j), [i, P] = this._getNameAndPrefix(j, this._builder.isNsAgnostic()), d = this._builder.build({
              nsPrefix: P,
              name: i,
              attributes: b,
              namespace: v,
              prefixes: g
            });
            if (d[n.$globalData] = this._globalData, O) {
              d[n.$finalize](), this._current[n.$onChild](d) && d[n.$setId](this._ids), d[n.$clean](this._builder);
              return;
            }
            this._stack.push(this._current), this._current = d;
          }
          onEndElement(j) {
            const U = this._current;
            if (U[n.$isCDATAXml]() && typeof U[n.$content] == "string") {
              const O = new t();
              O._globalData = this._globalData;
              const v = O.parse(U[n.$content]);
              U[n.$content] = null, U[n.$onChild](v);
            }
            U[n.$finalize](), this._current = this._stack.pop(), this._current[n.$onChild](U) && U[n.$setId](this._ids), U[n.$clean](this._builder);
          }
          onError(j) {
            this._errorCode = j;
          }
        }
        w.XFAParser = t;
      },
      /* 91 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.Builder = void 0;
        var n = V(81), F = V(78), C = V(92), e = V(80), t = V(101), l = V(2), j = V(87);
        class U extends j.XFAObject {
          constructor(b) {
            super(-1, "root", /* @__PURE__ */ Object.create(null)), this.element = null, this[F.$ids] = b;
          }
          [F.$onChild](b) {
            return this.element = b, !0;
          }
          [F.$finalize]() {
            super[F.$finalize](), this.element.template instanceof e.Template && (this[F.$ids].set(F.$root, this.element), this.element.template[F.$resolvePrototypes](this[F.$ids]), this.element.template[F.$ids] = this[F.$ids]);
          }
        }
        class O extends j.XFAObject {
          constructor() {
            super(-1, "", /* @__PURE__ */ Object.create(null));
          }
          [F.$onChild](b) {
            return !1;
          }
        }
        class v {
          constructor(b = null) {
            this._namespaceStack = [], this._nsAgnosticLevel = 0, this._namespacePrefixes = /* @__PURE__ */ new Map(), this._namespaces = /* @__PURE__ */ new Map(), this._nextNsId = Math.max(...Object.values(n.NamespaceIds).map(({
              id: i
            }) => i)), this._currentNamespace = b || new t.UnknownNamespace(++this._nextNsId);
          }
          buildRoot(b) {
            return new U(b);
          }
          build({
            nsPrefix: b,
            name: i,
            attributes: P,
            namespace: d,
            prefixes: A
          }) {
            const I = d !== null;
            if (I && (this._namespaceStack.push(this._currentNamespace), this._currentNamespace = this._searchNamespace(d)), A && this._addNamespacePrefix(A), P.hasOwnProperty(F.$nsAttributes)) {
              const H = C.NamespaceSetUp.datasets, x = P[F.$nsAttributes];
              let R = null;
              for (const [f, c] of Object.entries(x))
                if (this._getNamespaceToUse(f) === H) {
                  R = {
                    xfa: c
                  };
                  break;
                }
              R ? P[F.$nsAttributes] = R : delete P[F.$nsAttributes];
            }
            const E = this._getNamespaceToUse(b), k = (E == null ? void 0 : E[n.$buildXFAObject](i, P)) || new O();
            return k[F.$isNsAgnostic]() && this._nsAgnosticLevel++, (I || A || k[F.$isNsAgnostic]()) && (k[F.$cleanup] = {
              hasNamespace: I,
              prefixes: A,
              nsAgnostic: k[F.$isNsAgnostic]()
            }), k;
          }
          isNsAgnostic() {
            return this._nsAgnosticLevel > 0;
          }
          _searchNamespace(b) {
            let i = this._namespaces.get(b);
            if (i)
              return i;
            for (const [P, {
              check: d
            }] of Object.entries(n.NamespaceIds))
              if (d(b)) {
                if (i = C.NamespaceSetUp[P], i)
                  return this._namespaces.set(b, i), i;
                break;
              }
            return i = new t.UnknownNamespace(++this._nextNsId), this._namespaces.set(b, i), i;
          }
          _addNamespacePrefix(b) {
            for (const {
              prefix: i,
              value: P
            } of b) {
              const d = this._searchNamespace(P);
              let A = this._namespacePrefixes.get(i);
              A || (A = [], this._namespacePrefixes.set(i, A)), A.push(d);
            }
          }
          _getNamespaceToUse(b) {
            if (!b)
              return this._currentNamespace;
            const i = this._namespacePrefixes.get(b);
            return (i == null ? void 0 : i.length) > 0 ? i.at(-1) : ((0, l.warn)(`Unknown namespace prefix: ${b}.`), null);
          }
          clean(b) {
            const {
              hasNamespace: i,
              prefixes: P,
              nsAgnostic: d
            } = b;
            i && (this._currentNamespace = this._namespaceStack.pop()), P && P.forEach(({
              prefix: A
            }) => {
              this._namespacePrefixes.get(A).pop();
            }), d && this._nsAgnosticLevel--;
          }
        }
        w.Builder = v;
      },
      /* 92 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.NamespaceSetUp = void 0;
        var n = V(93), F = V(94), C = V(95), e = V(96), t = V(97), l = V(98), j = V(80), U = V(99), O = V(100);
        const v = {
          config: n.ConfigNamespace,
          connection: F.ConnectionSetNamespace,
          datasets: C.DatasetsNamespace,
          localeSet: e.LocaleSetNamespace,
          signature: t.SignatureNamespace,
          stylesheet: l.StylesheetNamespace,
          template: j.TemplateNamespace,
          xdp: U.XdpNamespace,
          xhtml: O.XhtmlNamespace
        };
        w.NamespaceSetUp = v;
      },
      /* 93 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.ConfigNamespace = void 0;
        var n = V(81), F = V(78), C = V(87), e = V(84), t = V(2);
        const l = n.NamespaceIds.config.id;
        class j extends C.XFAObject {
          constructor(ee) {
            super(l, "acrobat", !0), this.acrobat7 = null, this.autoSave = null, this.common = null, this.validate = null, this.validateApprovalSignatures = null, this.submitUrl = new C.XFAObjectArray();
          }
        }
        class U extends C.XFAObject {
          constructor(ee) {
            super(l, "acrobat7", !0), this.dynamicRender = null;
          }
        }
        class O extends C.OptionObject {
          constructor(ee) {
            super(l, "ADBE_JSConsole", ["delegate", "Enable", "Disable"]);
          }
        }
        class v extends C.OptionObject {
          constructor(ee) {
            super(l, "ADBE_JSDebugger", ["delegate", "Enable", "Disable"]);
          }
        }
        class g extends C.Option01 {
          constructor(ee) {
            super(l, "addSilentPrint");
          }
        }
        class b extends C.Option01 {
          constructor(ee) {
            super(l, "addViewerPreferences");
          }
        }
        class i extends C.Option10 {
          constructor(ee) {
            super(l, "adjustData");
          }
        }
        class P extends C.IntegerObject {
          constructor(ee) {
            super(l, "adobeExtensionLevel", 0, (He) => He >= 1 && He <= 8);
          }
        }
        class d extends C.XFAObject {
          constructor(ee) {
            super(l, "agent", !0), this.name = ee.name ? ee.name.trim() : "", this.common = new C.XFAObjectArray();
          }
        }
        class A extends C.ContentObject {
          constructor(ee) {
            super(l, "alwaysEmbed");
          }
        }
        class I extends C.StringObject {
          constructor(ee) {
            super(l, "amd");
          }
        }
        class E extends C.XFAObject {
          constructor(ee) {
            super(l, "area"), this.level = (0, e.getInteger)({
              data: ee.level,
              defaultValue: 0,
              validate: (He) => He >= 1 && He <= 3
            }), this.name = (0, e.getStringOption)(ee.name, ["", "barcode", "coreinit", "deviceDriver", "font", "general", "layout", "merge", "script", "signature", "sourceSet", "templateCache"]);
          }
        }
        class k extends C.OptionObject {
          constructor(ee) {
            super(l, "attributes", ["preserve", "delegate", "ignore"]);
          }
        }
        class H extends C.OptionObject {
          constructor(ee) {
            super(l, "autoSave", ["disabled", "enabled"]);
          }
        }
        class x extends C.StringObject {
          constructor(ee) {
            super(l, "base");
          }
        }
        class R extends C.XFAObject {
          constructor(ee) {
            super(l, "batchOutput"), this.format = (0, e.getStringOption)(ee.format, ["none", "concat", "zip", "zipCompress"]);
          }
        }
        class f extends C.ContentObject {
          constructor(ee) {
            super(l, "behaviorOverride");
          }
          [F.$finalize]() {
            this[F.$content] = new Map(this[F.$content].trim().split(/\s+/).filter((ee) => ee.includes(":")).map((ee) => ee.split(":", 2)));
          }
        }
        class c extends C.XFAObject {
          constructor(ee) {
            super(l, "cache", !0), this.templateCache = null;
          }
        }
        class N extends C.Option01 {
          constructor(ee) {
            super(l, "change");
          }
        }
        class u extends C.XFAObject {
          constructor(ee) {
            super(l, "common", !0), this.data = null, this.locale = null, this.localeSet = null, this.messaging = null, this.suppressBanner = null, this.template = null, this.validationMessaging = null, this.versionControl = null, this.log = new C.XFAObjectArray();
          }
        }
        class p extends C.XFAObject {
          constructor(ee) {
            super(l, "compress"), this.scope = (0, e.getStringOption)(ee.scope, ["imageOnly", "document"]);
          }
        }
        class S extends C.Option01 {
          constructor(ee) {
            super(l, "compressLogicalStructure");
          }
        }
        class B extends C.Option10 {
          constructor(ee) {
            super(l, "compressObjectStream");
          }
        }
        class T extends C.XFAObject {
          constructor(ee) {
            super(l, "compression", !0), this.compressLogicalStructure = null, this.compressObjectStream = null, this.level = null, this.type = null;
          }
        }
        class D extends C.XFAObject {
          constructor(ee) {
            super(l, "config", !0), this.acrobat = null, this.present = null, this.trace = null, this.agent = new C.XFAObjectArray();
          }
        }
        class K extends C.OptionObject {
          constructor(ee) {
            super(l, "conformance", ["A", "B"]);
          }
        }
        class _ extends C.Option01 {
          constructor(ee) {
            super(l, "contentCopy");
          }
        }
        class o extends C.IntegerObject {
          constructor(ee) {
            super(l, "copies", 1, (He) => He >= 1);
          }
        }
        class m extends C.StringObject {
          constructor(ee) {
            super(l, "creator");
          }
        }
        class s extends C.IntegerObject {
          constructor(ee) {
            super(l, "currentPage", 0, (He) => He >= 0);
          }
        }
        class r extends C.XFAObject {
          constructor(ee) {
            super(l, "data", !0), this.adjustData = null, this.attributes = null, this.incrementalLoad = null, this.outputXSL = null, this.range = null, this.record = null, this.startNode = null, this.uri = null, this.window = null, this.xsl = null, this.excludeNS = new C.XFAObjectArray(), this.transform = new C.XFAObjectArray();
          }
        }
        class y extends C.XFAObject {
          constructor(ee) {
            super(l, "debug", !0), this.uri = null;
          }
        }
        class M extends C.ContentObject {
          constructor(ee) {
            super(l, "defaultTypeface"), this.writingScript = (0, e.getStringOption)(ee.writingScript, ["*", "Arabic", "Cyrillic", "EastEuropeanRoman", "Greek", "Hebrew", "Japanese", "Korean", "Roman", "SimplifiedChinese", "Thai", "TraditionalChinese", "Vietnamese"]);
          }
        }
        class $ extends C.OptionObject {
          constructor(ee) {
            super(l, "destination", ["pdf", "pcl", "ps", "webClient", "zpl"]);
          }
        }
        class G extends C.Option01 {
          constructor(ee) {
            super(l, "documentAssembly");
          }
        }
        class ce extends C.XFAObject {
          constructor(ee) {
            super(l, "driver", !0), this.name = ee.name ? ee.name.trim() : "", this.fontInfo = null, this.xdc = null;
          }
        }
        class q extends C.OptionObject {
          constructor(ee) {
            super(l, "duplexOption", ["simplex", "duplexFlipLongEdge", "duplexFlipShortEdge"]);
          }
        }
        class re extends C.OptionObject {
          constructor(ee) {
            super(l, "dynamicRender", ["forbidden", "required"]);
          }
        }
        class Z extends C.Option01 {
          constructor(ee) {
            super(l, "embed");
          }
        }
        class te extends C.Option01 {
          constructor(ee) {
            super(l, "encrypt");
          }
        }
        class L extends C.XFAObject {
          constructor(ee) {
            super(l, "encryption", !0), this.encrypt = null, this.encryptionLevel = null, this.permissions = null;
          }
        }
        class X extends C.OptionObject {
          constructor(ee) {
            super(l, "encryptionLevel", ["40bit", "128bit"]);
          }
        }
        class J extends C.StringObject {
          constructor(ee) {
            super(l, "enforce");
          }
        }
        class Y extends C.XFAObject {
          constructor(ee) {
            super(l, "equate"), this.force = (0, e.getInteger)({
              data: ee.force,
              defaultValue: 1,
              validate: (He) => He === 0
            }), this.from = ee.from || "", this.to = ee.to || "";
          }
        }
        class ae extends C.XFAObject {
          constructor(ee) {
            super(l, "equateRange"), this.from = ee.from || "", this.to = ee.to || "", this._unicodeRange = ee.unicodeRange || "";
          }
          get unicodeRange() {
            const ee = [], He = /U\+([0-9a-fA-F]+)/, Ze = this._unicodeRange;
            for (let it of Ze.split(",").map((dt) => dt.trim()).filter((dt) => !!dt))
              it = it.split("-", 2).map((dt) => {
                const xt = dt.match(He);
                return xt ? parseInt(xt[1], 16) : 0;
              }), it.length === 1 && it.push(it[0]), ee.push(it);
            return (0, t.shadow)(this, "unicodeRange", ee);
          }
        }
        class se extends C.ContentObject {
          constructor(ee) {
            super(l, "exclude");
          }
          [F.$finalize]() {
            this[F.$content] = this[F.$content].trim().split(/\s+/).filter((ee) => ee && ["calculate", "close", "enter", "exit", "initialize", "ready", "validate"].includes(ee));
          }
        }
        class Q extends C.StringObject {
          constructor(ee) {
            super(l, "excludeNS");
          }
        }
        class z extends C.OptionObject {
          constructor(ee) {
            super(l, "flipLabel", ["usePrinterSetting", "on", "off"]);
          }
        }
        class ie extends C.XFAObject {
          constructor(ee) {
            super(l, "fontInfo", !0), this.embed = null, this.map = null, this.subsetBelow = null, this.alwaysEmbed = new C.XFAObjectArray(), this.defaultTypeface = new C.XFAObjectArray(), this.neverEmbed = new C.XFAObjectArray();
          }
        }
        class ne extends C.Option01 {
          constructor(ee) {
            super(l, "formFieldFilling");
          }
        }
        class W extends C.StringObject {
          constructor(ee) {
            super(l, "groupParent");
          }
        }
        class oe extends C.OptionObject {
          constructor(ee) {
            super(l, "ifEmpty", ["dataValue", "dataGroup", "ignore", "remove"]);
          }
        }
        class ue extends C.StringObject {
          constructor(ee) {
            super(l, "includeXDPContent");
          }
        }
        class pe extends C.OptionObject {
          constructor(ee) {
            super(l, "incrementalLoad", ["none", "forwardOnly"]);
          }
        }
        class ve extends C.Option01 {
          constructor(ee) {
            super(l, "incrementalMerge");
          }
        }
        class Ce extends C.Option01 {
          constructor(ee) {
            super(l, "interactive");
          }
        }
        class Fe extends C.OptionObject {
          constructor(ee) {
            super(l, "jog", ["usePrinterSetting", "none", "pageSet"]);
          }
        }
        class Pe extends C.XFAObject {
          constructor(ee) {
            super(l, "labelPrinter", !0), this.name = (0, e.getStringOption)(ee.name, ["zpl", "dpl", "ipl", "tcpl"]), this.batchOutput = null, this.flipLabel = null, this.fontInfo = null, this.xdc = null;
          }
        }
        class be extends C.OptionObject {
          constructor(ee) {
            super(l, "layout", ["paginate", "panel"]);
          }
        }
        class me extends C.IntegerObject {
          constructor(ee) {
            super(l, "level", 0, (He) => He > 0);
          }
        }
        class we extends C.Option01 {
          constructor(ee) {
            super(l, "linearized");
          }
        }
        class _e extends C.StringObject {
          constructor(ee) {
            super(l, "locale");
          }
        }
        class Se extends C.StringObject {
          constructor(ee) {
            super(l, "localeSet");
          }
        }
        class Ae extends C.XFAObject {
          constructor(ee) {
            super(l, "log", !0), this.mode = null, this.threshold = null, this.to = null, this.uri = null;
          }
        }
        class Te extends C.XFAObject {
          constructor(ee) {
            super(l, "map", !0), this.equate = new C.XFAObjectArray(), this.equateRange = new C.XFAObjectArray();
          }
        }
        class ke extends C.XFAObject {
          constructor(ee) {
            super(l, "mediumInfo", !0), this.map = null;
          }
        }
        class Ee extends C.XFAObject {
          constructor(ee) {
            super(l, "message", !0), this.msgId = null, this.severity = null;
          }
        }
        class Ve extends C.XFAObject {
          constructor(ee) {
            super(l, "messaging", !0), this.message = new C.XFAObjectArray();
          }
        }
        class je extends C.OptionObject {
          constructor(ee) {
            super(l, "mode", ["append", "overwrite"]);
          }
        }
        class at extends C.Option01 {
          constructor(ee) {
            super(l, "modifyAnnots");
          }
        }
        class $e extends C.IntegerObject {
          constructor(ee) {
            super(l, "msgId", 1, (He) => He >= 1);
          }
        }
        class ct extends C.StringObject {
          constructor(ee) {
            super(l, "nameAttr");
          }
        }
        class ze extends C.ContentObject {
          constructor(ee) {
            super(l, "neverEmbed");
          }
        }
        class Ye extends C.IntegerObject {
          constructor(ee) {
            super(l, "numberOfCopies", null, (He) => He >= 2 && He <= 5);
          }
        }
        class Qe extends C.XFAObject {
          constructor(ee) {
            super(l, "openAction", !0), this.destination = null;
          }
        }
        class Oe extends C.XFAObject {
          constructor(ee) {
            super(l, "output", !0), this.to = null, this.type = null, this.uri = null;
          }
        }
        class he extends C.StringObject {
          constructor(ee) {
            super(l, "outputBin");
          }
        }
        class ye extends C.XFAObject {
          constructor(ee) {
            super(l, "outputXSL", !0), this.uri = null;
          }
        }
        class Ie extends C.OptionObject {
          constructor(ee) {
            super(l, "overprint", ["none", "both", "draw", "field"]);
          }
        }
        class Le extends C.StringObject {
          constructor(ee) {
            super(l, "packets");
          }
          [F.$finalize]() {
            this[F.$content] !== "*" && (this[F.$content] = this[F.$content].trim().split(/\s+/).filter((ee) => ["config", "datasets", "template", "xfdf", "xslt"].includes(ee)));
          }
        }
        class Be extends C.XFAObject {
          constructor(ee) {
            super(l, "pageOffset"), this.x = (0, e.getInteger)({
              data: ee.x,
              defaultValue: "useXDCSetting",
              validate: (He) => !0
            }), this.y = (0, e.getInteger)({
              data: ee.y,
              defaultValue: "useXDCSetting",
              validate: (He) => !0
            });
          }
        }
        class Ne extends C.StringObject {
          constructor(ee) {
            super(l, "pageRange");
          }
          [F.$finalize]() {
            const ee = this[F.$content].trim().split(/\s+/).map((Ze) => parseInt(Ze, 10)), He = [];
            for (let Ze = 0, it = ee.length; Ze < it; Ze += 2)
              He.push(ee.slice(Ze, Ze + 2));
            this[F.$content] = He;
          }
        }
        class Ue extends C.OptionObject {
          constructor(ee) {
            super(l, "pagination", ["simplex", "duplexShortEdge", "duplexLongEdge"]);
          }
        }
        class qe extends C.OptionObject {
          constructor(ee) {
            super(l, "paginationOverride", ["none", "forceDuplex", "forceDuplexLongEdge", "forceDuplexShortEdge", "forceSimplex"]);
          }
        }
        class tt extends C.IntegerObject {
          constructor(ee) {
            super(l, "part", 1, (He) => !1);
          }
        }
        class ht extends C.XFAObject {
          constructor(ee) {
            super(l, "pcl", !0), this.name = ee.name || "", this.batchOutput = null, this.fontInfo = null, this.jog = null, this.mediumInfo = null, this.outputBin = null, this.pageOffset = null, this.staple = null, this.xdc = null;
          }
        }
        class rt extends C.XFAObject {
          constructor(ee) {
            super(l, "pdf", !0), this.name = ee.name || "", this.adobeExtensionLevel = null, this.batchOutput = null, this.compression = null, this.creator = null, this.encryption = null, this.fontInfo = null, this.interactive = null, this.linearized = null, this.openAction = null, this.pdfa = null, this.producer = null, this.renderPolicy = null, this.scriptModel = null, this.silentPrint = null, this.submitFormat = null, this.tagged = null, this.version = null, this.viewerPreferences = null, this.xdc = null;
          }
        }
        class nt extends C.XFAObject {
          constructor(ee) {
            super(l, "pdfa", !0), this.amd = null, this.conformance = null, this.includeXDPContent = null, this.part = null;
          }
        }
        class ut extends C.XFAObject {
          constructor(ee) {
            super(l, "permissions", !0), this.accessibleContent = null, this.change = null, this.contentCopy = null, this.documentAssembly = null, this.formFieldFilling = null, this.modifyAnnots = null, this.plaintextMetadata = null, this.print = null, this.printHighQuality = null;
          }
        }
        class bt extends C.Option01 {
          constructor(ee) {
            super(l, "pickTrayByPDFSize");
          }
        }
        class Ge extends C.StringObject {
          constructor(ee) {
            super(l, "picture");
          }
        }
        class We extends C.Option01 {
          constructor(ee) {
            super(l, "plaintextMetadata");
          }
        }
        class Je extends C.OptionObject {
          constructor(ee) {
            super(l, "presence", ["preserve", "dissolve", "dissolveStructure", "ignore", "remove"]);
          }
        }
        class et extends C.XFAObject {
          constructor(ee) {
            super(l, "present", !0), this.behaviorOverride = null, this.cache = null, this.common = null, this.copies = null, this.destination = null, this.incrementalMerge = null, this.layout = null, this.output = null, this.overprint = null, this.pagination = null, this.paginationOverride = null, this.script = null, this.validate = null, this.xdp = null, this.driver = new C.XFAObjectArray(), this.labelPrinter = new C.XFAObjectArray(), this.pcl = new C.XFAObjectArray(), this.pdf = new C.XFAObjectArray(), this.ps = new C.XFAObjectArray(), this.submitUrl = new C.XFAObjectArray(), this.webClient = new C.XFAObjectArray(), this.zpl = new C.XFAObjectArray();
          }
        }
        class lt extends C.Option01 {
          constructor(ee) {
            super(l, "print");
          }
        }
        class pt extends C.Option01 {
          constructor(ee) {
            super(l, "printHighQuality");
          }
        }
        class ot extends C.OptionObject {
          constructor(ee) {
            super(l, "printScaling", ["appdefault", "noScaling"]);
          }
        }
        class st extends C.StringObject {
          constructor(ee) {
            super(l, "printerName");
          }
        }
        class gt extends C.StringObject {
          constructor(ee) {
            super(l, "producer");
          }
        }
        class vt extends C.XFAObject {
          constructor(ee) {
            super(l, "ps", !0), this.name = ee.name || "", this.batchOutput = null, this.fontInfo = null, this.jog = null, this.mediumInfo = null, this.outputBin = null, this.staple = null, this.xdc = null;
          }
        }
        class Mt extends C.ContentObject {
          constructor(ee) {
            super(l, "range");
          }
          [F.$finalize]() {
            this[F.$content] = this[F.$content].trim().split(/\s*,\s*/, 2).map((ee) => ee.split("-").map((He) => parseInt(He.trim(), 10))).filter((ee) => ee.every((He) => !isNaN(He))).map((ee) => (ee.length === 1 && ee.push(ee[0]), ee));
          }
        }
        class At extends C.ContentObject {
          constructor(ee) {
            super(l, "record");
          }
          [F.$finalize]() {
            this[F.$content] = this[F.$content].trim();
            const ee = parseInt(this[F.$content], 10);
            !isNaN(ee) && ee >= 0 && (this[F.$content] = ee);
          }
        }
        class St extends C.ContentObject {
          constructor(ee) {
            super(l, "relevant");
          }
          [F.$finalize]() {
            this[F.$content] = this[F.$content].trim().split(/\s+/);
          }
        }
        class Et extends C.ContentObject {
          constructor(ee) {
            super(l, "rename");
          }
          [F.$finalize]() {
            this[F.$content] = this[F.$content].trim(), (this[F.$content].toLowerCase().startsWith("xml") || new RegExp("[\\p{L}_][\\p{L}\\d._\\p{M}-]*", "u").test(this[F.$content])) && (0, t.warn)("XFA - Rename: invalid XFA name");
          }
        }
        class mt extends C.OptionObject {
          constructor(ee) {
            super(l, "renderPolicy", ["server", "client"]);
          }
        }
        class Ct extends C.OptionObject {
          constructor(ee) {
            super(l, "runScripts", ["both", "client", "none", "server"]);
          }
        }
        class ft extends C.XFAObject {
          constructor(ee) {
            super(l, "script", !0), this.currentPage = null, this.exclude = null, this.runScripts = null;
          }
        }
        class Tt extends C.OptionObject {
          constructor(ee) {
            super(l, "scriptModel", ["XFA", "none"]);
          }
        }
        class _t extends C.OptionObject {
          constructor(ee) {
            super(l, "severity", ["ignore", "error", "information", "trace", "warning"]);
          }
        }
        class Xt extends C.XFAObject {
          constructor(ee) {
            super(l, "silentPrint", !0), this.addSilentPrint = null, this.printerName = null;
          }
        }
        class kt extends C.XFAObject {
          constructor(ee) {
            super(l, "staple"), this.mode = (0, e.getStringOption)(ee.mode, ["usePrinterSetting", "on", "off"]);
          }
        }
        class Ft extends C.StringObject {
          constructor(ee) {
            super(l, "startNode");
          }
        }
        class Lt extends C.IntegerObject {
          constructor(ee) {
            super(l, "startPage", 0, (He) => !0);
          }
        }
        class jt extends C.OptionObject {
          constructor(ee) {
            super(l, "submitFormat", ["html", "delegate", "fdf", "xml", "pdf"]);
          }
        }
        class qt extends C.StringObject {
          constructor(ee) {
            super(l, "submitUrl");
          }
        }
        class dn extends C.IntegerObject {
          constructor(ee) {
            super(l, "subsetBelow", 100, (He) => He >= 0 && He <= 100);
          }
        }
        class mi extends C.Option01 {
          constructor(ee) {
            super(l, "suppressBanner");
          }
        }
        class xi extends C.Option01 {
          constructor(ee) {
            super(l, "tagged");
          }
        }
        class bi extends C.XFAObject {
          constructor(ee) {
            super(l, "template", !0), this.base = null, this.relevant = null, this.startPage = null, this.uri = null, this.xsl = null;
          }
        }
        class yi extends C.OptionObject {
          constructor(ee) {
            super(l, "threshold", ["trace", "error", "information", "warning"]);
          }
        }
        class wi extends C.OptionObject {
          constructor(ee) {
            super(l, "to", ["null", "memory", "stderr", "stdout", "system", "uri"]);
          }
        }
        class Bn extends C.XFAObject {
          constructor(ee) {
            super(l, "templateCache"), this.maxEntries = (0, e.getInteger)({
              data: ee.maxEntries,
              defaultValue: 5,
              validate: (He) => He >= 0
            });
          }
        }
        class Tn extends C.XFAObject {
          constructor(ee) {
            super(l, "trace", !0), this.area = new C.XFAObjectArray();
          }
        }
        class Ai extends C.XFAObject {
          constructor(ee) {
            super(l, "transform", !0), this.groupParent = null, this.ifEmpty = null, this.nameAttr = null, this.picture = null, this.presence = null, this.rename = null, this.whitespace = null;
          }
        }
        class Si extends C.OptionObject {
          constructor(ee) {
            super(l, "type", ["none", "ascii85", "asciiHex", "ccittfax", "flate", "lzw", "runLength", "native", "xdp", "mergedXDP"]);
          }
        }
        class vi extends C.StringObject {
          constructor(ee) {
            super(l, "uri");
          }
        }
        class En extends C.OptionObject {
          constructor(ee) {
            super(l, "validate", ["preSubmit", "prePrint", "preExecute", "preSave"]);
          }
        }
        class $n extends C.ContentObject {
          constructor(ee) {
            super(l, "validateApprovalSignatures");
          }
          [F.$finalize]() {
            this[F.$content] = this[F.$content].trim().split(/\s+/).filter((ee) => ["docReady", "postSign"].includes(ee));
          }
        }
        class jn extends C.OptionObject {
          constructor(ee) {
            super(l, "validationMessaging", ["allMessagesIndividually", "allMessagesTogether", "firstMessageOnly", "noMessages"]);
          }
        }
        class Ci extends C.OptionObject {
          constructor(ee) {
            super(l, "version", ["1.7", "1.6", "1.5", "1.4", "1.3", "1.2"]);
          }
        }
        class ki extends C.XFAObject {
          constructor(ee) {
            super(l, "VersionControl"), this.outputBelow = (0, e.getStringOption)(ee.outputBelow, ["warn", "error", "update"]), this.sourceAbove = (0, e.getStringOption)(ee.sourceAbove, ["warn", "error"]), this.sourceBelow = (0, e.getStringOption)(ee.sourceBelow, ["update", "maintain"]);
          }
        }
        class Fi extends C.XFAObject {
          constructor(ee) {
            super(l, "viewerPreferences", !0), this.ADBE_JSConsole = null, this.ADBE_JSDebugger = null, this.addViewerPreferences = null, this.duplexOption = null, this.enforce = null, this.numberOfCopies = null, this.pageRange = null, this.pickTrayByPDFSize = null, this.printScaling = null;
          }
        }
        class Ti extends C.XFAObject {
          constructor(ee) {
            super(l, "webClient", !0), this.name = ee.name ? ee.name.trim() : "", this.fontInfo = null, this.xdc = null;
          }
        }
        class Ei extends C.OptionObject {
          constructor(ee) {
            super(l, "whitespace", ["preserve", "ltrim", "normalize", "rtrim", "trim"]);
          }
        }
        class In extends C.ContentObject {
          constructor(ee) {
            super(l, "window");
          }
          [F.$finalize]() {
            const ee = this[F.$content].trim().split(/\s*,\s*/, 2).map((He) => parseInt(He, 10));
            if (ee.some((He) => isNaN(He))) {
              this[F.$content] = [0, 0];
              return;
            }
            ee.length === 1 && ee.push(ee[0]), this[F.$content] = ee;
          }
        }
        class Ii extends C.XFAObject {
          constructor(ee) {
            super(l, "xdc", !0), this.uri = new C.XFAObjectArray(), this.xsl = new C.XFAObjectArray();
          }
        }
        class gn extends C.XFAObject {
          constructor(ee) {
            super(l, "xdp", !0), this.packets = null;
          }
        }
        class Oi extends C.XFAObject {
          constructor(ee) {
            super(l, "xsl", !0), this.debug = null, this.uri = null;
          }
        }
        class pn extends C.XFAObject {
          constructor(ee) {
            super(l, "zpl", !0), this.name = ee.name ? ee.name.trim() : "", this.batchOutput = null, this.flipLabel = null, this.fontInfo = null, this.xdc = null;
          }
        }
        class Ke {
          static [n.$buildXFAObject](ee, He) {
            if (Ke.hasOwnProperty(ee))
              return Ke[ee](He);
          }
          static acrobat(ee) {
            return new j(ee);
          }
          static acrobat7(ee) {
            return new U(ee);
          }
          static ADBE_JSConsole(ee) {
            return new O(ee);
          }
          static ADBE_JSDebugger(ee) {
            return new v(ee);
          }
          static addSilentPrint(ee) {
            return new g(ee);
          }
          static addViewerPreferences(ee) {
            return new b(ee);
          }
          static adjustData(ee) {
            return new i(ee);
          }
          static adobeExtensionLevel(ee) {
            return new P(ee);
          }
          static agent(ee) {
            return new d(ee);
          }
          static alwaysEmbed(ee) {
            return new A(ee);
          }
          static amd(ee) {
            return new I(ee);
          }
          static area(ee) {
            return new E(ee);
          }
          static attributes(ee) {
            return new k(ee);
          }
          static autoSave(ee) {
            return new H(ee);
          }
          static base(ee) {
            return new x(ee);
          }
          static batchOutput(ee) {
            return new R(ee);
          }
          static behaviorOverride(ee) {
            return new f(ee);
          }
          static cache(ee) {
            return new c(ee);
          }
          static change(ee) {
            return new N(ee);
          }
          static common(ee) {
            return new u(ee);
          }
          static compress(ee) {
            return new p(ee);
          }
          static compressLogicalStructure(ee) {
            return new S(ee);
          }
          static compressObjectStream(ee) {
            return new B(ee);
          }
          static compression(ee) {
            return new T(ee);
          }
          static config(ee) {
            return new D(ee);
          }
          static conformance(ee) {
            return new K(ee);
          }
          static contentCopy(ee) {
            return new _(ee);
          }
          static copies(ee) {
            return new o(ee);
          }
          static creator(ee) {
            return new m(ee);
          }
          static currentPage(ee) {
            return new s(ee);
          }
          static data(ee) {
            return new r(ee);
          }
          static debug(ee) {
            return new y(ee);
          }
          static defaultTypeface(ee) {
            return new M(ee);
          }
          static destination(ee) {
            return new $(ee);
          }
          static documentAssembly(ee) {
            return new G(ee);
          }
          static driver(ee) {
            return new ce(ee);
          }
          static duplexOption(ee) {
            return new q(ee);
          }
          static dynamicRender(ee) {
            return new re(ee);
          }
          static embed(ee) {
            return new Z(ee);
          }
          static encrypt(ee) {
            return new te(ee);
          }
          static encryption(ee) {
            return new L(ee);
          }
          static encryptionLevel(ee) {
            return new X(ee);
          }
          static enforce(ee) {
            return new J(ee);
          }
          static equate(ee) {
            return new Y(ee);
          }
          static equateRange(ee) {
            return new ae(ee);
          }
          static exclude(ee) {
            return new se(ee);
          }
          static excludeNS(ee) {
            return new Q(ee);
          }
          static flipLabel(ee) {
            return new z(ee);
          }
          static fontInfo(ee) {
            return new ie(ee);
          }
          static formFieldFilling(ee) {
            return new ne(ee);
          }
          static groupParent(ee) {
            return new W(ee);
          }
          static ifEmpty(ee) {
            return new oe(ee);
          }
          static includeXDPContent(ee) {
            return new ue(ee);
          }
          static incrementalLoad(ee) {
            return new pe(ee);
          }
          static incrementalMerge(ee) {
            return new ve(ee);
          }
          static interactive(ee) {
            return new Ce(ee);
          }
          static jog(ee) {
            return new Fe(ee);
          }
          static labelPrinter(ee) {
            return new Pe(ee);
          }
          static layout(ee) {
            return new be(ee);
          }
          static level(ee) {
            return new me(ee);
          }
          static linearized(ee) {
            return new we(ee);
          }
          static locale(ee) {
            return new _e(ee);
          }
          static localeSet(ee) {
            return new Se(ee);
          }
          static log(ee) {
            return new Ae(ee);
          }
          static map(ee) {
            return new Te(ee);
          }
          static mediumInfo(ee) {
            return new ke(ee);
          }
          static message(ee) {
            return new Ee(ee);
          }
          static messaging(ee) {
            return new Ve(ee);
          }
          static mode(ee) {
            return new je(ee);
          }
          static modifyAnnots(ee) {
            return new at(ee);
          }
          static msgId(ee) {
            return new $e(ee);
          }
          static nameAttr(ee) {
            return new ct(ee);
          }
          static neverEmbed(ee) {
            return new ze(ee);
          }
          static numberOfCopies(ee) {
            return new Ye(ee);
          }
          static openAction(ee) {
            return new Qe(ee);
          }
          static output(ee) {
            return new Oe(ee);
          }
          static outputBin(ee) {
            return new he(ee);
          }
          static outputXSL(ee) {
            return new ye(ee);
          }
          static overprint(ee) {
            return new Ie(ee);
          }
          static packets(ee) {
            return new Le(ee);
          }
          static pageOffset(ee) {
            return new Be(ee);
          }
          static pageRange(ee) {
            return new Ne(ee);
          }
          static pagination(ee) {
            return new Ue(ee);
          }
          static paginationOverride(ee) {
            return new qe(ee);
          }
          static part(ee) {
            return new tt(ee);
          }
          static pcl(ee) {
            return new ht(ee);
          }
          static pdf(ee) {
            return new rt(ee);
          }
          static pdfa(ee) {
            return new nt(ee);
          }
          static permissions(ee) {
            return new ut(ee);
          }
          static pickTrayByPDFSize(ee) {
            return new bt(ee);
          }
          static picture(ee) {
            return new Ge(ee);
          }
          static plaintextMetadata(ee) {
            return new We(ee);
          }
          static presence(ee) {
            return new Je(ee);
          }
          static present(ee) {
            return new et(ee);
          }
          static print(ee) {
            return new lt(ee);
          }
          static printHighQuality(ee) {
            return new pt(ee);
          }
          static printScaling(ee) {
            return new ot(ee);
          }
          static printerName(ee) {
            return new st(ee);
          }
          static producer(ee) {
            return new gt(ee);
          }
          static ps(ee) {
            return new vt(ee);
          }
          static range(ee) {
            return new Mt(ee);
          }
          static record(ee) {
            return new At(ee);
          }
          static relevant(ee) {
            return new St(ee);
          }
          static rename(ee) {
            return new Et(ee);
          }
          static renderPolicy(ee) {
            return new mt(ee);
          }
          static runScripts(ee) {
            return new Ct(ee);
          }
          static script(ee) {
            return new ft(ee);
          }
          static scriptModel(ee) {
            return new Tt(ee);
          }
          static severity(ee) {
            return new _t(ee);
          }
          static silentPrint(ee) {
            return new Xt(ee);
          }
          static staple(ee) {
            return new kt(ee);
          }
          static startNode(ee) {
            return new Ft(ee);
          }
          static startPage(ee) {
            return new Lt(ee);
          }
          static submitFormat(ee) {
            return new jt(ee);
          }
          static submitUrl(ee) {
            return new qt(ee);
          }
          static subsetBelow(ee) {
            return new dn(ee);
          }
          static suppressBanner(ee) {
            return new mi(ee);
          }
          static tagged(ee) {
            return new xi(ee);
          }
          static template(ee) {
            return new bi(ee);
          }
          static templateCache(ee) {
            return new Bn(ee);
          }
          static threshold(ee) {
            return new yi(ee);
          }
          static to(ee) {
            return new wi(ee);
          }
          static trace(ee) {
            return new Tn(ee);
          }
          static transform(ee) {
            return new Ai(ee);
          }
          static type(ee) {
            return new Si(ee);
          }
          static uri(ee) {
            return new vi(ee);
          }
          static validate(ee) {
            return new En(ee);
          }
          static validateApprovalSignatures(ee) {
            return new $n(ee);
          }
          static validationMessaging(ee) {
            return new jn(ee);
          }
          static version(ee) {
            return new Ci(ee);
          }
          static versionControl(ee) {
            return new ki(ee);
          }
          static viewerPreferences(ee) {
            return new Fi(ee);
          }
          static webClient(ee) {
            return new Ti(ee);
          }
          static whitespace(ee) {
            return new Ei(ee);
          }
          static window(ee) {
            return new In(ee);
          }
          static xdc(ee) {
            return new Ii(ee);
          }
          static xdp(ee) {
            return new gn(ee);
          }
          static xsl(ee) {
            return new Oi(ee);
          }
          static zpl(ee) {
            return new pn(ee);
          }
        }
        w.ConfigNamespace = Ke;
      },
      /* 94 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.ConnectionSetNamespace = void 0;
        var n = V(81), F = V(87);
        const C = n.NamespaceIds.connectionSet.id;
        class e extends F.XFAObject {
          constructor(E) {
            super(C, "connectionSet", !0), this.wsdlConnection = new F.XFAObjectArray(), this.xmlConnection = new F.XFAObjectArray(), this.xsdConnection = new F.XFAObjectArray();
          }
        }
        class t extends F.XFAObject {
          constructor(E) {
            super(C, "effectiveInputPolicy"), this.id = E.id || "", this.name = E.name || "", this.use = E.use || "", this.usehref = E.usehref || "";
          }
        }
        class l extends F.XFAObject {
          constructor(E) {
            super(C, "effectiveOutputPolicy"), this.id = E.id || "", this.name = E.name || "", this.use = E.use || "", this.usehref = E.usehref || "";
          }
        }
        class j extends F.StringObject {
          constructor(E) {
            super(C, "operation"), this.id = E.id || "", this.input = E.input || "", this.name = E.name || "", this.output = E.output || "", this.use = E.use || "", this.usehref = E.usehref || "";
          }
        }
        class U extends F.StringObject {
          constructor(E) {
            super(C, "rootElement"), this.id = E.id || "", this.name = E.name || "", this.use = E.use || "", this.usehref = E.usehref || "";
          }
        }
        class O extends F.StringObject {
          constructor(E) {
            super(C, "soapAction"), this.id = E.id || "", this.name = E.name || "", this.use = E.use || "", this.usehref = E.usehref || "";
          }
        }
        class v extends F.StringObject {
          constructor(E) {
            super(C, "soapAddress"), this.id = E.id || "", this.name = E.name || "", this.use = E.use || "", this.usehref = E.usehref || "";
          }
        }
        class g extends F.StringObject {
          constructor(E) {
            super(C, "uri"), this.id = E.id || "", this.name = E.name || "", this.use = E.use || "", this.usehref = E.usehref || "";
          }
        }
        class b extends F.StringObject {
          constructor(E) {
            super(C, "wsdlAddress"), this.id = E.id || "", this.name = E.name || "", this.use = E.use || "", this.usehref = E.usehref || "";
          }
        }
        class i extends F.XFAObject {
          constructor(E) {
            super(C, "wsdlConnection", !0), this.dataDescription = E.dataDescription || "", this.name = E.name || "", this.effectiveInputPolicy = null, this.effectiveOutputPolicy = null, this.operation = null, this.soapAction = null, this.soapAddress = null, this.wsdlAddress = null;
          }
        }
        class P extends F.XFAObject {
          constructor(E) {
            super(C, "xmlConnection", !0), this.dataDescription = E.dataDescription || "", this.name = E.name || "", this.uri = null;
          }
        }
        class d extends F.XFAObject {
          constructor(E) {
            super(C, "xsdConnection", !0), this.dataDescription = E.dataDescription || "", this.name = E.name || "", this.rootElement = null, this.uri = null;
          }
        }
        class A {
          static [n.$buildXFAObject](E, k) {
            if (A.hasOwnProperty(E))
              return A[E](k);
          }
          static connectionSet(E) {
            return new e(E);
          }
          static effectiveInputPolicy(E) {
            return new t(E);
          }
          static effectiveOutputPolicy(E) {
            return new l(E);
          }
          static operation(E) {
            return new j(E);
          }
          static rootElement(E) {
            return new U(E);
          }
          static soapAction(E) {
            return new O(E);
          }
          static soapAddress(E) {
            return new v(E);
          }
          static uri(E) {
            return new g(E);
          }
          static wsdlAddress(E) {
            return new b(E);
          }
          static wsdlConnection(E) {
            return new i(E);
          }
          static xmlConnection(E) {
            return new P(E);
          }
          static xsdConnection(E) {
            return new d(E);
          }
        }
        w.ConnectionSetNamespace = A;
      },
      /* 95 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.DatasetsNamespace = void 0;
        var n = V(78), F = V(81), C = V(87);
        const e = F.NamespaceIds.datasets.id;
        class t extends C.XmlObject {
          constructor(O) {
            super(e, "data", O);
          }
          [n.$isNsAgnostic]() {
            return !0;
          }
        }
        class l extends C.XFAObject {
          constructor(O) {
            super(e, "datasets", !0), this.data = null, this.Signature = null;
          }
          [n.$onChild](O) {
            const v = O[n.$nodeName];
            (v === "data" && O[n.$namespaceId] === e || v === "Signature" && O[n.$namespaceId] === F.NamespaceIds.signature.id) && (this[v] = O), this[n.$appendChild](O);
          }
        }
        class j {
          static [F.$buildXFAObject](O, v) {
            if (j.hasOwnProperty(O))
              return j[O](v);
          }
          static datasets(O) {
            return new l(O);
          }
          static data(O) {
            return new t(O);
          }
        }
        w.DatasetsNamespace = j;
      },
      /* 96 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.LocaleSetNamespace = void 0;
        var n = V(81), F = V(87), C = V(84);
        const e = n.NamespaceIds.localeSet.id;
        class t extends F.XFAObject {
          constructor(D) {
            super(e, "calendarSymbols", !0), this.name = "gregorian", this.dayNames = new F.XFAObjectArray(2), this.eraNames = null, this.meridiemNames = null, this.monthNames = new F.XFAObjectArray(2);
          }
        }
        class l extends F.StringObject {
          constructor(D) {
            super(e, "currencySymbol"), this.name = (0, C.getStringOption)(D.name, ["symbol", "isoname", "decimal"]);
          }
        }
        class j extends F.XFAObject {
          constructor(D) {
            super(e, "currencySymbols", !0), this.currencySymbol = new F.XFAObjectArray(3);
          }
        }
        class U extends F.StringObject {
          constructor(D) {
            super(e, "datePattern"), this.name = (0, C.getStringOption)(D.name, ["full", "long", "med", "short"]);
          }
        }
        class O extends F.XFAObject {
          constructor(D) {
            super(e, "datePatterns", !0), this.datePattern = new F.XFAObjectArray(4);
          }
        }
        class v extends F.ContentObject {
          constructor(D) {
            super(e, "dateTimeSymbols");
          }
        }
        class g extends F.StringObject {
          constructor(D) {
            super(e, "day");
          }
        }
        class b extends F.XFAObject {
          constructor(D) {
            super(e, "dayNames", !0), this.abbr = (0, C.getInteger)({
              data: D.abbr,
              defaultValue: 0,
              validate: (K) => K === 1
            }), this.day = new F.XFAObjectArray(7);
          }
        }
        class i extends F.StringObject {
          constructor(D) {
            super(e, "era");
          }
        }
        class P extends F.XFAObject {
          constructor(D) {
            super(e, "eraNames", !0), this.era = new F.XFAObjectArray(2);
          }
        }
        class d extends F.XFAObject {
          constructor(D) {
            super(e, "locale", !0), this.desc = D.desc || "", this.name = "isoname", this.calendarSymbols = null, this.currencySymbols = null, this.datePatterns = null, this.dateTimeSymbols = null, this.numberPatterns = null, this.numberSymbols = null, this.timePatterns = null, this.typeFaces = null;
          }
        }
        class A extends F.XFAObject {
          constructor(D) {
            super(e, "localeSet", !0), this.locale = new F.XFAObjectArray();
          }
        }
        class I extends F.StringObject {
          constructor(D) {
            super(e, "meridiem");
          }
        }
        class E extends F.XFAObject {
          constructor(D) {
            super(e, "meridiemNames", !0), this.meridiem = new F.XFAObjectArray(2);
          }
        }
        class k extends F.StringObject {
          constructor(D) {
            super(e, "month");
          }
        }
        class H extends F.XFAObject {
          constructor(D) {
            super(e, "monthNames", !0), this.abbr = (0, C.getInteger)({
              data: D.abbr,
              defaultValue: 0,
              validate: (K) => K === 1
            }), this.month = new F.XFAObjectArray(12);
          }
        }
        class x extends F.StringObject {
          constructor(D) {
            super(e, "numberPattern"), this.name = (0, C.getStringOption)(D.name, ["full", "long", "med", "short"]);
          }
        }
        class R extends F.XFAObject {
          constructor(D) {
            super(e, "numberPatterns", !0), this.numberPattern = new F.XFAObjectArray(4);
          }
        }
        class f extends F.StringObject {
          constructor(D) {
            super(e, "numberSymbol"), this.name = (0, C.getStringOption)(D.name, ["decimal", "grouping", "percent", "minus", "zero"]);
          }
        }
        class c extends F.XFAObject {
          constructor(D) {
            super(e, "numberSymbols", !0), this.numberSymbol = new F.XFAObjectArray(5);
          }
        }
        class N extends F.StringObject {
          constructor(D) {
            super(e, "timePattern"), this.name = (0, C.getStringOption)(D.name, ["full", "long", "med", "short"]);
          }
        }
        class u extends F.XFAObject {
          constructor(D) {
            super(e, "timePatterns", !0), this.timePattern = new F.XFAObjectArray(4);
          }
        }
        class p extends F.XFAObject {
          constructor(D) {
            super(e, "typeFace", !0), this.name = D.name | "";
          }
        }
        class S extends F.XFAObject {
          constructor(D) {
            super(e, "typeFaces", !0), this.typeFace = new F.XFAObjectArray();
          }
        }
        class B {
          static [n.$buildXFAObject](D, K) {
            if (B.hasOwnProperty(D))
              return B[D](K);
          }
          static calendarSymbols(D) {
            return new t(D);
          }
          static currencySymbol(D) {
            return new l(D);
          }
          static currencySymbols(D) {
            return new j(D);
          }
          static datePattern(D) {
            return new U(D);
          }
          static datePatterns(D) {
            return new O(D);
          }
          static dateTimeSymbols(D) {
            return new v(D);
          }
          static day(D) {
            return new g(D);
          }
          static dayNames(D) {
            return new b(D);
          }
          static era(D) {
            return new i(D);
          }
          static eraNames(D) {
            return new P(D);
          }
          static locale(D) {
            return new d(D);
          }
          static localeSet(D) {
            return new A(D);
          }
          static meridiem(D) {
            return new I(D);
          }
          static meridiemNames(D) {
            return new E(D);
          }
          static month(D) {
            return new k(D);
          }
          static monthNames(D) {
            return new H(D);
          }
          static numberPattern(D) {
            return new x(D);
          }
          static numberPatterns(D) {
            return new R(D);
          }
          static numberSymbol(D) {
            return new f(D);
          }
          static numberSymbols(D) {
            return new c(D);
          }
          static timePattern(D) {
            return new N(D);
          }
          static timePatterns(D) {
            return new u(D);
          }
          static typeFace(D) {
            return new p(D);
          }
          static typeFaces(D) {
            return new S(D);
          }
        }
        w.LocaleSetNamespace = B;
      },
      /* 97 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.SignatureNamespace = void 0;
        var n = V(81), F = V(87);
        const C = n.NamespaceIds.signature.id;
        class e extends F.XFAObject {
          constructor(j) {
            super(C, "signature", !0);
          }
        }
        class t {
          static [n.$buildXFAObject](j, U) {
            if (t.hasOwnProperty(j))
              return t[j](U);
          }
          static signature(j) {
            return new e(j);
          }
        }
        w.SignatureNamespace = t;
      },
      /* 98 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.StylesheetNamespace = void 0;
        var n = V(81), F = V(87);
        const C = n.NamespaceIds.stylesheet.id;
        class e extends F.XFAObject {
          constructor(j) {
            super(C, "stylesheet", !0);
          }
        }
        class t {
          static [n.$buildXFAObject](j, U) {
            if (t.hasOwnProperty(j))
              return t[j](U);
          }
          static stylesheet(j) {
            return new e(j);
          }
        }
        w.StylesheetNamespace = t;
      },
      /* 99 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.XdpNamespace = void 0;
        var n = V(81), F = V(78), C = V(87);
        const e = n.NamespaceIds.xdp.id;
        class t extends C.XFAObject {
          constructor(U) {
            super(e, "xdp", !0), this.uuid = U.uuid || "", this.timeStamp = U.timeStamp || "", this.config = null, this.connectionSet = null, this.datasets = null, this.localeSet = null, this.stylesheet = new C.XFAObjectArray(), this.template = null;
          }
          [F.$onChildCheck](U) {
            const O = n.NamespaceIds[U[F.$nodeName]];
            return O && U[F.$namespaceId] === O.id;
          }
        }
        class l {
          static [n.$buildXFAObject](U, O) {
            if (l.hasOwnProperty(U))
              return l[U](O);
          }
          static xdp(U) {
            return new t(U);
          }
        }
        w.XdpNamespace = l;
      },
      /* 100 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.XhtmlNamespace = void 0;
        var n = V(78), F = V(81), C = V(83), e = V(84), t = V(87);
        const l = F.NamespaceIds.xhtml.id, j = Symbol(), U = /* @__PURE__ */ new Set(["color", "font", "font-family", "font-size", "font-stretch", "font-style", "font-weight", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "letter-spacing", "line-height", "orphans", "page-break-after", "page-break-before", "page-break-inside", "tab-interval", "tab-stop", "text-align", "text-decoration", "text-indent", "vertical-align", "widows", "kerning-mode", "xfa-font-horizontal-scale", "xfa-font-vertical-scale", "xfa-spacerun", "xfa-tab-stops"]), O = /* @__PURE__ */ new Map([["page-break-after", "breakAfter"], ["page-break-before", "breakBefore"], ["page-break-inside", "breakInside"], ["kerning-mode", (D) => D === "none" ? "none" : "normal"], ["xfa-font-horizontal-scale", (D) => `scaleX(${Math.max(0, Math.min(parseInt(D) / 100)).toFixed(2)})`], ["xfa-font-vertical-scale", (D) => `scaleY(${Math.max(0, Math.min(parseInt(D) / 100)).toFixed(2)})`], ["xfa-spacerun", ""], ["xfa-tab-stops", ""], ["font-size", (D, K) => (D = K.fontSize = (0, e.getMeasurement)(D), (0, C.measureToString)(0.99 * D))], ["letter-spacing", (D) => (0, C.measureToString)((0, e.getMeasurement)(D))], ["line-height", (D) => (0, C.measureToString)((0, e.getMeasurement)(D))], ["margin", (D) => (0, C.measureToString)((0, e.getMeasurement)(D))], ["margin-bottom", (D) => (0, C.measureToString)((0, e.getMeasurement)(D))], ["margin-left", (D) => (0, C.measureToString)((0, e.getMeasurement)(D))], ["margin-right", (D) => (0, C.measureToString)((0, e.getMeasurement)(D))], ["margin-top", (D) => (0, C.measureToString)((0, e.getMeasurement)(D))], ["text-indent", (D) => (0, C.measureToString)((0, e.getMeasurement)(D))], ["font-family", (D) => D], ["vertical-align", (D) => (0, C.measureToString)((0, e.getMeasurement)(D))]]), v = /\s+/g, g = /[\r\n]+/g, b = /\r\n?/g;
        function i(D, K, _) {
          const o = /* @__PURE__ */ Object.create(null);
          if (!D)
            return o;
          const m = /* @__PURE__ */ Object.create(null);
          for (const [s, r] of D.split(";").map((y) => y.split(":", 2))) {
            const y = O.get(s);
            if (y === "")
              continue;
            let M = r;
            y && (M = typeof y == "string" ? y : y(r, m)), s.endsWith("scale") ? o.transform = o.transform ? `${o[s]} ${M}` : M : o[s.replaceAll(/-([a-zA-Z])/g, ($, G) => G.toUpperCase())] = M;
          }
          if (o.fontFamily && (0, C.setFontFamily)({
            typeface: o.fontFamily,
            weight: o.fontWeight || "normal",
            posture: o.fontStyle || "normal",
            size: m.fontSize || 0
          }, K, K[n.$globalData].fontFinder, o), _ && o.verticalAlign && o.verticalAlign !== "0px" && o.fontSize) {
            const y = (0, e.getMeasurement)(o.fontSize);
            o.fontSize = (0, C.measureToString)(y * 0.583), o.verticalAlign = (0, C.measureToString)(Math.sign((0, e.getMeasurement)(o.verticalAlign)) * y * 0.333);
          }
          return _ && o.fontSize && (o.fontSize = `calc(${o.fontSize} * var(--scale-factor))`), (0, C.fixTextIndent)(o), o;
        }
        function P(D) {
          return D.style ? D.style.trim().split(/\s*;\s*/).filter((K) => !!K).map((K) => K.split(/\s*:\s*/, 2)).filter(([K, _]) => (K === "font-family" && D[n.$globalData].usedTypefaces.add(_), U.has(K))).map((K) => K.join(":")).join(";") : "";
        }
        const d = /* @__PURE__ */ new Set(["body", "html"]);
        class A extends t.XmlObject {
          constructor(K, _) {
            super(l, _), this[j] = !1, this.style = K.style || "";
          }
          [n.$clean](K) {
            super[n.$clean](K), this.style = P(this);
          }
          [n.$acceptWhitespace]() {
            return !d.has(this[n.$nodeName]);
          }
          [n.$onText](K, _ = !1) {
            _ ? this[j] = !0 : (K = K.replaceAll(g, ""), this.style.includes("xfa-spacerun:yes") || (K = K.replaceAll(v, " "))), K && (this[n.$content] += K);
          }
          [n.$pushGlyphs](K, _ = !0) {
            const o = /* @__PURE__ */ Object.create(null), m = {
              top: NaN,
              bottom: NaN,
              left: NaN,
              right: NaN
            };
            let s = null;
            for (const [r, y] of this.style.split(";").map((M) => M.split(":", 2)))
              switch (r) {
                case "font-family":
                  o.typeface = (0, e.stripQuotes)(y);
                  break;
                case "font-size":
                  o.size = (0, e.getMeasurement)(y);
                  break;
                case "font-weight":
                  o.weight = y;
                  break;
                case "font-style":
                  o.posture = y;
                  break;
                case "letter-spacing":
                  o.letterSpacing = (0, e.getMeasurement)(y);
                  break;
                case "margin":
                  const M = y.split(/ \t/).map(($) => (0, e.getMeasurement)($));
                  switch (M.length) {
                    case 1:
                      m.top = m.bottom = m.left = m.right = M[0];
                      break;
                    case 2:
                      m.top = m.bottom = M[0], m.left = m.right = M[1];
                      break;
                    case 3:
                      m.top = M[0], m.bottom = M[2], m.left = m.right = M[1];
                      break;
                    case 4:
                      m.top = M[0], m.left = M[1], m.bottom = M[2], m.right = M[3];
                      break;
                  }
                  break;
                case "margin-top":
                  m.top = (0, e.getMeasurement)(y);
                  break;
                case "margin-bottom":
                  m.bottom = (0, e.getMeasurement)(y);
                  break;
                case "margin-left":
                  m.left = (0, e.getMeasurement)(y);
                  break;
                case "margin-right":
                  m.right = (0, e.getMeasurement)(y);
                  break;
                case "line-height":
                  s = (0, e.getMeasurement)(y);
                  break;
              }
            if (K.pushData(o, m, s), this[n.$content])
              K.addString(this[n.$content]);
            else
              for (const r of this[n.$getChildren]()) {
                if (r[n.$nodeName] === "#text") {
                  K.addString(r[n.$content]);
                  continue;
                }
                r[n.$pushGlyphs](K);
              }
            _ && K.popFont();
          }
          [n.$toHTML](K) {
            const _ = [];
            if (this[n.$extra] = {
              children: _
            }, this[n.$childrenToHTML]({}), _.length === 0 && !this[n.$content])
              return e.HTMLResult.EMPTY;
            let o;
            return this[j] ? o = this[n.$content] ? this[n.$content].replaceAll(b, `
`) : void 0 : o = this[n.$content] || void 0, e.HTMLResult.success({
              name: this[n.$nodeName],
              attributes: {
                href: this.href,
                style: i(this.style, this, this[j])
              },
              children: _,
              value: o
            });
          }
        }
        class I extends A {
          constructor(K) {
            super(K, "a"), this.href = (0, C.fixURL)(K.href) || "";
          }
        }
        class E extends A {
          constructor(K) {
            super(K, "b");
          }
          [n.$pushGlyphs](K) {
            K.pushFont({
              weight: "bold"
            }), super[n.$pushGlyphs](K), K.popFont();
          }
        }
        class k extends A {
          constructor(K) {
            super(K, "body");
          }
          [n.$toHTML](K) {
            const _ = super[n.$toHTML](K), {
              html: o
            } = _;
            return o ? (o.name = "div", o.attributes.class = ["xfaRich"], _) : e.HTMLResult.EMPTY;
          }
        }
        class H extends A {
          constructor(K) {
            super(K, "br");
          }
          [n.$text]() {
            return `
`;
          }
          [n.$pushGlyphs](K) {
            K.addString(`
`);
          }
          [n.$toHTML](K) {
            return e.HTMLResult.success({
              name: "br"
            });
          }
        }
        class x extends A {
          constructor(K) {
            super(K, "html");
          }
          [n.$toHTML](K) {
            var o;
            const _ = [];
            if (this[n.$extra] = {
              children: _
            }, this[n.$childrenToHTML]({}), _.length === 0)
              return e.HTMLResult.success({
                name: "div",
                attributes: {
                  class: ["xfaRich"],
                  style: {}
                },
                value: this[n.$content] || ""
              });
            if (_.length === 1) {
              const m = _[0];
              if ((o = m.attributes) != null && o.class.includes("xfaRich"))
                return e.HTMLResult.success(m);
            }
            return e.HTMLResult.success({
              name: "div",
              attributes: {
                class: ["xfaRich"],
                style: {}
              },
              children: _
            });
          }
        }
        class R extends A {
          constructor(K) {
            super(K, "i");
          }
          [n.$pushGlyphs](K) {
            K.pushFont({
              posture: "italic"
            }), super[n.$pushGlyphs](K), K.popFont();
          }
        }
        class f extends A {
          constructor(K) {
            super(K, "li");
          }
        }
        class c extends A {
          constructor(K) {
            super(K, "ol");
          }
        }
        class N extends A {
          constructor(K) {
            super(K, "p");
          }
          [n.$pushGlyphs](K) {
            super[n.$pushGlyphs](K, !1), K.addString(`
`), K.addPara(), K.popFont();
          }
          [n.$text]() {
            return this[n.$getParent]()[n.$getChildren]().at(-1) === this ? super[n.$text]() : super[n.$text]() + `
`;
          }
        }
        class u extends A {
          constructor(K) {
            super(K, "span");
          }
        }
        class p extends A {
          constructor(K) {
            super(K, "sub");
          }
        }
        class S extends A {
          constructor(K) {
            super(K, "sup");
          }
        }
        class B extends A {
          constructor(K) {
            super(K, "ul");
          }
        }
        class T {
          static [F.$buildXFAObject](K, _) {
            if (T.hasOwnProperty(K))
              return T[K](_);
          }
          static a(K) {
            return new I(K);
          }
          static b(K) {
            return new E(K);
          }
          static body(K) {
            return new k(K);
          }
          static br(K) {
            return new H(K);
          }
          static html(K) {
            return new x(K);
          }
          static i(K) {
            return new R(K);
          }
          static li(K) {
            return new f(K);
          }
          static ol(K) {
            return new c(K);
          }
          static p(K) {
            return new N(K);
          }
          static span(K) {
            return new u(K);
          }
          static sub(K) {
            return new p(K);
          }
          static sup(K) {
            return new S(K);
          }
          static ul(K) {
            return new B(K);
          }
        }
        w.XhtmlNamespace = T;
      },
      /* 101 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.UnknownNamespace = void 0;
        var n = V(81), F = V(87);
        class C {
          constructor(t) {
            this.namespaceId = t;
          }
          [n.$buildXFAObject](t, l) {
            return new F.XmlObject(this.namespaceId, t, l);
          }
        }
        w.UnknownNamespace = C;
      },
      /* 102 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.DatasetReader = void 0;
        var n = V(2), F = V(3), C = V(71);
        function e(j) {
          try {
            return (0, n.stringToUTF8String)(j);
          } catch (U) {
            return (0, n.warn)(`UTF-8 decoding failed: "${U}".`), j;
          }
        }
        class t extends C.SimpleXMLParser {
          constructor(U) {
            super(U), this.node = null;
          }
          onEndElement(U) {
            const O = super.onEndElement(U);
            if (O && U === "xfa:datasets")
              throw this.node = O, new Error("Aborting DatasetXMLParser.");
          }
        }
        class l {
          constructor(U) {
            if (U.datasets)
              this.node = new C.SimpleXMLParser({
                hasAttributes: !0
              }).parseFromString(U.datasets).documentElement;
            else {
              const O = new t({
                hasAttributes: !0
              });
              try {
                O.parseFromString(U["xdp:xdp"]);
              } catch {
              }
              this.node = O.node;
            }
          }
          getValue(U) {
            if (!this.node || !U)
              return "";
            const O = this.node.searchNode((0, F.parseXFAPath)(U), 0);
            if (!O)
              return "";
            const v = O.firstChild;
            return (v == null ? void 0 : v.nodeName) === "value" ? O.children.map((g) => e(g.textContent)) : e(O.textContent);
          }
        }
        w.DatasetReader = l;
      },
      /* 103 */
      /***/
      (fe, w, V) => {
        var U;
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.XRef = void 0;
        var n = V(2), F = V(4), C = V(16), e = V(3), t = V(5), l = V(74);
        class j {
          constructor(v, g) {
            Me(this, U, null);
            this.stream = v, this.pdfManager = g, this.entries = [], this._xrefStms = /* @__PURE__ */ new Set(), this._cacheMap = /* @__PURE__ */ new Map(), this._pendingRefs = new F.RefSet(), this._newPersistentRefNum = null, this._newTemporaryRefNum = null;
          }
          getNewPersistentRef(v) {
            this._newPersistentRefNum === null && (this._newPersistentRefNum = this.entries.length || 1);
            const g = this._newPersistentRefNum++;
            return this._cacheMap.set(g, v), F.Ref.get(g, 0);
          }
          getNewTemporaryRef() {
            return this._newTemporaryRefNum === null && (this._newTemporaryRefNum = this.entries.length || 1), F.Ref.get(this._newTemporaryRefNum++, 0);
          }
          resetNewTemporaryRef() {
            this._newTemporaryRefNum = null;
          }
          setStartXRef(v) {
            this.startXRefQueue = [v];
          }
          parse(v = !1) {
            let g;
            v ? ((0, n.warn)("Indexing all PDF objects"), g = this.indexObjects()) : g = this.readXRef(), g.assignXref(this), this.trailer = g;
            let b;
            try {
              b = g.get("Encrypt");
            } catch (P) {
              if (P instanceof e.MissingDataException)
                throw P;
              (0, n.warn)(`XRef.parse - Invalid "Encrypt" reference: "${P}".`);
            }
            if (b instanceof F.Dict) {
              const P = g.get("ID"), d = P != null && P.length ? P[0] : "";
              b.suppressEncryption = !0, this.encrypt = new l.CipherTransformFactory(b, d, this.pdfManager.password);
            }
            let i;
            try {
              i = g.get("Root");
            } catch (P) {
              if (P instanceof e.MissingDataException)
                throw P;
              (0, n.warn)(`XRef.parse - Invalid "Root" reference: "${P}".`);
            }
            if (i instanceof F.Dict)
              try {
                if (i.get("Pages") instanceof F.Dict) {
                  this.root = i;
                  return;
                }
              } catch (P) {
                if (P instanceof e.MissingDataException)
                  throw P;
                (0, n.warn)(`XRef.parse - Invalid "Pages" reference: "${P}".`);
              }
            throw v ? new n.InvalidPDFException("Invalid Root reference.") : new e.XRefParseException();
          }
          processXRefTable(v) {
            "tableState" in this || (this.tableState = {
              entryNum: 0,
              streamPos: v.lexer.stream.pos,
              parserBuf1: v.buf1,
              parserBuf2: v.buf2
            });
            const g = this.readXRefTable(v);
            if (!(0, F.isCmd)(g, "trailer"))
              throw new n.FormatError("Invalid XRef table: could not find trailer dictionary");
            let b = v.getObj();
            if (!(b instanceof F.Dict) && b.dict && (b = b.dict), !(b instanceof F.Dict))
              throw new n.FormatError("Invalid XRef table: could not parse trailer dictionary");
            return delete this.tableState, b;
          }
          readXRefTable(v) {
            const g = v.lexer.stream, b = this.tableState;
            g.pos = b.streamPos, v.buf1 = b.parserBuf1, v.buf2 = b.parserBuf2;
            let i;
            for (; ; ) {
              if (!("firstEntryNum" in b) || !("entryCount" in b)) {
                if ((0, F.isCmd)(i = v.getObj(), "trailer"))
                  break;
                b.firstEntryNum = i, b.entryCount = v.getObj();
              }
              let P = b.firstEntryNum;
              const d = b.entryCount;
              if (!Number.isInteger(P) || !Number.isInteger(d))
                throw new n.FormatError("Invalid XRef table: wrong types in subsection header");
              for (let A = b.entryNum; A < d; A++) {
                b.streamPos = g.pos, b.entryNum = A, b.parserBuf1 = v.buf1, b.parserBuf2 = v.buf2;
                const I = {};
                I.offset = v.getObj(), I.gen = v.getObj();
                const E = v.getObj();
                if (E instanceof F.Cmd)
                  switch (E.cmd) {
                    case "f":
                      I.free = !0;
                      break;
                    case "n":
                      I.uncompressed = !0;
                      break;
                  }
                if (!Number.isInteger(I.offset) || !Number.isInteger(I.gen) || !(I.free || I.uncompressed))
                  throw new n.FormatError(`Invalid entry in XRef subsection: ${P}, ${d}`);
                A === 0 && I.free && P === 1 && (P = 0), this.entries[A + P] || (this.entries[A + P] = I);
              }
              b.entryNum = 0, b.streamPos = g.pos, b.parserBuf1 = v.buf1, b.parserBuf2 = v.buf2, delete b.firstEntryNum, delete b.entryCount;
            }
            if (this.entries[0] && !this.entries[0].free)
              throw new n.FormatError("Invalid XRef table: unexpected first object");
            return i;
          }
          processXRefStream(v) {
            if (!("streamState" in this)) {
              const g = v.dict, b = g.get("W");
              let i = g.get("Index");
              i || (i = [0, g.get("Size")]), this.streamState = {
                entryRanges: i,
                byteWidths: b,
                entryNum: 0,
                streamPos: v.pos
              };
            }
            return this.readXRefStream(v), delete this.streamState, v.dict;
          }
          readXRefStream(v) {
            const g = this.streamState;
            v.pos = g.streamPos;
            const [b, i, P] = g.byteWidths, d = g.entryRanges;
            for (; d.length > 0; ) {
              const [A, I] = d;
              if (!Number.isInteger(A) || !Number.isInteger(I))
                throw new n.FormatError(`Invalid XRef range fields: ${A}, ${I}`);
              if (!Number.isInteger(b) || !Number.isInteger(i) || !Number.isInteger(P))
                throw new n.FormatError(`Invalid XRef entry fields length: ${A}, ${I}`);
              for (let E = g.entryNum; E < I; ++E) {
                g.entryNum = E, g.streamPos = v.pos;
                let k = 0, H = 0, x = 0;
                for (let f = 0; f < b; ++f) {
                  const c = v.getByte();
                  if (c === -1)
                    throw new n.FormatError("Invalid XRef byteWidths 'type'.");
                  k = k << 8 | c;
                }
                b === 0 && (k = 1);
                for (let f = 0; f < i; ++f) {
                  const c = v.getByte();
                  if (c === -1)
                    throw new n.FormatError("Invalid XRef byteWidths 'offset'.");
                  H = H << 8 | c;
                }
                for (let f = 0; f < P; ++f) {
                  const c = v.getByte();
                  if (c === -1)
                    throw new n.FormatError("Invalid XRef byteWidths 'generation'.");
                  x = x << 8 | c;
                }
                const R = {};
                switch (R.offset = H, R.gen = x, k) {
                  case 0:
                    R.free = !0;
                    break;
                  case 1:
                    R.uncompressed = !0;
                    break;
                  case 2:
                    break;
                  default:
                    throw new n.FormatError(`Invalid XRef entry type: ${k}`);
                }
                this.entries[A + E] || (this.entries[A + E] = R);
              }
              g.entryNum = 0, g.streamPos = v.pos, d.splice(0, 2);
            }
          }
          indexObjects() {
            function A(m, s) {
              let r = "", y = m[s];
              for (; y !== 10 && y !== 13 && y !== 60 && !(++s >= m.length); )
                r += String.fromCharCode(y), y = m[s];
              return r;
            }
            function I(m, s, r) {
              const y = r.length, M = m.length;
              let $ = 0;
              for (; s < M; ) {
                let G = 0;
                for (; G < y && m[s + G] === r[G]; )
                  ++G;
                if (G >= y)
                  break;
                s++, $++;
              }
              return $;
            }
            const E = /\b(endobj|\d+\s+\d+\s+obj|xref|trailer\s*<<)\b/g, k = /\b(startxref|\d+\s+\d+\s+obj)\b/g, H = /^(\d+)\s+(\d+)\s+obj\b/, x = new Uint8Array([116, 114, 97, 105, 108, 101, 114]), R = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]), f = new Uint8Array([47, 88, 82, 101, 102]);
            this.entries.length = 0, this._cacheMap.clear();
            const c = this.stream;
            c.pos = 0;
            const N = c.getBytes(), u = (0, n.bytesToString)(N), p = N.length;
            let S = c.start;
            const B = [], T = [];
            for (; S < p; ) {
              let m = N[S];
              if (m === 9 || m === 10 || m === 13 || m === 32) {
                ++S;
                continue;
              }
              if (m === 37) {
                do {
                  if (++S, S >= p)
                    break;
                  m = N[S];
                } while (m !== 10 && m !== 13);
                continue;
              }
              const s = A(N, S);
              let r;
              if (s.startsWith("xref") && (s.length === 4 || /\s/.test(s[4])))
                S += I(N, S, x), B.push(S), S += I(N, S, R);
              else if (r = H.exec(s)) {
                const y = r[1] | 0, M = r[2] | 0, $ = S + s.length;
                let G, ce = !1;
                if (!this.entries[y])
                  ce = !0;
                else if (this.entries[y].gen === M)
                  try {
                    new C.Parser({
                      lexer: new C.Lexer(c.makeSubStream($))
                    }).getObj(), ce = !0;
                  } catch (te) {
                    te instanceof e.ParserEOFException ? (0, n.warn)(`indexObjects -- checking object (${s}): "${te}".`) : ce = !0;
                  }
                ce && (this.entries[y] = {
                  offset: S - c.start,
                  gen: M,
                  uncompressed: !0
                }), E.lastIndex = $;
                const q = E.exec(u);
                q ? (G = E.lastIndex + 1 - S, q[1] !== "endobj" && ((0, n.warn)(`indexObjects: Found "${q[1]}" inside of another "obj", caused by missing "endobj" -- trying to recover.`), G -= q[1].length + 1)) : G = p - S;
                const re = N.subarray(S, S + G), Z = I(re, 0, f);
                Z < G && re[Z + 5] < 64 && (T.push(S - c.start), this._xrefStms.add(S - c.start)), S += G;
              } else if (s.startsWith("trailer") && (s.length === 7 || /\s/.test(s[7]))) {
                B.push(S);
                const y = S + s.length;
                let M;
                k.lastIndex = y;
                const $ = k.exec(u);
                $ ? (M = k.lastIndex + 1 - S, $[1] !== "startxref" && ((0, n.warn)(`indexObjects: Found "${$[1]}" after "trailer", caused by missing "startxref" -- trying to recover.`), M -= $[1].length + 1)) : M = p - S, S += M;
              } else
                S += s.length + 1;
            }
            for (const m of T)
              this.startXRefQueue.push(m), this.readXRef(!0);
            const D = [];
            let K = !1;
            for (const m of B) {
              c.pos = m;
              const s = new C.Parser({
                lexer: new C.Lexer(c),
                xref: this,
                allowStreams: !0,
                recoveryMode: !0
              }), r = s.getObj();
              if (!(0, F.isCmd)(r, "trailer"))
                continue;
              const y = s.getObj();
              y instanceof F.Dict && (D.push(y), y.has("Encrypt") && (K = !0));
            }
            let _, o;
            for (const m of [...D, "genFallback", ...D]) {
              if (m === "genFallback") {
                if (!o)
                  break;
                this._generationFallback = !0;
                continue;
              }
              let s = !1;
              try {
                const r = m.get("Root");
                if (!(r instanceof F.Dict))
                  continue;
                const y = r.get("Pages");
                if (!(y instanceof F.Dict))
                  continue;
                const M = y.get("Count");
                Number.isInteger(M) && (s = !0);
              } catch (r) {
                o = r;
                continue;
              }
              if (s && (!K || m.has("Encrypt")) && m.has("ID"))
                return m;
              _ = m;
            }
            if (_)
              return _;
            if (this.topDict)
              return this.topDict;
            throw new n.InvalidPDFException("Invalid PDF structure.");
          }
          readXRef(v = !1) {
            const g = this.stream, b = /* @__PURE__ */ new Set();
            for (; this.startXRefQueue.length; ) {
              try {
                const i = this.startXRefQueue[0];
                if (b.has(i)) {
                  (0, n.warn)("readXRef - skipping XRef table since it was already parsed."), this.startXRefQueue.shift();
                  continue;
                }
                b.add(i), g.pos = i + g.start;
                const P = new C.Parser({
                  lexer: new C.Lexer(g),
                  xref: this,
                  allowStreams: !0
                });
                let d = P.getObj(), A;
                if ((0, F.isCmd)(d, "xref"))
                  A = this.processXRefTable(P), this.topDict || (this.topDict = A), d = A.get("XRefStm"), Number.isInteger(d) && !this._xrefStms.has(d) && (this._xrefStms.add(d), this.startXRefQueue.push(d), le(this, U) ?? Xe(this, U, d));
                else if (Number.isInteger(d)) {
                  if (!Number.isInteger(P.getObj()) || !(0, F.isCmd)(P.getObj(), "obj") || !((d = P.getObj()) instanceof t.BaseStream))
                    throw new n.FormatError("Invalid XRef stream");
                  if (A = this.processXRefStream(d), this.topDict || (this.topDict = A), !A)
                    throw new n.FormatError("Failed to read XRef stream");
                } else
                  throw new n.FormatError("Invalid XRef stream header");
                d = A.get("Prev"), Number.isInteger(d) ? this.startXRefQueue.push(d) : d instanceof F.Ref && this.startXRefQueue.push(d.num);
              } catch (i) {
                if (i instanceof e.MissingDataException)
                  throw i;
                (0, n.info)("(while reading XRef): " + i);
              }
              this.startXRefQueue.shift();
            }
            if (this.topDict)
              return this.topDict;
            if (!v)
              throw new e.XRefParseException();
          }
          get lastXRefStreamPos() {
            return le(this, U) ?? (this._xrefStms.size > 0 ? Math.max(...this._xrefStms) : null);
          }
          getEntry(v) {
            const g = this.entries[v];
            return g && !g.free && g.offset ? g : null;
          }
          fetchIfRef(v, g = !1) {
            return v instanceof F.Ref ? this.fetch(v, g) : v;
          }
          fetch(v, g = !1) {
            if (!(v instanceof F.Ref))
              throw new Error("ref object is not a reference");
            const b = v.num, i = this._cacheMap.get(b);
            if (i !== void 0)
              return i instanceof F.Dict && !i.objId && (i.objId = v.toString()), i;
            let P = this.getEntry(b);
            if (P === null)
              return this._cacheMap.set(b, P), P;
            if (this._pendingRefs.has(v))
              return this._pendingRefs.remove(v), (0, n.warn)(`Ignoring circular reference: ${v}.`), F.CIRCULAR_REF;
            this._pendingRefs.put(v);
            try {
              P = P.uncompressed ? this.fetchUncompressed(v, P, g) : this.fetchCompressed(v, P, g), this._pendingRefs.remove(v);
            } catch (d) {
              throw this._pendingRefs.remove(v), d;
            }
            return P instanceof F.Dict ? P.objId = v.toString() : P instanceof t.BaseStream && (P.dict.objId = v.toString()), P;
          }
          fetchUncompressed(v, g, b = !1) {
            const i = v.gen;
            let P = v.num;
            if (g.gen !== i) {
              const H = `Inconsistent generation in XRef: ${v}`;
              if (this._generationFallback && g.gen < i)
                return (0, n.warn)(H), this.fetchUncompressed(F.Ref.get(P, g.gen), g, b);
              throw new e.XRefEntryException(H);
            }
            const d = this.stream.makeSubStream(g.offset + this.stream.start), A = new C.Parser({
              lexer: new C.Lexer(d),
              xref: this,
              allowStreams: !0
            }), I = A.getObj(), E = A.getObj(), k = A.getObj();
            if (I !== P || E !== i || !(k instanceof F.Cmd))
              throw new e.XRefEntryException(`Bad (uncompressed) XRef entry: ${v}`);
            if (k.cmd !== "obj") {
              if (k.cmd.startsWith("obj") && (P = parseInt(k.cmd.substring(3), 10), !Number.isNaN(P)))
                return P;
              throw new e.XRefEntryException(`Bad (uncompressed) XRef entry: ${v}`);
            }
            return g = this.encrypt && !b ? A.getObj(this.encrypt.createCipherTransform(P, i)) : A.getObj(), g instanceof t.BaseStream || this._cacheMap.set(P, g), g;
          }
          fetchCompressed(v, g, b = !1) {
            const i = g.offset, P = this.fetch(F.Ref.get(i, 0));
            if (!(P instanceof t.BaseStream))
              throw new n.FormatError("bad ObjStm stream");
            const d = P.dict.get("First"), A = P.dict.get("N");
            if (!Number.isInteger(d) || !Number.isInteger(A))
              throw new n.FormatError("invalid first and n parameters for ObjStm stream");
            let I = new C.Parser({
              lexer: new C.Lexer(P),
              xref: this,
              allowStreams: !0
            });
            const E = new Array(A), k = new Array(A);
            for (let R = 0; R < A; ++R) {
              const f = I.getObj();
              if (!Number.isInteger(f))
                throw new n.FormatError(`invalid object number in the ObjStm stream: ${f}`);
              const c = I.getObj();
              if (!Number.isInteger(c))
                throw new n.FormatError(`invalid object offset in the ObjStm stream: ${c}`);
              E[R] = f, k[R] = c;
            }
            const H = (P.start || 0) + d, x = new Array(A);
            for (let R = 0; R < A; ++R) {
              const f = R < A - 1 ? k[R + 1] - k[R] : void 0;
              if (f < 0)
                throw new n.FormatError("Invalid offset in the ObjStm stream.");
              I = new C.Parser({
                lexer: new C.Lexer(P.makeSubStream(H + k[R], f, P.dict)),
                xref: this,
                allowStreams: !0
              });
              const c = I.getObj();
              if (x[R] = c, c instanceof t.BaseStream)
                continue;
              const N = E[R], u = this.entries[N];
              u && u.offset === i && u.gen === R && this._cacheMap.set(N, c);
            }
            if (g = x[g.gen], g === void 0)
              throw new e.XRefEntryException(`Bad (compressed) XRef entry: ${v}`);
            return g;
          }
          async fetchIfRefAsync(v, g) {
            return v instanceof F.Ref ? this.fetchAsync(v, g) : v;
          }
          async fetchAsync(v, g) {
            try {
              return this.fetch(v, g);
            } catch (b) {
              if (!(b instanceof e.MissingDataException))
                throw b;
              return await this.pdfManager.requestRange(b.begin, b.end), this.fetchAsync(v, g);
            }
          }
          getCatalogObj() {
            return this.root;
          }
        }
        U = new WeakMap(), w.XRef = j;
      },
      /* 104 */
      /***/
      (fe, w, V) => {
        var l, Pa, U, Ma, v, Wn;
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.MessageHandler = void 0;
        var n = V(2);
        const F = {
          UNKNOWN: 0,
          DATA: 1,
          ERROR: 2
        }, C = {
          UNKNOWN: 0,
          CANCEL: 1,
          CANCEL_COMPLETE: 2,
          CLOSE: 3,
          ENQUEUE: 4,
          ERROR: 5,
          PULL: 6,
          PULL_COMPLETE: 7,
          START_COMPLETE: 8
        };
        function e(b) {
          switch (b instanceof Error || typeof b == "object" && b !== null || (0, n.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), b.name) {
            case "AbortException":
              return new n.AbortException(b.message);
            case "MissingPDFException":
              return new n.MissingPDFException(b.message);
            case "PasswordException":
              return new n.PasswordException(b.message, b.code);
            case "UnexpectedResponseException":
              return new n.UnexpectedResponseException(b.message, b.status);
            case "UnknownErrorException":
              return new n.UnknownErrorException(b.message, b.details);
            default:
              return new n.UnknownErrorException(b.message, b.toString());
          }
        }
        class t {
          constructor(i, P, d) {
            Me(this, l);
            Me(this, U);
            Me(this, v);
            this.sourceName = i, this.targetName = P, this.comObj = d, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), this._onComObjOnMessage = (A) => {
              const I = A.data;
              if (I.targetName !== this.sourceName)
                return;
              if (I.stream) {
                De(this, U, Ma).call(this, I);
                return;
              }
              if (I.callback) {
                const k = I.callbackId, H = this.callbackCapabilities[k];
                if (!H)
                  throw new Error(`Cannot resolve callback ${k}`);
                if (delete this.callbackCapabilities[k], I.callback === F.DATA)
                  H.resolve(I.data);
                else if (I.callback === F.ERROR)
                  H.reject(e(I.reason));
                else
                  throw new Error("Unexpected callback case");
                return;
              }
              const E = this.actionHandler[I.action];
              if (!E)
                throw new Error(`Unknown action from worker: ${I.action}`);
              if (I.callbackId) {
                const k = this.sourceName, H = I.sourceName;
                new Promise(function(x) {
                  x(E(I.data));
                }).then(function(x) {
                  d.postMessage({
                    sourceName: k,
                    targetName: H,
                    callback: F.DATA,
                    callbackId: I.callbackId,
                    data: x
                  });
                }, function(x) {
                  d.postMessage({
                    sourceName: k,
                    targetName: H,
                    callback: F.ERROR,
                    callbackId: I.callbackId,
                    reason: e(x)
                  });
                });
                return;
              }
              if (I.streamId) {
                De(this, l, Pa).call(this, I);
                return;
              }
              E(I.data);
            }, d.addEventListener("message", this._onComObjOnMessage);
          }
          on(i, P) {
            const d = this.actionHandler;
            if (d[i])
              throw new Error(`There is already an actionName called "${i}"`);
            d[i] = P;
          }
          send(i, P, d) {
            this.comObj.postMessage({
              sourceName: this.sourceName,
              targetName: this.targetName,
              action: i,
              data: P
            }, d);
          }
          sendWithPromise(i, P, d) {
            const A = this.callbackId++, I = new n.PromiseCapability();
            this.callbackCapabilities[A] = I;
            try {
              this.comObj.postMessage({
                sourceName: this.sourceName,
                targetName: this.targetName,
                action: i,
                callbackId: A,
                data: P
              }, d);
            } catch (E) {
              I.reject(E);
            }
            return I.promise;
          }
          sendWithStream(i, P, d, A) {
            const I = this.streamId++, E = this.sourceName, k = this.targetName, H = this.comObj;
            return new ReadableStream({
              start: (x) => {
                const R = new n.PromiseCapability();
                return this.streamControllers[I] = {
                  controller: x,
                  startCall: R,
                  pullCall: null,
                  cancelCall: null,
                  isClosed: !1
                }, H.postMessage({
                  sourceName: E,
                  targetName: k,
                  action: i,
                  streamId: I,
                  data: P,
                  desiredSize: x.desiredSize
                }, A), R.promise;
              },
              pull: (x) => {
                const R = new n.PromiseCapability();
                return this.streamControllers[I].pullCall = R, H.postMessage({
                  sourceName: E,
                  targetName: k,
                  stream: C.PULL,
                  streamId: I,
                  desiredSize: x.desiredSize
                }), R.promise;
              },
              cancel: (x) => {
                (0, n.assert)(x instanceof Error, "cancel must have a valid reason");
                const R = new n.PromiseCapability();
                return this.streamControllers[I].cancelCall = R, this.streamControllers[I].isClosed = !0, H.postMessage({
                  sourceName: E,
                  targetName: k,
                  stream: C.CANCEL,
                  streamId: I,
                  reason: e(x)
                }), R.promise;
              }
            }, d);
          }
          destroy() {
            this.comObj.removeEventListener("message", this._onComObjOnMessage);
          }
        }
        l = new WeakSet(), Pa = function(i) {
          const P = i.streamId, d = this.sourceName, A = i.sourceName, I = this.comObj, E = this, k = this.actionHandler[i.action], H = {
            enqueue(x, R = 1, f) {
              if (this.isCancelled)
                return;
              const c = this.desiredSize;
              this.desiredSize -= R, c > 0 && this.desiredSize <= 0 && (this.sinkCapability = new n.PromiseCapability(), this.ready = this.sinkCapability.promise), I.postMessage({
                sourceName: d,
                targetName: A,
                stream: C.ENQUEUE,
                streamId: P,
                chunk: x
              }, f);
            },
            close() {
              this.isCancelled || (this.isCancelled = !0, I.postMessage({
                sourceName: d,
                targetName: A,
                stream: C.CLOSE,
                streamId: P
              }), delete E.streamSinks[P]);
            },
            error(x) {
              (0, n.assert)(x instanceof Error, "error must have a valid reason"), !this.isCancelled && (this.isCancelled = !0, I.postMessage({
                sourceName: d,
                targetName: A,
                stream: C.ERROR,
                streamId: P,
                reason: e(x)
              }));
            },
            sinkCapability: new n.PromiseCapability(),
            onPull: null,
            onCancel: null,
            isCancelled: !1,
            desiredSize: i.desiredSize,
            ready: null
          };
          H.sinkCapability.resolve(), H.ready = H.sinkCapability.promise, this.streamSinks[P] = H, new Promise(function(x) {
            x(k(i.data, H));
          }).then(function() {
            I.postMessage({
              sourceName: d,
              targetName: A,
              stream: C.START_COMPLETE,
              streamId: P,
              success: !0
            });
          }, function(x) {
            I.postMessage({
              sourceName: d,
              targetName: A,
              stream: C.START_COMPLETE,
              streamId: P,
              reason: e(x)
            });
          });
        }, U = new WeakSet(), Ma = function(i) {
          const P = i.streamId, d = this.sourceName, A = i.sourceName, I = this.comObj, E = this.streamControllers[P], k = this.streamSinks[P];
          switch (i.stream) {
            case C.START_COMPLETE:
              i.success ? E.startCall.resolve() : E.startCall.reject(e(i.reason));
              break;
            case C.PULL_COMPLETE:
              i.success ? E.pullCall.resolve() : E.pullCall.reject(e(i.reason));
              break;
            case C.PULL:
              if (!k) {
                I.postMessage({
                  sourceName: d,
                  targetName: A,
                  stream: C.PULL_COMPLETE,
                  streamId: P,
                  success: !0
                });
                break;
              }
              k.desiredSize <= 0 && i.desiredSize > 0 && k.sinkCapability.resolve(), k.desiredSize = i.desiredSize, new Promise(function(H) {
                var x;
                H((x = k.onPull) == null ? void 0 : x.call(k));
              }).then(function() {
                I.postMessage({
                  sourceName: d,
                  targetName: A,
                  stream: C.PULL_COMPLETE,
                  streamId: P,
                  success: !0
                });
              }, function(H) {
                I.postMessage({
                  sourceName: d,
                  targetName: A,
                  stream: C.PULL_COMPLETE,
                  streamId: P,
                  reason: e(H)
                });
              });
              break;
            case C.ENQUEUE:
              if ((0, n.assert)(E, "enqueue should have stream controller"), E.isClosed)
                break;
              E.controller.enqueue(i.chunk);
              break;
            case C.CLOSE:
              if ((0, n.assert)(E, "close should have stream controller"), E.isClosed)
                break;
              E.isClosed = !0, E.controller.close(), De(this, v, Wn).call(this, E, P);
              break;
            case C.ERROR:
              (0, n.assert)(E, "error should have stream controller"), E.controller.error(e(i.reason)), De(this, v, Wn).call(this, E, P);
              break;
            case C.CANCEL_COMPLETE:
              i.success ? E.cancelCall.resolve() : E.cancelCall.reject(e(i.reason)), De(this, v, Wn).call(this, E, P);
              break;
            case C.CANCEL:
              if (!k)
                break;
              new Promise(function(H) {
                var x;
                H((x = k.onCancel) == null ? void 0 : x.call(k, e(i.reason)));
              }).then(function() {
                I.postMessage({
                  sourceName: d,
                  targetName: A,
                  stream: C.CANCEL_COMPLETE,
                  streamId: P,
                  success: !0
                });
              }, function(H) {
                I.postMessage({
                  sourceName: d,
                  targetName: A,
                  stream: C.CANCEL_COMPLETE,
                  streamId: P,
                  reason: e(H)
                });
              }), k.sinkCapability.reject(e(i.reason)), k.isCancelled = !0, delete this.streamSinks[P];
              break;
            default:
              throw new Error("Unexpected stream case");
          }
        }, v = new WeakSet(), Wn = async function(i, P) {
          var d, A, I;
          await Promise.allSettled([(d = i.startCall) == null ? void 0 : d.promise, (A = i.pullCall) == null ? void 0 : A.promise, (I = i.cancelCall) == null ? void 0 : I.promise]), delete this.streamControllers[P];
        }, w.MessageHandler = t;
      },
      /* 105 */
      /***/
      (fe, w, V) => {
        Object.defineProperty(w, "__esModule", {
          value: !0
        }), w.PDFWorkerStream = void 0;
        var n = V(2);
        class F {
          constructor(l) {
            this._msgHandler = l, this._contentLength = null, this._fullRequestReader = null, this._rangeRequestReaders = [];
          }
          getFullReader() {
            return (0, n.assert)(!this._fullRequestReader, "PDFWorkerStream.getFullReader can only be called once."), this._fullRequestReader = new C(this._msgHandler), this._fullRequestReader;
          }
          getRangeReader(l, j) {
            const U = new e(l, j, this._msgHandler);
            return this._rangeRequestReaders.push(U), U;
          }
          cancelAllRequests(l) {
            var j;
            (j = this._fullRequestReader) == null || j.cancel(l);
            for (const U of this._rangeRequestReaders.slice(0))
              U.cancel(l);
          }
        }
        w.PDFWorkerStream = F;
        class C {
          constructor(l) {
            this._msgHandler = l, this.onProgress = null, this._contentLength = null, this._isRangeSupported = !1, this._isStreamingSupported = !1;
            const j = this._msgHandler.sendWithStream("GetReader");
            this._reader = j.getReader(), this._headersReady = this._msgHandler.sendWithPromise("ReaderHeadersReady").then((U) => {
              this._isStreamingSupported = U.isStreamingSupported, this._isRangeSupported = U.isRangeSupported, this._contentLength = U.contentLength;
            });
          }
          get headersReady() {
            return this._headersReady;
          }
          get contentLength() {
            return this._contentLength;
          }
          get isStreamingSupported() {
            return this._isStreamingSupported;
          }
          get isRangeSupported() {
            return this._isRangeSupported;
          }
          async read() {
            const {
              value: l,
              done: j
            } = await this._reader.read();
            return j ? {
              value: void 0,
              done: !0
            } : {
              value: l.buffer,
              done: !1
            };
          }
          cancel(l) {
            this._reader.cancel(l);
          }
        }
        class e {
          constructor(l, j, U) {
            this._msgHandler = U, this.onProgress = null;
            const O = this._msgHandler.sendWithStream("GetRangeReader", {
              begin: l,
              end: j
            });
            this._reader = O.getReader();
          }
          get isStreamingSupported() {
            return !1;
          }
          async read() {
            const {
              value: l,
              done: j
            } = await this._reader.read();
            return j ? {
              value: void 0,
              done: !0
            } : {
              value: l.buffer,
              done: !1
            };
          }
          cancel(l) {
            this._reader.cancel(l);
          }
        }
      }
      /******/
    ], ge = {};
    function xe(fe) {
      var w = ge[fe];
      if (w !== void 0)
        return w.exports;
      var V = ge[fe] = {
        /******/
        // no module.id needed
        /******/
        // no module.loaded needed
        /******/
        exports: {}
        /******/
      };
      return Re[fe](V, V.exports, xe), V.exports;
    }
    var de = {};
    return (() => {
      var fe = de;
      Object.defineProperty(fe, "__esModule", {
        value: !0
      }), Object.defineProperty(fe, "WorkerMessageHandler", {
        enumerable: !0,
        get: function() {
          return w.WorkerMessageHandler;
        }
      });
      var w = xe(1);
    })(), de;
  })()
));
(function(ge, xe) {
  typeof exports == "object" && typeof module == "object" ? module.exports = ge.pdfjsLib = xe() : typeof define == "function" && define.amd ? define("pdfjs-dist/build/pdf", [], () => ge.pdfjsLib = xe()) : typeof exports == "object" ? exports["pdfjs-dist/build/pdf"] = ge.pdfjsLib = xe() : ge["pdfjs-dist/build/pdf"] = ge.pdfjsLib = xe();
})(globalThis, () => (
  /******/
  (() => {
    var __webpack_modules__ = [
      ,
      /* 1 */
      /***/
      (Re, ge) => {
        var Pe;
        Object.defineProperty(ge, "__esModule", {
          value: !0
        }), ge.VerbosityLevel = ge.Util = ge.UnknownErrorException = ge.UnexpectedResponseException = ge.TextRenderingMode = ge.RenderingIntentFlag = ge.PromiseCapability = ge.PermissionFlag = ge.PasswordResponses = ge.PasswordException = ge.PageActionEventType = ge.OPS = ge.MissingPDFException = ge.MAX_IMAGE_SIZE_TO_CACHE = ge.LINE_FACTOR = ge.LINE_DESCENT_FACTOR = ge.InvalidPDFException = ge.ImageKind = ge.IDENTITY_MATRIX = ge.FormatError = ge.FeatureTest = ge.FONT_IDENTITY_MATRIX = ge.DocumentActionEventType = ge.CMapCompressionType = ge.BaseException = ge.BASELINE_FACTOR = ge.AnnotationType = ge.AnnotationReplyType = ge.AnnotationPrefix = ge.AnnotationMode = ge.AnnotationFlag = ge.AnnotationFieldFlag = ge.AnnotationEditorType = ge.AnnotationEditorPrefix = ge.AnnotationEditorParamsType = ge.AnnotationBorderStyleType = ge.AnnotationActionEventType = ge.AbortException = void 0, ge.assert = B, ge.bytesToString = G, ge.createValidAbsoluteUrl = D, ge.getModificationDate = W, ge.getUuid = Ce, ge.getVerbosityLevel = N, ge.info = u, ge.isArrayBuffer = ie, ge.isArrayEqual = ne, ge.isNodeJS = void 0, ge.normalizeUnicode = ve, ge.objectFromMap = Z, ge.objectSize = re, ge.setVerbosityLevel = c, ge.shadow = K, ge.string32 = q, ge.stringToBytes = ce, ge.stringToPDFString = se, ge.stringToUTF8String = Q, ge.unreachable = S, ge.utf8StringToString = z, ge.warn = p;
        const xe = typeof process == "object" && process + "" == "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
        ge.isNodeJS = xe;
        const de = [1, 0, 0, 1, 0, 0];
        ge.IDENTITY_MATRIX = de;
        const fe = [1e-3, 0, 0, 1e-3, 0, 0];
        ge.FONT_IDENTITY_MATRIX = fe;
        const w = 1e7;
        ge.MAX_IMAGE_SIZE_TO_CACHE = w;
        const V = 1.35;
        ge.LINE_FACTOR = V;
        const n = 0.35;
        ge.LINE_DESCENT_FACTOR = n;
        const F = n / V;
        ge.BASELINE_FACTOR = F;
        const C = {
          ANY: 1,
          DISPLAY: 2,
          PRINT: 4,
          SAVE: 8,
          ANNOTATIONS_FORMS: 16,
          ANNOTATIONS_STORAGE: 32,
          ANNOTATIONS_DISABLE: 64,
          OPLIST: 256
        };
        ge.RenderingIntentFlag = C;
        const e = {
          DISABLE: 0,
          ENABLE: 1,
          ENABLE_FORMS: 2,
          ENABLE_STORAGE: 3
        };
        ge.AnnotationMode = e;
        const t = "pdfjs_internal_editor_";
        ge.AnnotationEditorPrefix = t;
        const l = {
          DISABLE: -1,
          NONE: 0,
          FREETEXT: 3,
          STAMP: 13,
          INK: 15
        };
        ge.AnnotationEditorType = l;
        const j = {
          RESIZE: 1,
          CREATE: 2,
          FREETEXT_SIZE: 11,
          FREETEXT_COLOR: 12,
          FREETEXT_OPACITY: 13,
          INK_COLOR: 21,
          INK_THICKNESS: 22,
          INK_OPACITY: 23
        };
        ge.AnnotationEditorParamsType = j;
        const U = {
          PRINT: 4,
          MODIFY_CONTENTS: 8,
          COPY: 16,
          MODIFY_ANNOTATIONS: 32,
          FILL_INTERACTIVE_FORMS: 256,
          COPY_FOR_ACCESSIBILITY: 512,
          ASSEMBLE: 1024,
          PRINT_HIGH_QUALITY: 2048
        };
        ge.PermissionFlag = U;
        const O = {
          FILL: 0,
          STROKE: 1,
          FILL_STROKE: 2,
          INVISIBLE: 3,
          FILL_ADD_TO_PATH: 4,
          STROKE_ADD_TO_PATH: 5,
          FILL_STROKE_ADD_TO_PATH: 6,
          ADD_TO_PATH: 7,
          FILL_STROKE_MASK: 3,
          ADD_TO_PATH_FLAG: 4
        };
        ge.TextRenderingMode = O;
        const v = {
          GRAYSCALE_1BPP: 1,
          RGB_24BPP: 2,
          RGBA_32BPP: 3
        };
        ge.ImageKind = v;
        const g = {
          TEXT: 1,
          LINK: 2,
          FREETEXT: 3,
          LINE: 4,
          SQUARE: 5,
          CIRCLE: 6,
          POLYGON: 7,
          POLYLINE: 8,
          HIGHLIGHT: 9,
          UNDERLINE: 10,
          SQUIGGLY: 11,
          STRIKEOUT: 12,
          STAMP: 13,
          CARET: 14,
          INK: 15,
          POPUP: 16,
          FILEATTACHMENT: 17,
          SOUND: 18,
          MOVIE: 19,
          WIDGET: 20,
          SCREEN: 21,
          PRINTERMARK: 22,
          TRAPNET: 23,
          WATERMARK: 24,
          THREED: 25,
          REDACT: 26
        };
        ge.AnnotationType = g;
        const b = {
          GROUP: "Group",
          REPLY: "R"
        };
        ge.AnnotationReplyType = b;
        const i = {
          INVISIBLE: 1,
          HIDDEN: 2,
          PRINT: 4,
          NOZOOM: 8,
          NOROTATE: 16,
          NOVIEW: 32,
          READONLY: 64,
          LOCKED: 128,
          TOGGLENOVIEW: 256,
          LOCKEDCONTENTS: 512
        };
        ge.AnnotationFlag = i;
        const P = {
          READONLY: 1,
          REQUIRED: 2,
          NOEXPORT: 4,
          MULTILINE: 4096,
          PASSWORD: 8192,
          NOTOGGLETOOFF: 16384,
          RADIO: 32768,
          PUSHBUTTON: 65536,
          COMBO: 131072,
          EDIT: 262144,
          SORT: 524288,
          FILESELECT: 1048576,
          MULTISELECT: 2097152,
          DONOTSPELLCHECK: 4194304,
          DONOTSCROLL: 8388608,
          COMB: 16777216,
          RICHTEXT: 33554432,
          RADIOSINUNISON: 33554432,
          COMMITONSELCHANGE: 67108864
        };
        ge.AnnotationFieldFlag = P;
        const d = {
          SOLID: 1,
          DASHED: 2,
          BEVELED: 3,
          INSET: 4,
          UNDERLINE: 5
        };
        ge.AnnotationBorderStyleType = d;
        const A = {
          E: "Mouse Enter",
          X: "Mouse Exit",
          D: "Mouse Down",
          U: "Mouse Up",
          Fo: "Focus",
          Bl: "Blur",
          PO: "PageOpen",
          PC: "PageClose",
          PV: "PageVisible",
          PI: "PageInvisible",
          K: "Keystroke",
          F: "Format",
          V: "Validate",
          C: "Calculate"
        };
        ge.AnnotationActionEventType = A;
        const I = {
          WC: "WillClose",
          WS: "WillSave",
          DS: "DidSave",
          WP: "WillPrint",
          DP: "DidPrint"
        };
        ge.DocumentActionEventType = I;
        const E = {
          O: "PageOpen",
          C: "PageClose"
        };
        ge.PageActionEventType = E;
        const k = {
          ERRORS: 0,
          WARNINGS: 1,
          INFOS: 5
        };
        ge.VerbosityLevel = k;
        const H = {
          NONE: 0,
          BINARY: 1
        };
        ge.CMapCompressionType = H;
        const x = {
          dependency: 1,
          setLineWidth: 2,
          setLineCap: 3,
          setLineJoin: 4,
          setMiterLimit: 5,
          setDash: 6,
          setRenderingIntent: 7,
          setFlatness: 8,
          setGState: 9,
          save: 10,
          restore: 11,
          transform: 12,
          moveTo: 13,
          lineTo: 14,
          curveTo: 15,
          curveTo2: 16,
          curveTo3: 17,
          closePath: 18,
          rectangle: 19,
          stroke: 20,
          closeStroke: 21,
          fill: 22,
          eoFill: 23,
          fillStroke: 24,
          eoFillStroke: 25,
          closeFillStroke: 26,
          closeEOFillStroke: 27,
          endPath: 28,
          clip: 29,
          eoClip: 30,
          beginText: 31,
          endText: 32,
          setCharSpacing: 33,
          setWordSpacing: 34,
          setHScale: 35,
          setLeading: 36,
          setFont: 37,
          setTextRenderingMode: 38,
          setTextRise: 39,
          moveText: 40,
          setLeadingMoveText: 41,
          setTextMatrix: 42,
          nextLine: 43,
          showText: 44,
          showSpacedText: 45,
          nextLineShowText: 46,
          nextLineSetSpacingShowText: 47,
          setCharWidth: 48,
          setCharWidthAndBounds: 49,
          setStrokeColorSpace: 50,
          setFillColorSpace: 51,
          setStrokeColor: 52,
          setStrokeColorN: 53,
          setFillColor: 54,
          setFillColorN: 55,
          setStrokeGray: 56,
          setFillGray: 57,
          setStrokeRGBColor: 58,
          setFillRGBColor: 59,
          setStrokeCMYKColor: 60,
          setFillCMYKColor: 61,
          shadingFill: 62,
          beginInlineImage: 63,
          beginImageData: 64,
          endInlineImage: 65,
          paintXObject: 66,
          markPoint: 67,
          markPointProps: 68,
          beginMarkedContent: 69,
          beginMarkedContentProps: 70,
          endMarkedContent: 71,
          beginCompat: 72,
          endCompat: 73,
          paintFormXObjectBegin: 74,
          paintFormXObjectEnd: 75,
          beginGroup: 76,
          endGroup: 77,
          beginAnnotation: 80,
          endAnnotation: 81,
          paintImageMaskXObject: 83,
          paintImageMaskXObjectGroup: 84,
          paintImageXObject: 85,
          paintInlineImageXObject: 86,
          paintInlineImageXObjectGroup: 87,
          paintImageXObjectRepeat: 88,
          paintImageMaskXObjectRepeat: 89,
          paintSolidColorImageMask: 90,
          constructPath: 91
        };
        ge.OPS = x;
        const R = {
          NEED_PASSWORD: 1,
          INCORRECT_PASSWORD: 2
        };
        ge.PasswordResponses = R;
        let f = k.WARNINGS;
        function c(be) {
          Number.isInteger(be) && (f = be);
        }
        function N() {
          return f;
        }
        function u(be) {
          f >= k.INFOS && console.log(`Info: ${be}`);
        }
        function p(be) {
          f >= k.WARNINGS && console.log(`Warning: ${be}`);
        }
        function S(be) {
          throw new Error(be);
        }
        function B(be, me) {
          be || S(me);
        }
        function T(be) {
          switch (be == null ? void 0 : be.protocol) {
            case "http:":
            case "https:":
            case "ftp:":
            case "mailto:":
            case "tel:":
              return !0;
            default:
              return !1;
          }
        }
        function D(be, me = null, we = null) {
          if (!be)
            return null;
          try {
            if (we && typeof be == "string") {
              if (we.addDefaultProtocol && be.startsWith("www.")) {
                const Se = be.match(/\./g);
                (Se == null ? void 0 : Se.length) >= 2 && (be = `http://${be}`);
              }
              if (we.tryConvertEncoding)
                try {
                  be = Q(be);
                } catch {
                }
            }
            const _e = me ? new URL(be, me) : new URL(be);
            if (T(_e))
              return _e;
          } catch {
          }
          return null;
        }
        function K(be, me, we, _e = !1) {
          return Object.defineProperty(be, me, {
            value: we,
            enumerable: !_e,
            configurable: !0,
            writable: !1
          }), we;
        }
        const _ = function() {
          function me(we, _e) {
            this.constructor === me && S("Cannot initialize BaseException."), this.message = we, this.name = _e;
          }
          return me.prototype = new Error(), me.constructor = me, me;
        }();
        ge.BaseException = _;
        class o extends _ {
          constructor(me, we) {
            super(me, "PasswordException"), this.code = we;
          }
        }
        ge.PasswordException = o;
        class m extends _ {
          constructor(me, we) {
            super(me, "UnknownErrorException"), this.details = we;
          }
        }
        ge.UnknownErrorException = m;
        class s extends _ {
          constructor(me) {
            super(me, "InvalidPDFException");
          }
        }
        ge.InvalidPDFException = s;
        class r extends _ {
          constructor(me) {
            super(me, "MissingPDFException");
          }
        }
        ge.MissingPDFException = r;
        class y extends _ {
          constructor(me, we) {
            super(me, "UnexpectedResponseException"), this.status = we;
          }
        }
        ge.UnexpectedResponseException = y;
        class M extends _ {
          constructor(me) {
            super(me, "FormatError");
          }
        }
        ge.FormatError = M;
        class $ extends _ {
          constructor(me) {
            super(me, "AbortException");
          }
        }
        ge.AbortException = $;
        function G(be) {
          (typeof be != "object" || (be == null ? void 0 : be.length) === void 0) && S("Invalid argument for bytesToString");
          const me = be.length, we = 8192;
          if (me < we)
            return String.fromCharCode.apply(null, be);
          const _e = [];
          for (let Se = 0; Se < me; Se += we) {
            const Ae = Math.min(Se + we, me), Te = be.subarray(Se, Ae);
            _e.push(String.fromCharCode.apply(null, Te));
          }
          return _e.join("");
        }
        function ce(be) {
          typeof be != "string" && S("Invalid argument for stringToBytes");
          const me = be.length, we = new Uint8Array(me);
          for (let _e = 0; _e < me; ++_e)
            we[_e] = be.charCodeAt(_e) & 255;
          return we;
        }
        function q(be) {
          return String.fromCharCode(be >> 24 & 255, be >> 16 & 255, be >> 8 & 255, be & 255);
        }
        function re(be) {
          return Object.keys(be).length;
        }
        function Z(be) {
          const me = /* @__PURE__ */ Object.create(null);
          for (const [we, _e] of be)
            me[we] = _e;
          return me;
        }
        function te() {
          const be = new Uint8Array(4);
          return be[0] = 1, new Uint32Array(be.buffer, 0, 1)[0] === 1;
        }
        function L() {
          try {
            return new Function(""), !0;
          } catch {
            return !1;
          }
        }
        class X {
          static get isLittleEndian() {
            return K(this, "isLittleEndian", te());
          }
          static get isEvalSupported() {
            return K(this, "isEvalSupported", L());
          }
          static get isOffscreenCanvasSupported() {
            return K(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas < "u");
          }
          static get platform() {
            return typeof navigator > "u" ? K(this, "platform", {
              isWin: !1,
              isMac: !1
            }) : K(this, "platform", {
              isWin: navigator.platform.includes("Win"),
              isMac: navigator.platform.includes("Mac")
            });
          }
          static get isCSSRoundSupported() {
            var me, we;
            return K(this, "isCSSRoundSupported", (we = (me = globalThis.CSS) == null ? void 0 : me.supports) == null ? void 0 : we.call(me, "width: round(1.5px, 1px)"));
          }
        }
        ge.FeatureTest = X;
        const J = [...Array(256).keys()].map((be) => be.toString(16).padStart(2, "0"));
        class Y {
          static makeHexColor(me, we, _e) {
            return `#${J[me]}${J[we]}${J[_e]}`;
          }
          static scaleMinMax(me, we) {
            let _e;
            me[0] ? (me[0] < 0 && (_e = we[0], we[0] = we[1], we[1] = _e), we[0] *= me[0], we[1] *= me[0], me[3] < 0 && (_e = we[2], we[2] = we[3], we[3] = _e), we[2] *= me[3], we[3] *= me[3]) : (_e = we[0], we[0] = we[2], we[2] = _e, _e = we[1], we[1] = we[3], we[3] = _e, me[1] < 0 && (_e = we[2], we[2] = we[3], we[3] = _e), we[2] *= me[1], we[3] *= me[1], me[2] < 0 && (_e = we[0], we[0] = we[1], we[1] = _e), we[0] *= me[2], we[1] *= me[2]), we[0] += me[4], we[1] += me[4], we[2] += me[5], we[3] += me[5];
          }
          static transform(me, we) {
            return [me[0] * we[0] + me[2] * we[1], me[1] * we[0] + me[3] * we[1], me[0] * we[2] + me[2] * we[3], me[1] * we[2] + me[3] * we[3], me[0] * we[4] + me[2] * we[5] + me[4], me[1] * we[4] + me[3] * we[5] + me[5]];
          }
          static applyTransform(me, we) {
            const _e = me[0] * we[0] + me[1] * we[2] + we[4], Se = me[0] * we[1] + me[1] * we[3] + we[5];
            return [_e, Se];
          }
          static applyInverseTransform(me, we) {
            const _e = we[0] * we[3] - we[1] * we[2], Se = (me[0] * we[3] - me[1] * we[2] + we[2] * we[5] - we[4] * we[3]) / _e, Ae = (-me[0] * we[1] + me[1] * we[0] + we[4] * we[1] - we[5] * we[0]) / _e;
            return [Se, Ae];
          }
          static getAxialAlignedBoundingBox(me, we) {
            const _e = this.applyTransform(me, we), Se = this.applyTransform(me.slice(2, 4), we), Ae = this.applyTransform([me[0], me[3]], we), Te = this.applyTransform([me[2], me[1]], we);
            return [Math.min(_e[0], Se[0], Ae[0], Te[0]), Math.min(_e[1], Se[1], Ae[1], Te[1]), Math.max(_e[0], Se[0], Ae[0], Te[0]), Math.max(_e[1], Se[1], Ae[1], Te[1])];
          }
          static inverseTransform(me) {
            const we = me[0] * me[3] - me[1] * me[2];
            return [me[3] / we, -me[1] / we, -me[2] / we, me[0] / we, (me[2] * me[5] - me[4] * me[3]) / we, (me[4] * me[1] - me[5] * me[0]) / we];
          }
          static singularValueDecompose2dScale(me) {
            const we = [me[0], me[2], me[1], me[3]], _e = me[0] * we[0] + me[1] * we[2], Se = me[0] * we[1] + me[1] * we[3], Ae = me[2] * we[0] + me[3] * we[2], Te = me[2] * we[1] + me[3] * we[3], ke = (_e + Te) / 2, Ee = Math.sqrt((_e + Te) ** 2 - 4 * (_e * Te - Ae * Se)) / 2, Ve = ke + Ee || 1, je = ke - Ee || 1;
            return [Math.sqrt(Ve), Math.sqrt(je)];
          }
          static normalizeRect(me) {
            const we = me.slice(0);
            return me[0] > me[2] && (we[0] = me[2], we[2] = me[0]), me[1] > me[3] && (we[1] = me[3], we[3] = me[1]), we;
          }
          static intersect(me, we) {
            const _e = Math.max(Math.min(me[0], me[2]), Math.min(we[0], we[2])), Se = Math.min(Math.max(me[0], me[2]), Math.max(we[0], we[2]));
            if (_e > Se)
              return null;
            const Ae = Math.max(Math.min(me[1], me[3]), Math.min(we[1], we[3])), Te = Math.min(Math.max(me[1], me[3]), Math.max(we[1], we[3]));
            return Ae > Te ? null : [_e, Ae, Se, Te];
          }
          static bezierBoundingBox(me, we, _e, Se, Ae, Te, ke, Ee) {
            const Ve = [], je = [[], []];
            let at, $e, ct, ze, Ye, Qe, Oe, he;
            for (let Be = 0; Be < 2; ++Be) {
              if (Be === 0 ? ($e = 6 * me - 12 * _e + 6 * Ae, at = -3 * me + 9 * _e - 9 * Ae + 3 * ke, ct = 3 * _e - 3 * me) : ($e = 6 * we - 12 * Se + 6 * Te, at = -3 * we + 9 * Se - 9 * Te + 3 * Ee, ct = 3 * Se - 3 * we), Math.abs(at) < 1e-12) {
                if (Math.abs($e) < 1e-12)
                  continue;
                ze = -ct / $e, 0 < ze && ze < 1 && Ve.push(ze);
                continue;
              }
              Oe = $e * $e - 4 * ct * at, he = Math.sqrt(Oe), !(Oe < 0) && (Ye = (-$e + he) / (2 * at), 0 < Ye && Ye < 1 && Ve.push(Ye), Qe = (-$e - he) / (2 * at), 0 < Qe && Qe < 1 && Ve.push(Qe));
            }
            let ye = Ve.length, Ie;
            const Le = ye;
            for (; ye--; )
              ze = Ve[ye], Ie = 1 - ze, je[0][ye] = Ie * Ie * Ie * me + 3 * Ie * Ie * ze * _e + 3 * Ie * ze * ze * Ae + ze * ze * ze * ke, je[1][ye] = Ie * Ie * Ie * we + 3 * Ie * Ie * ze * Se + 3 * Ie * ze * ze * Te + ze * ze * ze * Ee;
            return je[0][Le] = me, je[1][Le] = we, je[0][Le + 1] = ke, je[1][Le + 1] = Ee, je[0].length = je[1].length = Le + 2, [Math.min(...je[0]), Math.min(...je[1]), Math.max(...je[0]), Math.max(...je[1])];
          }
        }
        ge.Util = Y;
        const ae = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
        function se(be) {
          if (be[0] >= "ï") {
            let we;
            if (be[0] === "þ" && be[1] === "ÿ" ? we = "utf-16be" : be[0] === "ÿ" && be[1] === "þ" ? we = "utf-16le" : be[0] === "ï" && be[1] === "»" && be[2] === "¿" && (we = "utf-8"), we)
              try {
                const _e = new TextDecoder(we, {
                  fatal: !0
                }), Se = ce(be);
                return _e.decode(Se);
              } catch (_e) {
                p(`stringToPDFString: "${_e}".`);
              }
          }
          const me = [];
          for (let we = 0, _e = be.length; we < _e; we++) {
            const Se = ae[be.charCodeAt(we)];
            me.push(Se ? String.fromCharCode(Se) : be.charAt(we));
          }
          return me.join("");
        }
        function Q(be) {
          return decodeURIComponent(escape(be));
        }
        function z(be) {
          return unescape(encodeURIComponent(be));
        }
        function ie(be) {
          return typeof be == "object" && (be == null ? void 0 : be.byteLength) !== void 0;
        }
        function ne(be, me) {
          if (be.length !== me.length)
            return !1;
          for (let we = 0, _e = be.length; we < _e; we++)
            if (be[we] !== me[we])
              return !1;
          return !0;
        }
        function W(be = /* @__PURE__ */ new Date()) {
          return [be.getUTCFullYear().toString(), (be.getUTCMonth() + 1).toString().padStart(2, "0"), be.getUTCDate().toString().padStart(2, "0"), be.getUTCHours().toString().padStart(2, "0"), be.getUTCMinutes().toString().padStart(2, "0"), be.getUTCSeconds().toString().padStart(2, "0")].join("");
        }
        class oe {
          constructor() {
            Me(this, Pe, !1);
            this.promise = new Promise((me, we) => {
              this.resolve = (_e) => {
                Xe(this, Pe, !0), me(_e);
              }, this.reject = (_e) => {
                Xe(this, Pe, !0), we(_e);
              };
            });
          }
          get settled() {
            return le(this, Pe);
          }
        }
        Pe = new WeakMap(), ge.PromiseCapability = oe;
        let ue = null, pe = null;
        function ve(be) {
          return ue || (ue = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu, pe = /* @__PURE__ */ new Map([["ﬅ", "ſt"]])), be.replaceAll(ue, (me, we, _e) => we ? we.normalize("NFKC") : pe.get(_e));
        }
        function Ce() {
          if (typeof crypto < "u" && typeof (crypto == null ? void 0 : crypto.randomUUID) == "function")
            return crypto.randomUUID();
          const be = new Uint8Array(32);
          if (typeof crypto < "u" && typeof (crypto == null ? void 0 : crypto.getRandomValues) == "function")
            crypto.getRandomValues(be);
          else
            for (let me = 0; me < 32; me++)
              be[me] = Math.floor(Math.random() * 255);
          return G(be);
        }
        const Fe = "pdfjs_internal_id_";
        ge.AnnotationPrefix = Fe;
      },
      /* 2 */
      /***/
      (__unused_webpack_module, exports, __w_pdfjs_require__) => {
        var Re, xe, de, fe, An, V, qn, F, C, e, t, l, j, U, O, v, Vn, b, i, Ui, d, A;
        Object.defineProperty(exports, "__esModule", {
          value: !0
        }), exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultFilterFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0, Object.defineProperty(exports, "SVGGraphics", {
          enumerable: !0,
          get: function() {
            return _displaySvg.SVGGraphics;
          }
        }), exports.build = void 0, exports.getDocument = getDocument, exports.version = void 0;
        var _util = __w_pdfjs_require__(1), _annotation_storage = __w_pdfjs_require__(3), _display_utils = __w_pdfjs_require__(6), _font_loader = __w_pdfjs_require__(9), _displayNode_utils = __w_pdfjs_require__(10), _canvas = __w_pdfjs_require__(11), _worker_options = __w_pdfjs_require__(14), _message_handler = __w_pdfjs_require__(15), _metadata = __w_pdfjs_require__(16), _optional_content_config = __w_pdfjs_require__(17), _transport_stream = __w_pdfjs_require__(18), _displayFetch_stream = __w_pdfjs_require__(19), _displayNetwork = __w_pdfjs_require__(22), _displayNode_stream = __w_pdfjs_require__(23), _displaySvg = __w_pdfjs_require__(24), _xfa_text = __w_pdfjs_require__(25);
        const DEFAULT_RANGE_CHUNK_SIZE = 65536, RENDERING_CANCELLED_TIMEOUT = 100, DELAYED_CLEANUP_TIMEOUT = 5e3, DefaultCanvasFactory = _util.isNodeJS ? _displayNode_utils.NodeCanvasFactory : _display_utils.DOMCanvasFactory;
        exports.DefaultCanvasFactory = DefaultCanvasFactory;
        const DefaultCMapReaderFactory = _util.isNodeJS ? _displayNode_utils.NodeCMapReaderFactory : _display_utils.DOMCMapReaderFactory;
        exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;
        const DefaultFilterFactory = _util.isNodeJS ? _displayNode_utils.NodeFilterFactory : _display_utils.DOMFilterFactory;
        exports.DefaultFilterFactory = DefaultFilterFactory;
        const DefaultStandardFontDataFactory = _util.isNodeJS ? _displayNode_utils.NodeStandardFontDataFactory : _display_utils.DOMStandardFontDataFactory;
        exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory;
        function getDocument(E) {
          if (typeof E == "string" || E instanceof URL ? E = {
            url: E
          } : (0, _util.isArrayBuffer)(E) && (E = {
            data: E
          }), typeof E != "object")
            throw new Error("Invalid parameter in getDocument, need parameter object.");
          if (!E.url && !E.data && !E.range)
            throw new Error("Invalid parameter object: need either .data, .range or .url");
          const k = new PDFDocumentLoadingTask(), {
            docId: H
          } = k, x = E.url ? getUrlProp(E.url) : null, R = E.data ? getDataProp(E.data) : null, f = E.httpHeaders || null, c = E.withCredentials === !0, N = E.password ?? null, u = E.range instanceof PDFDataRangeTransport ? E.range : null, p = Number.isInteger(E.rangeChunkSize) && E.rangeChunkSize > 0 ? E.rangeChunkSize : DEFAULT_RANGE_CHUNK_SIZE;
          let S = E.worker instanceof PDFWorker ? E.worker : null;
          const B = E.verbosity, T = typeof E.docBaseUrl == "string" && !(0, _display_utils.isDataScheme)(E.docBaseUrl) ? E.docBaseUrl : null, D = typeof E.cMapUrl == "string" ? E.cMapUrl : null, K = E.cMapPacked !== !1, _ = E.CMapReaderFactory || DefaultCMapReaderFactory, o = typeof E.standardFontDataUrl == "string" ? E.standardFontDataUrl : null, m = E.StandardFontDataFactory || DefaultStandardFontDataFactory, s = E.stopAtErrors !== !0, r = Number.isInteger(E.maxImageSize) && E.maxImageSize > -1 ? E.maxImageSize : -1, y = E.isEvalSupported !== !1, M = typeof E.isOffscreenCanvasSupported == "boolean" ? E.isOffscreenCanvasSupported : !_util.isNodeJS, $ = Number.isInteger(E.canvasMaxAreaInBytes) ? E.canvasMaxAreaInBytes : -1, G = typeof E.disableFontFace == "boolean" ? E.disableFontFace : _util.isNodeJS, ce = E.fontExtraProperties === !0, q = E.enableXfa === !0, re = E.ownerDocument || globalThis.document, Z = E.disableRange === !0, te = E.disableStream === !0, L = E.disableAutoFetch === !0, X = E.pdfBug === !0, J = u ? u.length : E.length ?? NaN, Y = typeof E.useSystemFonts == "boolean" ? E.useSystemFonts : !_util.isNodeJS && !G, ae = typeof E.useWorkerFetch == "boolean" ? E.useWorkerFetch : _ === _display_utils.DOMCMapReaderFactory && m === _display_utils.DOMStandardFontDataFactory && D && o && (0, _display_utils.isValidFetchUrl)(D, document.baseURI) && (0, _display_utils.isValidFetchUrl)(o, document.baseURI), se = E.canvasFactory || new DefaultCanvasFactory({
            ownerDocument: re
          }), Q = E.filterFactory || new DefaultFilterFactory({
            docId: H,
            ownerDocument: re
          }), z = null;
          (0, _util.setVerbosityLevel)(B);
          const ie = {
            canvasFactory: se,
            filterFactory: Q
          };
          if (ae || (ie.cMapReaderFactory = new _({
            baseUrl: D,
            isCompressed: K
          }), ie.standardFontDataFactory = new m({
            baseUrl: o
          })), !S) {
            const oe = {
              verbosity: B,
              port: _worker_options.GlobalWorkerOptions.workerPort
            };
            S = oe.port ? PDFWorker.fromPort(oe) : new PDFWorker(oe), k._worker = S;
          }
          const ne = {
            docId: H,
            apiVersion: "3.11.174",
            data: R,
            password: N,
            disableAutoFetch: L,
            rangeChunkSize: p,
            length: J,
            docBaseUrl: T,
            enableXfa: q,
            evaluatorOptions: {
              maxImageSize: r,
              disableFontFace: G,
              ignoreErrors: s,
              isEvalSupported: y,
              isOffscreenCanvasSupported: M,
              canvasMaxAreaInBytes: $,
              fontExtraProperties: ce,
              useSystemFonts: Y,
              cMapUrl: ae ? D : null,
              standardFontDataUrl: ae ? o : null
            }
          }, W = {
            ignoreErrors: s,
            isEvalSupported: y,
            disableFontFace: G,
            fontExtraProperties: ce,
            enableXfa: q,
            ownerDocument: re,
            disableAutoFetch: L,
            pdfBug: X,
            styleElement: z
          };
          return S.promise.then(function() {
            if (k.destroyed)
              throw new Error("Loading aborted");
            const oe = _fetchDocument(S, ne), ue = new Promise(function(pe) {
              let ve;
              u ? ve = new _transport_stream.PDFDataTransportStream({
                length: J,
                initialData: u.initialData,
                progressiveDone: u.progressiveDone,
                contentDispositionFilename: u.contentDispositionFilename,
                disableRange: Z,
                disableStream: te
              }, u) : R || (ve = ((Fe) => _util.isNodeJS ? new _displayNode_stream.PDFNodeStream(Fe) : (0, _display_utils.isValidFetchUrl)(Fe.url) ? new _displayFetch_stream.PDFFetchStream(Fe) : new _displayNetwork.PDFNetworkStream(Fe))({
                url: x,
                length: J,
                httpHeaders: f,
                withCredentials: c,
                rangeChunkSize: p,
                disableRange: Z,
                disableStream: te
              })), pe(ve);
            });
            return Promise.all([oe, ue]).then(function([pe, ve]) {
              if (k.destroyed)
                throw new Error("Loading aborted");
              const Ce = new _message_handler.MessageHandler(H, pe, S.port), Fe = new WorkerTransport(Ce, k, ve, W, ie);
              k._transport = Fe, Ce.send("Ready", null);
            });
          }).catch(k._capability.reject), k;
        }
        async function _fetchDocument(E, k) {
          if (E.destroyed)
            throw new Error("Worker was destroyed");
          const H = await E.messageHandler.sendWithPromise("GetDocRequest", k, k.data ? [k.data.buffer] : null);
          if (E.destroyed)
            throw new Error("Worker was destroyed");
          return H;
        }
        function getUrlProp(E) {
          if (E instanceof URL)
            return E.href;
          try {
            return new URL(E, window.location).href;
          } catch {
            if (_util.isNodeJS && typeof E == "string")
              return E;
          }
          throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
        }
        function getDataProp(E) {
          if (_util.isNodeJS && typeof Buffer < "u" && E instanceof Buffer)
            throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
          if (E instanceof Uint8Array && E.byteLength === E.buffer.byteLength)
            return E;
          if (typeof E == "string")
            return (0, _util.stringToBytes)(E);
          if (typeof E == "object" && !isNaN(E == null ? void 0 : E.length) || (0, _util.isArrayBuffer)(E))
            return new Uint8Array(E);
          throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
        }
        const ge = class ge {
          constructor() {
            this._capability = new _util.PromiseCapability(), this._transport = null, this._worker = null, this.docId = `d${xn(ge, Re)._++}`, this.destroyed = !1, this.onPassword = null, this.onProgress = null;
          }
          get promise() {
            return this._capability.promise;
          }
          async destroy() {
            var k, H, x;
            this.destroyed = !0;
            try {
              (k = this._worker) != null && k.port && (this._worker._pendingDestroy = !0), await ((H = this._transport) == null ? void 0 : H.destroy());
            } catch (R) {
              throw (x = this._worker) != null && x.port && delete this._worker._pendingDestroy, R;
            }
            this._transport = null, this._worker && (this._worker.destroy(), this._worker = null);
          }
        };
        Re = new WeakMap(), Me(ge, Re, 0);
        let PDFDocumentLoadingTask = ge;
        exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;
        class PDFDataRangeTransport {
          constructor(k, H, x = !1, R = null) {
            this.length = k, this.initialData = H, this.progressiveDone = x, this.contentDispositionFilename = R, this._rangeListeners = [], this._progressListeners = [], this._progressiveReadListeners = [], this._progressiveDoneListeners = [], this._readyCapability = new _util.PromiseCapability();
          }
          addRangeListener(k) {
            this._rangeListeners.push(k);
          }
          addProgressListener(k) {
            this._progressListeners.push(k);
          }
          addProgressiveReadListener(k) {
            this._progressiveReadListeners.push(k);
          }
          addProgressiveDoneListener(k) {
            this._progressiveDoneListeners.push(k);
          }
          onDataRange(k, H) {
            for (const x of this._rangeListeners)
              x(k, H);
          }
          onDataProgress(k, H) {
            this._readyCapability.promise.then(() => {
              for (const x of this._progressListeners)
                x(k, H);
            });
          }
          onDataProgressiveRead(k) {
            this._readyCapability.promise.then(() => {
              for (const H of this._progressiveReadListeners)
                H(k);
            });
          }
          onDataProgressiveDone() {
            this._readyCapability.promise.then(() => {
              for (const k of this._progressiveDoneListeners)
                k();
            });
          }
          transportReady() {
            this._readyCapability.resolve();
          }
          requestDataRange(k, H) {
            (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
          }
          abort() {
          }
        }
        exports.PDFDataRangeTransport = PDFDataRangeTransport;
        class PDFDocumentProxy {
          constructor(k, H) {
            this._pdfInfo = k, this._transport = H, Object.defineProperty(this, "getJavaScript", {
              value: () => ((0, _display_utils.deprecated)("`PDFDocumentProxy.getJavaScript`, please use `PDFDocumentProxy.getJSActions` instead."), this.getJSActions().then((x) => {
                if (!x)
                  return x;
                const R = [];
                for (const f in x)
                  R.push(...x[f]);
                return R;
              }))
            });
          }
          get annotationStorage() {
            return this._transport.annotationStorage;
          }
          get filterFactory() {
            return this._transport.filterFactory;
          }
          get numPages() {
            return this._pdfInfo.numPages;
          }
          get fingerprints() {
            return this._pdfInfo.fingerprints;
          }
          get isPureXfa() {
            return (0, _util.shadow)(this, "isPureXfa", !!this._transport._htmlForXfa);
          }
          get allXfaHtml() {
            return this._transport._htmlForXfa;
          }
          getPage(k) {
            return this._transport.getPage(k);
          }
          getPageIndex(k) {
            return this._transport.getPageIndex(k);
          }
          getDestinations() {
            return this._transport.getDestinations();
          }
          getDestination(k) {
            return this._transport.getDestination(k);
          }
          getPageLabels() {
            return this._transport.getPageLabels();
          }
          getPageLayout() {
            return this._transport.getPageLayout();
          }
          getPageMode() {
            return this._transport.getPageMode();
          }
          getViewerPreferences() {
            return this._transport.getViewerPreferences();
          }
          getOpenAction() {
            return this._transport.getOpenAction();
          }
          getAttachments() {
            return this._transport.getAttachments();
          }
          getJSActions() {
            return this._transport.getDocJSActions();
          }
          getOutline() {
            return this._transport.getOutline();
          }
          getOptionalContentConfig() {
            return this._transport.getOptionalContentConfig();
          }
          getPermissions() {
            return this._transport.getPermissions();
          }
          getMetadata() {
            return this._transport.getMetadata();
          }
          getMarkInfo() {
            return this._transport.getMarkInfo();
          }
          getData() {
            return this._transport.getData();
          }
          saveDocument() {
            return this._transport.saveDocument();
          }
          getDownloadInfo() {
            return this._transport.downloadInfoCapability.promise;
          }
          cleanup(k = !1) {
            return this._transport.startCleanup(k || this.isPureXfa);
          }
          destroy() {
            return this.loadingTask.destroy();
          }
          get loadingParams() {
            return this._transport.loadingParams;
          }
          get loadingTask() {
            return this._transport.loadingTask;
          }
          getFieldObjects() {
            return this._transport.getFieldObjects();
          }
          hasJSActions() {
            return this._transport.hasJSActions();
          }
          getCalculationOrderIds() {
            return this._transport.getCalculationOrderIds();
          }
        }
        exports.PDFDocumentProxy = PDFDocumentProxy;
        class PDFPageProxy {
          constructor(k, H, x, R = !1) {
            Me(this, fe);
            Me(this, V);
            Me(this, xe, null);
            Me(this, de, !1);
            this._pageIndex = k, this._pageInfo = H, this._transport = x, this._stats = R ? new _display_utils.StatTimer() : null, this._pdfBug = R, this.commonObjs = x.commonObjs, this.objs = new PDFObjects(), this._maybeCleanupAfterRender = !1, this._intentStates = /* @__PURE__ */ new Map(), this.destroyed = !1;
          }
          get pageNumber() {
            return this._pageIndex + 1;
          }
          get rotate() {
            return this._pageInfo.rotate;
          }
          get ref() {
            return this._pageInfo.ref;
          }
          get userUnit() {
            return this._pageInfo.userUnit;
          }
          get view() {
            return this._pageInfo.view;
          }
          getViewport({
            scale: k,
            rotation: H = this.rotate,
            offsetX: x = 0,
            offsetY: R = 0,
            dontFlip: f = !1
          } = {}) {
            return new _display_utils.PageViewport({
              viewBox: this.view,
              scale: k,
              rotation: H,
              offsetX: x,
              offsetY: R,
              dontFlip: f
            });
          }
          getAnnotations({
            intent: k = "display"
          } = {}) {
            const H = this._transport.getRenderingIntent(k);
            return this._transport.getAnnotations(this._pageIndex, H.renderingIntent);
          }
          getJSActions() {
            return this._transport.getPageJSActions(this._pageIndex);
          }
          get filterFactory() {
            return this._transport.filterFactory;
          }
          get isPureXfa() {
            return (0, _util.shadow)(this, "isPureXfa", !!this._transport._htmlForXfa);
          }
          async getXfa() {
            var k;
            return ((k = this._transport._htmlForXfa) == null ? void 0 : k.children[this._pageIndex]) || null;
          }
          render({
            canvasContext: k,
            viewport: H,
            intent: x = "display",
            annotationMode: R = _util.AnnotationMode.ENABLE,
            transform: f = null,
            background: c = null,
            optionalContentConfigPromise: N = null,
            annotationCanvasMap: u = null,
            pageColors: p = null,
            printAnnotationStorage: S = null
          }) {
            var m, s;
            (m = this._stats) == null || m.time("Overall");
            const B = this._transport.getRenderingIntent(x, R, S);
            Xe(this, de, !1), De(this, V, qn).call(this), N || (N = this._transport.getOptionalContentConfig());
            let T = this._intentStates.get(B.cacheKey);
            T || (T = /* @__PURE__ */ Object.create(null), this._intentStates.set(B.cacheKey, T)), T.streamReaderCancelTimeout && (clearTimeout(T.streamReaderCancelTimeout), T.streamReaderCancelTimeout = null);
            const D = !!(B.renderingIntent & _util.RenderingIntentFlag.PRINT);
            T.displayReadyCapability || (T.displayReadyCapability = new _util.PromiseCapability(), T.operatorList = {
              fnArray: [],
              argsArray: [],
              lastChunk: !1,
              separateAnnots: null
            }, (s = this._stats) == null || s.time("Page Request"), this._pumpOperatorList(B));
            const K = (r) => {
              var y, M;
              T.renderTasks.delete(_), (this._maybeCleanupAfterRender || D) && Xe(this, de, !0), De(this, fe, An).call(this, !D), r ? (_.capability.reject(r), this._abortOperatorList({
                intentState: T,
                reason: r instanceof Error ? r : new Error(r)
              })) : _.capability.resolve(), (y = this._stats) == null || y.timeEnd("Rendering"), (M = this._stats) == null || M.timeEnd("Overall");
            }, _ = new InternalRenderTask({
              callback: K,
              params: {
                canvasContext: k,
                viewport: H,
                transform: f,
                background: c
              },
              objs: this.objs,
              commonObjs: this.commonObjs,
              annotationCanvasMap: u,
              operatorList: T.operatorList,
              pageIndex: this._pageIndex,
              canvasFactory: this._transport.canvasFactory,
              filterFactory: this._transport.filterFactory,
              useRequestAnimationFrame: !D,
              pdfBug: this._pdfBug,
              pageColors: p
            });
            (T.renderTasks || (T.renderTasks = /* @__PURE__ */ new Set())).add(_);
            const o = _.task;
            return Promise.all([T.displayReadyCapability.promise, N]).then(([r, y]) => {
              var M;
              if (this.destroyed) {
                K();
                return;
              }
              (M = this._stats) == null || M.time("Rendering"), _.initializeGraphics({
                transparency: r,
                optionalContentConfig: y
              }), _.operatorListChanged();
            }).catch(K), o;
          }
          getOperatorList({
            intent: k = "display",
            annotationMode: H = _util.AnnotationMode.ENABLE,
            printAnnotationStorage: x = null
          } = {}) {
            var u;
            function R() {
              c.operatorList.lastChunk && (c.opListReadCapability.resolve(c.operatorList), c.renderTasks.delete(N));
            }
            const f = this._transport.getRenderingIntent(k, H, x, !0);
            let c = this._intentStates.get(f.cacheKey);
            c || (c = /* @__PURE__ */ Object.create(null), this._intentStates.set(f.cacheKey, c));
            let N;
            return c.opListReadCapability || (N = /* @__PURE__ */ Object.create(null), N.operatorListChanged = R, c.opListReadCapability = new _util.PromiseCapability(), (c.renderTasks || (c.renderTasks = /* @__PURE__ */ new Set())).add(N), c.operatorList = {
              fnArray: [],
              argsArray: [],
              lastChunk: !1,
              separateAnnots: null
            }, (u = this._stats) == null || u.time("Page Request"), this._pumpOperatorList(f)), c.opListReadCapability.promise;
          }
          streamTextContent({
            includeMarkedContent: k = !1,
            disableNormalization: H = !1
          } = {}) {
            return this._transport.messageHandler.sendWithStream("GetTextContent", {
              pageIndex: this._pageIndex,
              includeMarkedContent: k === !0,
              disableNormalization: H === !0
            }, {
              highWaterMark: 100,
              size(R) {
                return R.items.length;
              }
            });
          }
          getTextContent(k = {}) {
            if (this._transport._htmlForXfa)
              return this.getXfa().then((x) => _xfa_text.XfaText.textContent(x));
            const H = this.streamTextContent(k);
            return new Promise(function(x, R) {
              function f() {
                c.read().then(function({
                  value: u,
                  done: p
                }) {
                  if (p) {
                    x(N);
                    return;
                  }
                  Object.assign(N.styles, u.styles), N.items.push(...u.items), f();
                }, R);
              }
              const c = H.getReader(), N = {
                items: [],
                styles: /* @__PURE__ */ Object.create(null)
              };
              f();
            });
          }
          getStructTree() {
            return this._transport.getStructTree(this._pageIndex);
          }
          _destroy() {
            this.destroyed = !0;
            const k = [];
            for (const H of this._intentStates.values())
              if (this._abortOperatorList({
                intentState: H,
                reason: new Error("Page was destroyed."),
                force: !0
              }), !H.opListReadCapability)
                for (const x of H.renderTasks)
                  k.push(x.completed), x.cancel();
            return this.objs.clear(), Xe(this, de, !1), De(this, V, qn).call(this), Promise.all(k);
          }
          cleanup(k = !1) {
            Xe(this, de, !0);
            const H = De(this, fe, An).call(this, !1);
            return k && H && this._stats && (this._stats = new _display_utils.StatTimer()), H;
          }
          _startRenderPage(k, H) {
            var R, f;
            const x = this._intentStates.get(H);
            x && ((R = this._stats) == null || R.timeEnd("Page Request"), (f = x.displayReadyCapability) == null || f.resolve(k));
          }
          _renderPageChunk(k, H) {
            for (let x = 0, R = k.length; x < R; x++)
              H.operatorList.fnArray.push(k.fnArray[x]), H.operatorList.argsArray.push(k.argsArray[x]);
            H.operatorList.lastChunk = k.lastChunk, H.operatorList.separateAnnots = k.separateAnnots;
            for (const x of H.renderTasks)
              x.operatorListChanged();
            k.lastChunk && De(this, fe, An).call(this, !0);
          }
          _pumpOperatorList({
            renderingIntent: k,
            cacheKey: H,
            annotationStorageSerializable: x
          }) {
            const {
              map: R,
              transfers: f
            } = x, N = this._transport.messageHandler.sendWithStream("GetOperatorList", {
              pageIndex: this._pageIndex,
              intent: k,
              cacheKey: H,
              annotationStorage: R
            }, f).getReader(), u = this._intentStates.get(H);
            u.streamReader = N;
            const p = () => {
              N.read().then(({
                value: S,
                done: B
              }) => {
                if (B) {
                  u.streamReader = null;
                  return;
                }
                this._transport.destroyed || (this._renderPageChunk(S, u), p());
              }, (S) => {
                if (u.streamReader = null, !this._transport.destroyed) {
                  if (u.operatorList) {
                    u.operatorList.lastChunk = !0;
                    for (const B of u.renderTasks)
                      B.operatorListChanged();
                    De(this, fe, An).call(this, !0);
                  }
                  if (u.displayReadyCapability)
                    u.displayReadyCapability.reject(S);
                  else if (u.opListReadCapability)
                    u.opListReadCapability.reject(S);
                  else
                    throw S;
                }
              });
            };
            p();
          }
          _abortOperatorList({
            intentState: k,
            reason: H,
            force: x = !1
          }) {
            if (k.streamReader) {
              if (k.streamReaderCancelTimeout && (clearTimeout(k.streamReaderCancelTimeout), k.streamReaderCancelTimeout = null), !x) {
                if (k.renderTasks.size > 0)
                  return;
                if (H instanceof _display_utils.RenderingCancelledException) {
                  let R = RENDERING_CANCELLED_TIMEOUT;
                  H.extraDelay > 0 && H.extraDelay < 1e3 && (R += H.extraDelay), k.streamReaderCancelTimeout = setTimeout(() => {
                    k.streamReaderCancelTimeout = null, this._abortOperatorList({
                      intentState: k,
                      reason: H,
                      force: !0
                    });
                  }, R);
                  return;
                }
              }
              if (k.streamReader.cancel(new _util.AbortException(H.message)).catch(() => {
              }), k.streamReader = null, !this._transport.destroyed) {
                for (const [R, f] of this._intentStates)
                  if (f === k) {
                    this._intentStates.delete(R);
                    break;
                  }
                this.cleanup();
              }
            }
          }
          get stats() {
            return this._stats;
          }
        }
        xe = new WeakMap(), de = new WeakMap(), fe = new WeakSet(), An = function(k = !1) {
          if (De(this, V, qn).call(this), !le(this, de) || this.destroyed)
            return !1;
          if (k)
            return Xe(this, xe, setTimeout(() => {
              Xe(this, xe, null), De(this, fe, An).call(this, !1);
            }, DELAYED_CLEANUP_TIMEOUT)), !1;
          for (const {
            renderTasks: H,
            operatorList: x
          } of this._intentStates.values())
            if (H.size > 0 || !x.lastChunk)
              return !1;
          return this._intentStates.clear(), this.objs.clear(), Xe(this, de, !1), !0;
        }, V = new WeakSet(), qn = function() {
          le(this, xe) && (clearTimeout(le(this, xe)), Xe(this, xe, null));
        }, exports.PDFPageProxy = PDFPageProxy;
        class LoopbackPort {
          constructor() {
            Me(this, F, /* @__PURE__ */ new Set());
            Me(this, C, Promise.resolve());
          }
          postMessage(k, H) {
            const x = {
              data: structuredClone(k, H ? {
                transfer: H
              } : null)
            };
            le(this, C).then(() => {
              for (const R of le(this, F))
                R.call(this, x);
            });
          }
          addEventListener(k, H) {
            le(this, F).add(H);
          }
          removeEventListener(k, H) {
            le(this, F).delete(H);
          }
          terminate() {
            le(this, F).clear();
          }
        }
        F = new WeakMap(), C = new WeakMap(), exports.LoopbackPort = LoopbackPort;
        const PDFWorkerUtil = {
          isWorkerDisabled: !1,
          fallbackWorkerSrc: null,
          fakeWorkerId: 0
        };
        exports.PDFWorkerUtil = PDFWorkerUtil;
        {
          if (_util.isNodeJS && typeof require == "function")
            PDFWorkerUtil.isWorkerDisabled = !0, PDFWorkerUtil.fallbackWorkerSrc = "./pdf.worker.js";
          else if (typeof document == "object") {
            const E = (e = document == null ? void 0 : document.currentScript) == null ? void 0 : e.src;
            E && (PDFWorkerUtil.fallbackWorkerSrc = E.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2"));
          }
          PDFWorkerUtil.isSameOrigin = function(E, k) {
            let H;
            try {
              if (H = new URL(E), !H.origin || H.origin === "null")
                return !1;
            } catch {
              return !1;
            }
            const x = new URL(k, H);
            return H.origin === x.origin;
          }, PDFWorkerUtil.createCDNWrapper = function(E) {
            const k = `importScripts("${E}");`;
            return URL.createObjectURL(new Blob([k]));
          };
        }
        const _PDFWorker = class _PDFWorker {
          constructor({
            name: E = null,
            port: k = null,
            verbosity: H = (0, _util.getVerbosityLevel)()
          } = {}) {
            var x;
            if (this.name = E, this.destroyed = !1, this.verbosity = H, this._readyCapability = new _util.PromiseCapability(), this._port = null, this._webWorker = null, this._messageHandler = null, k) {
              if ((x = le(_PDFWorker, t)) != null && x.has(k))
                throw new Error("Cannot use more than one PDFWorker per port.");
              (le(_PDFWorker, t) || Xe(_PDFWorker, t, /* @__PURE__ */ new WeakMap())).set(k, this), this._initializeFromPort(k);
              return;
            }
            this._initialize();
          }
          get promise() {
            return this._readyCapability.promise;
          }
          get port() {
            return this._port;
          }
          get messageHandler() {
            return this._messageHandler;
          }
          _initializeFromPort(E) {
            this._port = E, this._messageHandler = new _message_handler.MessageHandler("main", "worker", E), this._messageHandler.on("ready", function() {
            }), this._readyCapability.resolve(), this._messageHandler.send("configure", {
              verbosity: this.verbosity
            });
          }
          _initialize() {
            if (!PDFWorkerUtil.isWorkerDisabled && !_PDFWorker._mainThreadWorkerMessageHandler) {
              let {
                workerSrc: E
              } = _PDFWorker;
              try {
                PDFWorkerUtil.isSameOrigin(window.location.href, E) || (E = PDFWorkerUtil.createCDNWrapper(new URL(E, window.location).href));
                const k = new Worker(E), H = new _message_handler.MessageHandler("main", "worker", k), x = () => {
                  k.removeEventListener("error", R), H.destroy(), k.terminate(), this.destroyed ? this._readyCapability.reject(new Error("Worker was destroyed")) : this._setupFakeWorker();
                }, R = () => {
                  this._webWorker || x();
                };
                k.addEventListener("error", R), H.on("test", (c) => {
                  if (k.removeEventListener("error", R), this.destroyed) {
                    x();
                    return;
                  }
                  c ? (this._messageHandler = H, this._port = k, this._webWorker = k, this._readyCapability.resolve(), H.send("configure", {
                    verbosity: this.verbosity
                  })) : (this._setupFakeWorker(), H.destroy(), k.terminate());
                }), H.on("ready", (c) => {
                  if (k.removeEventListener("error", R), this.destroyed) {
                    x();
                    return;
                  }
                  try {
                    f();
                  } catch {
                    this._setupFakeWorker();
                  }
                });
                const f = () => {
                  const c = new Uint8Array();
                  H.send("test", c, [c.buffer]);
                };
                f();
                return;
              } catch {
                (0, _util.info)("The worker has been disabled.");
              }
            }
            this._setupFakeWorker();
          }
          _setupFakeWorker() {
            PDFWorkerUtil.isWorkerDisabled || ((0, _util.warn)("Setting up fake worker."), PDFWorkerUtil.isWorkerDisabled = !0), _PDFWorker._setupFakeWorkerGlobal.then((E) => {
              if (this.destroyed) {
                this._readyCapability.reject(new Error("Worker was destroyed"));
                return;
              }
              const k = new LoopbackPort();
              this._port = k;
              const H = `fake${PDFWorkerUtil.fakeWorkerId++}`, x = new _message_handler.MessageHandler(H + "_worker", H, k);
              E.setup(x, k);
              const R = new _message_handler.MessageHandler(H, H + "_worker", k);
              this._messageHandler = R, this._readyCapability.resolve(), R.send("configure", {
                verbosity: this.verbosity
              });
            }).catch((E) => {
              this._readyCapability.reject(new Error(`Setting up fake worker failed: "${E.message}".`));
            });
          }
          destroy() {
            var E;
            this.destroyed = !0, this._webWorker && (this._webWorker.terminate(), this._webWorker = null), (E = le(_PDFWorker, t)) == null || E.delete(this._port), this._port = null, this._messageHandler && (this._messageHandler.destroy(), this._messageHandler = null);
          }
          static fromPort(E) {
            var H;
            if (!(E != null && E.port))
              throw new Error("PDFWorker.fromPort - invalid method signature.");
            const k = (H = le(this, t)) == null ? void 0 : H.get(E.port);
            if (k) {
              if (k._pendingDestroy)
                throw new Error("PDFWorker.fromPort - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
              return k;
            }
            return new _PDFWorker(E);
          }
          static get workerSrc() {
            if (_worker_options.GlobalWorkerOptions.workerSrc)
              return _worker_options.GlobalWorkerOptions.workerSrc;
            if (PDFWorkerUtil.fallbackWorkerSrc !== null)
              return _util.isNodeJS || (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.'), PDFWorkerUtil.fallbackWorkerSrc;
            throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
          }
          static get _mainThreadWorkerMessageHandler() {
            var E;
            try {
              return ((E = globalThis.pdfjsWorker) == null ? void 0 : E.WorkerMessageHandler) || null;
            } catch {
              return null;
            }
          }
          static get _setupFakeWorkerGlobal() {
            const loader = async () => {
              const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler;
              if (mainWorkerMessageHandler)
                return mainWorkerMessageHandler;
              if (_util.isNodeJS && typeof require == "function") {
                const worker = eval("require")(this.workerSrc);
                return worker.WorkerMessageHandler;
              }
              return await (0, _display_utils.loadScript)(this.workerSrc), window.pdfjsWorker.WorkerMessageHandler;
            };
            return (0, _util.shadow)(this, "_setupFakeWorkerGlobal", loader());
          }
        };
        t = new WeakMap(), Me(_PDFWorker, t, void 0);
        let PDFWorker = _PDFWorker;
        exports.PDFWorker = PDFWorker;
        class WorkerTransport {
          constructor(k, H, x, R, f) {
            Me(this, v);
            Me(this, l, /* @__PURE__ */ new Map());
            Me(this, j, /* @__PURE__ */ new Map());
            Me(this, U, /* @__PURE__ */ new Map());
            Me(this, O, null);
            this.messageHandler = k, this.loadingTask = H, this.commonObjs = new PDFObjects(), this.fontLoader = new _font_loader.FontLoader({
              ownerDocument: R.ownerDocument,
              styleElement: R.styleElement
            }), this._params = R, this.canvasFactory = f.canvasFactory, this.filterFactory = f.filterFactory, this.cMapReaderFactory = f.cMapReaderFactory, this.standardFontDataFactory = f.standardFontDataFactory, this.destroyed = !1, this.destroyCapability = null, this._networkStream = x, this._fullReader = null, this._lastProgress = null, this.downloadInfoCapability = new _util.PromiseCapability(), this.setupMessageHandler();
          }
          get annotationStorage() {
            return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
          }
          getRenderingIntent(k, H = _util.AnnotationMode.ENABLE, x = null, R = !1) {
            let f = _util.RenderingIntentFlag.DISPLAY, c = _annotation_storage.SerializableEmpty;
            switch (k) {
              case "any":
                f = _util.RenderingIntentFlag.ANY;
                break;
              case "display":
                break;
              case "print":
                f = _util.RenderingIntentFlag.PRINT;
                break;
              default:
                (0, _util.warn)(`getRenderingIntent - invalid intent: ${k}`);
            }
            switch (H) {
              case _util.AnnotationMode.DISABLE:
                f += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;
                break;
              case _util.AnnotationMode.ENABLE:
                break;
              case _util.AnnotationMode.ENABLE_FORMS:
                f += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;
                break;
              case _util.AnnotationMode.ENABLE_STORAGE:
                f += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE, c = (f & _util.RenderingIntentFlag.PRINT && x instanceof _annotation_storage.PrintAnnotationStorage ? x : this.annotationStorage).serializable;
                break;
              default:
                (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${H}`);
            }
            return R && (f += _util.RenderingIntentFlag.OPLIST), {
              renderingIntent: f,
              cacheKey: `${f}_${c.hash}`,
              annotationStorageSerializable: c
            };
          }
          destroy() {
            var x;
            if (this.destroyCapability)
              return this.destroyCapability.promise;
            this.destroyed = !0, this.destroyCapability = new _util.PromiseCapability(), (x = le(this, O)) == null || x.reject(new Error("Worker was destroyed during onPassword callback"));
            const k = [];
            for (const R of le(this, j).values())
              k.push(R._destroy());
            le(this, j).clear(), le(this, U).clear(), this.hasOwnProperty("annotationStorage") && this.annotationStorage.resetModified();
            const H = this.messageHandler.sendWithPromise("Terminate", null);
            return k.push(H), Promise.all(k).then(() => {
              var R;
              this.commonObjs.clear(), this.fontLoader.clear(), le(this, l).clear(), this.filterFactory.destroy(), (R = this._networkStream) == null || R.cancelAllRequests(new _util.AbortException("Worker was terminated.")), this.messageHandler && (this.messageHandler.destroy(), this.messageHandler = null), this.destroyCapability.resolve();
            }, this.destroyCapability.reject), this.destroyCapability.promise;
          }
          setupMessageHandler() {
            const {
              messageHandler: k,
              loadingTask: H
            } = this;
            k.on("GetReader", (x, R) => {
              (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available."), this._fullReader = this._networkStream.getFullReader(), this._fullReader.onProgress = (f) => {
                this._lastProgress = {
                  loaded: f.loaded,
                  total: f.total
                };
              }, R.onPull = () => {
                this._fullReader.read().then(function({
                  value: f,
                  done: c
                }) {
                  if (c) {
                    R.close();
                    return;
                  }
                  (0, _util.assert)(f instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer."), R.enqueue(new Uint8Array(f), 1, [f]);
                }).catch((f) => {
                  R.error(f);
                });
              }, R.onCancel = (f) => {
                this._fullReader.cancel(f), R.ready.catch((c) => {
                  if (!this.destroyed)
                    throw c;
                });
              };
            }), k.on("ReaderHeadersReady", (x) => {
              const R = new _util.PromiseCapability(), f = this._fullReader;
              return f.headersReady.then(() => {
                var c;
                (!f.isStreamingSupported || !f.isRangeSupported) && (this._lastProgress && ((c = H.onProgress) == null || c.call(H, this._lastProgress)), f.onProgress = (N) => {
                  var u;
                  (u = H.onProgress) == null || u.call(H, {
                    loaded: N.loaded,
                    total: N.total
                  });
                }), R.resolve({
                  isStreamingSupported: f.isStreamingSupported,
                  isRangeSupported: f.isRangeSupported,
                  contentLength: f.contentLength
                });
              }, R.reject), R.promise;
            }), k.on("GetRangeReader", (x, R) => {
              (0, _util.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
              const f = this._networkStream.getRangeReader(x.begin, x.end);
              if (!f) {
                R.close();
                return;
              }
              R.onPull = () => {
                f.read().then(function({
                  value: c,
                  done: N
                }) {
                  if (N) {
                    R.close();
                    return;
                  }
                  (0, _util.assert)(c instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer."), R.enqueue(new Uint8Array(c), 1, [c]);
                }).catch((c) => {
                  R.error(c);
                });
              }, R.onCancel = (c) => {
                f.cancel(c), R.ready.catch((N) => {
                  if (!this.destroyed)
                    throw N;
                });
              };
            }), k.on("GetDoc", ({
              pdfInfo: x
            }) => {
              this._numPages = x.numPages, this._htmlForXfa = x.htmlForXfa, delete x.htmlForXfa, H._capability.resolve(new PDFDocumentProxy(x, this));
            }), k.on("DocException", function(x) {
              let R;
              switch (x.name) {
                case "PasswordException":
                  R = new _util.PasswordException(x.message, x.code);
                  break;
                case "InvalidPDFException":
                  R = new _util.InvalidPDFException(x.message);
                  break;
                case "MissingPDFException":
                  R = new _util.MissingPDFException(x.message);
                  break;
                case "UnexpectedResponseException":
                  R = new _util.UnexpectedResponseException(x.message, x.status);
                  break;
                case "UnknownErrorException":
                  R = new _util.UnknownErrorException(x.message, x.details);
                  break;
                default:
                  (0, _util.unreachable)("DocException - expected a valid Error.");
              }
              H._capability.reject(R);
            }), k.on("PasswordRequest", (x) => {
              if (Xe(this, O, new _util.PromiseCapability()), H.onPassword) {
                const R = (f) => {
                  f instanceof Error ? le(this, O).reject(f) : le(this, O).resolve({
                    password: f
                  });
                };
                try {
                  H.onPassword(R, x.code);
                } catch (f) {
                  le(this, O).reject(f);
                }
              } else
                le(this, O).reject(new _util.PasswordException(x.message, x.code));
              return le(this, O).promise;
            }), k.on("DataLoaded", (x) => {
              var R;
              (R = H.onProgress) == null || R.call(H, {
                loaded: x.length,
                total: x.length
              }), this.downloadInfoCapability.resolve(x);
            }), k.on("StartRenderPage", (x) => {
              if (this.destroyed)
                return;
              le(this, j).get(x.pageIndex)._startRenderPage(x.transparency, x.cacheKey);
            }), k.on("commonobj", ([x, R, f]) => {
              var c;
              if (!this.destroyed && !this.commonObjs.has(x))
                switch (R) {
                  case "Font":
                    const N = this._params;
                    if ("error" in f) {
                      const S = f.error;
                      (0, _util.warn)(`Error during font loading: ${S}`), this.commonObjs.resolve(x, S);
                      break;
                    }
                    const u = N.pdfBug && ((c = globalThis.FontInspector) != null && c.enabled) ? (S, B) => globalThis.FontInspector.fontAdded(S, B) : null, p = new _font_loader.FontFaceObject(f, {
                      isEvalSupported: N.isEvalSupported,
                      disableFontFace: N.disableFontFace,
                      ignoreErrors: N.ignoreErrors,
                      inspectFont: u
                    });
                    this.fontLoader.bind(p).catch((S) => k.sendWithPromise("FontFallback", {
                      id: x
                    })).finally(() => {
                      !N.fontExtraProperties && p.data && (p.data = null), this.commonObjs.resolve(x, p);
                    });
                    break;
                  case "FontPath":
                  case "Image":
                  case "Pattern":
                    this.commonObjs.resolve(x, f);
                    break;
                  default:
                    throw new Error(`Got unknown common object type ${R}`);
                }
            }), k.on("obj", ([x, R, f, c]) => {
              var u;
              if (this.destroyed)
                return;
              const N = le(this, j).get(R);
              if (!N.objs.has(x))
                switch (f) {
                  case "Image":
                    if (N.objs.resolve(x, c), c) {
                      let p;
                      if (c.bitmap) {
                        const {
                          width: S,
                          height: B
                        } = c;
                        p = S * B * 4;
                      } else
                        p = ((u = c.data) == null ? void 0 : u.length) || 0;
                      p > _util.MAX_IMAGE_SIZE_TO_CACHE && (N._maybeCleanupAfterRender = !0);
                    }
                    break;
                  case "Pattern":
                    N.objs.resolve(x, c);
                    break;
                  default:
                    throw new Error(`Got unknown object type ${f}`);
                }
            }), k.on("DocProgress", (x) => {
              var R;
              this.destroyed || (R = H.onProgress) == null || R.call(H, {
                loaded: x.loaded,
                total: x.total
              });
            }), k.on("FetchBuiltInCMap", (x) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.cMapReaderFactory ? this.cMapReaderFactory.fetch(x) : Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."))), k.on("FetchStandardFontData", (x) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.standardFontDataFactory ? this.standardFontDataFactory.fetch(x) : Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.")));
          }
          getData() {
            return this.messageHandler.sendWithPromise("GetData", null);
          }
          saveDocument() {
            var x;
            this.annotationStorage.size <= 0 && (0, _util.warn)("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
            const {
              map: k,
              transfers: H
            } = this.annotationStorage.serializable;
            return this.messageHandler.sendWithPromise("SaveDocument", {
              isPureXfa: !!this._htmlForXfa,
              numPages: this._numPages,
              annotationStorage: k,
              filename: ((x = this._fullReader) == null ? void 0 : x.filename) ?? null
            }, H).finally(() => {
              this.annotationStorage.resetModified();
            });
          }
          getPage(k) {
            if (!Number.isInteger(k) || k <= 0 || k > this._numPages)
              return Promise.reject(new Error("Invalid page request."));
            const H = k - 1, x = le(this, U).get(H);
            if (x)
              return x;
            const R = this.messageHandler.sendWithPromise("GetPage", {
              pageIndex: H
            }).then((f) => {
              if (this.destroyed)
                throw new Error("Transport destroyed");
              const c = new PDFPageProxy(H, f, this, this._params.pdfBug);
              return le(this, j).set(H, c), c;
            });
            return le(this, U).set(H, R), R;
          }
          getPageIndex(k) {
            return typeof k != "object" || k === null || !Number.isInteger(k.num) || k.num < 0 || !Number.isInteger(k.gen) || k.gen < 0 ? Promise.reject(new Error("Invalid pageIndex request.")) : this.messageHandler.sendWithPromise("GetPageIndex", {
              num: k.num,
              gen: k.gen
            });
          }
          getAnnotations(k, H) {
            return this.messageHandler.sendWithPromise("GetAnnotations", {
              pageIndex: k,
              intent: H
            });
          }
          getFieldObjects() {
            return De(this, v, Vn).call(this, "GetFieldObjects");
          }
          hasJSActions() {
            return De(this, v, Vn).call(this, "HasJSActions");
          }
          getCalculationOrderIds() {
            return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
          }
          getDestinations() {
            return this.messageHandler.sendWithPromise("GetDestinations", null);
          }
          getDestination(k) {
            return typeof k != "string" ? Promise.reject(new Error("Invalid destination request.")) : this.messageHandler.sendWithPromise("GetDestination", {
              id: k
            });
          }
          getPageLabels() {
            return this.messageHandler.sendWithPromise("GetPageLabels", null);
          }
          getPageLayout() {
            return this.messageHandler.sendWithPromise("GetPageLayout", null);
          }
          getPageMode() {
            return this.messageHandler.sendWithPromise("GetPageMode", null);
          }
          getViewerPreferences() {
            return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
          }
          getOpenAction() {
            return this.messageHandler.sendWithPromise("GetOpenAction", null);
          }
          getAttachments() {
            return this.messageHandler.sendWithPromise("GetAttachments", null);
          }
          getDocJSActions() {
            return De(this, v, Vn).call(this, "GetDocJSActions");
          }
          getPageJSActions(k) {
            return this.messageHandler.sendWithPromise("GetPageJSActions", {
              pageIndex: k
            });
          }
          getStructTree(k) {
            return this.messageHandler.sendWithPromise("GetStructTree", {
              pageIndex: k
            });
          }
          getOutline() {
            return this.messageHandler.sendWithPromise("GetOutline", null);
          }
          getOptionalContentConfig() {
            return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then((k) => new _optional_content_config.OptionalContentConfig(k));
          }
          getPermissions() {
            return this.messageHandler.sendWithPromise("GetPermissions", null);
          }
          getMetadata() {
            const k = "GetMetadata", H = le(this, l).get(k);
            if (H)
              return H;
            const x = this.messageHandler.sendWithPromise(k, null).then((R) => {
              var f, c;
              return {
                info: R[0],
                metadata: R[1] ? new _metadata.Metadata(R[1]) : null,
                contentDispositionFilename: ((f = this._fullReader) == null ? void 0 : f.filename) ?? null,
                contentLength: ((c = this._fullReader) == null ? void 0 : c.contentLength) ?? null
              };
            });
            return le(this, l).set(k, x), x;
          }
          getMarkInfo() {
            return this.messageHandler.sendWithPromise("GetMarkInfo", null);
          }
          async startCleanup(k = !1) {
            if (!this.destroyed) {
              await this.messageHandler.sendWithPromise("Cleanup", null);
              for (const H of le(this, j).values())
                if (!H.cleanup())
                  throw new Error(`startCleanup: Page ${H.pageNumber} is currently rendering.`);
              this.commonObjs.clear(), k || this.fontLoader.clear(), le(this, l).clear(), this.filterFactory.destroy(!0);
            }
          }
          get loadingParams() {
            const {
              disableAutoFetch: k,
              enableXfa: H
            } = this._params;
            return (0, _util.shadow)(this, "loadingParams", {
              disableAutoFetch: k,
              enableXfa: H
            });
          }
        }
        l = new WeakMap(), j = new WeakMap(), U = new WeakMap(), O = new WeakMap(), v = new WeakSet(), Vn = function(k, H = null) {
          const x = le(this, l).get(k);
          if (x)
            return x;
          const R = this.messageHandler.sendWithPromise(k, H);
          return le(this, l).set(k, R), R;
        };
        class PDFObjects {
          constructor() {
            Me(this, i);
            Me(this, b, /* @__PURE__ */ Object.create(null));
          }
          get(k, H = null) {
            if (H) {
              const R = De(this, i, Ui).call(this, k);
              return R.capability.promise.then(() => H(R.data)), null;
            }
            const x = le(this, b)[k];
            if (!(x != null && x.capability.settled))
              throw new Error(`Requesting object that isn't resolved yet ${k}.`);
            return x.data;
          }
          has(k) {
            const H = le(this, b)[k];
            return (H == null ? void 0 : H.capability.settled) || !1;
          }
          resolve(k, H = null) {
            const x = De(this, i, Ui).call(this, k);
            x.data = H, x.capability.resolve();
          }
          clear() {
            var k;
            for (const H in le(this, b)) {
              const {
                data: x
              } = le(this, b)[H];
              (k = x == null ? void 0 : x.bitmap) == null || k.close();
            }
            Xe(this, b, /* @__PURE__ */ Object.create(null));
          }
        }
        b = new WeakMap(), i = new WeakSet(), Ui = function(k) {
          var H;
          return (H = le(this, b))[k] || (H[k] = {
            capability: new _util.PromiseCapability(),
            data: null
          });
        };
        class RenderTask {
          constructor(k) {
            Me(this, d, null);
            Xe(this, d, k), this.onContinue = null;
          }
          get promise() {
            return le(this, d).capability.promise;
          }
          cancel(k = 0) {
            le(this, d).cancel(null, k);
          }
          get separateAnnots() {
            const {
              separateAnnots: k
            } = le(this, d).operatorList;
            if (!k)
              return !1;
            const {
              annotationCanvasMap: H
            } = le(this, d);
            return k.form || k.canvas && (H == null ? void 0 : H.size) > 0;
          }
        }
        d = new WeakMap(), exports.RenderTask = RenderTask;
        const I = class I {
          constructor({
            callback: k,
            params: H,
            objs: x,
            commonObjs: R,
            annotationCanvasMap: f,
            operatorList: c,
            pageIndex: N,
            canvasFactory: u,
            filterFactory: p,
            useRequestAnimationFrame: S = !1,
            pdfBug: B = !1,
            pageColors: T = null
          }) {
            this.callback = k, this.params = H, this.objs = x, this.commonObjs = R, this.annotationCanvasMap = f, this.operatorListIdx = null, this.operatorList = c, this._pageIndex = N, this.canvasFactory = u, this.filterFactory = p, this._pdfBug = B, this.pageColors = T, this.running = !1, this.graphicsReadyCallback = null, this.graphicsReady = !1, this._useRequestAnimationFrame = S === !0 && typeof window < "u", this.cancelled = !1, this.capability = new _util.PromiseCapability(), this.task = new RenderTask(this), this._cancelBound = this.cancel.bind(this), this._continueBound = this._continue.bind(this), this._scheduleNextBound = this._scheduleNext.bind(this), this._nextBound = this._next.bind(this), this._canvas = H.canvasContext.canvas;
          }
          get completed() {
            return this.capability.promise.catch(function() {
            });
          }
          initializeGraphics({
            transparency: k = !1,
            optionalContentConfig: H
          }) {
            var N, u;
            if (this.cancelled)
              return;
            if (this._canvas) {
              if (le(I, A).has(this._canvas))
                throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
              le(I, A).add(this._canvas);
            }
            this._pdfBug && ((N = globalThis.StepperManager) != null && N.enabled) && (this.stepper = globalThis.StepperManager.create(this._pageIndex), this.stepper.init(this.operatorList), this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint());
            const {
              canvasContext: x,
              viewport: R,
              transform: f,
              background: c
            } = this.params;
            this.gfx = new _canvas.CanvasGraphics(x, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
              optionalContentConfig: H
            }, this.annotationCanvasMap, this.pageColors), this.gfx.beginDrawing({
              transform: f,
              viewport: R,
              transparency: k,
              background: c
            }), this.operatorListIdx = 0, this.graphicsReady = !0, (u = this.graphicsReadyCallback) == null || u.call(this);
          }
          cancel(k = null, H = 0) {
            var x;
            this.running = !1, this.cancelled = !0, (x = this.gfx) == null || x.endDrawing(), le(I, A).delete(this._canvas), this.callback(k || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, H));
          }
          operatorListChanged() {
            var k;
            if (!this.graphicsReady) {
              this.graphicsReadyCallback || (this.graphicsReadyCallback = this._continueBound);
              return;
            }
            (k = this.stepper) == null || k.updateOperatorList(this.operatorList), !this.running && this._continue();
          }
          _continue() {
            this.running = !0, !this.cancelled && (this.task.onContinue ? this.task.onContinue(this._scheduleNextBound) : this._scheduleNext());
          }
          _scheduleNext() {
            this._useRequestAnimationFrame ? window.requestAnimationFrame(() => {
              this._nextBound().catch(this._cancelBound);
            }) : Promise.resolve().then(this._nextBound).catch(this._cancelBound);
          }
          async _next() {
            this.cancelled || (this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper), this.operatorListIdx === this.operatorList.argsArray.length && (this.running = !1, this.operatorList.lastChunk && (this.gfx.endDrawing(), le(I, A).delete(this._canvas), this.callback())));
          }
        };
        A = new WeakMap(), Me(I, A, /* @__PURE__ */ new WeakSet());
        let InternalRenderTask = I;
        const version = "3.11.174";
        exports.version = version;
        const build = "ce8716743";
        exports.build = build;
      },
      /* 3 */
      /***/
      (Re, ge, xe) => {
        var C, e, t, _a, j;
        Object.defineProperty(ge, "__esModule", {
          value: !0
        }), ge.SerializableEmpty = ge.PrintAnnotationStorage = ge.AnnotationStorage = void 0;
        var de = xe(1), fe = xe(4), w = xe(8);
        const V = Object.freeze({
          map: null,
          hash: "",
          transfers: void 0
        });
        ge.SerializableEmpty = V;
        class n {
          constructor() {
            Me(this, t);
            Me(this, C, !1);
            Me(this, e, /* @__PURE__ */ new Map());
            this.onSetModified = null, this.onResetModified = null, this.onAnnotationEditor = null;
          }
          getValue(O, v) {
            const g = le(this, e).get(O);
            return g === void 0 ? v : Object.assign(v, g);
          }
          getRawValue(O) {
            return le(this, e).get(O);
          }
          remove(O) {
            if (le(this, e).delete(O), le(this, e).size === 0 && this.resetModified(), typeof this.onAnnotationEditor == "function") {
              for (const v of le(this, e).values())
                if (v instanceof fe.AnnotationEditor)
                  return;
              this.onAnnotationEditor(null);
            }
          }
          setValue(O, v) {
            const g = le(this, e).get(O);
            let b = !1;
            if (g !== void 0)
              for (const [i, P] of Object.entries(v))
                g[i] !== P && (b = !0, g[i] = P);
            else
              b = !0, le(this, e).set(O, v);
            b && De(this, t, _a).call(this), v instanceof fe.AnnotationEditor && typeof this.onAnnotationEditor == "function" && this.onAnnotationEditor(v.constructor._type);
          }
          has(O) {
            return le(this, e).has(O);
          }
          getAll() {
            return le(this, e).size > 0 ? (0, de.objectFromMap)(le(this, e)) : null;
          }
          setAll(O) {
            for (const [v, g] of Object.entries(O))
              this.setValue(v, g);
          }
          get size() {
            return le(this, e).size;
          }
          resetModified() {
            le(this, C) && (Xe(this, C, !1), typeof this.onResetModified == "function" && this.onResetModified());
          }
          get print() {
            return new F(this);
          }
          get serializable() {
            if (le(this, e).size === 0)
              return V;
            const O = /* @__PURE__ */ new Map(), v = new w.MurmurHash3_64(), g = [], b = /* @__PURE__ */ Object.create(null);
            let i = !1;
            for (const [P, d] of le(this, e)) {
              const A = d instanceof fe.AnnotationEditor ? d.serialize(!1, b) : d;
              A && (O.set(P, A), v.update(`${P}:${JSON.stringify(A)}`), i || (i = !!A.bitmap));
            }
            if (i)
              for (const P of O.values())
                P.bitmap && g.push(P.bitmap);
            return O.size > 0 ? {
              map: O,
              hash: v.hexdigest(),
              transfers: g
            } : V;
          }
        }
        C = new WeakMap(), e = new WeakMap(), t = new WeakSet(), _a = function() {
          le(this, C) || (Xe(this, C, !0), typeof this.onSetModified == "function" && this.onSetModified());
        }, ge.AnnotationStorage = n;
        class F extends n {
          constructor(v) {
            super();
            Me(this, j, void 0);
            const {
              map: g,
              hash: b,
              transfers: i
            } = v.serializable, P = structuredClone(g, i ? {
              transfer: i
            } : null);
            Xe(this, j, {
              map: P,
              hash: b,
              transfers: i
            });
          }
          get print() {
            (0, de.unreachable)("Should not call PrintAnnotationStorage.print");
          }
          get serializable() {
            return le(this, j);
          }
        }
        j = new WeakMap(), ge.PrintAnnotationStorage = F;
      },
      /* 4 */
      /***/
      (Re, ge, xe) => {
        var F, C, e, t, l, j, U, O, v, g, b, i, P, d, A, Hi, E, Xi, H, zi, R, Gi, c, Ra, u, Da, S, La, T, Wi, K, Na;
        Object.defineProperty(ge, "__esModule", {
          value: !0
        }), ge.AnnotationEditor = void 0;
        var de = xe(5), fe = xe(1), w = xe(6);
        const o = class o {
          constructor(s) {
            Me(this, A);
            Me(this, E);
            Me(this, R);
            Me(this, c);
            Me(this, u);
            Me(this, S);
            Me(this, T);
            Me(this, K);
            Me(this, F, "");
            Me(this, C, !1);
            Me(this, e, null);
            Me(this, t, null);
            Me(this, l, null);
            Me(this, j, !1);
            Me(this, U, null);
            Me(this, O, this.focusin.bind(this));
            Me(this, v, this.focusout.bind(this));
            Me(this, g, !1);
            Me(this, b, !1);
            Me(this, i, !1);
            Ot(this, "_initialOptions", /* @__PURE__ */ Object.create(null));
            Ot(this, "_uiManager", null);
            Ot(this, "_focusEventsAllowed", !0);
            Ot(this, "_l10nPromise", null);
            Me(this, P, !1);
            Me(this, d, o._zIndex++);
            this.constructor === o && (0, fe.unreachable)("Cannot initialize AnnotationEditor."), this.parent = s.parent, this.id = s.id, this.width = this.height = null, this.pageIndex = s.parent.pageIndex, this.name = s.name, this.div = null, this._uiManager = s.uiManager, this.annotationElementId = null, this._willKeepAspectRatio = !1, this._initialOptions.isCentered = s.isCentered, this._structTreeParentId = null;
            const {
              rotation: r,
              rawDims: {
                pageWidth: y,
                pageHeight: M,
                pageX: $,
                pageY: G
              }
            } = this.parent.viewport;
            this.rotation = r, this.pageRotation = (360 + r - this._uiManager.viewParameters.rotation) % 360, this.pageDimensions = [y, M], this.pageTranslation = [$, G];
            const [ce, q] = this.parentDimensions;
            this.x = s.x / ce, this.y = s.y / q, this.isAttachedToDOM = !1, this.deleted = !1;
          }
          get editorType() {
            return Object.getPrototypeOf(this).constructor._type;
          }
          static get _defaultLineColor() {
            return (0, fe.shadow)(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
          }
          static deleteAnnotationElement(s) {
            const r = new n({
              id: s.parent.getNextId(),
              parent: s.parent,
              uiManager: s._uiManager
            });
            r.annotationElementId = s.annotationElementId, r.deleted = !0, r._uiManager.addToAnnotationStorage(r);
          }
          static initialize(s, r = null) {
            if (o._l10nPromise || (o._l10nPromise = new Map(["editor_alt_text_button_label", "editor_alt_text_edit_button_label", "editor_alt_text_decorative_tooltip"].map((M) => [M, s.get(M)]))), r != null && r.strings)
              for (const M of r.strings)
                o._l10nPromise.set(M, s.get(M));
            if (o._borderLineWidth !== -1)
              return;
            const y = getComputedStyle(document.documentElement);
            o._borderLineWidth = parseFloat(y.getPropertyValue("--outline-width")) || 0;
          }
          static updateDefaultParams(s, r) {
          }
          static get defaultPropertiesToUpdate() {
            return [];
          }
          static isHandlingMimeForPasting(s) {
            return !1;
          }
          static paste(s, r) {
            (0, fe.unreachable)("Not implemented");
          }
          get propertiesToUpdate() {
            return [];
          }
          get _isDraggable() {
            return le(this, P);
          }
          set _isDraggable(s) {
            var r;
            Xe(this, P, s), (r = this.div) == null || r.classList.toggle("draggable", s);
          }
          center() {
            const [s, r] = this.pageDimensions;
            switch (this.parentRotation) {
              case 90:
                this.x -= this.height * r / (s * 2), this.y += this.width * s / (r * 2);
                break;
              case 180:
                this.x += this.width / 2, this.y += this.height / 2;
                break;
              case 270:
                this.x += this.height * r / (s * 2), this.y -= this.width * s / (r * 2);
                break;
              default:
                this.x -= this.width / 2, this.y -= this.height / 2;
                break;
            }
            this.fixAndSetPosition();
          }
          addCommands(s) {
            this._uiManager.addCommands(s);
          }
          get currentLayer() {
            return this._uiManager.currentLayer;
          }
          setInBackground() {
            this.div.style.zIndex = 0;
          }
          setInForeground() {
            this.div.style.zIndex = le(this, d);
          }
          setParent(s) {
            s !== null && (this.pageIndex = s.pageIndex, this.pageDimensions = s.pageDimensions), this.parent = s;
          }
          focusin(s) {
            this._focusEventsAllowed && (le(this, g) ? Xe(this, g, !1) : this.parent.setSelected(this));
          }
          focusout(s) {
            var y;
            if (!this._focusEventsAllowed || !this.isAttachedToDOM)
              return;
            const r = s.relatedTarget;
            r != null && r.closest(`#${this.id}`) || (s.preventDefault(), (y = this.parent) != null && y.isMultipleSelection || this.commitOrRemove());
          }
          commitOrRemove() {
            this.isEmpty() ? this.remove() : this.commit();
          }
          commit() {
            this.addToAnnotationStorage();
          }
          addToAnnotationStorage() {
            this._uiManager.addToAnnotationStorage(this);
          }
          setAt(s, r, y, M) {
            const [$, G] = this.parentDimensions;
            [y, M] = this.screenToPageTranslation(y, M), this.x = (s + y) / $, this.y = (r + M) / G, this.fixAndSetPosition();
          }
          translate(s, r) {
            De(this, A, Hi).call(this, this.parentDimensions, s, r);
          }
          translateInPage(s, r) {
            De(this, A, Hi).call(this, this.pageDimensions, s, r), this.div.scrollIntoView({
              block: "nearest"
            });
          }
          drag(s, r) {
            const [y, M] = this.parentDimensions;
            if (this.x += s / y, this.y += r / M, this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
              const {
                x: re,
                y: Z
              } = this.div.getBoundingClientRect();
              this.parent.findNewParent(this, re, Z) && (this.x -= Math.floor(this.x), this.y -= Math.floor(this.y));
            }
            let {
              x: $,
              y: G
            } = this;
            const [ce, q] = De(this, E, Xi).call(this);
            $ += ce, G += q, this.div.style.left = `${(100 * $).toFixed(2)}%`, this.div.style.top = `${(100 * G).toFixed(2)}%`, this.div.scrollIntoView({
              block: "nearest"
            });
          }
          fixAndSetPosition() {
            const [s, r] = this.pageDimensions;
            let {
              x: y,
              y: M,
              width: $,
              height: G
            } = this;
            switch ($ *= s, G *= r, y *= s, M *= r, this.rotation) {
              case 0:
                y = Math.max(0, Math.min(s - $, y)), M = Math.max(0, Math.min(r - G, M));
                break;
              case 90:
                y = Math.max(0, Math.min(s - G, y)), M = Math.min(r, Math.max($, M));
                break;
              case 180:
                y = Math.min(s, Math.max($, y)), M = Math.min(r, Math.max(G, M));
                break;
              case 270:
                y = Math.min(s, Math.max(G, y)), M = Math.max(0, Math.min(r - $, M));
                break;
            }
            this.x = y /= s, this.y = M /= r;
            const [ce, q] = De(this, E, Xi).call(this);
            y += ce, M += q;
            const {
              style: re
            } = this.div;
            re.left = `${(100 * y).toFixed(2)}%`, re.top = `${(100 * M).toFixed(2)}%`, this.moveInDOM();
          }
          screenToPageTranslation(s, r) {
            var y;
            return De(y = o, H, zi).call(y, s, r, this.parentRotation);
          }
          pageTranslationToScreen(s, r) {
            var y;
            return De(y = o, H, zi).call(y, s, r, 360 - this.parentRotation);
          }
          get parentScale() {
            return this._uiManager.viewParameters.realScale;
          }
          get parentRotation() {
            return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
          }
          get parentDimensions() {
            const {
              parentScale: s,
              pageDimensions: [r, y]
            } = this, M = r * s, $ = y * s;
            return fe.FeatureTest.isCSSRoundSupported ? [Math.round(M), Math.round($)] : [M, $];
          }
          setDims(s, r) {
            var $;
            const [y, M] = this.parentDimensions;
            this.div.style.width = `${(100 * s / y).toFixed(2)}%`, le(this, j) || (this.div.style.height = `${(100 * r / M).toFixed(2)}%`), ($ = le(this, e)) == null || $.classList.toggle("small", s < o.SMALL_EDITOR_SIZE || r < o.SMALL_EDITOR_SIZE);
          }
          fixDims() {
            const {
              style: s
            } = this.div, {
              height: r,
              width: y
            } = s, M = y.endsWith("%"), $ = !le(this, j) && r.endsWith("%");
            if (M && $)
              return;
            const [G, ce] = this.parentDimensions;
            M || (s.width = `${(100 * parseFloat(y) / G).toFixed(2)}%`), !le(this, j) && !$ && (s.height = `${(100 * parseFloat(r) / ce).toFixed(2)}%`);
          }
          getInitialTranslation() {
            return [0, 0];
          }
          async addAltTextButton() {
            if (le(this, e))
              return;
            const s = Xe(this, e, document.createElement("button"));
            s.className = "altText";
            const r = await o._l10nPromise.get("editor_alt_text_button_label");
            s.textContent = r, s.setAttribute("aria-label", r), s.tabIndex = "0", s.addEventListener("contextmenu", w.noContextMenu), s.addEventListener("pointerdown", (y) => y.stopPropagation()), s.addEventListener("click", (y) => {
              y.preventDefault(), this._uiManager.editAltText(this);
            }, {
              capture: !0
            }), s.addEventListener("keydown", (y) => {
              y.target === s && y.key === "Enter" && (y.preventDefault(), this._uiManager.editAltText(this));
            }), De(this, T, Wi).call(this), this.div.append(s), o.SMALL_EDITOR_SIZE || (o.SMALL_EDITOR_SIZE = Math.min(128, Math.round(s.getBoundingClientRect().width * 1.4)));
          }
          getClientDimensions() {
            return this.div.getBoundingClientRect();
          }
          get altTextData() {
            return {
              altText: le(this, F),
              decorative: le(this, C)
            };
          }
          set altTextData({
            altText: s,
            decorative: r
          }) {
            le(this, F) === s && le(this, C) === r || (Xe(this, F, s), Xe(this, C, r), De(this, T, Wi).call(this));
          }
          render() {
            this.div = document.createElement("div"), this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360), this.div.className = this.name, this.div.setAttribute("id", this.id), this.div.setAttribute("tabIndex", 0), this.setInForeground(), this.div.addEventListener("focusin", le(this, O)), this.div.addEventListener("focusout", le(this, v));
            const [s, r] = this.parentDimensions;
            this.parentRotation % 180 !== 0 && (this.div.style.maxWidth = `${(100 * r / s).toFixed(2)}%`, this.div.style.maxHeight = `${(100 * s / r).toFixed(2)}%`);
            const [y, M] = this.getInitialTranslation();
            return this.translate(y, M), (0, de.bindEvents)(this, this.div, ["pointerdown"]), this.div;
          }
          pointerdown(s) {
            const {
              isMac: r
            } = fe.FeatureTest.platform;
            if (s.button !== 0 || s.ctrlKey && r) {
              s.preventDefault();
              return;
            }
            Xe(this, g, !0), De(this, K, Na).call(this, s);
          }
          moveInDOM() {
            var s;
            (s = this.parent) == null || s.moveEditorInDOM(this);
          }
          _setParentAndPosition(s, r, y) {
            s.changeParent(this), this.x = r, this.y = y, this.fixAndSetPosition();
          }
          getRect(s, r) {
            const y = this.parentScale, [M, $] = this.pageDimensions, [G, ce] = this.pageTranslation, q = s / y, re = r / y, Z = this.x * M, te = this.y * $, L = this.width * M, X = this.height * $;
            switch (this.rotation) {
              case 0:
                return [Z + q + G, $ - te - re - X + ce, Z + q + L + G, $ - te - re + ce];
              case 90:
                return [Z + re + G, $ - te + q + ce, Z + re + X + G, $ - te + q + L + ce];
              case 180:
                return [Z - q - L + G, $ - te + re + ce, Z - q + G, $ - te + re + X + ce];
              case 270:
                return [Z - re - X + G, $ - te - q - L + ce, Z - re + G, $ - te - q + ce];
              default:
                throw new Error("Invalid rotation");
            }
          }
          getRectInCurrentCoords(s, r) {
            const [y, M, $, G] = s, ce = $ - y, q = G - M;
            switch (this.rotation) {
              case 0:
                return [y, r - G, ce, q];
              case 90:
                return [y, r - M, q, ce];
              case 180:
                return [$, r - M, ce, q];
              case 270:
                return [$, r - G, q, ce];
              default:
                throw new Error("Invalid rotation");
            }
          }
          onceAdded() {
          }
          isEmpty() {
            return !1;
          }
          enableEditMode() {
            Xe(this, i, !0);
          }
          disableEditMode() {
            Xe(this, i, !1);
          }
          isInEditMode() {
            return le(this, i);
          }
          shouldGetKeyboardEvents() {
            return !1;
          }
          needsToBeRebuilt() {
            return this.div && !this.isAttachedToDOM;
          }
          rebuild() {
            var s, r;
            (s = this.div) == null || s.addEventListener("focusin", le(this, O)), (r = this.div) == null || r.addEventListener("focusout", le(this, v));
          }
          serialize(s = !1, r = null) {
            (0, fe.unreachable)("An editor must be serializable");
          }
          static deserialize(s, r, y) {
            const M = new this.prototype.constructor({
              parent: r,
              id: r.getNextId(),
              uiManager: y
            });
            M.rotation = s.rotation;
            const [$, G] = M.pageDimensions, [ce, q, re, Z] = M.getRectInCurrentCoords(s.rect, G);
            return M.x = ce / $, M.y = q / G, M.width = re / $, M.height = Z / G, M;
          }
          remove() {
            var s;
            this.div.removeEventListener("focusin", le(this, O)), this.div.removeEventListener("focusout", le(this, v)), this.isEmpty() || this.commit(), this.parent ? this.parent.remove(this) : this._uiManager.removeEditor(this), (s = le(this, e)) == null || s.remove(), Xe(this, e, null), Xe(this, t, null);
          }
          get isResizable() {
            return !1;
          }
          makeResizable() {
            this.isResizable && (De(this, c, Ra).call(this), le(this, U).classList.remove("hidden"));
          }
          select() {
            var s;
            this.makeResizable(), (s = this.div) == null || s.classList.add("selectedEditor");
          }
          unselect() {
            var s, r, y;
            (s = le(this, U)) == null || s.classList.add("hidden"), (r = this.div) == null || r.classList.remove("selectedEditor"), (y = this.div) != null && y.contains(document.activeElement) && this._uiManager.currentLayer.div.focus();
          }
          updateParams(s, r) {
          }
          disableEditing() {
            le(this, e) && (le(this, e).hidden = !0);
          }
          enableEditing() {
            le(this, e) && (le(this, e).hidden = !1);
          }
          enterInEditMode() {
          }
          get contentDiv() {
            return this.div;
          }
          get isEditing() {
            return le(this, b);
          }
          set isEditing(s) {
            Xe(this, b, s), this.parent && (s ? (this.parent.setSelected(this), this.parent.setActiveEditor(this)) : this.parent.setActiveEditor(null));
          }
          setAspectRatio(s, r) {
            Xe(this, j, !0);
            const y = s / r, {
              style: M
            } = this.div;
            M.aspectRatio = y, M.height = "auto";
          }
          static get MIN_SIZE() {
            return 16;
          }
        };
        F = new WeakMap(), C = new WeakMap(), e = new WeakMap(), t = new WeakMap(), l = new WeakMap(), j = new WeakMap(), U = new WeakMap(), O = new WeakMap(), v = new WeakMap(), g = new WeakMap(), b = new WeakMap(), i = new WeakMap(), P = new WeakMap(), d = new WeakMap(), A = new WeakSet(), Hi = function([s, r], y, M) {
          [y, M] = this.screenToPageTranslation(y, M), this.x += y / s, this.y += M / r, this.fixAndSetPosition();
        }, E = new WeakSet(), Xi = function() {
          const [s, r] = this.parentDimensions, {
            _borderLineWidth: y
          } = o, M = y / s, $ = y / r;
          switch (this.rotation) {
            case 90:
              return [-M, $];
            case 180:
              return [M, $];
            case 270:
              return [M, -$];
            default:
              return [-M, -$];
          }
        }, H = new WeakSet(), zi = function(s, r, y) {
          switch (y) {
            case 90:
              return [r, -s];
            case 180:
              return [-s, -r];
            case 270:
              return [-r, s];
            default:
              return [s, r];
          }
        }, R = new WeakSet(), Gi = function(s) {
          switch (s) {
            case 90: {
              const [r, y] = this.pageDimensions;
              return [0, -r / y, y / r, 0];
            }
            case 180:
              return [-1, 0, 0, -1];
            case 270: {
              const [r, y] = this.pageDimensions;
              return [0, r / y, -y / r, 0];
            }
            default:
              return [1, 0, 0, 1];
          }
        }, c = new WeakSet(), Ra = function() {
          if (le(this, U))
            return;
          Xe(this, U, document.createElement("div")), le(this, U).classList.add("resizers");
          const s = ["topLeft", "topRight", "bottomRight", "bottomLeft"];
          this._willKeepAspectRatio || s.push("topMiddle", "middleRight", "bottomMiddle", "middleLeft");
          for (const r of s) {
            const y = document.createElement("div");
            le(this, U).append(y), y.classList.add("resizer", r), y.addEventListener("pointerdown", De(this, u, Da).bind(this, r)), y.addEventListener("contextmenu", w.noContextMenu);
          }
          this.div.prepend(le(this, U));
        }, u = new WeakSet(), Da = function(s, r) {
          r.preventDefault();
          const {
            isMac: y
          } = fe.FeatureTest.platform;
          if (r.button !== 0 || r.ctrlKey && y)
            return;
          const M = De(this, S, La).bind(this, s), $ = this._isDraggable;
          this._isDraggable = !1;
          const G = {
            passive: !0,
            capture: !0
          };
          window.addEventListener("pointermove", M, G);
          const ce = this.x, q = this.y, re = this.width, Z = this.height, te = this.parent.div.style.cursor, L = this.div.style.cursor;
          this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(r.target).cursor;
          const X = () => {
            this._isDraggable = $, window.removeEventListener("pointerup", X), window.removeEventListener("blur", X), window.removeEventListener("pointermove", M, G), this.parent.div.style.cursor = te, this.div.style.cursor = L;
            const J = this.x, Y = this.y, ae = this.width, se = this.height;
            J === ce && Y === q && ae === re && se === Z || this.addCommands({
              cmd: () => {
                this.width = ae, this.height = se, this.x = J, this.y = Y;
                const [Q, z] = this.parentDimensions;
                this.setDims(Q * ae, z * se), this.fixAndSetPosition();
              },
              undo: () => {
                this.width = re, this.height = Z, this.x = ce, this.y = q;
                const [Q, z] = this.parentDimensions;
                this.setDims(Q * re, z * Z), this.fixAndSetPosition();
              },
              mustExec: !0
            });
          };
          window.addEventListener("pointerup", X), window.addEventListener("blur", X);
        }, S = new WeakSet(), La = function(s, r) {
          const [y, M] = this.parentDimensions, $ = this.x, G = this.y, ce = this.width, q = this.height, re = o.MIN_SIZE / y, Z = o.MIN_SIZE / M, te = (_e) => Math.round(_e * 1e4) / 1e4, L = De(this, R, Gi).call(this, this.rotation), X = (_e, Se) => [L[0] * _e + L[2] * Se, L[1] * _e + L[3] * Se], J = De(this, R, Gi).call(this, 360 - this.rotation), Y = (_e, Se) => [J[0] * _e + J[2] * Se, J[1] * _e + J[3] * Se];
          let ae, se, Q = !1, z = !1;
          switch (s) {
            case "topLeft":
              Q = !0, ae = (_e, Se) => [0, 0], se = (_e, Se) => [_e, Se];
              break;
            case "topMiddle":
              ae = (_e, Se) => [_e / 2, 0], se = (_e, Se) => [_e / 2, Se];
              break;
            case "topRight":
              Q = !0, ae = (_e, Se) => [_e, 0], se = (_e, Se) => [0, Se];
              break;
            case "middleRight":
              z = !0, ae = (_e, Se) => [_e, Se / 2], se = (_e, Se) => [0, Se / 2];
              break;
            case "bottomRight":
              Q = !0, ae = (_e, Se) => [_e, Se], se = (_e, Se) => [0, 0];
              break;
            case "bottomMiddle":
              ae = (_e, Se) => [_e / 2, Se], se = (_e, Se) => [_e / 2, 0];
              break;
            case "bottomLeft":
              Q = !0, ae = (_e, Se) => [0, Se], se = (_e, Se) => [_e, 0];
              break;
            case "middleLeft":
              z = !0, ae = (_e, Se) => [0, Se / 2], se = (_e, Se) => [_e, Se / 2];
              break;
          }
          const ie = ae(ce, q), ne = se(ce, q);
          let W = X(...ne);
          const oe = te($ + W[0]), ue = te(G + W[1]);
          let pe = 1, ve = 1, [Ce, Fe] = this.screenToPageTranslation(r.movementX, r.movementY);
          if ([Ce, Fe] = Y(Ce / y, Fe / M), Q) {
            const _e = Math.hypot(ce, q);
            pe = ve = Math.max(Math.min(Math.hypot(ne[0] - ie[0] - Ce, ne[1] - ie[1] - Fe) / _e, 1 / ce, 1 / q), re / ce, Z / q);
          } else
            z ? pe = Math.max(re, Math.min(1, Math.abs(ne[0] - ie[0] - Ce))) / ce : ve = Math.max(Z, Math.min(1, Math.abs(ne[1] - ie[1] - Fe))) / q;
          const Pe = te(ce * pe), be = te(q * ve);
          W = X(...se(Pe, be));
          const me = oe - W[0], we = ue - W[1];
          this.width = Pe, this.height = be, this.x = me, this.y = we, this.setDims(y * Pe, M * be), this.fixAndSetPosition();
        }, T = new WeakSet(), Wi = async function() {
          var y;
          const s = le(this, e);
          if (!s)
            return;
          if (!le(this, F) && !le(this, C)) {
            s.classList.remove("done"), (y = le(this, t)) == null || y.remove();
            return;
          }
          o._l10nPromise.get("editor_alt_text_edit_button_label").then((M) => {
            s.setAttribute("aria-label", M);
          });
          let r = le(this, t);
          if (!r) {
            Xe(this, t, r = document.createElement("span")), r.className = "tooltip", r.setAttribute("role", "tooltip");
            const M = r.id = `alt-text-tooltip-${this.id}`;
            s.setAttribute("aria-describedby", M);
            const $ = 100;
            s.addEventListener("mouseenter", () => {
              Xe(this, l, setTimeout(() => {
                Xe(this, l, null), le(this, t).classList.add("show"), this._uiManager._eventBus.dispatch("reporttelemetry", {
                  source: this,
                  details: {
                    type: "editing",
                    subtype: this.editorType,
                    data: {
                      action: "alt_text_tooltip"
                    }
                  }
                });
              }, $));
            }), s.addEventListener("mouseleave", () => {
              var G;
              clearTimeout(le(this, l)), Xe(this, l, null), (G = le(this, t)) == null || G.classList.remove("show");
            });
          }
          s.classList.add("done"), r.innerText = le(this, C) ? await o._l10nPromise.get("editor_alt_text_decorative_tooltip") : le(this, F), r.parentNode || s.append(r);
        }, K = new WeakSet(), Na = function(s) {
          if (!this._isDraggable)
            return;
          const r = this._uiManager.isSelected(this);
          this._uiManager.setUpDragSession();
          let y, M;
          r && (y = {
            passive: !0,
            capture: !0
          }, M = (G) => {
            const [ce, q] = this.screenToPageTranslation(G.movementX, G.movementY);
            this._uiManager.dragSelectedEditors(ce, q);
          }, window.addEventListener("pointermove", M, y));
          const $ = () => {
            if (window.removeEventListener("pointerup", $), window.removeEventListener("blur", $), r && window.removeEventListener("pointermove", M, y), Xe(this, g, !1), !this._uiManager.endDragSession()) {
              const {
                isMac: G
              } = fe.FeatureTest.platform;
              s.ctrlKey && !G || s.shiftKey || s.metaKey && G ? this.parent.toggleSelected(this) : this.parent.setSelected(this);
            }
          };
          window.addEventListener("pointerup", $), window.addEventListener("blur", $);
        }, Me(o, H), Ot(o, "_borderLineWidth", -1), Ot(o, "_colorManager", new de.ColorManager()), Ot(o, "_zIndex", 1), Ot(o, "SMALL_EDITOR_SIZE", 0);
        let V = o;
        ge.AnnotationEditor = V;
        class n extends V {
          constructor(s) {
            super(s), this.annotationElementId = s.annotationElementId, this.deleted = !0;
          }
          serialize() {
            return {
              id: this.annotationElementId,
              deleted: !0,
              pageIndex: this.pageIndex
            };
          }
        }
      },
      /* 5 */
      /***/
      (Re, ge, xe) => {
        var j, U, O, v, g, qi, P, d, A, I, E, Ba, x, R, f, c, N, u, p, S, B, T, D, K, _, o, m, s, r, y, M, $, G, ce, q, re, Z, te, L, X, J, Y, ae, se, Q, z, ie, $a, W, Vi, ue, Ki, ve, Kn, Fe, Yi, be, Ji, we, Jt, Se, Pn, Te, ja, Ee, Ua, je, Zi, $e, Mn, ze, Qi;
        Object.defineProperty(ge, "__esModule", {
          value: !0
        }), ge.KeyboardManager = ge.CommandManager = ge.ColorManager = ge.AnnotationEditorUIManager = void 0, ge.bindEvents = w, ge.opacityToHex = V;
        var de = xe(1), fe = xe(6);
        function w(Oe, he, ye) {
          for (const Ie of ye)
            he.addEventListener(Ie, Oe[Ie].bind(Oe));
        }
        function V(Oe) {
          return Math.round(Math.min(255, Math.max(1, 255 * Oe))).toString(16).padStart(2, "0");
        }
        class n {
          constructor() {
            Me(this, j, 0);
          }
          getId() {
            return `${de.AnnotationEditorPrefix}${xn(this, j)._++}`;
          }
        }
        j = new WeakMap();
        const i = class i {
          constructor() {
            Me(this, g);
            Me(this, U, (0, de.getUuid)());
            Me(this, O, 0);
            Me(this, v, null);
          }
          static get _isSVGFittingCanvas() {
            const he = 'data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>', Ie = new OffscreenCanvas(1, 3).getContext("2d"), Le = new Image();
            Le.src = he;
            const Be = Le.decode().then(() => (Ie.drawImage(Le, 0, 0, 1, 1, 0, 0, 1, 3), new Uint32Array(Ie.getImageData(0, 0, 1, 1).data.buffer)[0] === 0));
            return (0, de.shadow)(this, "_isSVGFittingCanvas", Be);
          }
          async getFromFile(he) {
            const {
              lastModified: ye,
              name: Ie,
              size: Le,
              type: Be
            } = he;
            return De(this, g, qi).call(this, `${ye}_${Ie}_${Le}_${Be}`, he);
          }
          async getFromUrl(he) {
            return De(this, g, qi).call(this, he, he);
          }
          async getFromId(he) {
            le(this, v) || Xe(this, v, /* @__PURE__ */ new Map());
            const ye = le(this, v).get(he);
            return ye ? ye.bitmap ? (ye.refCounter += 1, ye) : ye.file ? this.getFromFile(ye.file) : this.getFromUrl(ye.url) : null;
          }
          getSvgUrl(he) {
            const ye = le(this, v).get(he);
            return ye != null && ye.isSvg ? ye.svgUrl : null;
          }
          deleteId(he) {
            le(this, v) || Xe(this, v, /* @__PURE__ */ new Map());
            const ye = le(this, v).get(he);
            ye && (ye.refCounter -= 1, ye.refCounter === 0 && (ye.bitmap = null));
          }
          isValidId(he) {
            return he.startsWith(`image_${le(this, U)}_`);
          }
        };
        U = new WeakMap(), O = new WeakMap(), v = new WeakMap(), g = new WeakSet(), qi = async function(he, ye) {
          le(this, v) || Xe(this, v, /* @__PURE__ */ new Map());
          let Ie = le(this, v).get(he);
          if (Ie === null)
            return null;
          if (Ie != null && Ie.bitmap)
            return Ie.refCounter += 1, Ie;
          try {
            Ie || (Ie = {
              bitmap: null,
              id: `image_${le(this, U)}_${xn(this, O)._++}`,
              refCounter: 0,
              isSvg: !1
            });
            let Le;
            if (typeof ye == "string") {
              Ie.url = ye;
              const Be = await fetch(ye);
              if (!Be.ok)
                throw new Error(Be.statusText);
              Le = await Be.blob();
            } else
              Le = Ie.file = ye;
            if (Le.type === "image/svg+xml") {
              const Be = i._isSVGFittingCanvas, Ne = new FileReader(), Ue = new Image(), qe = new Promise((tt, ht) => {
                Ue.onload = () => {
                  Ie.bitmap = Ue, Ie.isSvg = !0, tt();
                }, Ne.onload = async () => {
                  const rt = Ie.svgUrl = Ne.result;
                  Ue.src = await Be ? `${rt}#svgView(preserveAspectRatio(none))` : rt;
                }, Ue.onerror = Ne.onerror = ht;
              });
              Ne.readAsDataURL(Le), await qe;
            } else
              Ie.bitmap = await createImageBitmap(Le);
            Ie.refCounter = 1;
          } catch (Le) {
            console.error(Le), Ie = null;
          }
          return le(this, v).set(he, Ie), Ie && le(this, v).set(Ie.id, Ie), Ie;
        };
        let F = i;
        class C {
          constructor(he = 128) {
            Me(this, P, []);
            Me(this, d, !1);
            Me(this, A, void 0);
            Me(this, I, -1);
            Xe(this, A, he);
          }
          add({
            cmd: he,
            undo: ye,
            mustExec: Ie,
            type: Le = NaN,
            overwriteIfSameType: Be = !1,
            keepUndo: Ne = !1
          }) {
            if (Ie && he(), le(this, d))
              return;
            const Ue = {
              cmd: he,
              undo: ye,
              type: Le
            };
            if (le(this, I) === -1) {
              le(this, P).length > 0 && (le(this, P).length = 0), Xe(this, I, 0), le(this, P).push(Ue);
              return;
            }
            if (Be && le(this, P)[le(this, I)].type === Le) {
              Ne && (Ue.undo = le(this, P)[le(this, I)].undo), le(this, P)[le(this, I)] = Ue;
              return;
            }
            const qe = le(this, I) + 1;
            qe === le(this, A) ? le(this, P).splice(0, 1) : (Xe(this, I, qe), qe < le(this, P).length && le(this, P).splice(qe)), le(this, P).push(Ue);
          }
          undo() {
            le(this, I) !== -1 && (Xe(this, d, !0), le(this, P)[le(this, I)].undo(), Xe(this, d, !1), Xe(this, I, le(this, I) - 1));
          }
          redo() {
            le(this, I) < le(this, P).length - 1 && (Xe(this, I, le(this, I) + 1), Xe(this, d, !0), le(this, P)[le(this, I)].cmd(), Xe(this, d, !1));
          }
          hasSomethingToUndo() {
            return le(this, I) !== -1;
          }
          hasSomethingToRedo() {
            return le(this, I) < le(this, P).length - 1;
          }
          destroy() {
            Xe(this, P, null);
          }
        }
        P = new WeakMap(), d = new WeakMap(), A = new WeakMap(), I = new WeakMap(), ge.CommandManager = C;
        class e {
          constructor(he) {
            Me(this, E);
            this.buffer = [], this.callbacks = /* @__PURE__ */ new Map(), this.allKeys = /* @__PURE__ */ new Set();
            const {
              isMac: ye
            } = de.FeatureTest.platform;
            for (const [Ie, Le, Be = {}] of he)
              for (const Ne of Ie) {
                const Ue = Ne.startsWith("mac+");
                ye && Ue ? (this.callbacks.set(Ne.slice(4), {
                  callback: Le,
                  options: Be
                }), this.allKeys.add(Ne.split("+").at(-1))) : !ye && !Ue && (this.callbacks.set(Ne, {
                  callback: Le,
                  options: Be
                }), this.allKeys.add(Ne.split("+").at(-1)));
              }
          }
          exec(he, ye) {
            if (!this.allKeys.has(ye.key))
              return;
            const Ie = this.callbacks.get(De(this, E, Ba).call(this, ye));
            if (!Ie)
              return;
            const {
              callback: Le,
              options: {
                bubbles: Be = !1,
                args: Ne = [],
                checker: Ue = null
              }
            } = Ie;
            Ue && !Ue(he, ye) || (Le.bind(he, ...Ne)(), Be || (ye.stopPropagation(), ye.preventDefault()));
          }
        }
        E = new WeakSet(), Ba = function(he) {
          he.altKey && this.buffer.push("alt"), he.ctrlKey && this.buffer.push("ctrl"), he.metaKey && this.buffer.push("meta"), he.shiftKey && this.buffer.push("shift"), this.buffer.push(he.key);
          const ye = this.buffer.join("+");
          return this.buffer.length = 0, ye;
        }, ge.KeyboardManager = e;
        const H = class H {
          get _colors() {
            const he = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
            return (0, fe.getColorValues)(he), (0, de.shadow)(this, "_colors", he);
          }
          convert(he) {
            const ye = (0, fe.getRGB)(he);
            if (!window.matchMedia("(forced-colors: active)").matches)
              return ye;
            for (const [Ie, Le] of this._colors)
              if (Le.every((Be, Ne) => Be === ye[Ne]))
                return H._colorsMapping.get(Ie);
            return ye;
          }
          getHexCode(he) {
            const ye = this._colors.get(he);
            return ye ? de.Util.makeHexColor(...ye) : he;
          }
        };
        Ot(H, "_colorsMapping", /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]));
        let t = H;
        ge.ColorManager = t;
        const Qe = class Qe {
          constructor(he, ye, Ie, Le, Be, Ne) {
            Me(this, ie);
            Me(this, W);
            Me(this, ue);
            Me(this, ve);
            Me(this, Fe);
            Me(this, be);
            Me(this, we);
            Me(this, Se);
            Me(this, Te);
            Me(this, Ee);
            Me(this, je);
            Me(this, $e);
            Me(this, ze);
            Me(this, x, null);
            Me(this, R, /* @__PURE__ */ new Map());
            Me(this, f, /* @__PURE__ */ new Map());
            Me(this, c, null);
            Me(this, N, null);
            Me(this, u, new C());
            Me(this, p, 0);
            Me(this, S, /* @__PURE__ */ new Set());
            Me(this, B, null);
            Me(this, T, null);
            Me(this, D, /* @__PURE__ */ new Set());
            Me(this, K, null);
            Me(this, _, new n());
            Me(this, o, !1);
            Me(this, m, !1);
            Me(this, s, null);
            Me(this, r, de.AnnotationEditorType.NONE);
            Me(this, y, /* @__PURE__ */ new Set());
            Me(this, M, null);
            Me(this, $, this.blur.bind(this));
            Me(this, G, this.focus.bind(this));
            Me(this, ce, this.copy.bind(this));
            Me(this, q, this.cut.bind(this));
            Me(this, re, this.paste.bind(this));
            Me(this, Z, this.keydown.bind(this));
            Me(this, te, this.onEditingAction.bind(this));
            Me(this, L, this.onPageChanging.bind(this));
            Me(this, X, this.onScaleChanging.bind(this));
            Me(this, J, this.onRotationChanging.bind(this));
            Me(this, Y, {
              isEditing: !1,
              isEmpty: !0,
              hasSomethingToUndo: !1,
              hasSomethingToRedo: !1,
              hasSelectedEditor: !1
            });
            Me(this, ae, [0, 0]);
            Me(this, se, null);
            Me(this, Q, null);
            Me(this, z, null);
            Xe(this, Q, he), Xe(this, z, ye), Xe(this, c, Ie), this._eventBus = Le, this._eventBus._on("editingaction", le(this, te)), this._eventBus._on("pagechanging", le(this, L)), this._eventBus._on("scalechanging", le(this, X)), this._eventBus._on("rotationchanging", le(this, J)), Xe(this, N, Be.annotationStorage), Xe(this, K, Be.filterFactory), Xe(this, M, Ne), this.viewParameters = {
              realScale: fe.PixelsPerInch.PDF_TO_CSS_UNITS,
              rotation: 0
            };
          }
          static get _keyboardManager() {
            const he = Qe.prototype, ye = (Be) => {
              const {
                activeElement: Ne
              } = document;
              return Ne && le(Be, Q).contains(Ne) && Be.hasSomethingToControl();
            }, Ie = this.TRANSLATE_SMALL, Le = this.TRANSLATE_BIG;
            return (0, de.shadow)(this, "_keyboardManager", new e([[["ctrl+a", "mac+meta+a"], he.selectAll], [["ctrl+z", "mac+meta+z"], he.undo], [["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], he.redo], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], he.delete], [["Escape", "mac+Escape"], he.unselectAll], [["ArrowLeft", "mac+ArrowLeft"], he.translateSelectedEditors, {
              args: [-Ie, 0],
              checker: ye
            }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], he.translateSelectedEditors, {
              args: [-Le, 0],
              checker: ye
            }], [["ArrowRight", "mac+ArrowRight"], he.translateSelectedEditors, {
              args: [Ie, 0],
              checker: ye
            }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], he.translateSelectedEditors, {
              args: [Le, 0],
              checker: ye
            }], [["ArrowUp", "mac+ArrowUp"], he.translateSelectedEditors, {
              args: [0, -Ie],
              checker: ye
            }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], he.translateSelectedEditors, {
              args: [0, -Le],
              checker: ye
            }], [["ArrowDown", "mac+ArrowDown"], he.translateSelectedEditors, {
              args: [0, Ie],
              checker: ye
            }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], he.translateSelectedEditors, {
              args: [0, Le],
              checker: ye
            }]]));
          }
          destroy() {
            De(this, ve, Kn).call(this), De(this, W, Vi).call(this), this._eventBus._off("editingaction", le(this, te)), this._eventBus._off("pagechanging", le(this, L)), this._eventBus._off("scalechanging", le(this, X)), this._eventBus._off("rotationchanging", le(this, J));
            for (const he of le(this, f).values())
              he.destroy();
            le(this, f).clear(), le(this, R).clear(), le(this, D).clear(), Xe(this, x, null), le(this, y).clear(), le(this, u).destroy(), le(this, c).destroy();
          }
          get hcmFilter() {
            return (0, de.shadow)(this, "hcmFilter", le(this, M) ? le(this, K).addHCMFilter(le(this, M).foreground, le(this, M).background) : "none");
          }
          get direction() {
            return (0, de.shadow)(this, "direction", getComputedStyle(le(this, Q)).direction);
          }
          editAltText(he) {
            var ye;
            (ye = le(this, c)) == null || ye.editAltText(this, he);
          }
          onPageChanging({
            pageNumber: he
          }) {
            Xe(this, p, he - 1);
          }
          focusMainContainer() {
            le(this, Q).focus();
          }
          findParent(he, ye) {
            for (const Ie of le(this, f).values()) {
              const {
                x: Le,
                y: Be,
                width: Ne,
                height: Ue
              } = Ie.div.getBoundingClientRect();
              if (he >= Le && he <= Le + Ne && ye >= Be && ye <= Be + Ue)
                return Ie;
            }
            return null;
          }
          disableUserSelect(he = !1) {
            le(this, z).classList.toggle("noUserSelect", he);
          }
          addShouldRescale(he) {
            le(this, D).add(he);
          }
          removeShouldRescale(he) {
            le(this, D).delete(he);
          }
          onScaleChanging({
            scale: he
          }) {
            this.commitOrRemove(), this.viewParameters.realScale = he * fe.PixelsPerInch.PDF_TO_CSS_UNITS;
            for (const ye of le(this, D))
              ye.onScaleChanging();
          }
          onRotationChanging({
            pagesRotation: he
          }) {
            this.commitOrRemove(), this.viewParameters.rotation = he;
          }
          addToAnnotationStorage(he) {
            !he.isEmpty() && le(this, N) && !le(this, N).has(he.id) && le(this, N).setValue(he.id, he);
          }
          blur() {
            if (!this.hasSelection)
              return;
            const {
              activeElement: he
            } = document;
            for (const ye of le(this, y))
              if (ye.div.contains(he)) {
                Xe(this, s, [ye, he]), ye._focusEventsAllowed = !1;
                break;
              }
          }
          focus() {
            if (!le(this, s))
              return;
            const [he, ye] = le(this, s);
            Xe(this, s, null), ye.addEventListener("focusin", () => {
              he._focusEventsAllowed = !0;
            }, {
              once: !0
            }), ye.focus();
          }
          addEditListeners() {
            De(this, ue, Ki).call(this), De(this, Fe, Yi).call(this);
          }
          removeEditListeners() {
            De(this, ve, Kn).call(this), De(this, be, Ji).call(this);
          }
          copy(he) {
            var Ie;
            if (he.preventDefault(), (Ie = le(this, x)) == null || Ie.commitOrRemove(), !this.hasSelection)
              return;
            const ye = [];
            for (const Le of le(this, y)) {
              const Be = Le.serialize(!0);
              Be && ye.push(Be);
            }
            ye.length !== 0 && he.clipboardData.setData("application/pdfjs", JSON.stringify(ye));
          }
          cut(he) {
            this.copy(he), this.delete();
          }
          paste(he) {
            he.preventDefault();
            const {
              clipboardData: ye
            } = he;
            for (const Be of ye.items)
              for (const Ne of le(this, T))
                if (Ne.isHandlingMimeForPasting(Be.type)) {
                  Ne.paste(Be, this.currentLayer);
                  return;
                }
            let Ie = ye.getData("application/pdfjs");
            if (!Ie)
              return;
            try {
              Ie = JSON.parse(Ie);
            } catch (Be) {
              (0, de.warn)(`paste: "${Be.message}".`);
              return;
            }
            if (!Array.isArray(Ie))
              return;
            this.unselectAll();
            const Le = this.currentLayer;
            try {
              const Be = [];
              for (const qe of Ie) {
                const tt = Le.deserialize(qe);
                if (!tt)
                  return;
                Be.push(tt);
              }
              const Ne = () => {
                for (const qe of Be)
                  De(this, je, Zi).call(this, qe);
                De(this, ze, Qi).call(this, Be);
              }, Ue = () => {
                for (const qe of Be)
                  qe.remove();
              };
              this.addCommands({
                cmd: Ne,
                undo: Ue,
                mustExec: !0
              });
            } catch (Be) {
              (0, de.warn)(`paste: "${Be.message}".`);
            }
          }
          keydown(he) {
            var ye;
            (ye = this.getActive()) != null && ye.shouldGetKeyboardEvents() || Qe._keyboardManager.exec(this, he);
          }
          onEditingAction(he) {
            ["undo", "redo", "delete", "selectAll"].includes(he.name) && this[he.name]();
          }
          setEditingState(he) {
            he ? (De(this, ie, $a).call(this), De(this, ue, Ki).call(this), De(this, Fe, Yi).call(this), De(this, we, Jt).call(this, {
              isEditing: le(this, r) !== de.AnnotationEditorType.NONE,
              isEmpty: De(this, $e, Mn).call(this),
              hasSomethingToUndo: le(this, u).hasSomethingToUndo(),
              hasSomethingToRedo: le(this, u).hasSomethingToRedo(),
              hasSelectedEditor: !1
            })) : (De(this, W, Vi).call(this), De(this, ve, Kn).call(this), De(this, be, Ji).call(this), De(this, we, Jt).call(this, {
              isEditing: !1
            }), this.disableUserSelect(!1));
          }
          registerEditorTypes(he) {
            if (!le(this, T)) {
              Xe(this, T, he);
              for (const ye of le(this, T))
                De(this, Se, Pn).call(this, ye.defaultPropertiesToUpdate);
            }
          }
          getId() {
            return le(this, _).getId();
          }
          get currentLayer() {
            return le(this, f).get(le(this, p));
          }
          getLayer(he) {
            return le(this, f).get(he);
          }
          get currentPageIndex() {
            return le(this, p);
          }
          addLayer(he) {
            le(this, f).set(he.pageIndex, he), le(this, o) ? he.enable() : he.disable();
          }
          removeLayer(he) {
            le(this, f).delete(he.pageIndex);
          }
          updateMode(he, ye = null) {
            if (le(this, r) !== he) {
              if (Xe(this, r, he), he === de.AnnotationEditorType.NONE) {
                this.setEditingState(!1), De(this, Ee, Ua).call(this);
                return;
              }
              this.setEditingState(!0), De(this, Te, ja).call(this), this.unselectAll();
              for (const Ie of le(this, f).values())
                Ie.updateMode(he);
              if (ye) {
                for (const Ie of le(this, R).values())
                  if (Ie.annotationElementId === ye) {
                    this.setSelected(Ie), Ie.enterInEditMode();
                    break;
                  }
              }
            }
          }
          updateToolbar(he) {
            he !== le(this, r) && this._eventBus.dispatch("switchannotationeditormode", {
              source: this,
              mode: he
            });
          }
          updateParams(he, ye) {
            if (le(this, T)) {
              if (he === de.AnnotationEditorParamsType.CREATE) {
                this.currentLayer.addNewEditor(he);
                return;
              }
              for (const Ie of le(this, y))
                Ie.updateParams(he, ye);
              for (const Ie of le(this, T))
                Ie.updateDefaultParams(he, ye);
            }
          }
          enableWaiting(he = !1) {
            if (le(this, m) !== he) {
              Xe(this, m, he);
              for (const ye of le(this, f).values())
                he ? ye.disableClick() : ye.enableClick(), ye.div.classList.toggle("waiting", he);
            }
          }
          getEditors(he) {
            const ye = [];
            for (const Ie of le(this, R).values())
              Ie.pageIndex === he && ye.push(Ie);
            return ye;
          }
          getEditor(he) {
            return le(this, R).get(he);
          }
          addEditor(he) {
            le(this, R).set(he.id, he);
          }
          removeEditor(he) {
            var ye;
            le(this, R).delete(he.id), this.unselect(he), (!he.annotationElementId || !le(this, S).has(he.annotationElementId)) && ((ye = le(this, N)) == null || ye.remove(he.id));
          }
          addDeletedAnnotationElement(he) {
            le(this, S).add(he.annotationElementId), he.deleted = !0;
          }
          isDeletedAnnotationElement(he) {
            return le(this, S).has(he);
          }
          removeDeletedAnnotationElement(he) {
            le(this, S).delete(he.annotationElementId), he.deleted = !1;
          }
          setActiveEditor(he) {
            le(this, x) !== he && (Xe(this, x, he), he && De(this, Se, Pn).call(this, he.propertiesToUpdate));
          }
          toggleSelected(he) {
            if (le(this, y).has(he)) {
              le(this, y).delete(he), he.unselect(), De(this, we, Jt).call(this, {
                hasSelectedEditor: this.hasSelection
              });
              return;
            }
            le(this, y).add(he), he.select(), De(this, Se, Pn).call(this, he.propertiesToUpdate), De(this, we, Jt).call(this, {
              hasSelectedEditor: !0
            });
          }
          setSelected(he) {
            for (const ye of le(this, y))
              ye !== he && ye.unselect();
            le(this, y).clear(), le(this, y).add(he), he.select(), De(this, Se, Pn).call(this, he.propertiesToUpdate), De(this, we, Jt).call(this, {
              hasSelectedEditor: !0
            });
          }
          isSelected(he) {
            return le(this, y).has(he);
          }
          unselect(he) {
            he.unselect(), le(this, y).delete(he), De(this, we, Jt).call(this, {
              hasSelectedEditor: this.hasSelection
            });
          }
          get hasSelection() {
            return le(this, y).size !== 0;
          }
          undo() {
            le(this, u).undo(), De(this, we, Jt).call(this, {
              hasSomethingToUndo: le(this, u).hasSomethingToUndo(),
              hasSomethingToRedo: !0,
              isEmpty: De(this, $e, Mn).call(this)
            });
          }
          redo() {
            le(this, u).redo(), De(this, we, Jt).call(this, {
              hasSomethingToUndo: !0,
              hasSomethingToRedo: le(this, u).hasSomethingToRedo(),
              isEmpty: De(this, $e, Mn).call(this)
            });
          }
          addCommands(he) {
            le(this, u).add(he), De(this, we, Jt).call(this, {
              hasSomethingToUndo: !0,
              hasSomethingToRedo: !1,
              isEmpty: De(this, $e, Mn).call(this)
            });
          }
          delete() {
            if (this.commitOrRemove(), !this.hasSelection)
              return;
            const he = [...le(this, y)], ye = () => {
              for (const Le of he)
                Le.remove();
            }, Ie = () => {
              for (const Le of he)
                De(this, je, Zi).call(this, Le);
            };
            this.addCommands({
              cmd: ye,
              undo: Ie,
              mustExec: !0
            });
          }
          commitOrRemove() {
            var he;
            (he = le(this, x)) == null || he.commitOrRemove();
          }
          hasSomethingToControl() {
            return le(this, x) || this.hasSelection;
          }
          selectAll() {
            for (const he of le(this, y))
              he.commit();
            De(this, ze, Qi).call(this, le(this, R).values());
          }
          unselectAll() {
            if (le(this, x)) {
              le(this, x).commitOrRemove();
              return;
            }
            if (this.hasSelection) {
              for (const he of le(this, y))
                he.unselect();
              le(this, y).clear(), De(this, we, Jt).call(this, {
                hasSelectedEditor: !1
              });
            }
          }
          translateSelectedEditors(he, ye, Ie = !1) {
            if (Ie || this.commitOrRemove(), !this.hasSelection)
              return;
            le(this, ae)[0] += he, le(this, ae)[1] += ye;
            const [Le, Be] = le(this, ae), Ne = [...le(this, y)], Ue = 1e3;
            le(this, se) && clearTimeout(le(this, se)), Xe(this, se, setTimeout(() => {
              Xe(this, se, null), le(this, ae)[0] = le(this, ae)[1] = 0, this.addCommands({
                cmd: () => {
                  for (const qe of Ne)
                    le(this, R).has(qe.id) && qe.translateInPage(Le, Be);
                },
                undo: () => {
                  for (const qe of Ne)
                    le(this, R).has(qe.id) && qe.translateInPage(-Le, -Be);
                },
                mustExec: !1
              });
            }, Ue));
            for (const qe of Ne)
              qe.translateInPage(he, ye);
          }
          setUpDragSession() {
            if (this.hasSelection) {
              this.disableUserSelect(!0), Xe(this, B, /* @__PURE__ */ new Map());
              for (const he of le(this, y))
                le(this, B).set(he, {
                  savedX: he.x,
                  savedY: he.y,
                  savedPageIndex: he.pageIndex,
                  newX: 0,
                  newY: 0,
                  newPageIndex: -1
                });
            }
          }
          endDragSession() {
            if (!le(this, B))
              return !1;
            this.disableUserSelect(!1);
            const he = le(this, B);
            Xe(this, B, null);
            let ye = !1;
            for (const [{
              x: Le,
              y: Be,
              pageIndex: Ne
            }, Ue] of he)
              Ue.newX = Le, Ue.newY = Be, Ue.newPageIndex = Ne, ye || (ye = Le !== Ue.savedX || Be !== Ue.savedY || Ne !== Ue.savedPageIndex);
            if (!ye)
              return !1;
            const Ie = (Le, Be, Ne, Ue) => {
              if (le(this, R).has(Le.id)) {
                const qe = le(this, f).get(Ue);
                qe ? Le._setParentAndPosition(qe, Be, Ne) : (Le.pageIndex = Ue, Le.x = Be, Le.y = Ne);
              }
            };
            return this.addCommands({
              cmd: () => {
                for (const [Le, {
                  newX: Be,
                  newY: Ne,
                  newPageIndex: Ue
                }] of he)
                  Ie(Le, Be, Ne, Ue);
              },
              undo: () => {
                for (const [Le, {
                  savedX: Be,
                  savedY: Ne,
                  savedPageIndex: Ue
                }] of he)
                  Ie(Le, Be, Ne, Ue);
              },
              mustExec: !0
            }), !0;
          }
          dragSelectedEditors(he, ye) {
            if (le(this, B))
              for (const Ie of le(this, B).keys())
                Ie.drag(he, ye);
          }
          rebuild(he) {
            if (he.parent === null) {
              const ye = this.getLayer(he.pageIndex);
              ye ? (ye.changeParent(he), ye.addOrRebuild(he)) : (this.addEditor(he), this.addToAnnotationStorage(he), he.rebuild());
            } else
              he.parent.addOrRebuild(he);
          }
          isActive(he) {
            return le(this, x) === he;
          }
          getActive() {
            return le(this, x);
          }
          getMode() {
            return le(this, r);
          }
          get imageManager() {
            return (0, de.shadow)(this, "imageManager", new F());
          }
        };
        x = new WeakMap(), R = new WeakMap(), f = new WeakMap(), c = new WeakMap(), N = new WeakMap(), u = new WeakMap(), p = new WeakMap(), S = new WeakMap(), B = new WeakMap(), T = new WeakMap(), D = new WeakMap(), K = new WeakMap(), _ = new WeakMap(), o = new WeakMap(), m = new WeakMap(), s = new WeakMap(), r = new WeakMap(), y = new WeakMap(), M = new WeakMap(), $ = new WeakMap(), G = new WeakMap(), ce = new WeakMap(), q = new WeakMap(), re = new WeakMap(), Z = new WeakMap(), te = new WeakMap(), L = new WeakMap(), X = new WeakMap(), J = new WeakMap(), Y = new WeakMap(), ae = new WeakMap(), se = new WeakMap(), Q = new WeakMap(), z = new WeakMap(), ie = new WeakSet(), $a = function() {
          window.addEventListener("focus", le(this, G)), window.addEventListener("blur", le(this, $));
        }, W = new WeakSet(), Vi = function() {
          window.removeEventListener("focus", le(this, G)), window.removeEventListener("blur", le(this, $));
        }, ue = new WeakSet(), Ki = function() {
          window.addEventListener("keydown", le(this, Z), {
            capture: !0
          });
        }, ve = new WeakSet(), Kn = function() {
          window.removeEventListener("keydown", le(this, Z), {
            capture: !0
          });
        }, Fe = new WeakSet(), Yi = function() {
          document.addEventListener("copy", le(this, ce)), document.addEventListener("cut", le(this, q)), document.addEventListener("paste", le(this, re));
        }, be = new WeakSet(), Ji = function() {
          document.removeEventListener("copy", le(this, ce)), document.removeEventListener("cut", le(this, q)), document.removeEventListener("paste", le(this, re));
        }, we = new WeakSet(), Jt = function(he) {
          Object.entries(he).some(([Ie, Le]) => le(this, Y)[Ie] !== Le) && this._eventBus.dispatch("annotationeditorstateschanged", {
            source: this,
            details: Object.assign(le(this, Y), he)
          });
        }, Se = new WeakSet(), Pn = function(he) {
          this._eventBus.dispatch("annotationeditorparamschanged", {
            source: this,
            details: he
          });
        }, Te = new WeakSet(), ja = function() {
          if (!le(this, o)) {
            Xe(this, o, !0);
            for (const he of le(this, f).values())
              he.enable();
          }
        }, Ee = new WeakSet(), Ua = function() {
          if (this.unselectAll(), le(this, o)) {
            Xe(this, o, !1);
            for (const he of le(this, f).values())
              he.disable();
          }
        }, je = new WeakSet(), Zi = function(he) {
          const ye = le(this, f).get(he.pageIndex);
          ye ? ye.addOrRebuild(he) : this.addEditor(he);
        }, $e = new WeakSet(), Mn = function() {
          if (le(this, R).size === 0)
            return !0;
          if (le(this, R).size === 1)
            for (const he of le(this, R).values())
              return he.isEmpty();
          return !1;
        }, ze = new WeakSet(), Qi = function(he) {
          le(this, y).clear();
          for (const ye of he)
            ye.isEmpty() || (le(this, y).add(ye), ye.select());
          De(this, we, Jt).call(this, {
            hasSelectedEditor: !0
          });
        }, Ot(Qe, "TRANSLATE_SMALL", 1), Ot(Qe, "TRANSLATE_BIG", 10);
        let l = Qe;
        ge.AnnotationEditorUIManager = l;
      },
      /* 6 */
      /***/
      (Re, ge, xe) => {
        var p, S, B, T, D, K, _, o, m, s, r, y, Sn, $, vn, ce, ea, re, Yn, te, Jn, X, _n, Y, Rn;
        Object.defineProperty(ge, "__esModule", {
          value: !0
        }), ge.StatTimer = ge.RenderingCancelledException = ge.PixelsPerInch = ge.PageViewport = ge.PDFDateString = ge.DOMStandardFontDataFactory = ge.DOMSVGFactory = ge.DOMFilterFactory = ge.DOMCanvasFactory = ge.DOMCMapReaderFactory = void 0, ge.deprecated = I, ge.getColorValues = R, ge.getCurrentTransform = f, ge.getCurrentTransformInverse = c, ge.getFilenameFromUrl = g, ge.getPdfFilenameFromUrl = b, ge.getRGB = x, ge.getXfaPageViewport = H, ge.isDataScheme = O, ge.isPdfFile = v, ge.isValidFetchUrl = P, ge.loadScript = A, ge.noContextMenu = d, ge.setLayerDimensions = N;
        var de = xe(7), fe = xe(1);
        const w = "http://www.w3.org/2000/svg", u = class u {
        };
        Ot(u, "CSS", 96), Ot(u, "PDF", 72), Ot(u, "PDF_TO_CSS_UNITS", u.CSS / u.PDF);
        let V = u;
        ge.PixelsPerInch = V;
        class n extends de.BaseFilterFactory {
          constructor({
            docId: z,
            ownerDocument: ie = globalThis.document
          } = {}) {
            super();
            Me(this, y);
            Me(this, $);
            Me(this, ce);
            Me(this, re);
            Me(this, te);
            Me(this, X);
            Me(this, Y);
            Me(this, p, void 0);
            Me(this, S, void 0);
            Me(this, B, void 0);
            Me(this, T, void 0);
            Me(this, D, void 0);
            Me(this, K, void 0);
            Me(this, _, void 0);
            Me(this, o, void 0);
            Me(this, m, void 0);
            Me(this, s, void 0);
            Me(this, r, 0);
            Xe(this, B, z), Xe(this, T, ie);
          }
          addFilter(z) {
            if (!z)
              return "none";
            let ie = le(this, y, Sn).get(z);
            if (ie)
              return ie;
            let ne, W, oe, ue;
            if (z.length === 1) {
              const Fe = z[0], Pe = new Array(256);
              for (let be = 0; be < 256; be++)
                Pe[be] = Fe[be] / 255;
              ue = ne = W = oe = Pe.join(",");
            } else {
              const [Fe, Pe, be] = z, me = new Array(256), we = new Array(256), _e = new Array(256);
              for (let Se = 0; Se < 256; Se++)
                me[Se] = Fe[Se] / 255, we[Se] = Pe[Se] / 255, _e[Se] = be[Se] / 255;
              ne = me.join(","), W = we.join(","), oe = _e.join(","), ue = `${ne}${W}${oe}`;
            }
            if (ie = le(this, y, Sn).get(ue), ie)
              return le(this, y, Sn).set(z, ie), ie;
            const pe = `g_${le(this, B)}_transfer_map_${xn(this, r)._++}`, ve = `url(#${pe})`;
            le(this, y, Sn).set(z, ve), le(this, y, Sn).set(ue, ve);
            const Ce = De(this, re, Yn).call(this, pe);
            return De(this, X, _n).call(this, ne, W, oe, Ce), ve;
          }
          addHCMFilter(z, ie) {
            var Pe;
            const ne = `${z}-${ie}`;
            if (le(this, K) === ne)
              return le(this, _);
            if (Xe(this, K, ne), Xe(this, _, "none"), (Pe = le(this, D)) == null || Pe.remove(), !z || !ie)
              return le(this, _);
            const W = De(this, Y, Rn).call(this, z);
            z = fe.Util.makeHexColor(...W);
            const oe = De(this, Y, Rn).call(this, ie);
            if (ie = fe.Util.makeHexColor(...oe), le(this, $, vn).style.color = "", z === "#000000" && ie === "#ffffff" || z === ie)
              return le(this, _);
            const ue = new Array(256);
            for (let be = 0; be <= 255; be++) {
              const me = be / 255;
              ue[be] = me <= 0.03928 ? me / 12.92 : ((me + 0.055) / 1.055) ** 2.4;
            }
            const pe = ue.join(","), ve = `g_${le(this, B)}_hcm_filter`, Ce = Xe(this, o, De(this, re, Yn).call(this, ve));
            De(this, X, _n).call(this, pe, pe, pe, Ce), De(this, ce, ea).call(this, Ce);
            const Fe = (be, me) => {
              const we = W[be] / 255, _e = oe[be] / 255, Se = new Array(me + 1);
              for (let Ae = 0; Ae <= me; Ae++)
                Se[Ae] = we + Ae / me * (_e - we);
              return Se.join(",");
            };
            return De(this, X, _n).call(this, Fe(0, 5), Fe(1, 5), Fe(2, 5), Ce), Xe(this, _, `url(#${ve})`), le(this, _);
          }
          addHighlightHCMFilter(z, ie, ne, W) {
            var _e;
            const oe = `${z}-${ie}-${ne}-${W}`;
            if (le(this, m) === oe)
              return le(this, s);
            if (Xe(this, m, oe), Xe(this, s, "none"), (_e = le(this, o)) == null || _e.remove(), !z || !ie)
              return le(this, s);
            const [ue, pe] = [z, ie].map(De(this, Y, Rn).bind(this));
            let ve = Math.round(0.2126 * ue[0] + 0.7152 * ue[1] + 0.0722 * ue[2]), Ce = Math.round(0.2126 * pe[0] + 0.7152 * pe[1] + 0.0722 * pe[2]), [Fe, Pe] = [ne, W].map(De(this, Y, Rn).bind(this));
            Ce < ve && ([ve, Ce, Fe, Pe] = [Ce, ve, Pe, Fe]), le(this, $, vn).style.color = "";
            const be = (Se, Ae, Te) => {
              const ke = new Array(256), Ee = (Ce - ve) / Te, Ve = Se / 255, je = (Ae - Se) / (255 * Te);
              let at = 0;
              for (let $e = 0; $e <= Te; $e++) {
                const ct = Math.round(ve + $e * Ee), ze = Ve + $e * je;
                for (let Ye = at; Ye <= ct; Ye++)
                  ke[Ye] = ze;
                at = ct + 1;
              }
              for (let $e = at; $e < 256; $e++)
                ke[$e] = ke[at - 1];
              return ke.join(",");
            }, me = `g_${le(this, B)}_hcm_highlight_filter`, we = Xe(this, o, De(this, re, Yn).call(this, me));
            return De(this, ce, ea).call(this, we), De(this, X, _n).call(this, be(Fe[0], Pe[0], 5), be(Fe[1], Pe[1], 5), be(Fe[2], Pe[2], 5), we), Xe(this, s, `url(#${me})`), le(this, s);
          }
          destroy(z = !1) {
            z && (le(this, _) || le(this, s)) || (le(this, S) && (le(this, S).parentNode.parentNode.remove(), Xe(this, S, null)), le(this, p) && (le(this, p).clear(), Xe(this, p, null)), Xe(this, r, 0));
          }
        }
        p = new WeakMap(), S = new WeakMap(), B = new WeakMap(), T = new WeakMap(), D = new WeakMap(), K = new WeakMap(), _ = new WeakMap(), o = new WeakMap(), m = new WeakMap(), s = new WeakMap(), r = new WeakMap(), y = new WeakSet(), Sn = function() {
          return le(this, p) || Xe(this, p, /* @__PURE__ */ new Map());
        }, $ = new WeakSet(), vn = function() {
          if (!le(this, S)) {
            const z = le(this, T).createElement("div"), {
              style: ie
            } = z;
            ie.visibility = "hidden", ie.contain = "strict", ie.width = ie.height = 0, ie.position = "absolute", ie.top = ie.left = 0, ie.zIndex = -1;
            const ne = le(this, T).createElementNS(w, "svg");
            ne.setAttribute("width", 0), ne.setAttribute("height", 0), Xe(this, S, le(this, T).createElementNS(w, "defs")), z.append(ne), ne.append(le(this, S)), le(this, T).body.append(z);
          }
          return le(this, S);
        }, ce = new WeakSet(), ea = function(z) {
          const ie = le(this, T).createElementNS(w, "feColorMatrix");
          ie.setAttribute("type", "matrix"), ie.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0"), z.append(ie);
        }, re = new WeakSet(), Yn = function(z) {
          const ie = le(this, T).createElementNS(w, "filter");
          return ie.setAttribute("color-interpolation-filters", "sRGB"), ie.setAttribute("id", z), le(this, $, vn).append(ie), ie;
        }, te = new WeakSet(), Jn = function(z, ie, ne) {
          const W = le(this, T).createElementNS(w, ie);
          W.setAttribute("type", "discrete"), W.setAttribute("tableValues", ne), z.append(W);
        }, X = new WeakSet(), _n = function(z, ie, ne, W) {
          const oe = le(this, T).createElementNS(w, "feComponentTransfer");
          W.append(oe), De(this, te, Jn).call(this, oe, "feFuncR", z), De(this, te, Jn).call(this, oe, "feFuncG", ie), De(this, te, Jn).call(this, oe, "feFuncB", ne);
        }, Y = new WeakSet(), Rn = function(z) {
          return le(this, $, vn).style.color = z, x(getComputedStyle(le(this, $, vn)).getPropertyValue("color"));
        }, ge.DOMFilterFactory = n;
        class F extends de.BaseCanvasFactory {
          constructor({
            ownerDocument: Q = globalThis.document
          } = {}) {
            super(), this._document = Q;
          }
          _createCanvas(Q, z) {
            const ie = this._document.createElement("canvas");
            return ie.width = Q, ie.height = z, ie;
          }
        }
        ge.DOMCanvasFactory = F;
        async function C(se, Q = !1) {
          if (P(se, document.baseURI)) {
            const z = await fetch(se);
            if (!z.ok)
              throw new Error(z.statusText);
            return Q ? new Uint8Array(await z.arrayBuffer()) : (0, fe.stringToBytes)(await z.text());
          }
          return new Promise((z, ie) => {
            const ne = new XMLHttpRequest();
            ne.open("GET", se, !0), Q && (ne.responseType = "arraybuffer"), ne.onreadystatechange = () => {
              if (ne.readyState === XMLHttpRequest.DONE) {
                if (ne.status === 200 || ne.status === 0) {
                  let W;
                  if (Q && ne.response ? W = new Uint8Array(ne.response) : !Q && ne.responseText && (W = (0, fe.stringToBytes)(ne.responseText)), W) {
                    z(W);
                    return;
                  }
                }
                ie(new Error(ne.statusText));
              }
            }, ne.send(null);
          });
        }
        class e extends de.BaseCMapReaderFactory {
          _fetchData(Q, z) {
            return C(Q, this.isCompressed).then((ie) => ({
              cMapData: ie,
              compressionType: z
            }));
          }
        }
        ge.DOMCMapReaderFactory = e;
        class t extends de.BaseStandardFontDataFactory {
          _fetchData(Q) {
            return C(Q, !0);
          }
        }
        ge.DOMStandardFontDataFactory = t;
        class l extends de.BaseSVGFactory {
          _createSVG(Q) {
            return document.createElementNS(w, Q);
          }
        }
        ge.DOMSVGFactory = l;
        class j {
          constructor({
            viewBox: Q,
            scale: z,
            rotation: ie,
            offsetX: ne = 0,
            offsetY: W = 0,
            dontFlip: oe = !1
          }) {
            this.viewBox = Q, this.scale = z, this.rotation = ie, this.offsetX = ne, this.offsetY = W;
            const ue = (Q[2] + Q[0]) / 2, pe = (Q[3] + Q[1]) / 2;
            let ve, Ce, Fe, Pe;
            switch (ie %= 360, ie < 0 && (ie += 360), ie) {
              case 180:
                ve = -1, Ce = 0, Fe = 0, Pe = 1;
                break;
              case 90:
                ve = 0, Ce = 1, Fe = 1, Pe = 0;
                break;
              case 270:
                ve = 0, Ce = -1, Fe = -1, Pe = 0;
                break;
              case 0:
                ve = 1, Ce = 0, Fe = 0, Pe = -1;
                break;
              default:
                throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
            }
            oe && (Fe = -Fe, Pe = -Pe);
            let be, me, we, _e;
            ve === 0 ? (be = Math.abs(pe - Q[1]) * z + ne, me = Math.abs(ue - Q[0]) * z + W, we = (Q[3] - Q[1]) * z, _e = (Q[2] - Q[0]) * z) : (be = Math.abs(ue - Q[0]) * z + ne, me = Math.abs(pe - Q[1]) * z + W, we = (Q[2] - Q[0]) * z, _e = (Q[3] - Q[1]) * z), this.transform = [ve * z, Ce * z, Fe * z, Pe * z, be - ve * z * ue - Fe * z * pe, me - Ce * z * ue - Pe * z * pe], this.width = we, this.height = _e;
          }
          get rawDims() {
            const {
              viewBox: Q
            } = this;
            return (0, fe.shadow)(this, "rawDims", {
              pageWidth: Q[2] - Q[0],
              pageHeight: Q[3] - Q[1],
              pageX: Q[0],
              pageY: Q[1]
            });
          }
          clone({
            scale: Q = this.scale,
            rotation: z = this.rotation,
            offsetX: ie = this.offsetX,
            offsetY: ne = this.offsetY,
            dontFlip: W = !1
          } = {}) {
            return new j({
              viewBox: this.viewBox.slice(),
              scale: Q,
              rotation: z,
              offsetX: ie,
              offsetY: ne,
              dontFlip: W
            });
          }
          convertToViewportPoint(Q, z) {
            return fe.Util.applyTransform([Q, z], this.transform);
          }
          convertToViewportRectangle(Q) {
            const z = fe.Util.applyTransform([Q[0], Q[1]], this.transform), ie = fe.Util.applyTransform([Q[2], Q[3]], this.transform);
            return [z[0], z[1], ie[0], ie[1]];
          }
          convertToPdfPoint(Q, z) {
            return fe.Util.applyInverseTransform([Q, z], this.transform);
          }
        }
        ge.PageViewport = j;
        class U extends fe.BaseException {
          constructor(Q, z = 0) {
            super(Q, "RenderingCancelledException"), this.extraDelay = z;
          }
        }
        ge.RenderingCancelledException = U;
        function O(se) {
          const Q = se.length;
          let z = 0;
          for (; z < Q && se[z].trim() === ""; )
            z++;
          return se.substring(z, z + 5).toLowerCase() === "data:";
        }
        function v(se) {
          return typeof se == "string" && /\.pdf$/i.test(se);
        }
        function g(se, Q = !1) {
          return Q || ([se] = se.split(/[#?]/, 1)), se.substring(se.lastIndexOf("/") + 1);
        }
        function b(se, Q = "document.pdf") {
          if (typeof se != "string")
            return Q;
          if (O(se))
            return (0, fe.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.'), Q;
          const z = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/, ie = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i, ne = z.exec(se);
          let W = ie.exec(ne[1]) || ie.exec(ne[2]) || ie.exec(ne[3]);
          if (W && (W = W[0], W.includes("%")))
            try {
              W = ie.exec(decodeURIComponent(W))[0];
            } catch {
            }
          return W || Q;
        }
        class i {
          constructor() {
            Ot(this, "started", /* @__PURE__ */ Object.create(null));
            Ot(this, "times", []);
          }
          time(Q) {
            Q in this.started && (0, fe.warn)(`Timer is already running for ${Q}`), this.started[Q] = Date.now();
          }
          timeEnd(Q) {
            Q in this.started || (0, fe.warn)(`Timer has not been started for ${Q}`), this.times.push({
              name: Q,
              start: this.started[Q],
              end: Date.now()
            }), delete this.started[Q];
          }
          toString() {
            const Q = [];
            let z = 0;
            for (const {
              name: ie
            } of this.times)
              z = Math.max(ie.length, z);
            for (const {
              name: ie,
              start: ne,
              end: W
            } of this.times)
              Q.push(`${ie.padEnd(z)} ${W - ne}ms
`);
            return Q.join("");
          }
        }
        ge.StatTimer = i;
        function P(se, Q) {
          try {
            const {
              protocol: z
            } = Q ? new URL(se, Q) : new URL(se);
            return z === "http:" || z === "https:";
          } catch {
            return !1;
          }
        }
        function d(se) {
          se.preventDefault();
        }
        function A(se, Q = !1) {
          return new Promise((z, ie) => {
            const ne = document.createElement("script");
            ne.src = se, ne.onload = function(W) {
              Q && ne.remove(), z(W);
            }, ne.onerror = function() {
              ie(new Error(`Cannot load script at: ${ne.src}`));
            }, (document.head || document.documentElement).append(ne);
          });
        }
        function I(se) {
          console.log("Deprecated API usage: " + se);
        }
        let E;
        class k {
          static toDateObject(Q) {
            if (!Q || typeof Q != "string")
              return null;
            E || (E = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"));
            const z = E.exec(Q);
            if (!z)
              return null;
            const ie = parseInt(z[1], 10);
            let ne = parseInt(z[2], 10);
            ne = ne >= 1 && ne <= 12 ? ne - 1 : 0;
            let W = parseInt(z[3], 10);
            W = W >= 1 && W <= 31 ? W : 1;
            let oe = parseInt(z[4], 10);
            oe = oe >= 0 && oe <= 23 ? oe : 0;
            let ue = parseInt(z[5], 10);
            ue = ue >= 0 && ue <= 59 ? ue : 0;
            let pe = parseInt(z[6], 10);
            pe = pe >= 0 && pe <= 59 ? pe : 0;
            const ve = z[7] || "Z";
            let Ce = parseInt(z[8], 10);
            Ce = Ce >= 0 && Ce <= 23 ? Ce : 0;
            let Fe = parseInt(z[9], 10) || 0;
            return Fe = Fe >= 0 && Fe <= 59 ? Fe : 0, ve === "-" ? (oe += Ce, ue += Fe) : ve === "+" && (oe -= Ce, ue -= Fe), new Date(Date.UTC(ie, ne, W, oe, ue, pe));
          }
        }
        ge.PDFDateString = k;
        function H(se, {
          scale: Q = 1,
          rotation: z = 0
        }) {
          const {
            width: ie,
            height: ne
          } = se.attributes.style, W = [0, 0, parseInt(ie), parseInt(ne)];
          return new j({
            viewBox: W,
            scale: Q,
            rotation: z
          });
        }
        function x(se) {
          if (se.startsWith("#")) {
            const Q = parseInt(se.slice(1), 16);
            return [(Q & 16711680) >> 16, (Q & 65280) >> 8, Q & 255];
          }
          return se.startsWith("rgb(") ? se.slice(4, -1).split(",").map((Q) => parseInt(Q)) : se.startsWith("rgba(") ? se.slice(5, -1).split(",").map((Q) => parseInt(Q)).slice(0, 3) : ((0, fe.warn)(`Not a valid color format: "${se}"`), [0, 0, 0]);
        }
        function R(se) {
          const Q = document.createElement("span");
          Q.style.visibility = "hidden", document.body.append(Q);
          for (const z of se.keys()) {
            Q.style.color = z;
            const ie = window.getComputedStyle(Q).color;
            se.set(z, x(ie));
          }
          Q.remove();
        }
        function f(se) {
          const {
            a: Q,
            b: z,
            c: ie,
            d: ne,
            e: W,
            f: oe
          } = se.getTransform();
          return [Q, z, ie, ne, W, oe];
        }
        function c(se) {
          const {
            a: Q,
            b: z,
            c: ie,
            d: ne,
            e: W,
            f: oe
          } = se.getTransform().invertSelf();
          return [Q, z, ie, ne, W, oe];
        }
        function N(se, Q, z = !1, ie = !0) {
          if (Q instanceof j) {
            const {
              pageWidth: ne,
              pageHeight: W
            } = Q.rawDims, {
              style: oe
            } = se, ue = fe.FeatureTest.isCSSRoundSupported, pe = `var(--scale-factor) * ${ne}px`, ve = `var(--scale-factor) * ${W}px`, Ce = ue ? `round(${pe}, 1px)` : `calc(${pe})`, Fe = ue ? `round(${ve}, 1px)` : `calc(${ve})`;
            !z || Q.rotation % 180 === 0 ? (oe.width = Ce, oe.height = Fe) : (oe.width = Fe, oe.height = Ce);
          }
          ie && se.setAttribute("data-main-rotation", Q.rotation);
        }
      },
      /* 7 */
      /***/
      (Re, ge, xe) => {
        Object.defineProperty(ge, "__esModule", {
          value: !0
        }), ge.BaseStandardFontDataFactory = ge.BaseSVGFactory = ge.BaseFilterFactory = ge.BaseCanvasFactory = ge.BaseCMapReaderFactory = void 0;
        var de = xe(1);
        class fe {
          constructor() {
            this.constructor === fe && (0, de.unreachable)("Cannot initialize BaseFilterFactory.");
          }
          addFilter(e) {
            return "none";
          }
          addHCMFilter(e, t) {
            return "none";
          }
          addHighlightHCMFilter(e, t, l, j) {
            return "none";
          }
          destroy(e = !1) {
          }
        }
        ge.BaseFilterFactory = fe;
        class w {
          constructor() {
            this.constructor === w && (0, de.unreachable)("Cannot initialize BaseCanvasFactory.");
          }
          create(e, t) {
            if (e <= 0 || t <= 0)
              throw new Error("Invalid canvas size");
            const l = this._createCanvas(e, t);
            return {
              canvas: l,
              context: l.getContext("2d")
            };
          }
          reset(e, t, l) {
            if (!e.canvas)
              throw new Error("Canvas is not specified");
            if (t <= 0 || l <= 0)
              throw new Error("Invalid canvas size");
            e.canvas.width = t, e.canvas.height = l;
          }
          destroy(e) {
            if (!e.canvas)
              throw new Error("Canvas is not specified");
            e.canvas.width = 0, e.canvas.height = 0, e.canvas = null, e.context = null;
          }
          _createCanvas(e, t) {
            (0, de.unreachable)("Abstract method `_createCanvas` called.");
          }
        }
        ge.BaseCanvasFactory = w;
        class V {
          constructor({
            baseUrl: e = null,
            isCompressed: t = !0
          }) {
            this.constructor === V && (0, de.unreachable)("Cannot initialize BaseCMapReaderFactory."), this.baseUrl = e, this.isCompressed = t;
          }
          async fetch({
            name: e
          }) {
            if (!this.baseUrl)
              throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
            if (!e)
              throw new Error("CMap name must be specified.");
            const t = this.baseUrl + e + (this.isCompressed ? ".bcmap" : ""), l = this.isCompressed ? de.CMapCompressionType.BINARY : de.CMapCompressionType.NONE;
            return this._fetchData(t, l).catch((j) => {
              throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${t}`);
            });
          }
          _fetchData(e, t) {
            (0, de.unreachable)("Abstract method `_fetchData` called.");
          }
        }
        ge.BaseCMapReaderFactory = V;
        class n {
          constructor({
            baseUrl: e = null
          }) {
            this.constructor === n && (0, de.unreachable)("Cannot initialize BaseStandardFontDataFactory."), this.baseUrl = e;
          }
          async fetch({
            filename: e
          }) {
            if (!this.baseUrl)
              throw new Error('The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.');
            if (!e)
              throw new Error("Font filename must be specified.");
            const t = `${this.baseUrl}${e}`;
            return this._fetchData(t).catch((l) => {
              throw new Error(`Unable to load font data at: ${t}`);
            });
          }
          _fetchData(e) {
            (0, de.unreachable)("Abstract method `_fetchData` called.");
          }
        }
        ge.BaseStandardFontDataFactory = n;
        class F {
          constructor() {
            this.constructor === F && (0, de.unreachable)("Cannot initialize BaseSVGFactory.");
          }
          create(e, t, l = !1) {
            if (e <= 0 || t <= 0)
              throw new Error("Invalid SVG dimensions");
            const j = this._createSVG("svg:svg");
            return j.setAttribute("version", "1.1"), l || (j.setAttribute("width", `${e}px`), j.setAttribute("height", `${t}px`)), j.setAttribute("preserveAspectRatio", "none"), j.setAttribute("viewBox", `0 0 ${e} ${t}`), j;
          }
          createElement(e) {
            if (typeof e != "string")
              throw new Error("Invalid SVG element type");
            return this._createSVG(e);
          }
          _createSVG(e) {
            (0, de.unreachable)("Abstract method `_createSVG` called.");
          }
        }
        ge.BaseSVGFactory = F;
      },
      /* 8 */
      /***/
      (Re, ge, xe) => {
        Object.defineProperty(ge, "__esModule", {
          value: !0
        }), ge.MurmurHash3_64 = void 0;
        var de = xe(1);
        const fe = 3285377520, w = 4294901760, V = 65535;
        class n {
          constructor(C) {
            this.h1 = C ? C & 4294967295 : fe, this.h2 = C ? C & 4294967295 : fe;
          }
          update(C) {
            let e, t;
            if (typeof C == "string") {
              e = new Uint8Array(C.length * 2), t = 0;
              for (let I = 0, E = C.length; I < E; I++) {
                const k = C.charCodeAt(I);
                k <= 255 ? e[t++] = k : (e[t++] = k >>> 8, e[t++] = k & 255);
              }
            } else if ((0, de.isArrayBuffer)(C))
              e = C.slice(), t = e.byteLength;
            else
              throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");
            const l = t >> 2, j = t - l * 4, U = new Uint32Array(e.buffer, 0, l);
            let O = 0, v = 0, g = this.h1, b = this.h2;
            const i = 3432918353, P = 461845907, d = i & V, A = P & V;
            for (let I = 0; I < l; I++)
              I & 1 ? (O = U[I], O = O * i & w | O * d & V, O = O << 15 | O >>> 17, O = O * P & w | O * A & V, g ^= O, g = g << 13 | g >>> 19, g = g * 5 + 3864292196) : (v = U[I], v = v * i & w | v * d & V, v = v << 15 | v >>> 17, v = v * P & w | v * A & V, b ^= v, b = b << 13 | b >>> 19, b = b * 5 + 3864292196);
            switch (O = 0, j) {
              case 3:
                O ^= e[l * 4 + 2] << 16;
              case 2:
                O ^= e[l * 4 + 1] << 8;
              case 1:
                O ^= e[l * 4], O = O * i & w | O * d & V, O = O << 15 | O >>> 17, O = O * P & w | O * A & V, l & 1 ? g ^= O : b ^= O;
            }
            this.h1 = g, this.h2 = b;
          }
          hexdigest() {
            let C = this.h1, e = this.h2;
            return C ^= e >>> 1, C = C * 3981806797 & w | C * 36045 & V, e = e * 4283543511 & w | ((e << 16 | C >>> 16) * 2950163797 & w) >>> 16, C ^= e >>> 1, C = C * 444984403 & w | C * 60499 & V, e = e * 3301882366 & w | ((e << 16 | C >>> 16) * 3120437893 & w) >>> 16, C ^= e >>> 1, (C >>> 0).toString(16).padStart(8, "0") + (e >>> 0).toString(16).padStart(8, "0");
          }
        }
        ge.MurmurHash3_64 = n;
      },
      /* 9 */
      /***/
      (Re, ge, xe) => {
        var V;
        Object.defineProperty(ge, "__esModule", {
          value: !0
        }), ge.FontLoader = ge.FontFaceObject = void 0;
        var de = xe(1);
        class fe {
          constructor({
            ownerDocument: F = globalThis.document,
            styleElement: C = null
          }) {
            Me(this, V, /* @__PURE__ */ new Set());
            this._document = F, this.nativeFontFaces = /* @__PURE__ */ new Set(), this.styleElement = null, this.loadingRequests = [], this.loadTestFontId = 0;
          }
          addNativeFontFace(F) {
            this.nativeFontFaces.add(F), this._document.fonts.add(F);
          }
          removeNativeFontFace(F) {
            this.nativeFontFaces.delete(F), this._document.fonts.delete(F);
          }
          insertRule(F) {
            this.styleElement || (this.styleElement = this._document.createElement("style"), this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement));
            const C = this.styleElement.sheet;
            C.insertRule(F, C.cssRules.length);
          }
          clear() {
            for (const F of this.nativeFontFaces)
              this._document.fonts.delete(F);
            this.nativeFontFaces.clear(), le(this, V).clear(), this.styleElement && (this.styleElement.remove(), this.styleElement = null);
          }
          async loadSystemFont(F) {
            if (!(!F || le(this, V).has(F.loadedName))) {
              if ((0, de.assert)(!this.disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set."), this.isFontLoadingAPISupported) {
                const {
                  loadedName: C,
                  src: e,
                  style: t
                } = F, l = new FontFace(C, e, t);
                this.addNativeFontFace(l);
                try {
                  await l.load(), le(this, V).add(C);
                } catch {
                  (0, de.warn)(`Cannot load system font: ${F.baseFontName}, installing it could help to improve PDF rendering.`), this.removeNativeFontFace(l);
                }
                return;
              }
              (0, de.unreachable)("Not implemented: loadSystemFont without the Font Loading API.");
            }
          }
          async bind(F) {
            if (F.attached || F.missingFile && !F.systemFontInfo)
              return;
            if (F.attached = !0, F.systemFontInfo) {
              await this.loadSystemFont(F.systemFontInfo);
              return;
            }
            if (this.isFontLoadingAPISupported) {
              const e = F.createNativeFontFace();
              if (e) {
                this.addNativeFontFace(e);
                try {
                  await e.loaded;
                } catch (t) {
                  throw (0, de.warn)(`Failed to load font '${e.family}': '${t}'.`), F.disableFontFace = !0, t;
                }
              }
              return;
            }
            const C = F.createFontFaceRule();
            if (C) {
              if (this.insertRule(C), this.isSyncFontLoadingSupported)
                return;
              await new Promise((e) => {
                const t = this._queueLoadingCallback(e);
                this._prepareFontLoadEvent(F, t);
              });
            }
          }
          get isFontLoadingAPISupported() {
            var C;
            const F = !!((C = this._document) != null && C.fonts);
            return (0, de.shadow)(this, "isFontLoadingAPISupported", F);
          }
          get isSyncFontLoadingSupported() {
            let F = !1;
            return (de.isNodeJS || typeof navigator < "u" && /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent)) && (F = !0), (0, de.shadow)(this, "isSyncFontLoadingSupported", F);
          }
          _queueLoadingCallback(F) {
            function C() {
              for ((0, de.assert)(!t.done, "completeRequest() cannot be called twice."), t.done = !0; e.length > 0 && e[0].done; ) {
                const l = e.shift();
                setTimeout(l.callback, 0);
              }
            }
            const {
              loadingRequests: e
            } = this, t = {
              done: !1,
              complete: C,
              callback: F
            };
            return e.push(t), t;
          }
          get _loadTestFont() {
            const F = atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
            return (0, de.shadow)(this, "_loadTestFont", F);
          }
          _prepareFontLoadEvent(F, C) {
            function e(x, R) {
              return x.charCodeAt(R) << 24 | x.charCodeAt(R + 1) << 16 | x.charCodeAt(R + 2) << 8 | x.charCodeAt(R + 3) & 255;
            }
            function t(x, R, f, c) {
              const N = x.substring(0, R), u = x.substring(R + f);
              return N + c + u;
            }
            let l, j;
            const U = this._document.createElement("canvas");
            U.width = 1, U.height = 1;
            const O = U.getContext("2d");
            let v = 0;
            function g(x, R) {
              if (++v > 30) {
                (0, de.warn)("Load test font never loaded."), R();
                return;
              }
              if (O.font = "30px " + x, O.fillText(".", 0, 20), O.getImageData(0, 0, 1, 1).data[3] > 0) {
                R();
                return;
              }
              setTimeout(g.bind(null, x, R));
            }
            const b = `lt${Date.now()}${this.loadTestFontId++}`;
            let i = this._loadTestFont;
            i = t(i, 976, b.length, b);
            const d = 16, A = 1482184792;
            let I = e(i, d);
            for (l = 0, j = b.length - 3; l < j; l += 4)
              I = I - A + e(b, l) | 0;
            l < b.length && (I = I - A + e(b + "XXX", l) | 0), i = t(i, d, 4, (0, de.string32)(I));
            const E = `url(data:font/opentype;base64,${btoa(i)});`, k = `@font-face {font-family:"${b}";src:${E}}`;
            this.insertRule(k);
            const H = this._document.createElement("div");
            H.style.visibility = "hidden", H.style.width = H.style.height = "10px", H.style.position = "absolute", H.style.top = H.style.left = "0px";
            for (const x of [F.loadedName, b]) {
              const R = this._document.createElement("span");
              R.textContent = "Hi", R.style.fontFamily = x, H.append(R);
            }
            this._document.body.append(H), g(b, () => {
              H.remove(), C.complete();
            });
          }
        }
        V = new WeakMap(), ge.FontLoader = fe;
        class w {
          constructor(F, {
            isEvalSupported: C = !0,
            disableFontFace: e = !1,
            ignoreErrors: t = !1,
            inspectFont: l = null
          }) {
            this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
            for (const j in F)
              this[j] = F[j];
            this.isEvalSupported = C !== !1, this.disableFontFace = e === !0, this.ignoreErrors = t === !0, this._inspectFont = l;
          }
          createNativeFontFace() {
            var C;
            if (!this.data || this.disableFontFace)
              return null;
            let F;
            if (!this.cssFontInfo)
              F = new FontFace(this.loadedName, this.data, {});
            else {
              const e = {
                weight: this.cssFontInfo.fontWeight
              };
              this.cssFontInfo.italicAngle && (e.style = `oblique ${this.cssFontInfo.italicAngle}deg`), F = new FontFace(this.cssFontInfo.fontFamily, this.data, e);
            }
            return (C = this._inspectFont) == null || C.call(this, this), F;
          }
          createFontFaceRule() {
            var t;
            if (!this.data || this.disableFontFace)
              return null;
            const F = (0, de.bytesToString)(this.data), C = `url(data:${this.mimetype};base64,${btoa(F)});`;
            let e;
            if (!this.cssFontInfo)
              e = `@font-face {font-family:"${this.loadedName}";src:${C}}`;
            else {
              let l = `font-weight: ${this.cssFontInfo.fontWeight};`;
              this.cssFontInfo.italicAngle && (l += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`), e = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${l}src:${C}}`;
            }
            return (t = this._inspectFont) == null || t.call(this, this, C), e;
          }
          getPathGenerator(F, C) {
            if (this.compiledGlyphs[C] !== void 0)
              return this.compiledGlyphs[C];
            let e;
            try {
              e = F.get(this.loadedName + "_path_" + C);
            } catch (t) {
              if (!this.ignoreErrors)
                throw t;
              return (0, de.warn)(`getPathGenerator - ignoring character: "${t}".`), this.compiledGlyphs[C] = function(l, j) {
              };
            }
            if (this.isEvalSupported && de.FeatureTest.isEvalSupported) {
              const t = [];
              for (const l of e) {
                const j = l.args !== void 0 ? l.args.join(",") : "";
                t.push("c.", l.cmd, "(", j, `);
`);
              }
              return this.compiledGlyphs[C] = new Function("c", "size", t.join(""));
            }
            return this.compiledGlyphs[C] = function(t, l) {
              for (const j of e)
                j.cmd === "scale" && (j.args = [l, -l]), t[j.cmd].apply(t, j.args);
            };
          }
        }
        ge.FontFaceObject = w;
      },
      /* 10 */
      /***/
      (Re, ge, xe) => {
        Object.defineProperty(ge, "__esModule", {
          value: !0
        }), ge.NodeStandardFontDataFactory = ge.NodeFilterFactory = ge.NodeCanvasFactory = ge.NodeCMapReaderFactory = void 0;
        var de = xe(7);
        xe(1);
        const fe = function(C) {
          return new Promise((e, t) => {
            require("fs").readFile(C, (j, U) => {
              if (j || !U) {
                t(new Error(j));
                return;
              }
              e(new Uint8Array(U));
            });
          });
        };
        class w extends de.BaseFilterFactory {
        }
        ge.NodeFilterFactory = w;
        class V extends de.BaseCanvasFactory {
          _createCanvas(e, t) {
            return require("canvas").createCanvas(e, t);
          }
        }
        ge.NodeCanvasFactory = V;
        class n extends de.BaseCMapReaderFactory {
          _fetchData(e, t) {
            return fe(e).then((l) => ({
              cMapData: l,
              compressionType: t
            }));
          }
        }
        ge.NodeCMapReaderFactory = n;
        class F extends de.BaseStandardFontDataFactory {
          _fetchData(e) {
            return fe(e);
          }
        }
        ge.NodeStandardFontDataFactory = F;
      },
      /* 11 */
      /***/
      (Re, ge, xe) => {
        var S, ta, T, na;
        Object.defineProperty(ge, "__esModule", {
          value: !0
        }), ge.CanvasGraphics = void 0;
        var de = xe(1), fe = xe(6), w = xe(12), V = xe(13);
        const n = 16, F = 100, C = 4096, e = 15, t = 10, l = 1e3, j = 16;
        function U(_, o) {
          if (_._removeMirroring)
            throw new Error("Context is already forwarding operations.");
          _.__originalSave = _.save, _.__originalRestore = _.restore, _.__originalRotate = _.rotate, _.__originalScale = _.scale, _.__originalTranslate = _.translate, _.__originalTransform = _.transform, _.__originalSetTransform = _.setTransform, _.__originalResetTransform = _.resetTransform, _.__originalClip = _.clip, _.__originalMoveTo = _.moveTo, _.__originalLineTo = _.lineTo, _.__originalBezierCurveTo = _.bezierCurveTo, _.__originalRect = _.rect, _.__originalClosePath = _.closePath, _.__originalBeginPath = _.beginPath, _._removeMirroring = () => {
            _.save = _.__originalSave, _.restore = _.__originalRestore, _.rotate = _.__originalRotate, _.scale = _.__originalScale, _.translate = _.__originalTranslate, _.transform = _.__originalTransform, _.setTransform = _.__originalSetTransform, _.resetTransform = _.__originalResetTransform, _.clip = _.__originalClip, _.moveTo = _.__originalMoveTo, _.lineTo = _.__originalLineTo, _.bezierCurveTo = _.__originalBezierCurveTo, _.rect = _.__originalRect, _.closePath = _.__originalClosePath, _.beginPath = _.__originalBeginPath, delete _._removeMirroring;
          }, _.save = function() {
            o.save(), this.__originalSave();
          }, _.restore = function() {
            o.restore(), this.__originalRestore();
          }, _.translate = function(s, r) {
            o.translate(s, r), this.__originalTranslate(s, r);
          }, _.scale = function(s, r) {
            o.scale(s, r), this.__originalScale(s, r);
          }, _.transform = function(s, r, y, M, $, G) {
            o.transform(s, r, y, M, $, G), this.__originalTransform(s, r, y, M, $, G);
          }, _.setTransform = function(s, r, y, M, $, G) {
            o.setTransform(s, r, y, M, $, G), this.__originalSetTransform(s, r, y, M, $, G);
          }, _.resetTransform = function() {
            o.resetTransform(), this.__originalResetTransform();
          }, _.rotate = function(s) {
            o.rotate(s), this.__originalRotate(s);
          }, _.clip = function(s) {
            o.clip(s), this.__originalClip(s);
          }, _.moveTo = function(m, s) {
            o.moveTo(m, s), this.__originalMoveTo(m, s);
          }, _.lineTo = function(m, s) {
            o.lineTo(m, s), this.__originalLineTo(m, s);
          }, _.bezierCurveTo = function(m, s, r, y, M, $) {
            o.bezierCurveTo(m, s, r, y, M, $), this.__originalBezierCurveTo(m, s, r, y, M, $);
          }, _.rect = function(m, s, r, y) {
            o.rect(m, s, r, y), this.__originalRect(m, s, r, y);
          }, _.closePath = function() {
            o.closePath(), this.__originalClosePath();
          }, _.beginPath = function() {
            o.beginPath(), this.__originalBeginPath();
          };
        }
        class O {
          constructor(o) {
            this.canvasFactory = o, this.cache = /* @__PURE__ */ Object.create(null);
          }
          getCanvas(o, m, s) {
            let r;
            return this.cache[o] !== void 0 ? (r = this.cache[o], this.canvasFactory.reset(r, m, s)) : (r = this.canvasFactory.create(m, s), this.cache[o] = r), r;
          }
          delete(o) {
            delete this.cache[o];
          }
          clear() {
            for (const o in this.cache) {
              const m = this.cache[o];
              this.canvasFactory.destroy(m), delete this.cache[o];
            }
          }
        }
        function v(_, o, m, s, r, y, M, $, G, ce) {
          const [q, re, Z, te, L, X] = (0, fe.getCurrentTransform)(_);
          if (re === 0 && Z === 0) {
            const ae = M * q + L, se = Math.round(ae), Q = $ * te + X, z = Math.round(Q), ie = (M + G) * q + L, ne = Math.abs(Math.round(ie) - se) || 1, W = ($ + ce) * te + X, oe = Math.abs(Math.round(W) - z) || 1;
            return _.setTransform(Math.sign(q), 0, 0, Math.sign(te), se, z), _.drawImage(o, m, s, r, y, 0, 0, ne, oe), _.setTransform(q, re, Z, te, L, X), [ne, oe];
          }
          if (q === 0 && te === 0) {
            const ae = $ * Z + L, se = Math.round(ae), Q = M * re + X, z = Math.round(Q), ie = ($ + ce) * Z + L, ne = Math.abs(Math.round(ie) - se) || 1, W = (M + G) * re + X, oe = Math.abs(Math.round(W) - z) || 1;
            return _.setTransform(0, Math.sign(re), Math.sign(Z), 0, se, z), _.drawImage(o, m, s, r, y, 0, 0, oe, ne), _.setTransform(q, re, Z, te, L, X), [oe, ne];
          }
          _.drawImage(o, m, s, r, y, M, $, G, ce);
          const J = Math.hypot(q, re), Y = Math.hypot(Z, te);
          return [J * G, Y * ce];
        }
        function g(_) {
          const {
            width: o,
            height: m
          } = _;
          if (o > l || m > l)
            return null;
          const s = 1e3, r = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]), y = o + 1;
          let M = new Uint8Array(y * (m + 1)), $, G, ce;
          const q = o + 7 & -8;
          let re = new Uint8Array(q * m), Z = 0;
          for (const Y of _.data) {
            let ae = 128;
            for (; ae > 0; )
              re[Z++] = Y & ae ? 0 : 255, ae >>= 1;
          }
          let te = 0;
          for (Z = 0, re[Z] !== 0 && (M[0] = 1, ++te), G = 1; G < o; G++)
            re[Z] !== re[Z + 1] && (M[G] = re[Z] ? 2 : 1, ++te), Z++;
          for (re[Z] !== 0 && (M[G] = 2, ++te), $ = 1; $ < m; $++) {
            Z = $ * q, ce = $ * y, re[Z - q] !== re[Z] && (M[ce] = re[Z] ? 1 : 8, ++te);
            let Y = (re[Z] ? 4 : 0) + (re[Z - q] ? 8 : 0);
            for (G = 1; G < o; G++)
              Y = (Y >> 2) + (re[Z + 1] ? 4 : 0) + (re[Z - q + 1] ? 8 : 0), r[Y] && (M[ce + G] = r[Y], ++te), Z++;
            if (re[Z - q] !== re[Z] && (M[ce + G] = re[Z] ? 2 : 4, ++te), te > s)
              return null;
          }
          for (Z = q * (m - 1), ce = $ * y, re[Z] !== 0 && (M[ce] = 8, ++te), G = 1; G < o; G++)
            re[Z] !== re[Z + 1] && (M[ce + G] = re[Z] ? 4 : 8, ++te), Z++;
          if (re[Z] !== 0 && (M[ce + G] = 4, ++te), te > s)
            return null;
          const L = new Int32Array([0, y, -1, 0, -y, 0, 0, 0, 1]), X = new Path2D();
          for ($ = 0; te && $ <= m; $++) {
            let Y = $ * y;
            const ae = Y + o;
            for (; Y < ae && !M[Y]; )
              Y++;
            if (Y === ae)
              continue;
            X.moveTo(Y % y, $);
            const se = Y;
            let Q = M[Y];
            do {
              const z = L[Q];
              do
                Y += z;
              while (!M[Y]);
              const ie = M[Y];
              ie !== 5 && ie !== 10 ? (Q = ie, M[Y] = 0) : (Q = ie & 51 * Q >> 4, M[Y] &= Q >> 2 | Q << 2), X.lineTo(Y % y, Y / y | 0), M[Y] || --te;
            } while (se !== Y);
            --$;
          }
          return re = null, M = null, function(Y) {
            Y.save(), Y.scale(1 / o, -1 / m), Y.translate(0, -m), Y.fill(X), Y.beginPath(), Y.restore();
          };
        }
        class b {
          constructor(o, m) {
            this.alphaIsShape = !1, this.fontSize = 0, this.fontSizeScale = 1, this.textMatrix = de.IDENTITY_MATRIX, this.textMatrixScale = 1, this.fontMatrix = de.FONT_IDENTITY_MATRIX, this.leading = 0, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRenderingMode = de.TextRenderingMode.FILL, this.textRise = 0, this.fillColor = "#000000", this.strokeColor = "#000000", this.patternFill = !1, this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.activeSMask = null, this.transferMaps = "none", this.startNewPathAndClipBox([0, 0, o, m]);
          }
          clone() {
            const o = Object.create(this);
            return o.clipBox = this.clipBox.slice(), o;
          }
          setCurrentPoint(o, m) {
            this.x = o, this.y = m;
          }
          updatePathMinMax(o, m, s) {
            [m, s] = de.Util.applyTransform([m, s], o), this.minX = Math.min(this.minX, m), this.minY = Math.min(this.minY, s), this.maxX = Math.max(this.maxX, m), this.maxY = Math.max(this.maxY, s);
          }
          updateRectMinMax(o, m) {
            const s = de.Util.applyTransform(m, o), r = de.Util.applyTransform(m.slice(2), o);
            this.minX = Math.min(this.minX, s[0], r[0]), this.minY = Math.min(this.minY, s[1], r[1]), this.maxX = Math.max(this.maxX, s[0], r[0]), this.maxY = Math.max(this.maxY, s[1], r[1]);
          }
          updateScalingPathMinMax(o, m) {
            de.Util.scaleMinMax(o, m), this.minX = Math.min(this.minX, m[0]), this.maxX = Math.max(this.maxX, m[1]), this.minY = Math.min(this.minY, m[2]), this.maxY = Math.max(this.maxY, m[3]);
          }
          updateCurvePathMinMax(o, m, s, r, y, M, $, G, ce, q) {
            const re = de.Util.bezierBoundingBox(m, s, r, y, M, $, G, ce);
            if (q) {
              q[0] = Math.min(q[0], re[0], re[2]), q[1] = Math.max(q[1], re[0], re[2]), q[2] = Math.min(q[2], re[1], re[3]), q[3] = Math.max(q[3], re[1], re[3]);
              return;
            }
            this.updateRectMinMax(o, re);
          }
          getPathBoundingBox(o = w.PathType.FILL, m = null) {
            const s = [this.minX, this.minY, this.maxX, this.maxY];
            if (o === w.PathType.STROKE) {
              m || (0, de.unreachable)("Stroke bounding box must include transform.");
              const r = de.Util.singularValueDecompose2dScale(m), y = r[0] * this.lineWidth / 2, M = r[1] * this.lineWidth / 2;
              s[0] -= y, s[1] -= M, s[2] += y, s[3] += M;
            }
            return s;
          }
          updateClipFromPath() {
            const o = de.Util.intersect(this.clipBox, this.getPathBoundingBox());
            this.startNewPathAndClipBox(o || [0, 0, 0, 0]);
          }
          isEmptyClip() {
            return this.minX === 1 / 0;
          }
          startNewPathAndClipBox(o) {
            this.clipBox = o, this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = 0, this.maxY = 0;
          }
          getClippedPathBoundingBox(o = w.PathType.FILL, m = null) {
            return de.Util.intersect(this.clipBox, this.getPathBoundingBox(o, m));
          }
        }
        function i(_, o) {
          if (typeof ImageData < "u" && o instanceof ImageData) {
            _.putImageData(o, 0, 0);
            return;
          }
          const m = o.height, s = o.width, r = m % j, y = (m - r) / j, M = r === 0 ? y : y + 1, $ = _.createImageData(s, j);
          let G = 0, ce;
          const q = o.data, re = $.data;
          let Z, te, L, X;
          if (o.kind === de.ImageKind.GRAYSCALE_1BPP) {
            const J = q.byteLength, Y = new Uint32Array(re.buffer, 0, re.byteLength >> 2), ae = Y.length, se = s + 7 >> 3, Q = 4294967295, z = de.FeatureTest.isLittleEndian ? 4278190080 : 255;
            for (Z = 0; Z < M; Z++) {
              for (L = Z < y ? j : r, ce = 0, te = 0; te < L; te++) {
                const ie = J - G;
                let ne = 0;
                const W = ie > se ? s : ie * 8 - 7, oe = W & -8;
                let ue = 0, pe = 0;
                for (; ne < oe; ne += 8)
                  pe = q[G++], Y[ce++] = pe & 128 ? Q : z, Y[ce++] = pe & 64 ? Q : z, Y[ce++] = pe & 32 ? Q : z, Y[ce++] = pe & 16 ? Q : z, Y[ce++] = pe & 8 ? Q : z, Y[ce++] = pe & 4 ? Q : z, Y[ce++] = pe & 2 ? Q : z, Y[ce++] = pe & 1 ? Q : z;
                for (; ne < W; ne++)
                  ue === 0 && (pe = q[G++], ue = 128), Y[ce++] = pe & ue ? Q : z, ue >>= 1;
              }
              for (; ce < ae; )
                Y[ce++] = 0;
              _.putImageData($, 0, Z * j);
            }
          } else if (o.kind === de.ImageKind.RGBA_32BPP) {
            for (te = 0, X = s * j * 4, Z = 0; Z < y; Z++)
              re.set(q.subarray(G, G + X)), G += X, _.putImageData($, 0, te), te += j;
            Z < M && (X = s * r * 4, re.set(q.subarray(G, G + X)), _.putImageData($, 0, te));
          } else if (o.kind === de.ImageKind.RGB_24BPP)
            for (L = j, X = s * L, Z = 0; Z < M; Z++) {
              for (Z >= y && (L = r, X = s * L), ce = 0, te = X; te--; )
                re[ce++] = q[G++], re[ce++] = q[G++], re[ce++] = q[G++], re[ce++] = 255;
              _.putImageData($, 0, Z * j);
            }
          else
            throw new Error(`bad image kind: ${o.kind}`);
        }
        function P(_, o) {
          if (o.bitmap) {
            _.drawImage(o.bitmap, 0, 0);
            return;
          }
          const m = o.height, s = o.width, r = m % j, y = (m - r) / j, M = r === 0 ? y : y + 1, $ = _.createImageData(s, j);
          let G = 0;
          const ce = o.data, q = $.data;
          for (let re = 0; re < M; re++) {
            const Z = re < y ? j : r;
            ({
              srcPos: G
            } = (0, V.convertBlackAndWhiteToRGBA)({
              src: ce,
              srcPos: G,
              dest: q,
              width: s,
              height: Z,
              nonBlackColor: 0
            })), _.putImageData($, 0, re * j);
          }
        }
        function d(_, o) {
          const m = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
          for (const s of m)
            _[s] !== void 0 && (o[s] = _[s]);
          _.setLineDash !== void 0 && (o.setLineDash(_.getLineDash()), o.lineDashOffset = _.lineDashOffset);
        }
        function A(_) {
          if (_.strokeStyle = _.fillStyle = "#000000", _.fillRule = "nonzero", _.globalAlpha = 1, _.lineWidth = 1, _.lineCap = "butt", _.lineJoin = "miter", _.miterLimit = 10, _.globalCompositeOperation = "source-over", _.font = "10px sans-serif", _.setLineDash !== void 0 && (_.setLineDash([]), _.lineDashOffset = 0), !de.isNodeJS) {
            const {
              filter: o
            } = _;
            o !== "none" && o !== "" && (_.filter = "none");
          }
        }
        function I(_, o, m, s) {
          const r = _.length;
          for (let y = 3; y < r; y += 4) {
            const M = _[y];
            if (M === 0)
              _[y - 3] = o, _[y - 2] = m, _[y - 1] = s;
            else if (M < 255) {
              const $ = 255 - M;
              _[y - 3] = _[y - 3] * M + o * $ >> 8, _[y - 2] = _[y - 2] * M + m * $ >> 8, _[y - 1] = _[y - 1] * M + s * $ >> 8;
            }
          }
        }
        function E(_, o, m) {
          const s = _.length, r = 1 / 255;
          for (let y = 3; y < s; y += 4) {
            const M = m ? m[_[y]] : _[y];
            o[y] = o[y] * M * r | 0;
          }
        }
        function k(_, o, m) {
          const s = _.length;
          for (let r = 3; r < s; r += 4) {
            const y = _[r - 3] * 77 + _[r - 2] * 152 + _[r - 1] * 28;
            o[r] = m ? o[r] * m[y >> 8] >> 8 : o[r] * y >> 16;
          }
        }
        function H(_, o, m, s, r, y, M, $, G, ce, q) {
          const re = !!y, Z = re ? y[0] : 0, te = re ? y[1] : 0, L = re ? y[2] : 0, X = r === "Luminosity" ? k : E, Y = Math.min(s, Math.ceil(1048576 / m));
          for (let ae = 0; ae < s; ae += Y) {
            const se = Math.min(Y, s - ae), Q = _.getImageData($ - ce, ae + (G - q), m, se), z = o.getImageData($, ae + G, m, se);
            re && I(Q.data, Z, te, L), X(Q.data, z.data, M), o.putImageData(z, $, ae + G);
          }
        }
        function x(_, o, m, s) {
          const r = s[0], y = s[1], M = s[2] - r, $ = s[3] - y;
          M === 0 || $ === 0 || (H(o.context, m, M, $, o.subtype, o.backdrop, o.transferMap, r, y, o.offsetX, o.offsetY), _.save(), _.globalAlpha = 1, _.globalCompositeOperation = "source-over", _.setTransform(1, 0, 0, 1, 0, 0), _.drawImage(m.canvas, 0, 0), _.restore());
        }
        function R(_, o) {
          const m = de.Util.singularValueDecompose2dScale(_);
          m[0] = Math.fround(m[0]), m[1] = Math.fround(m[1]);
          const s = Math.fround((globalThis.devicePixelRatio || 1) * fe.PixelsPerInch.PDF_TO_CSS_UNITS);
          return o !== void 0 ? o : m[0] <= s || m[1] <= s;
        }
        const f = ["butt", "round", "square"], c = ["miter", "round", "bevel"], N = {}, u = {}, K = class K {
          constructor(o, m, s, r, y, {
            optionalContentConfig: M,
            markedContentStack: $ = null
          }, G, ce) {
            Me(this, S);
            Me(this, T);
            this.ctx = o, this.current = new b(this.ctx.canvas.width, this.ctx.canvas.height), this.stateStack = [], this.pendingClip = null, this.pendingEOFill = !1, this.res = null, this.xobjs = null, this.commonObjs = m, this.objs = s, this.canvasFactory = r, this.filterFactory = y, this.groupStack = [], this.processingType3 = null, this.baseTransform = null, this.baseTransformStack = [], this.groupLevel = 0, this.smaskStack = [], this.smaskCounter = 0, this.tempSMask = null, this.suspendedCtx = null, this.contentVisible = !0, this.markedContentStack = $ || [], this.optionalContentConfig = M, this.cachedCanvases = new O(this.canvasFactory), this.cachedPatterns = /* @__PURE__ */ new Map(), this.annotationCanvasMap = G, this.viewportScale = 1, this.outputScaleX = 1, this.outputScaleY = 1, this.pageColors = ce, this._cachedScaleForStroking = [-1, 0], this._cachedGetSinglePixelWidth = null, this._cachedBitmapsMap = /* @__PURE__ */ new Map();
          }
          getObject(o, m = null) {
            return typeof o == "string" ? o.startsWith("g_") ? this.commonObjs.get(o) : this.objs.get(o) : m;
          }
          beginDrawing({
            transform: o,
            viewport: m,
            transparency: s = !1,
            background: r = null
          }) {
            const y = this.ctx.canvas.width, M = this.ctx.canvas.height, $ = this.ctx.fillStyle;
            if (this.ctx.fillStyle = r || "#ffffff", this.ctx.fillRect(0, 0, y, M), this.ctx.fillStyle = $, s) {
              const G = this.cachedCanvases.getCanvas("transparent", y, M);
              this.compositeCtx = this.ctx, this.transparentCanvas = G.canvas, this.ctx = G.context, this.ctx.save(), this.ctx.transform(...(0, fe.getCurrentTransform)(this.compositeCtx));
            }
            this.ctx.save(), A(this.ctx), o && (this.ctx.transform(...o), this.outputScaleX = o[0], this.outputScaleY = o[0]), this.ctx.transform(...m.transform), this.viewportScale = m.scale, this.baseTransform = (0, fe.getCurrentTransform)(this.ctx);
          }
          executeOperatorList(o, m, s, r) {
            const y = o.argsArray, M = o.fnArray;
            let $ = m || 0;
            const G = y.length;
            if (G === $)
              return $;
            const ce = G - $ > t && typeof s == "function", q = ce ? Date.now() + e : 0;
            let re = 0;
            const Z = this.commonObjs, te = this.objs;
            let L;
            for (; ; ) {
              if (r !== void 0 && $ === r.nextBreakPoint)
                return r.breakIt($, s), $;
              if (L = M[$], L !== de.OPS.dependency)
                this[L].apply(this, y[$]);
              else
                for (const X of y[$]) {
                  const J = X.startsWith("g_") ? Z : te;
                  if (!J.has(X))
                    return J.get(X, s), $;
                }
              if ($++, $ === G)
                return $;
              if (ce && ++re > t) {
                if (Date.now() > q)
                  return s(), $;
                re = 0;
              }
            }
          }
          endDrawing() {
            De(this, S, ta).call(this), this.cachedCanvases.clear(), this.cachedPatterns.clear();
            for (const o of this._cachedBitmapsMap.values()) {
              for (const m of o.values())
                typeof HTMLCanvasElement < "u" && m instanceof HTMLCanvasElement && (m.width = m.height = 0);
              o.clear();
            }
            this._cachedBitmapsMap.clear(), De(this, T, na).call(this);
          }
          _scaleImage(o, m) {
            const s = o.width, r = o.height;
            let y = Math.max(Math.hypot(m[0], m[1]), 1), M = Math.max(Math.hypot(m[2], m[3]), 1), $ = s, G = r, ce = "prescale1", q, re;
            for (; y > 2 && $ > 1 || M > 2 && G > 1; ) {
              let Z = $, te = G;
              y > 2 && $ > 1 && (Z = $ >= 16384 ? Math.floor($ / 2) - 1 || 1 : Math.ceil($ / 2), y /= $ / Z), M > 2 && G > 1 && (te = G >= 16384 ? Math.floor(G / 2) - 1 || 1 : Math.ceil(G) / 2, M /= G / te), q = this.cachedCanvases.getCanvas(ce, Z, te), re = q.context, re.clearRect(0, 0, Z, te), re.drawImage(o, 0, 0, $, G, 0, 0, Z, te), o = q.canvas, $ = Z, G = te, ce = ce === "prescale1" ? "prescale2" : "prescale1";
            }
            return {
              img: o,
              paintWidth: $,
              paintHeight: G
            };
          }
          _createMaskCanvas(o) {
            const m = this.ctx, {
              width: s,
              height: r
            } = o, y = this.current.fillColor, M = this.current.patternFill, $ = (0, fe.getCurrentTransform)(m);
            let G, ce, q, re;
            if ((o.bitmap || o.data) && o.count > 1) {
              const ne = o.bitmap || o.data.buffer;
              ce = JSON.stringify(M ? $ : [$.slice(0, 4), y]), G = this._cachedBitmapsMap.get(ne), G || (G = /* @__PURE__ */ new Map(), this._cachedBitmapsMap.set(ne, G));
              const W = G.get(ce);
              if (W && !M) {
                const oe = Math.round(Math.min($[0], $[2]) + $[4]), ue = Math.round(Math.min($[1], $[3]) + $[5]);
                return {
                  canvas: W,
                  offsetX: oe,
                  offsetY: ue
                };
              }
              q = W;
            }
            q || (re = this.cachedCanvases.getCanvas("maskCanvas", s, r), P(re.context, o));
            let Z = de.Util.transform($, [1 / s, 0, 0, -1 / r, 0, 0]);
            Z = de.Util.transform(Z, [1, 0, 0, 1, 0, -r]);
            const te = de.Util.applyTransform([0, 0], Z), L = de.Util.applyTransform([s, r], Z), X = de.Util.normalizeRect([te[0], te[1], L[0], L[1]]), J = Math.round(X[2] - X[0]) || 1, Y = Math.round(X[3] - X[1]) || 1, ae = this.cachedCanvases.getCanvas("fillCanvas", J, Y), se = ae.context, Q = Math.min(te[0], L[0]), z = Math.min(te[1], L[1]);
            se.translate(-Q, -z), se.transform(...Z), q || (q = this._scaleImage(re.canvas, (0, fe.getCurrentTransformInverse)(se)), q = q.img, G && M && G.set(ce, q)), se.imageSmoothingEnabled = R((0, fe.getCurrentTransform)(se), o.interpolate), v(se, q, 0, 0, q.width, q.height, 0, 0, s, r), se.globalCompositeOperation = "source-in";
            const ie = de.Util.transform((0, fe.getCurrentTransformInverse)(se), [1, 0, 0, 1, -Q, -z]);
            return se.fillStyle = M ? y.getPattern(m, this, ie, w.PathType.FILL) : y, se.fillRect(0, 0, s, r), G && !M && (this.cachedCanvases.delete("fillCanvas"), G.set(ce, ae.canvas)), {
              canvas: ae.canvas,
              offsetX: Math.round(Q),
              offsetY: Math.round(z)
            };
          }
          setLineWidth(o) {
            o !== this.current.lineWidth && (this._cachedScaleForStroking[0] = -1), this.current.lineWidth = o, this.ctx.lineWidth = o;
          }
          setLineCap(o) {
            this.ctx.lineCap = f[o];
          }
          setLineJoin(o) {
            this.ctx.lineJoin = c[o];
          }
          setMiterLimit(o) {
            this.ctx.miterLimit = o;
          }
          setDash(o, m) {
            const s = this.ctx;
            s.setLineDash !== void 0 && (s.setLineDash(o), s.lineDashOffset = m);
          }
          setRenderingIntent(o) {
          }
          setFlatness(o) {
          }
          setGState(o) {
            for (const [m, s] of o)
              switch (m) {
                case "LW":
                  this.setLineWidth(s);
                  break;
                case "LC":
                  this.setLineCap(s);
                  break;
                case "LJ":
                  this.setLineJoin(s);
                  break;
                case "ML":
                  this.setMiterLimit(s);
                  break;
                case "D":
                  this.setDash(s[0], s[1]);
                  break;
                case "RI":
                  this.setRenderingIntent(s);
                  break;
                case "FL":
                  this.setFlatness(s);
                  break;
                case "Font":
                  this.setFont(s[0], s[1]);
                  break;
                case "CA":
                  this.current.strokeAlpha = s;
                  break;
                case "ca":
                  this.current.fillAlpha = s, this.ctx.globalAlpha = s;
                  break;
                case "BM":
                  this.ctx.globalCompositeOperation = s;
                  break;
                case "SMask":
                  this.current.activeSMask = s ? this.tempSMask : null, this.tempSMask = null, this.checkSMaskState();
                  break;
                case "TR":
                  this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(s);
                  break;
              }
          }
          get inSMaskMode() {
            return !!this.suspendedCtx;
          }
          checkSMaskState() {
            const o = this.inSMaskMode;
            this.current.activeSMask && !o ? this.beginSMaskMode() : !this.current.activeSMask && o && this.endSMaskMode();
          }
          beginSMaskMode() {
            if (this.inSMaskMode)
              throw new Error("beginSMaskMode called while already in smask mode");
            const o = this.ctx.canvas.width, m = this.ctx.canvas.height, s = "smaskGroupAt" + this.groupLevel, r = this.cachedCanvases.getCanvas(s, o, m);
            this.suspendedCtx = this.ctx, this.ctx = r.context;
            const y = this.ctx;
            y.setTransform(...(0, fe.getCurrentTransform)(this.suspendedCtx)), d(this.suspendedCtx, y), U(y, this.suspendedCtx), this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
          }
          endSMaskMode() {
            if (!this.inSMaskMode)
              throw new Error("endSMaskMode called while not in smask mode");
            this.ctx._removeMirroring(), d(this.ctx, this.suspendedCtx), this.ctx = this.suspendedCtx, this.suspendedCtx = null;
          }
          compose(o) {
            if (!this.current.activeSMask)
              return;
            o ? (o[0] = Math.floor(o[0]), o[1] = Math.floor(o[1]), o[2] = Math.ceil(o[2]), o[3] = Math.ceil(o[3])) : o = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
            const m = this.current.activeSMask, s = this.suspendedCtx;
            x(s, m, this.ctx, o), this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height), this.ctx.restore();
          }
          save() {
            this.inSMaskMode ? (d(this.ctx, this.suspendedCtx), this.suspendedCtx.save()) : this.ctx.save();
            const o = this.current;
            this.stateStack.push(o), this.current = o.clone();
          }
          restore() {
            this.stateStack.length === 0 && this.inSMaskMode && this.endSMaskMode(), this.stateStack.length !== 0 && (this.current = this.stateStack.pop(), this.inSMaskMode ? (this.suspendedCtx.restore(), d(this.suspendedCtx, this.ctx)) : this.ctx.restore(), this.checkSMaskState(), this.pendingClip = null, this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null);
          }
          transform(o, m, s, r, y, M) {
            this.ctx.transform(o, m, s, r, y, M), this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null;
          }
          constructPath(o, m, s) {
            const r = this.ctx, y = this.current;
            let M = y.x, $ = y.y, G, ce;
            const q = (0, fe.getCurrentTransform)(r), re = q[0] === 0 && q[3] === 0 || q[1] === 0 && q[2] === 0, Z = re ? s.slice(0) : null;
            for (let te = 0, L = 0, X = o.length; te < X; te++)
              switch (o[te] | 0) {
                case de.OPS.rectangle:
                  M = m[L++], $ = m[L++];
                  const J = m[L++], Y = m[L++], ae = M + J, se = $ + Y;
                  r.moveTo(M, $), J === 0 || Y === 0 ? r.lineTo(ae, se) : (r.lineTo(ae, $), r.lineTo(ae, se), r.lineTo(M, se)), re || y.updateRectMinMax(q, [M, $, ae, se]), r.closePath();
                  break;
                case de.OPS.moveTo:
                  M = m[L++], $ = m[L++], r.moveTo(M, $), re || y.updatePathMinMax(q, M, $);
                  break;
                case de.OPS.lineTo:
                  M = m[L++], $ = m[L++], r.lineTo(M, $), re || y.updatePathMinMax(q, M, $);
                  break;
                case de.OPS.curveTo:
                  G = M, ce = $, M = m[L + 4], $ = m[L + 5], r.bezierCurveTo(m[L], m[L + 1], m[L + 2], m[L + 3], M, $), y.updateCurvePathMinMax(q, G, ce, m[L], m[L + 1], m[L + 2], m[L + 3], M, $, Z), L += 6;
                  break;
                case de.OPS.curveTo2:
                  G = M, ce = $, r.bezierCurveTo(M, $, m[L], m[L + 1], m[L + 2], m[L + 3]), y.updateCurvePathMinMax(q, G, ce, M, $, m[L], m[L + 1], m[L + 2], m[L + 3], Z), M = m[L + 2], $ = m[L + 3], L += 4;
                  break;
                case de.OPS.curveTo3:
                  G = M, ce = $, M = m[L + 2], $ = m[L + 3], r.bezierCurveTo(m[L], m[L + 1], M, $, M, $), y.updateCurvePathMinMax(q, G, ce, m[L], m[L + 1], M, $, M, $, Z), L += 4;
                  break;
                case de.OPS.closePath:
                  r.closePath();
                  break;
              }
            re && y.updateScalingPathMinMax(q, Z), y.setCurrentPoint(M, $);
          }
          closePath() {
            this.ctx.closePath();
          }
          stroke(o = !0) {
            const m = this.ctx, s = this.current.strokeColor;
            m.globalAlpha = this.current.strokeAlpha, this.contentVisible && (typeof s == "object" && (s != null && s.getPattern) ? (m.save(), m.strokeStyle = s.getPattern(m, this, (0, fe.getCurrentTransformInverse)(m), w.PathType.STROKE), this.rescaleAndStroke(!1), m.restore()) : this.rescaleAndStroke(!0)), o && this.consumePath(this.current.getClippedPathBoundingBox()), m.globalAlpha = this.current.fillAlpha;
          }
          closeStroke() {
            this.closePath(), this.stroke();
          }
          fill(o = !0) {
            const m = this.ctx, s = this.current.fillColor, r = this.current.patternFill;
            let y = !1;
            r && (m.save(), m.fillStyle = s.getPattern(m, this, (0, fe.getCurrentTransformInverse)(m), w.PathType.FILL), y = !0);
            const M = this.current.getClippedPathBoundingBox();
            this.contentVisible && M !== null && (this.pendingEOFill ? (m.fill("evenodd"), this.pendingEOFill = !1) : m.fill()), y && m.restore(), o && this.consumePath(M);
          }
          eoFill() {
            this.pendingEOFill = !0, this.fill();
          }
          fillStroke() {
            this.fill(!1), this.stroke(!1), this.consumePath();
          }
          eoFillStroke() {
            this.pendingEOFill = !0, this.fillStroke();
          }
          closeFillStroke() {
            this.closePath(), this.fillStroke();
          }
          closeEOFillStroke() {
            this.pendingEOFill = !0, this.closePath(), this.fillStroke();
          }
          endPath() {
            this.consumePath();
          }
          clip() {
            this.pendingClip = N;
          }
          eoClip() {
            this.pendingClip = u;
          }
          beginText() {
            this.current.textMatrix = de.IDENTITY_MATRIX, this.current.textMatrixScale = 1, this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
          }
          endText() {
            const o = this.pendingTextPaths, m = this.ctx;
            if (o === void 0) {
              m.beginPath();
              return;
            }
            m.save(), m.beginPath();
            for (const s of o)
              m.setTransform(...s.transform), m.translate(s.x, s.y), s.addToPath(m, s.fontSize);
            m.restore(), m.clip(), m.beginPath(), delete this.pendingTextPaths;
          }
          setCharSpacing(o) {
            this.current.charSpacing = o;
          }
          setWordSpacing(o) {
            this.current.wordSpacing = o;
          }
          setHScale(o) {
            this.current.textHScale = o / 100;
          }
          setLeading(o) {
            this.current.leading = -o;
          }
          setFont(o, m) {
            var q;
            const s = this.commonObjs.get(o), r = this.current;
            if (!s)
              throw new Error(`Can't find font for ${o}`);
            if (r.fontMatrix = s.fontMatrix || de.FONT_IDENTITY_MATRIX, (r.fontMatrix[0] === 0 || r.fontMatrix[3] === 0) && (0, de.warn)("Invalid font matrix for font " + o), m < 0 ? (m = -m, r.fontDirection = -1) : r.fontDirection = 1, this.current.font = s, this.current.fontSize = m, s.isType3Font)
              return;
            const y = s.loadedName || "sans-serif", M = ((q = s.systemFontInfo) == null ? void 0 : q.css) || `"${y}", ${s.fallbackName}`;
            let $ = "normal";
            s.black ? $ = "900" : s.bold && ($ = "bold");
            const G = s.italic ? "italic" : "normal";
            let ce = m;
            m < n ? ce = n : m > F && (ce = F), this.current.fontSizeScale = m / ce, this.ctx.font = `${G} ${$} ${ce}px ${M}`;
          }
          setTextRenderingMode(o) {
            this.current.textRenderingMode = o;
          }
          setTextRise(o) {
            this.current.textRise = o;
          }
          moveText(o, m) {
            this.current.x = this.current.lineX += o, this.current.y = this.current.lineY += m;
          }
          setLeadingMoveText(o, m) {
            this.setLeading(-m), this.moveText(o, m);
          }
          setTextMatrix(o, m, s, r, y, M) {
            this.current.textMatrix = [o, m, s, r, y, M], this.current.textMatrixScale = Math.hypot(o, m), this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
          }
          nextLine() {
            this.moveText(0, this.current.leading);
          }
          paintChar(o, m, s, r) {
            const y = this.ctx, M = this.current, $ = M.font, G = M.textRenderingMode, ce = M.fontSize / M.fontSizeScale, q = G & de.TextRenderingMode.FILL_STROKE_MASK, re = !!(G & de.TextRenderingMode.ADD_TO_PATH_FLAG), Z = M.patternFill && !$.missingFile;
            let te;
            ($.disableFontFace || re || Z) && (te = $.getPathGenerator(this.commonObjs, o)), $.disableFontFace || Z ? (y.save(), y.translate(m, s), y.beginPath(), te(y, ce), r && y.setTransform(...r), (q === de.TextRenderingMode.FILL || q === de.TextRenderingMode.FILL_STROKE) && y.fill(), (q === de.TextRenderingMode.STROKE || q === de.TextRenderingMode.FILL_STROKE) && y.stroke(), y.restore()) : ((q === de.TextRenderingMode.FILL || q === de.TextRenderingMode.FILL_STROKE) && y.fillText(o, m, s), (q === de.TextRenderingMode.STROKE || q === de.TextRenderingMode.FILL_STROKE) && y.strokeText(o, m, s)), re && (this.pendingTextPaths || (this.pendingTextPaths = [])).push({
              transform: (0, fe.getCurrentTransform)(y),
              x: m,
              y: s,
              fontSize: ce,
              addToPath: te
            });
          }
          get isFontSubpixelAAEnabled() {
            const {
              context: o
            } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
            o.scale(1.5, 1), o.fillText("I", 0, 10);
            const m = o.getImageData(0, 0, 10, 10).data;
            let s = !1;
            for (let r = 3; r < m.length; r += 4)
              if (m[r] > 0 && m[r] < 255) {
                s = !0;
                break;
              }
            return (0, de.shadow)(this, "isFontSubpixelAAEnabled", s);
          }
          showText(o) {
            const m = this.current, s = m.font;
            if (s.isType3Font)
              return this.showType3Text(o);
            const r = m.fontSize;
            if (r === 0)
              return;
            const y = this.ctx, M = m.fontSizeScale, $ = m.charSpacing, G = m.wordSpacing, ce = m.fontDirection, q = m.textHScale * ce, re = o.length, Z = s.vertical, te = Z ? 1 : -1, L = s.defaultVMetrics, X = r * m.fontMatrix[0], J = m.textRenderingMode === de.TextRenderingMode.FILL && !s.disableFontFace && !m.patternFill;
            y.save(), y.transform(...m.textMatrix), y.translate(m.x, m.y + m.textRise), ce > 0 ? y.scale(q, -1) : y.scale(q, 1);
            let Y;
            if (m.patternFill) {
              y.save();
              const ie = m.fillColor.getPattern(y, this, (0, fe.getCurrentTransformInverse)(y), w.PathType.FILL);
              Y = (0, fe.getCurrentTransform)(y), y.restore(), y.fillStyle = ie;
            }
            let ae = m.lineWidth;
            const se = m.textMatrixScale;
            if (se === 0 || ae === 0) {
              const ie = m.textRenderingMode & de.TextRenderingMode.FILL_STROKE_MASK;
              (ie === de.TextRenderingMode.STROKE || ie === de.TextRenderingMode.FILL_STROKE) && (ae = this.getSinglePixelWidth());
            } else
              ae /= se;
            if (M !== 1 && (y.scale(M, M), ae /= M), y.lineWidth = ae, s.isInvalidPDFjsFont) {
              const ie = [];
              let ne = 0;
              for (const W of o)
                ie.push(W.unicode), ne += W.width;
              y.fillText(ie.join(""), 0, 0), m.x += ne * X * q, y.restore(), this.compose();
              return;
            }
            let Q = 0, z;
            for (z = 0; z < re; ++z) {
              const ie = o[z];
              if (typeof ie == "number") {
                Q += te * ie * r / 1e3;
                continue;
              }
              let ne = !1;
              const W = (ie.isSpace ? G : 0) + $, oe = ie.fontChar, ue = ie.accent;
              let pe, ve, Ce = ie.width;
              if (Z) {
                const Pe = ie.vmetric || L, be = -(ie.vmetric ? Pe[1] : Ce * 0.5) * X, me = Pe[2] * X;
                Ce = Pe ? -Pe[0] : Ce, pe = be / M, ve = (Q + me) / M;
              } else
                pe = Q / M, ve = 0;
              if (s.remeasure && Ce > 0) {
                const Pe = y.measureText(oe).width * 1e3 / r * M;
                if (Ce < Pe && this.isFontSubpixelAAEnabled) {
                  const be = Ce / Pe;
                  ne = !0, y.save(), y.scale(be, 1), pe /= be;
                } else
                  Ce !== Pe && (pe += (Ce - Pe) / 2e3 * r / M);
              }
              if (this.contentVisible && (ie.isInFont || s.missingFile)) {
                if (J && !ue)
                  y.fillText(oe, pe, ve);
                else if (this.paintChar(oe, pe, ve, Y), ue) {
                  const Pe = pe + r * ue.offset.x / M, be = ve - r * ue.offset.y / M;
                  this.paintChar(ue.fontChar, Pe, be, Y);
                }
              }
              const Fe = Z ? Ce * X - W * ce : Ce * X + W * ce;
              Q += Fe, ne && y.restore();
            }
            Z ? m.y -= Q : m.x += Q * q, y.restore(), this.compose();
          }
          showType3Text(o) {
            const m = this.ctx, s = this.current, r = s.font, y = s.fontSize, M = s.fontDirection, $ = r.vertical ? 1 : -1, G = s.charSpacing, ce = s.wordSpacing, q = s.textHScale * M, re = s.fontMatrix || de.FONT_IDENTITY_MATRIX, Z = o.length, te = s.textRenderingMode === de.TextRenderingMode.INVISIBLE;
            let L, X, J, Y;
            if (!(te || y === 0)) {
              for (this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null, m.save(), m.transform(...s.textMatrix), m.translate(s.x, s.y), m.scale(q, M), L = 0; L < Z; ++L) {
                if (X = o[L], typeof X == "number") {
                  Y = $ * X * y / 1e3, this.ctx.translate(Y, 0), s.x += Y * q;
                  continue;
                }
                const ae = (X.isSpace ? ce : 0) + G, se = r.charProcOperatorList[X.operatorListId];
                if (!se) {
                  (0, de.warn)(`Type3 character "${X.operatorListId}" is not available.`);
                  continue;
                }
                this.contentVisible && (this.processingType3 = X, this.save(), m.scale(y, y), m.transform(...re), this.executeOperatorList(se), this.restore()), J = de.Util.applyTransform([X.width, 0], re)[0] * y + ae, m.translate(J, 0), s.x += J * q;
              }
              m.restore(), this.processingType3 = null;
            }
          }
          setCharWidth(o, m) {
          }
          setCharWidthAndBounds(o, m, s, r, y, M) {
            this.ctx.rect(s, r, y - s, M - r), this.ctx.clip(), this.endPath();
          }
          getColorN_Pattern(o) {
            let m;
            if (o[0] === "TilingPattern") {
              const s = o[1], r = this.baseTransform || (0, fe.getCurrentTransform)(this.ctx), y = {
                createCanvasGraphics: (M) => new K(M, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
                  optionalContentConfig: this.optionalContentConfig,
                  markedContentStack: this.markedContentStack
                })
              };
              m = new w.TilingPattern(o, s, this.ctx, y, r);
            } else
              m = this._getPattern(o[1], o[2]);
            return m;
          }
          setStrokeColorN() {
            this.current.strokeColor = this.getColorN_Pattern(arguments);
          }
          setFillColorN() {
            this.current.fillColor = this.getColorN_Pattern(arguments), this.current.patternFill = !0;
          }
          setStrokeRGBColor(o, m, s) {
            const r = de.Util.makeHexColor(o, m, s);
            this.ctx.strokeStyle = r, this.current.strokeColor = r;
          }
          setFillRGBColor(o, m, s) {
            const r = de.Util.makeHexColor(o, m, s);
            this.ctx.fillStyle = r, this.current.fillColor = r, this.current.patternFill = !1;
          }
          _getPattern(o, m = null) {
            let s;
            return this.cachedPatterns.has(o) ? s = this.cachedPatterns.get(o) : (s = (0, w.getShadingPattern)(this.getObject(o)), this.cachedPatterns.set(o, s)), m && (s.matrix = m), s;
          }
          shadingFill(o) {
            if (!this.contentVisible)
              return;
            const m = this.ctx;
            this.save();
            const s = this._getPattern(o);
            m.fillStyle = s.getPattern(m, this, (0, fe.getCurrentTransformInverse)(m), w.PathType.SHADING);
            const r = (0, fe.getCurrentTransformInverse)(m);
            if (r) {
              const {
                width: y,
                height: M
              } = m.canvas, [$, G, ce, q] = de.Util.getAxialAlignedBoundingBox([0, 0, y, M], r);
              this.ctx.fillRect($, G, ce - $, q - G);
            } else
              this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
            this.compose(this.current.getClippedPathBoundingBox()), this.restore();
          }
          beginInlineImage() {
            (0, de.unreachable)("Should not call beginInlineImage");
          }
          beginImageData() {
            (0, de.unreachable)("Should not call beginImageData");
          }
          paintFormXObjectBegin(o, m) {
            if (this.contentVisible && (this.save(), this.baseTransformStack.push(this.baseTransform), Array.isArray(o) && o.length === 6 && this.transform(...o), this.baseTransform = (0, fe.getCurrentTransform)(this.ctx), m)) {
              const s = m[2] - m[0], r = m[3] - m[1];
              this.ctx.rect(m[0], m[1], s, r), this.current.updateRectMinMax((0, fe.getCurrentTransform)(this.ctx), m), this.clip(), this.endPath();
            }
          }
          paintFormXObjectEnd() {
            this.contentVisible && (this.restore(), this.baseTransform = this.baseTransformStack.pop());
          }
          beginGroup(o) {
            if (!this.contentVisible)
              return;
            this.save(), this.inSMaskMode && (this.endSMaskMode(), this.current.activeSMask = null);
            const m = this.ctx;
            o.isolated || (0, de.info)("TODO: Support non-isolated groups."), o.knockout && (0, de.warn)("Knockout groups not supported.");
            const s = (0, fe.getCurrentTransform)(m);
            if (o.matrix && m.transform(...o.matrix), !o.bbox)
              throw new Error("Bounding box is required.");
            let r = de.Util.getAxialAlignedBoundingBox(o.bbox, (0, fe.getCurrentTransform)(m));
            const y = [0, 0, m.canvas.width, m.canvas.height];
            r = de.Util.intersect(r, y) || [0, 0, 0, 0];
            const M = Math.floor(r[0]), $ = Math.floor(r[1]);
            let G = Math.max(Math.ceil(r[2]) - M, 1), ce = Math.max(Math.ceil(r[3]) - $, 1), q = 1, re = 1;
            G > C && (q = G / C, G = C), ce > C && (re = ce / C, ce = C), this.current.startNewPathAndClipBox([0, 0, G, ce]);
            let Z = "groupAt" + this.groupLevel;
            o.smask && (Z += "_smask_" + this.smaskCounter++ % 2);
            const te = this.cachedCanvases.getCanvas(Z, G, ce), L = te.context;
            L.scale(1 / q, 1 / re), L.translate(-M, -$), L.transform(...s), o.smask ? this.smaskStack.push({
              canvas: te.canvas,
              context: L,
              offsetX: M,
              offsetY: $,
              scaleX: q,
              scaleY: re,
              subtype: o.smask.subtype,
              backdrop: o.smask.backdrop,
              transferMap: o.smask.transferMap || null,
              startTransformInverse: null
            }) : (m.setTransform(1, 0, 0, 1, 0, 0), m.translate(M, $), m.scale(q, re), m.save()), d(m, L), this.ctx = L, this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]), this.groupStack.push(m), this.groupLevel++;
          }
          endGroup(o) {
            if (!this.contentVisible)
              return;
            this.groupLevel--;
            const m = this.ctx, s = this.groupStack.pop();
            if (this.ctx = s, this.ctx.imageSmoothingEnabled = !1, o.smask)
              this.tempSMask = this.smaskStack.pop(), this.restore();
            else {
              this.ctx.restore();
              const r = (0, fe.getCurrentTransform)(this.ctx);
              this.restore(), this.ctx.save(), this.ctx.setTransform(...r);
              const y = de.Util.getAxialAlignedBoundingBox([0, 0, m.canvas.width, m.canvas.height], r);
              this.ctx.drawImage(m.canvas, 0, 0), this.ctx.restore(), this.compose(y);
            }
          }
          beginAnnotation(o, m, s, r, y) {
            if (De(this, S, ta).call(this), A(this.ctx), this.ctx.save(), this.save(), this.baseTransform && this.ctx.setTransform(...this.baseTransform), Array.isArray(m) && m.length === 4) {
              const M = m[2] - m[0], $ = m[3] - m[1];
              if (y && this.annotationCanvasMap) {
                s = s.slice(), s[4] -= m[0], s[5] -= m[1], m = m.slice(), m[0] = m[1] = 0, m[2] = M, m[3] = $;
                const [G, ce] = de.Util.singularValueDecompose2dScale((0, fe.getCurrentTransform)(this.ctx)), {
                  viewportScale: q
                } = this, re = Math.ceil(M * this.outputScaleX * q), Z = Math.ceil($ * this.outputScaleY * q);
                this.annotationCanvas = this.canvasFactory.create(re, Z);
                const {
                  canvas: te,
                  context: L
                } = this.annotationCanvas;
                this.annotationCanvasMap.set(o, te), this.annotationCanvas.savedCtx = this.ctx, this.ctx = L, this.ctx.save(), this.ctx.setTransform(G, 0, 0, -ce, 0, $ * ce), A(this.ctx);
              } else
                A(this.ctx), this.ctx.rect(m[0], m[1], M, $), this.ctx.clip(), this.endPath();
            }
            this.current = new b(this.ctx.canvas.width, this.ctx.canvas.height), this.transform(...s), this.transform(...r);
          }
          endAnnotation() {
            this.annotationCanvas && (this.ctx.restore(), De(this, T, na).call(this), this.ctx = this.annotationCanvas.savedCtx, delete this.annotationCanvas.savedCtx, delete this.annotationCanvas);
          }
          paintImageMaskXObject(o) {
            if (!this.contentVisible)
              return;
            const m = o.count;
            o = this.getObject(o.data, o), o.count = m;
            const s = this.ctx, r = this.processingType3;
            if (r && (r.compiled === void 0 && (r.compiled = g(o)), r.compiled)) {
              r.compiled(s);
              return;
            }
            const y = this._createMaskCanvas(o), M = y.canvas;
            s.save(), s.setTransform(1, 0, 0, 1, 0, 0), s.drawImage(M, y.offsetX, y.offsetY), s.restore(), this.compose();
          }
          paintImageMaskXObjectRepeat(o, m, s = 0, r = 0, y, M) {
            if (!this.contentVisible)
              return;
            o = this.getObject(o.data, o);
            const $ = this.ctx;
            $.save();
            const G = (0, fe.getCurrentTransform)($);
            $.transform(m, s, r, y, 0, 0);
            const ce = this._createMaskCanvas(o);
            $.setTransform(1, 0, 0, 1, ce.offsetX - G[4], ce.offsetY - G[5]);
            for (let q = 0, re = M.length; q < re; q += 2) {
              const Z = de.Util.transform(G, [m, s, r, y, M[q], M[q + 1]]), [te, L] = de.Util.applyTransform([0, 0], Z);
              $.drawImage(ce.canvas, te, L);
            }
            $.restore(), this.compose();
          }
          paintImageMaskXObjectGroup(o) {
            if (!this.contentVisible)
              return;
            const m = this.ctx, s = this.current.fillColor, r = this.current.patternFill;
            for (const y of o) {
              const {
                data: M,
                width: $,
                height: G,
                transform: ce
              } = y, q = this.cachedCanvases.getCanvas("maskCanvas", $, G), re = q.context;
              re.save();
              const Z = this.getObject(M, y);
              P(re, Z), re.globalCompositeOperation = "source-in", re.fillStyle = r ? s.getPattern(re, this, (0, fe.getCurrentTransformInverse)(m), w.PathType.FILL) : s, re.fillRect(0, 0, $, G), re.restore(), m.save(), m.transform(...ce), m.scale(1, -1), v(m, q.canvas, 0, 0, $, G, 0, -1, 1, 1), m.restore();
            }
            this.compose();
          }
          paintImageXObject(o) {
            if (!this.contentVisible)
              return;
            const m = this.getObject(o);
            if (!m) {
              (0, de.warn)("Dependent image isn't ready yet");
              return;
            }
            this.paintInlineImageXObject(m);
          }
          paintImageXObjectRepeat(o, m, s, r) {
            if (!this.contentVisible)
              return;
            const y = this.getObject(o);
            if (!y) {
              (0, de.warn)("Dependent image isn't ready yet");
              return;
            }
            const M = y.width, $ = y.height, G = [];
            for (let ce = 0, q = r.length; ce < q; ce += 2)
              G.push({
                transform: [m, 0, 0, s, r[ce], r[ce + 1]],
                x: 0,
                y: 0,
                w: M,
                h: $
              });
            this.paintInlineImageXObjectGroup(y, G);
          }
          applyTransferMapsToCanvas(o) {
            return this.current.transferMaps !== "none" && (o.filter = this.current.transferMaps, o.drawImage(o.canvas, 0, 0), o.filter = "none"), o.canvas;
          }
          applyTransferMapsToBitmap(o) {
            if (this.current.transferMaps === "none")
              return o.bitmap;
            const {
              bitmap: m,
              width: s,
              height: r
            } = o, y = this.cachedCanvases.getCanvas("inlineImage", s, r), M = y.context;
            return M.filter = this.current.transferMaps, M.drawImage(m, 0, 0), M.filter = "none", y.canvas;
          }
          paintInlineImageXObject(o) {
            if (!this.contentVisible)
              return;
            const m = o.width, s = o.height, r = this.ctx;
            if (this.save(), !de.isNodeJS) {
              const {
                filter: $
              } = r;
              $ !== "none" && $ !== "" && (r.filter = "none");
            }
            r.scale(1 / m, -1 / s);
            let y;
            if (o.bitmap)
              y = this.applyTransferMapsToBitmap(o);
            else if (typeof HTMLElement == "function" && o instanceof HTMLElement || !o.data)
              y = o;
            else {
              const G = this.cachedCanvases.getCanvas("inlineImage", m, s).context;
              i(G, o), y = this.applyTransferMapsToCanvas(G);
            }
            const M = this._scaleImage(y, (0, fe.getCurrentTransformInverse)(r));
            r.imageSmoothingEnabled = R((0, fe.getCurrentTransform)(r), o.interpolate), v(r, M.img, 0, 0, M.paintWidth, M.paintHeight, 0, -s, m, s), this.compose(), this.restore();
          }
          paintInlineImageXObjectGroup(o, m) {
            if (!this.contentVisible)
              return;
            const s = this.ctx;
            let r;
            if (o.bitmap)
              r = o.bitmap;
            else {
              const y = o.width, M = o.height, G = this.cachedCanvases.getCanvas("inlineImage", y, M).context;
              i(G, o), r = this.applyTransferMapsToCanvas(G);
            }
            for (const y of m)
              s.save(), s.transform(...y.transform), s.scale(1, -1), v(s, r, y.x, y.y, y.w, y.h, 0, -1, 1, 1), s.restore();
            this.compose();
          }
          paintSolidColorImageMask() {
            this.contentVisible && (this.ctx.fillRect(0, 0, 1, 1), this.compose());
          }
          markPoint(o) {
          }
          markPointProps(o, m) {
          }
          beginMarkedContent(o) {
            this.markedContentStack.push({
              visible: !0
            });
          }
          beginMarkedContentProps(o, m) {
            o === "OC" ? this.markedContentStack.push({
              visible: this.optionalContentConfig.isVisible(m)
            }) : this.markedContentStack.push({
              visible: !0
            }), this.contentVisible = this.isContentVisible();
          }
          endMarkedContent() {
            this.markedContentStack.pop(), this.contentVisible = this.isContentVisible();
          }
          beginCompat() {
          }
          endCompat() {
          }
          consumePath(o) {
            const m = this.current.isEmptyClip();
            this.pendingClip && this.current.updateClipFromPath(), this.pendingClip || this.compose(o);
            const s = this.ctx;
            this.pendingClip && (m || (this.pendingClip === u ? s.clip("evenodd") : s.clip()), this.pendingClip = null), this.current.startNewPathAndClipBox(this.current.clipBox), s.beginPath();
          }
          getSinglePixelWidth() {
            if (!this._cachedGetSinglePixelWidth) {
              const o = (0, fe.getCurrentTransform)(this.ctx);
              if (o[1] === 0 && o[2] === 0)
                this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(o[0]), Math.abs(o[3]));
              else {
                const m = Math.abs(o[0] * o[3] - o[2] * o[1]), s = Math.hypot(o[0], o[2]), r = Math.hypot(o[1], o[3]);
                this._cachedGetSinglePixelWidth = Math.max(s, r) / m;
              }
            }
            return this._cachedGetSinglePixelWidth;
          }
          getScaleForStroking() {
            if (this._cachedScaleForStroking[0] === -1) {
              const {
                lineWidth: o
              } = this.current, {
                a: m,
                b: s,
                c: r,
                d: y
              } = this.ctx.getTransform();
              let M, $;
              if (s === 0 && r === 0) {
                const G = Math.abs(m), ce = Math.abs(y);
                if (G === ce)
                  if (o === 0)
                    M = $ = 1 / G;
                  else {
                    const q = G * o;
                    M = $ = q < 1 ? 1 / q : 1;
                  }
                else if (o === 0)
                  M = 1 / G, $ = 1 / ce;
                else {
                  const q = G * o, re = ce * o;
                  M = q < 1 ? 1 / q : 1, $ = re < 1 ? 1 / re : 1;
                }
              } else {
                const G = Math.abs(m * y - s * r), ce = Math.hypot(m, s), q = Math.hypot(r, y);
                if (o === 0)
                  M = q / G, $ = ce / G;
                else {
                  const re = o * G;
                  M = q > re ? q / re : 1, $ = ce > re ? ce / re : 1;
                }
              }
              this._cachedScaleForStroking[0] = M, this._cachedScaleForStroking[1] = $;
            }
            return this._cachedScaleForStroking;
          }
          rescaleAndStroke(o) {
            const {
              ctx: m
            } = this, {
              lineWidth: s
            } = this.current, [r, y] = this.getScaleForStroking();
            if (m.lineWidth = s || 1, r === 1 && y === 1) {
              m.stroke();
              return;
            }
            const M = m.getLineDash();
            if (o && m.save(), m.scale(r, y), M.length > 0) {
              const $ = Math.max(r, y);
              m.setLineDash(M.map((G) => G / $)), m.lineDashOffset /= $;
            }
            m.stroke(), o && m.restore();
          }
          isContentVisible() {
            for (let o = this.markedContentStack.length - 1; o >= 0; o--)
              if (!this.markedContentStack[o].visible)
                return !1;
            return !0;
          }
        };
        S = new WeakSet(), ta = function() {
          for (; this.stateStack.length || this.inSMaskMode; )
            this.restore();
          this.ctx.restore(), this.transparentCanvas && (this.ctx = this.compositeCtx, this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.drawImage(this.transparentCanvas, 0, 0), this.ctx.restore(), this.transparentCanvas = null);
        }, T = new WeakSet(), na = function() {
          if (this.pageColors) {
            const o = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
            if (o !== "none") {
              const m = this.ctx.filter;
              this.ctx.filter = o, this.ctx.drawImage(this.ctx.canvas, 0, 0), this.ctx.filter = m;
            }
          }
        };
        let p = K;
        ge.CanvasGraphics = p;
        for (const _ in de.OPS)
          p.prototype[_] !== void 0 && (p.prototype[de.OPS[_]] = p.prototype[_]);
      },
      /* 12 */
      /***/
      (Re, ge, xe) => {
        Object.defineProperty(ge, "__esModule", {
          value: !0
        }), ge.TilingPattern = ge.PathType = void 0, ge.getShadingPattern = j;
        var de = xe(1), fe = xe(6);
        const w = {
          FILL: "Fill",
          STROKE: "Stroke",
          SHADING: "Shading"
        };
        ge.PathType = w;
        function V(g, b) {
          if (!b)
            return;
          const i = b[2] - b[0], P = b[3] - b[1], d = new Path2D();
          d.rect(b[0], b[1], i, P), g.clip(d);
        }
        class n {
          constructor() {
            this.constructor === n && (0, de.unreachable)("Cannot initialize BaseShadingPattern.");
          }
          getPattern() {
            (0, de.unreachable)("Abstract method `getPattern` called.");
          }
        }
        class F extends n {
          constructor(b) {
            super(), this._type = b[1], this._bbox = b[2], this._colorStops = b[3], this._p0 = b[4], this._p1 = b[5], this._r0 = b[6], this._r1 = b[7], this.matrix = null;
          }
          _createGradient(b) {
            let i;
            this._type === "axial" ? i = b.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]) : this._type === "radial" && (i = b.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1));
            for (const P of this._colorStops)
              i.addColorStop(P[0], P[1]);
            return i;
          }
          getPattern(b, i, P, d) {
            let A;
            if (d === w.STROKE || d === w.FILL) {
              const I = i.current.getClippedPathBoundingBox(d, (0, fe.getCurrentTransform)(b)) || [0, 0, 0, 0], E = Math.ceil(I[2] - I[0]) || 1, k = Math.ceil(I[3] - I[1]) || 1, H = i.cachedCanvases.getCanvas("pattern", E, k, !0), x = H.context;
              x.clearRect(0, 0, x.canvas.width, x.canvas.height), x.beginPath(), x.rect(0, 0, x.canvas.width, x.canvas.height), x.translate(-I[0], -I[1]), P = de.Util.transform(P, [1, 0, 0, 1, I[0], I[1]]), x.transform(...i.baseTransform), this.matrix && x.transform(...this.matrix), V(x, this._bbox), x.fillStyle = this._createGradient(x), x.fill(), A = b.createPattern(H.canvas, "no-repeat");
              const R = new DOMMatrix(P);
              A.setTransform(R);
            } else
              V(b, this._bbox), A = this._createGradient(b);
            return A;
          }
        }
        function C(g, b, i, P, d, A, I, E) {
          const k = b.coords, H = b.colors, x = g.data, R = g.width * 4;
          let f;
          k[i + 1] > k[P + 1] && (f = i, i = P, P = f, f = A, A = I, I = f), k[P + 1] > k[d + 1] && (f = P, P = d, d = f, f = I, I = E, E = f), k[i + 1] > k[P + 1] && (f = i, i = P, P = f, f = A, A = I, I = f);
          const c = (k[i] + b.offsetX) * b.scaleX, N = (k[i + 1] + b.offsetY) * b.scaleY, u = (k[P] + b.offsetX) * b.scaleX, p = (k[P + 1] + b.offsetY) * b.scaleY, S = (k[d] + b.offsetX) * b.scaleX, B = (k[d + 1] + b.offsetY) * b.scaleY;
          if (N >= B)
            return;
          const T = H[A], D = H[A + 1], K = H[A + 2], _ = H[I], o = H[I + 1], m = H[I + 2], s = H[E], r = H[E + 1], y = H[E + 2], M = Math.round(N), $ = Math.round(B);
          let G, ce, q, re, Z, te, L, X;
          for (let J = M; J <= $; J++) {
            if (J < p) {
              const z = J < N ? 0 : (N - J) / (N - p);
              G = c - (c - u) * z, ce = T - (T - _) * z, q = D - (D - o) * z, re = K - (K - m) * z;
            } else {
              let z;
              J > B ? z = 1 : p === B ? z = 0 : z = (p - J) / (p - B), G = u - (u - S) * z, ce = _ - (_ - s) * z, q = o - (o - r) * z, re = m - (m - y) * z;
            }
            let Y;
            J < N ? Y = 0 : J > B ? Y = 1 : Y = (N - J) / (N - B), Z = c - (c - S) * Y, te = T - (T - s) * Y, L = D - (D - r) * Y, X = K - (K - y) * Y;
            const ae = Math.round(Math.min(G, Z)), se = Math.round(Math.max(G, Z));
            let Q = R * J + ae * 4;
            for (let z = ae; z <= se; z++)
              Y = (G - z) / (G - Z), Y < 0 ? Y = 0 : Y > 1 && (Y = 1), x[Q++] = ce - (ce - te) * Y | 0, x[Q++] = q - (q - L) * Y | 0, x[Q++] = re - (re - X) * Y | 0, x[Q++] = 255;
          }
        }
        function e(g, b, i) {
          const P = b.coords, d = b.colors;
          let A, I;
          switch (b.type) {
            case "lattice":
              const E = b.verticesPerRow, k = Math.floor(P.length / E) - 1, H = E - 1;
              for (A = 0; A < k; A++) {
                let x = A * E;
                for (let R = 0; R < H; R++, x++)
                  C(g, i, P[x], P[x + 1], P[x + E], d[x], d[x + 1], d[x + E]), C(g, i, P[x + E + 1], P[x + 1], P[x + E], d[x + E + 1], d[x + 1], d[x + E]);
              }
              break;
            case "triangles":
              for (A = 0, I = P.length; A < I; A += 3)
                C(g, i, P[A], P[A + 1], P[A + 2], d[A], d[A + 1], d[A + 2]);
              break;
            default:
              throw new Error("illegal figure");
          }
        }
        class t extends n {
          constructor(b) {
            super(), this._coords = b[2], this._colors = b[3], this._figures = b[4], this._bounds = b[5], this._bbox = b[7], this._background = b[8], this.matrix = null;
          }
          _createMeshCanvas(b, i, P) {
            const E = Math.floor(this._bounds[0]), k = Math.floor(this._bounds[1]), H = Math.ceil(this._bounds[2]) - E, x = Math.ceil(this._bounds[3]) - k, R = Math.min(Math.ceil(Math.abs(H * b[0] * 1.1)), 3e3), f = Math.min(Math.ceil(Math.abs(x * b[1] * 1.1)), 3e3), c = H / R, N = x / f, u = {
              coords: this._coords,
              colors: this._colors,
              offsetX: -E,
              offsetY: -k,
              scaleX: 1 / c,
              scaleY: 1 / N
            }, p = R + 2 * 2, S = f + 2 * 2, B = P.getCanvas("mesh", p, S, !1), T = B.context, D = T.createImageData(R, f);
            if (i) {
              const _ = D.data;
              for (let o = 0, m = _.length; o < m; o += 4)
                _[o] = i[0], _[o + 1] = i[1], _[o + 2] = i[2], _[o + 3] = 255;
            }
            for (const _ of this._figures)
              e(D, _, u);
            return T.putImageData(D, 2, 2), {
              canvas: B.canvas,
              offsetX: E - 2 * c,
              offsetY: k - 2 * N,
              scaleX: c,
              scaleY: N
            };
          }
          getPattern(b, i, P, d) {
            V(b, this._bbox);
            let A;
            if (d === w.SHADING)
              A = de.Util.singularValueDecompose2dScale((0, fe.getCurrentTransform)(b));
            else if (A = de.Util.singularValueDecompose2dScale(i.baseTransform), this.matrix) {
              const E = de.Util.singularValueDecompose2dScale(this.matrix);
              A = [A[0] * E[0], A[1] * E[1]];
            }
            const I = this._createMeshCanvas(A, d === w.SHADING ? null : this._background, i.cachedCanvases);
            return d !== w.SHADING && (b.setTransform(...i.baseTransform), this.matrix && b.transform(...this.matrix)), b.translate(I.offsetX, I.offsetY), b.scale(I.scaleX, I.scaleY), b.createPattern(I.canvas, "no-repeat");
          }
        }
        class l extends n {
          getPattern() {
            return "hotpink";
          }
        }
        function j(g) {
          switch (g[0]) {
            case "RadialAxial":
              return new F(g);
            case "Mesh":
              return new t(g);
            case "Dummy":
              return new l();
          }
          throw new Error(`Unknown IR type: ${g[0]}`);
        }
        const U = {
          COLORED: 1,
          UNCOLORED: 2
        }, v = class v {
          constructor(b, i, P, d, A) {
            this.operatorList = b[2], this.matrix = b[3] || [1, 0, 0, 1, 0, 0], this.bbox = b[4], this.xstep = b[5], this.ystep = b[6], this.paintType = b[7], this.tilingType = b[8], this.color = i, this.ctx = P, this.canvasGraphicsFactory = d, this.baseTransform = A;
          }
          createPatternCanvas(b) {
            const i = this.operatorList, P = this.bbox, d = this.xstep, A = this.ystep, I = this.paintType, E = this.tilingType, k = this.color, H = this.canvasGraphicsFactory;
            (0, de.info)("TilingType: " + E);
            const x = P[0], R = P[1], f = P[2], c = P[3], N = de.Util.singularValueDecompose2dScale(this.matrix), u = de.Util.singularValueDecompose2dScale(this.baseTransform), p = [N[0] * u[0], N[1] * u[1]], S = this.getSizeAndScale(d, this.ctx.canvas.width, p[0]), B = this.getSizeAndScale(A, this.ctx.canvas.height, p[1]), T = b.cachedCanvases.getCanvas("pattern", S.size, B.size, !0), D = T.context, K = H.createCanvasGraphics(D);
            K.groupLevel = b.groupLevel, this.setFillAndStrokeStyleToContext(K, I, k);
            let _ = x, o = R, m = f, s = c;
            return x < 0 && (_ = 0, m += Math.abs(x)), R < 0 && (o = 0, s += Math.abs(R)), D.translate(-(S.scale * _), -(B.scale * o)), K.transform(S.scale, 0, 0, B.scale, 0, 0), D.save(), this.clipBbox(K, _, o, m, s), K.baseTransform = (0, fe.getCurrentTransform)(K.ctx), K.executeOperatorList(i), K.endDrawing(), {
              canvas: T.canvas,
              scaleX: S.scale,
              scaleY: B.scale,
              offsetX: _,
              offsetY: o
            };
          }
          getSizeAndScale(b, i, P) {
            b = Math.abs(b);
            const d = Math.max(v.MAX_PATTERN_SIZE, i);
            let A = Math.ceil(b * P);
            return A >= d ? A = d : P = A / b, {
              scale: P,
              size: A
            };
          }
          clipBbox(b, i, P, d, A) {
            const I = d - i, E = A - P;
            b.ctx.rect(i, P, I, E), b.current.updateRectMinMax((0, fe.getCurrentTransform)(b.ctx), [i, P, d, A]), b.clip(), b.endPath();
          }
          setFillAndStrokeStyleToContext(b, i, P) {
            const d = b.ctx, A = b.current;
            switch (i) {
              case U.COLORED:
                const I = this.ctx;
                d.fillStyle = I.fillStyle, d.strokeStyle = I.strokeStyle, A.fillColor = I.fillStyle, A.strokeColor = I.strokeStyle;
                break;
              case U.UNCOLORED:
                const E = de.Util.makeHexColor(P[0], P[1], P[2]);
                d.fillStyle = E, d.strokeStyle = E, A.fillColor = E, A.strokeColor = E;
                break;
              default:
                throw new de.FormatError(`Unsupported paint type: ${i}`);
            }
          }
          getPattern(b, i, P, d) {
            let A = P;
            d !== w.SHADING && (A = de.Util.transform(A, i.baseTransform), this.matrix && (A = de.Util.transform(A, this.matrix)));
            const I = this.createPatternCanvas(i);
            let E = new DOMMatrix(A);
            E = E.translate(I.offsetX, I.offsetY), E = E.scale(1 / I.scaleX, 1 / I.scaleY);
            const k = b.createPattern(I.canvas, "repeat");
            return k.setTransform(E), k;
          }
        };
        Ot(v, "MAX_PATTERN_SIZE", 3e3);
        let O = v;
        ge.TilingPattern = O;
      },
      /* 13 */
      /***/
      (Re, ge, xe) => {
        Object.defineProperty(ge, "__esModule", {
          value: !0
        }), ge.convertBlackAndWhiteToRGBA = w, ge.convertToRGBA = fe, ge.grayToRGBA = n;
        var de = xe(1);
        function fe(F) {
          switch (F.kind) {
            case de.ImageKind.GRAYSCALE_1BPP:
              return w(F);
            case de.ImageKind.RGB_24BPP:
              return V(F);
          }
          return null;
        }
        function w({
          src: F,
          srcPos: C = 0,
          dest: e,
          width: t,
          height: l,
          nonBlackColor: j = 4294967295,
          inverseDecode: U = !1
        }) {
          const O = de.FeatureTest.isLittleEndian ? 4278190080 : 255, [v, g] = U ? [j, O] : [O, j], b = t >> 3, i = t & 7, P = F.length;
          e = new Uint32Array(e.buffer);
          let d = 0;
          for (let A = 0; A < l; A++) {
            for (const E = C + b; C < E; C++) {
              const k = C < P ? F[C] : 255;
              e[d++] = k & 128 ? g : v, e[d++] = k & 64 ? g : v, e[d++] = k & 32 ? g : v, e[d++] = k & 16 ? g : v, e[d++] = k & 8 ? g : v, e[d++] = k & 4 ? g : v, e[d++] = k & 2 ? g : v, e[d++] = k & 1 ? g : v;
            }
            if (i === 0)
              continue;
            const I = C < P ? F[C++] : 255;
            for (let E = 0; E < i; E++)
              e[d++] = I & 1 << 7 - E ? g : v;
          }
          return {
            srcPos: C,
            destPos: d
          };
        }
        function V({
          src: F,
          srcPos: C = 0,
          dest: e,
          destPos: t = 0,
          width: l,
          height: j
        }) {
          let U = 0;
          const O = F.length >> 2, v = new Uint32Array(F.buffer, C, O);
          if (de.FeatureTest.isLittleEndian) {
            for (; U < O - 2; U += 3, t += 4) {
              const g = v[U], b = v[U + 1], i = v[U + 2];
              e[t] = g | 4278190080, e[t + 1] = g >>> 24 | b << 8 | 4278190080, e[t + 2] = b >>> 16 | i << 16 | 4278190080, e[t + 3] = i >>> 8 | 4278190080;
            }
            for (let g = U * 4, b = F.length; g < b; g += 3)
              e[t++] = F[g] | F[g + 1] << 8 | F[g + 2] << 16 | 4278190080;
          } else {
            for (; U < O - 2; U += 3, t += 4) {
              const g = v[U], b = v[U + 1], i = v[U + 2];
              e[t] = g | 255, e[t + 1] = g << 24 | b >>> 8 | 255, e[t + 2] = b << 16 | i >>> 16 | 255, e[t + 3] = i << 8 | 255;
            }
            for (let g = U * 4, b = F.length; g < b; g += 3)
              e[t++] = F[g] << 24 | F[g + 1] << 16 | F[g + 2] << 8 | 255;
          }
          return {
            srcPos: C,
            destPos: t
          };
        }
        function n(F, C) {
          if (de.FeatureTest.isLittleEndian)
            for (let e = 0, t = F.length; e < t; e++)
              C[e] = F[e] * 65793 | 4278190080;
          else
            for (let e = 0, t = F.length; e < t; e++)
              C[e] = F[e] * 16843008 | 255;
        }
      },
      /* 14 */
      /***/
      (Re, ge) => {
        Object.defineProperty(ge, "__esModule", {
          value: !0
        }), ge.GlobalWorkerOptions = void 0;
        const xe = /* @__PURE__ */ Object.create(null);
        ge.GlobalWorkerOptions = xe, xe.workerPort = null, xe.workerSrc = "";
      },
      /* 15 */
      /***/
      (Re, ge, xe) => {
        var F, Ha, e, Xa, l, Zn;
        Object.defineProperty(ge, "__esModule", {
          value: !0
        }), ge.MessageHandler = void 0;
        var de = xe(1);
        const fe = {
          UNKNOWN: 0,
          DATA: 1,
          ERROR: 2
        }, w = {
          UNKNOWN: 0,
          CANCEL: 1,
          CANCEL_COMPLETE: 2,
          CLOSE: 3,
          ENQUEUE: 4,
          ERROR: 5,
          PULL: 6,
          PULL_COMPLETE: 7,
          START_COMPLETE: 8
        };
        function V(U) {
          switch (U instanceof Error || typeof U == "object" && U !== null || (0, de.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), U.name) {
            case "AbortException":
              return new de.AbortException(U.message);
            case "MissingPDFException":
              return new de.MissingPDFException(U.message);
            case "PasswordException":
              return new de.PasswordException(U.message, U.code);
            case "UnexpectedResponseException":
              return new de.UnexpectedResponseException(U.message, U.status);
            case "UnknownErrorException":
              return new de.UnknownErrorException(U.message, U.details);
            default:
              return new de.UnknownErrorException(U.message, U.toString());
          }
        }
        class n {
          constructor(O, v, g) {
            Me(this, F);
            Me(this, e);
            Me(this, l);
            this.sourceName = O, this.targetName = v, this.comObj = g, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), this._onComObjOnMessage = (b) => {
              const i = b.data;
              if (i.targetName !== this.sourceName)
                return;
              if (i.stream) {
                De(this, e, Xa).call(this, i);
                return;
              }
              if (i.callback) {
                const d = i.callbackId, A = this.callbackCapabilities[d];
                if (!A)
                  throw new Error(`Cannot resolve callback ${d}`);
                if (delete this.callbackCapabilities[d], i.callback === fe.DATA)
                  A.resolve(i.data);
                else if (i.callback === fe.ERROR)
                  A.reject(V(i.reason));
                else
                  throw new Error("Unexpected callback case");
                return;
              }
              const P = this.actionHandler[i.action];
              if (!P)
                throw new Error(`Unknown action from worker: ${i.action}`);
              if (i.callbackId) {
                const d = this.sourceName, A = i.sourceName;
                new Promise(function(I) {
                  I(P(i.data));
                }).then(function(I) {
                  g.postMessage({
                    sourceName: d,
                    targetName: A,
                    callback: fe.DATA,
                    callbackId: i.callbackId,
                    data: I
                  });
                }, function(I) {
                  g.postMessage({
                    sourceName: d,
                    targetName: A,
                    callback: fe.ERROR,
                    callbackId: i.callbackId,
                    reason: V(I)
                  });
                });
                return;
              }
              if (i.streamId) {
                De(this, F, Ha).call(this, i);
                return;
              }
              P(i.data);
            }, g.addEventListener("message", this._onComObjOnMessage);
          }
          on(O, v) {
            const g = this.actionHandler;
            if (g[O])
              throw new Error(`There is already an actionName called "${O}"`);
            g[O] = v;
          }
          send(O, v, g) {
            this.comObj.postMessage({
              sourceName: this.sourceName,
              targetName: this.targetName,
              action: O,
              data: v
            }, g);
          }
          sendWithPromise(O, v, g) {
            const b = this.callbackId++, i = new de.PromiseCapability();
            this.callbackCapabilities[b] = i;
            try {
              this.comObj.postMessage({
                sourceName: this.sourceName,
                targetName: this.targetName,
                action: O,
                callbackId: b,
                data: v
              }, g);
            } catch (P) {
              i.reject(P);
            }
            return i.promise;
          }
          sendWithStream(O, v, g, b) {
            const i = this.streamId++, P = this.sourceName, d = this.targetName, A = this.comObj;
            return new ReadableStream({
              start: (I) => {
                const E = new de.PromiseCapability();
                return this.streamControllers[i] = {
                  controller: I,
                  startCall: E,
                  pullCall: null,
                  cancelCall: null,
                  isClosed: !1
                }, A.postMessage({
                  sourceName: P,
                  targetName: d,
                  action: O,
                  streamId: i,
                  data: v,
                  desiredSize: I.desiredSize
                }, b), E.promise;
              },
              pull: (I) => {
                const E = new de.PromiseCapability();
                return this.streamControllers[i].pullCall = E, A.postMessage({
                  sourceName: P,
                  targetName: d,
                  stream: w.PULL,
                  streamId: i,
                  desiredSize: I.desiredSize
                }), E.promise;
              },
              cancel: (I) => {
                (0, de.assert)(I instanceof Error, "cancel must have a valid reason");
                const E = new de.PromiseCapability();
                return this.streamControllers[i].cancelCall = E, this.streamControllers[i].isClosed = !0, A.postMessage({
                  sourceName: P,
                  targetName: d,
                  stream: w.CANCEL,
                  streamId: i,
                  reason: V(I)
                }), E.promise;
              }
            }, g);
          }
          destroy() {
            this.comObj.removeEventListener("message", this._onComObjOnMessage);
          }
        }
        F = new WeakSet(), Ha = function(O) {
          const v = O.streamId, g = this.sourceName, b = O.sourceName, i = this.comObj, P = this, d = this.actionHandler[O.action], A = {
            enqueue(I, E = 1, k) {
              if (this.isCancelled)
                return;
              const H = this.desiredSize;
              this.desiredSize -= E, H > 0 && this.desiredSize <= 0 && (this.sinkCapability = new de.PromiseCapability(), this.ready = this.sinkCapability.promise), i.postMessage({
                sourceName: g,
                targetName: b,
                stream: w.ENQUEUE,
                streamId: v,
                chunk: I
              }, k);
            },
            close() {
              this.isCancelled || (this.isCancelled = !0, i.postMessage({
                sourceName: g,
                targetName: b,
                stream: w.CLOSE,
                streamId: v
              }), delete P.streamSinks[v]);
            },
            error(I) {
              (0, de.assert)(I instanceof Error, "error must have a valid reason"), !this.isCancelled && (this.isCancelled = !0, i.postMessage({
                sourceName: g,
                targetName: b,
                stream: w.ERROR,
                streamId: v,
                reason: V(I)
              }));
            },
            sinkCapability: new de.PromiseCapability(),
            onPull: null,
            onCancel: null,
            isCancelled: !1,
            desiredSize: O.desiredSize,
            ready: null
          };
          A.sinkCapability.resolve(), A.ready = A.sinkCapability.promise, this.streamSinks[v] = A, new Promise(function(I) {
            I(d(O.data, A));
          }).then(function() {
            i.postMessage({
              sourceName: g,
              targetName: b,
              stream: w.START_COMPLETE,
              streamId: v,
              success: !0
            });
          }, function(I) {
            i.postMessage({
              sourceName: g,
              targetName: b,
              stream: w.START_COMPLETE,
              streamId: v,
              reason: V(I)
            });
          });
        }, e = new WeakSet(), Xa = function(O) {
          const v = O.streamId, g = this.sourceName, b = O.sourceName, i = this.comObj, P = this.streamControllers[v], d = this.streamSinks[v];
          switch (O.stream) {
            case w.START_COMPLETE:
              O.success ? P.startCall.resolve() : P.startCall.reject(V(O.reason));
              break;
            case w.PULL_COMPLETE:
              O.success ? P.pullCall.resolve() : P.pullCall.reject(V(O.reason));
              break;
            case w.PULL:
              if (!d) {
                i.postMessage({
                  sourceName: g,
                  targetName: b,
                  stream: w.PULL_COMPLETE,
                  streamId: v,
                  success: !0
                });
                break;
              }
              d.desiredSize <= 0 && O.desiredSize > 0 && d.sinkCapability.resolve(), d.desiredSize = O.desiredSize, new Promise(function(A) {
                var I;
                A((I = d.onPull) == null ? void 0 : I.call(d));
              }).then(function() {
                i.postMessage({
                  sourceName: g,
                  targetName: b,
                  stream: w.PULL_COMPLETE,
                  streamId: v,
                  success: !0
                });
              }, function(A) {
                i.postMessage({
                  sourceName: g,
                  targetName: b,
                  stream: w.PULL_COMPLETE,
                  streamId: v,
                  reason: V(A)
                });
              });
              break;
            case w.ENQUEUE:
              if ((0, de.assert)(P, "enqueue should have stream controller"), P.isClosed)
                break;
              P.controller.enqueue(O.chunk);
              break;
            case w.CLOSE:
              if ((0, de.assert)(P, "close should have stream controller"), P.isClosed)
                break;
              P.isClosed = !0, P.controller.close(), De(this, l, Zn).call(this, P, v);
              break;
            case w.ERROR:
              (0, de.assert)(P, "error should have stream controller"), P.controller.error(V(O.reason)), De(this, l, Zn).call(this, P, v);
              break;
            case w.CANCEL_COMPLETE:
              O.success ? P.cancelCall.resolve() : P.cancelCall.reject(V(O.reason)), De(this, l, Zn).call(this, P, v);
              break;
            case w.CANCEL:
              if (!d)
                break;
              new Promise(function(A) {
                var I;
                A((I = d.onCancel) == null ? void 0 : I.call(d, V(O.reason)));
              }).then(function() {
                i.postMessage({
                  sourceName: g,
                  targetName: b,
                  stream: w.CANCEL_COMPLETE,
                  streamId: v,
                  success: !0
                });
              }, function(A) {
                i.postMessage({
                  sourceName: g,
                  targetName: b,
                  stream: w.CANCEL_COMPLETE,
                  streamId: v,
                  reason: V(A)
                });
              }), d.sinkCapability.reject(V(O.reason)), d.isCancelled = !0, delete this.streamSinks[v];
              break;
            default:
              throw new Error("Unexpected stream case");
          }
        }, l = new WeakSet(), Zn = async function(O, v) {
          var g, b, i;
          await Promise.allSettled([(g = O.startCall) == null ? void 0 : g.promise, (b = O.pullCall) == null ? void 0 : b.promise, (i = O.cancelCall) == null ? void 0 : i.promise]), delete this.streamControllers[v];
        }, ge.MessageHandler = n;
      },
      /* 16 */
      /***/
      (Re, ge, xe) => {
        var w, V;
        Object.defineProperty(ge, "__esModule", {
          value: !0
        }), ge.Metadata = void 0;
        var de = xe(1);
        class fe {
          constructor({
            parsedData: F,
            rawData: C
          }) {
            Me(this, w, void 0);
            Me(this, V, void 0);
            Xe(this, w, F), Xe(this, V, C);
          }
          getRaw() {
            return le(this, V);
          }
          get(F) {
            return le(this, w).get(F) ?? null;
          }
          getAll() {
            return (0, de.objectFromMap)(le(this, w));
          }
          has(F) {
            return le(this, w).has(F);
          }
        }
        w = new WeakMap(), V = new WeakMap(), ge.Metadata = fe;
      },
      /* 17 */
      /***/
      (Re, ge, xe) => {
        var F, C, e, t, l, j, ia;
        Object.defineProperty(ge, "__esModule", {
          value: !0
        }), ge.OptionalContentConfig = void 0;
        var de = xe(1), fe = xe(8);
        const w = Symbol("INTERNAL");
        class V {
          constructor(v, g) {
            Me(this, F, !0);
            this.name = v, this.intent = g;
          }
          get visible() {
            return le(this, F);
          }
          _setVisible(v, g) {
            v !== w && (0, de.unreachable)("Internal method `_setVisible` called."), Xe(this, F, g);
          }
        }
        F = new WeakMap();
        class n {
          constructor(v) {
            Me(this, j);
            Me(this, C, null);
            Me(this, e, /* @__PURE__ */ new Map());
            Me(this, t, null);
            Me(this, l, null);
            if (this.name = null, this.creator = null, v !== null) {
              this.name = v.name, this.creator = v.creator, Xe(this, l, v.order);
              for (const g of v.groups)
                le(this, e).set(g.id, new V(g.name, g.intent));
              if (v.baseState === "OFF")
                for (const g of le(this, e).values())
                  g._setVisible(w, !1);
              for (const g of v.on)
                le(this, e).get(g)._setVisible(w, !0);
              for (const g of v.off)
                le(this, e).get(g)._setVisible(w, !1);
              Xe(this, t, this.getHash());
            }
          }
          isVisible(v) {
            if (le(this, e).size === 0)
              return !0;
            if (!v)
              return (0, de.warn)("Optional content group not defined."), !0;
            if (v.type === "OCG")
              return le(this, e).has(v.id) ? le(this, e).get(v.id).visible : ((0, de.warn)(`Optional content group not found: ${v.id}`), !0);
            if (v.type === "OCMD") {
              if (v.expression)
                return De(this, j, ia).call(this, v.expression);
              if (!v.policy || v.policy === "AnyOn") {
                for (const g of v.ids) {
                  if (!le(this, e).has(g))
                    return (0, de.warn)(`Optional content group not found: ${g}`), !0;
                  if (le(this, e).get(g).visible)
                    return !0;
                }
                return !1;
              } else if (v.policy === "AllOn") {
                for (const g of v.ids) {
                  if (!le(this, e).has(g))
                    return (0, de.warn)(`Optional content group not found: ${g}`), !0;
                  if (!le(this, e).get(g).visible)
                    return !1;
                }
                return !0;
              } else if (v.policy === "AnyOff") {
                for (const g of v.ids) {
                  if (!le(this, e).has(g))
                    return (0, de.warn)(`Optional content group not found: ${g}`), !0;
                  if (!le(this, e).get(g).visible)
                    return !0;
                }
                return !1;
              } else if (v.policy === "AllOff") {
                for (const g of v.ids) {
                  if (!le(this, e).has(g))
                    return (0, de.warn)(`Optional content group not found: ${g}`), !0;
                  if (le(this, e).get(g).visible)
                    return !1;
                }
                return !0;
              }
              return (0, de.warn)(`Unknown optional content policy ${v.policy}.`), !0;
            }
            return (0, de.warn)(`Unknown group type ${v.type}.`), !0;
          }
          setVisibility(v, g = !0) {
            if (!le(this, e).has(v)) {
              (0, de.warn)(`Optional content group not found: ${v}`);
              return;
            }
            le(this, e).get(v)._setVisible(w, !!g), Xe(this, C, null);
          }
          get hasInitialVisibility() {
            return le(this, t) === null || this.getHash() === le(this, t);
          }
          getOrder() {
            return le(this, e).size ? le(this, l) ? le(this, l).slice() : [...le(this, e).keys()] : null;
          }
          getGroups() {
            return le(this, e).size > 0 ? (0, de.objectFromMap)(le(this, e)) : null;
          }
          getGroup(v) {
            return le(this, e).get(v) || null;
          }
          getHash() {
            if (le(this, C) !== null)
              return le(this, C);
            const v = new fe.MurmurHash3_64();
            for (const [g, b] of le(this, e))
              v.update(`${g}:${b.visible}`);
            return Xe(this, C, v.hexdigest());
          }
        }
        C = new WeakMap(), e = new WeakMap(), t = new WeakMap(), l = new WeakMap(), j = new WeakSet(), ia = function(v) {
          const g = v.length;
          if (g < 2)
            return !0;
          const b = v[0];
          for (let i = 1; i < g; i++) {
            const P = v[i];
            let d;
            if (Array.isArray(P))
              d = De(this, j, ia).call(this, P);
            else if (le(this, e).has(P))
              d = le(this, e).get(P).visible;
            else
              return (0, de.warn)(`Optional content group not found: ${P}`), !0;
            switch (b) {
              case "And":
                if (!d)
                  return !1;
                break;
              case "Or":
                if (d)
                  return !0;
                break;
              case "Not":
                return !d;
              default:
                return !0;
            }
          }
          return b === "And";
        }, ge.OptionalContentConfig = n;
      },
      /* 18 */
      /***/
      (Re, ge, xe) => {
        Object.defineProperty(ge, "__esModule", {
          value: !0
        }), ge.PDFDataTransportStream = void 0;
        var de = xe(1), fe = xe(6);
        class w {
          constructor({
            length: C,
            initialData: e,
            progressiveDone: t = !1,
            contentDispositionFilename: l = null,
            disableRange: j = !1,
            disableStream: U = !1
          }, O) {
            if ((0, de.assert)(O, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.'), this._queuedChunks = [], this._progressiveDone = t, this._contentDispositionFilename = l, (e == null ? void 0 : e.length) > 0) {
              const v = e instanceof Uint8Array && e.byteLength === e.buffer.byteLength ? e.buffer : new Uint8Array(e).buffer;
              this._queuedChunks.push(v);
            }
            this._pdfDataRangeTransport = O, this._isStreamingSupported = !U, this._isRangeSupported = !j, this._contentLength = C, this._fullRequestReader = null, this._rangeReaders = [], this._pdfDataRangeTransport.addRangeListener((v, g) => {
              this._onReceiveData({
                begin: v,
                chunk: g
              });
            }), this._pdfDataRangeTransport.addProgressListener((v, g) => {
              this._onProgress({
                loaded: v,
                total: g
              });
            }), this._pdfDataRangeTransport.addProgressiveReadListener((v) => {
              this._onReceiveData({
                chunk: v
              });
            }), this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
              this._onProgressiveDone();
            }), this._pdfDataRangeTransport.transportReady();
          }
          _onReceiveData({
            begin: C,
            chunk: e
          }) {
            const t = e instanceof Uint8Array && e.byteLength === e.buffer.byteLength ? e.buffer : new Uint8Array(e).buffer;
            if (C === void 0)
              this._fullRequestReader ? this._fullRequestReader._enqueue(t) : this._queuedChunks.push(t);
            else {
              const l = this._rangeReaders.some(function(j) {
                return j._begin !== C ? !1 : (j._enqueue(t), !0);
              });
              (0, de.assert)(l, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
            }
          }
          get _progressiveDataLength() {
            var C;
            return ((C = this._fullRequestReader) == null ? void 0 : C._loaded) ?? 0;
          }
          _onProgress(C) {
            var e, t, l, j;
            C.total === void 0 ? (t = (e = this._rangeReaders[0]) == null ? void 0 : e.onProgress) == null || t.call(e, {
              loaded: C.loaded
            }) : (j = (l = this._fullRequestReader) == null ? void 0 : l.onProgress) == null || j.call(l, {
              loaded: C.loaded,
              total: C.total
            });
          }
          _onProgressiveDone() {
            var C;
            (C = this._fullRequestReader) == null || C.progressiveDone(), this._progressiveDone = !0;
          }
          _removeRangeReader(C) {
            const e = this._rangeReaders.indexOf(C);
            e >= 0 && this._rangeReaders.splice(e, 1);
          }
          getFullReader() {
            (0, de.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
            const C = this._queuedChunks;
            return this._queuedChunks = null, new V(this, C, this._progressiveDone, this._contentDispositionFilename);
          }
          getRangeReader(C, e) {
            if (e <= this._progressiveDataLength)
              return null;
            const t = new n(this, C, e);
            return this._pdfDataRangeTransport.requestDataRange(C, e), this._rangeReaders.push(t), t;
          }
          cancelAllRequests(C) {
            var e;
            (e = this._fullRequestReader) == null || e.cancel(C);
            for (const t of this._rangeReaders.slice(0))
              t.cancel(C);
            this._pdfDataRangeTransport.abort();
          }
        }
        ge.PDFDataTransportStream = w;
        class V {
          constructor(C, e, t = !1, l = null) {
            this._stream = C, this._done = t || !1, this._filename = (0, fe.isPdfFile)(l) ? l : null, this._queuedChunks = e || [], this._loaded = 0;
            for (const j of this._queuedChunks)
              this._loaded += j.byteLength;
            this._requests = [], this._headersReady = Promise.resolve(), C._fullRequestReader = this, this.onProgress = null;
          }
          _enqueue(C) {
            this._done || (this._requests.length > 0 ? this._requests.shift().resolve({
              value: C,
              done: !1
            }) : this._queuedChunks.push(C), this._loaded += C.byteLength);
          }
          get headersReady() {
            return this._headersReady;
          }
          get filename() {
            return this._filename;
          }
          get isRangeSupported() {
            return this._stream._isRangeSupported;
          }
          get isStreamingSupported() {
            return this._stream._isStreamingSupported;
          }
          get contentLength() {
            return this._stream._contentLength;
          }
          async read() {
            if (this._queuedChunks.length > 0)
              return {
                value: this._queuedChunks.shift(),
                done: !1
              };
            if (this._done)
              return {
                value: void 0,
                done: !0
              };
            const C = new de.PromiseCapability();
            return this._requests.push(C), C.promise;
          }
          cancel(C) {
            this._done = !0;
            for (const e of this._requests)
              e.resolve({
                value: void 0,
                done: !0
              });
            this._requests.length = 0;
          }
          progressiveDone() {
            this._done || (this._done = !0);
          }
        }
        class n {
          constructor(C, e, t) {
            this._stream = C, this._begin = e, this._end = t, this._queuedChunk = null, this._requests = [], this._done = !1, this.onProgress = null;
          }
          _enqueue(C) {
            if (!this._done) {
              if (this._requests.length === 0)
                this._queuedChunk = C;
              else {
                this._requests.shift().resolve({
                  value: C,
                  done: !1
                });
                for (const t of this._requests)
                  t.resolve({
                    value: void 0,
                    done: !0
                  });
                this._requests.length = 0;
              }
              this._done = !0, this._stream._removeRangeReader(this);
            }
          }
          get isStreamingSupported() {
            return !1;
          }
          async read() {
            if (this._queuedChunk) {
              const e = this._queuedChunk;
              return this._queuedChunk = null, {
                value: e,
                done: !1
              };
            }
            if (this._done)
              return {
                value: void 0,
                done: !0
              };
            const C = new de.PromiseCapability();
            return this._requests.push(C), C.promise;
          }
          cancel(C) {
            this._done = !0;
            for (const e of this._requests)
              e.resolve({
                value: void 0,
                done: !0
              });
            this._requests.length = 0, this._stream._removeRangeReader(this);
          }
        }
      },
      /* 19 */
      /***/
      (Re, ge, xe) => {
        Object.defineProperty(ge, "__esModule", {
          value: !0
        }), ge.PDFFetchStream = void 0;
        var de = xe(1), fe = xe(20);
        function w(t, l, j) {
          return {
            method: "GET",
            headers: t,
            signal: j.signal,
            mode: "cors",
            credentials: l ? "include" : "same-origin",
            redirect: "follow"
          };
        }
        function V(t) {
          const l = new Headers();
          for (const j in t) {
            const U = t[j];
            U !== void 0 && l.append(j, U);
          }
          return l;
        }
        function n(t) {
          return t instanceof Uint8Array ? t.buffer : t instanceof ArrayBuffer ? t : ((0, de.warn)(`getArrayBuffer - unexpected data format: ${t}`), new Uint8Array(t).buffer);
        }
        class F {
          constructor(l) {
            this.source = l, this.isHttp = /^https?:/i.test(l.url), this.httpHeaders = this.isHttp && l.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
          }
          get _progressiveDataLength() {
            var l;
            return ((l = this._fullRequestReader) == null ? void 0 : l._loaded) ?? 0;
          }
          getFullReader() {
            return (0, de.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once."), this._fullRequestReader = new C(this), this._fullRequestReader;
          }
          getRangeReader(l, j) {
            if (j <= this._progressiveDataLength)
              return null;
            const U = new e(this, l, j);
            return this._rangeRequestReaders.push(U), U;
          }
          cancelAllRequests(l) {
            var j;
            (j = this._fullRequestReader) == null || j.cancel(l);
            for (const U of this._rangeRequestReaders.slice(0))
              U.cancel(l);
          }
        }
        ge.PDFFetchStream = F;
        class C {
          constructor(l) {
            this._stream = l, this._reader = null, this._loaded = 0, this._filename = null;
            const j = l.source;
            this._withCredentials = j.withCredentials || !1, this._contentLength = j.length, this._headersCapability = new de.PromiseCapability(), this._disableRange = j.disableRange || !1, this._rangeChunkSize = j.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._abortController = new AbortController(), this._isStreamingSupported = !j.disableStream, this._isRangeSupported = !j.disableRange, this._headers = V(this._stream.httpHeaders);
            const U = j.url;
            fetch(U, w(this._headers, this._withCredentials, this._abortController)).then((O) => {
              if (!(0, fe.validateResponseStatus)(O.status))
                throw (0, fe.createResponseStatusError)(O.status, U);
              this._reader = O.body.getReader(), this._headersCapability.resolve();
              const v = (i) => O.headers.get(i), {
                allowRangeRequests: g,
                suggestedLength: b
              } = (0, fe.validateRangeRequestCapabilities)({
                getResponseHeader: v,
                isHttp: this._stream.isHttp,
                rangeChunkSize: this._rangeChunkSize,
                disableRange: this._disableRange
              });
              this._isRangeSupported = g, this._contentLength = b || this._contentLength, this._filename = (0, fe.extractFilenameFromHeader)(v), !this._isStreamingSupported && this._isRangeSupported && this.cancel(new de.AbortException("Streaming is disabled."));
            }).catch(this._headersCapability.reject), this.onProgress = null;
          }
          get headersReady() {
            return this._headersCapability.promise;
          }
          get filename() {
            return this._filename;
          }
          get contentLength() {
            return this._contentLength;
          }
          get isRangeSupported() {
            return this._isRangeSupported;
          }
          get isStreamingSupported() {
            return this._isStreamingSupported;
          }
          async read() {
            var U;
            await this._headersCapability.promise;
            const {
              value: l,
              done: j
            } = await this._reader.read();
            return j ? {
              value: l,
              done: j
            } : (this._loaded += l.byteLength, (U = this.onProgress) == null || U.call(this, {
              loaded: this._loaded,
              total: this._contentLength
            }), {
              value: n(l),
              done: !1
            });
          }
          cancel(l) {
            var j;
            (j = this._reader) == null || j.cancel(l), this._abortController.abort();
          }
        }
        class e {
          constructor(l, j, U) {
            this._stream = l, this._reader = null, this._loaded = 0;
            const O = l.source;
            this._withCredentials = O.withCredentials || !1, this._readCapability = new de.PromiseCapability(), this._isStreamingSupported = !O.disableStream, this._abortController = new AbortController(), this._headers = V(this._stream.httpHeaders), this._headers.append("Range", `bytes=${j}-${U - 1}`);
            const v = O.url;
            fetch(v, w(this._headers, this._withCredentials, this._abortController)).then((g) => {
              if (!(0, fe.validateResponseStatus)(g.status))
                throw (0, fe.createResponseStatusError)(g.status, v);
              this._readCapability.resolve(), this._reader = g.body.getReader();
            }).catch(this._readCapability.reject), this.onProgress = null;
          }
          get isStreamingSupported() {
            return this._isStreamingSupported;
          }
          async read() {
            var U;
            await this._readCapability.promise;
            const {
              value: l,
              done: j
            } = await this._reader.read();
            return j ? {
              value: l,
              done: j
            } : (this._loaded += l.byteLength, (U = this.onProgress) == null || U.call(this, {
              loaded: this._loaded
            }), {
              value: n(l),
              done: !1
            });
          }
          cancel(l) {
            var j;
            (j = this._reader) == null || j.cancel(l), this._abortController.abort();
          }
        }
      },
      /* 20 */
      /***/
      (Re, ge, xe) => {
        Object.defineProperty(ge, "__esModule", {
          value: !0
        }), ge.createResponseStatusError = F, ge.extractFilenameFromHeader = n, ge.validateRangeRequestCapabilities = V, ge.validateResponseStatus = C;
        var de = xe(1), fe = xe(21), w = xe(6);
        function V({
          getResponseHeader: e,
          isHttp: t,
          rangeChunkSize: l,
          disableRange: j
        }) {
          const U = {
            allowRangeRequests: !1,
            suggestedLength: void 0
          }, O = parseInt(e("Content-Length"), 10);
          return !Number.isInteger(O) || (U.suggestedLength = O, O <= 2 * l) || j || !t || e("Accept-Ranges") !== "bytes" || (e("Content-Encoding") || "identity") !== "identity" || (U.allowRangeRequests = !0), U;
        }
        function n(e) {
          const t = e("Content-Disposition");
          if (t) {
            let l = (0, fe.getFilenameFromContentDispositionHeader)(t);
            if (l.includes("%"))
              try {
                l = decodeURIComponent(l);
              } catch {
              }
            if ((0, w.isPdfFile)(l))
              return l;
          }
          return null;
        }
        function F(e, t) {
          return e === 404 || e === 0 && t.startsWith("file:") ? new de.MissingPDFException('Missing PDF "' + t + '".') : new de.UnexpectedResponseException(`Unexpected server response (${e}) while retrieving PDF "${t}".`, e);
        }
        function C(e) {
          return e === 200 || e === 206;
        }
      },
      /* 21 */
      /***/
      (Re, ge, xe) => {
        Object.defineProperty(ge, "__esModule", {
          value: !0
        }), ge.getFilenameFromContentDispositionHeader = fe;
        var de = xe(1);
        function fe(w) {
          let V = !0, n = F("filename\\*", "i").exec(w);
          if (n) {
            n = n[1];
            let O = l(n);
            return O = unescape(O), O = j(O), O = U(O), e(O);
          }
          if (n = t(w), n) {
            const O = U(n);
            return e(O);
          }
          if (n = F("filename", "i").exec(w), n) {
            n = n[1];
            let O = l(n);
            return O = U(O), e(O);
          }
          function F(O, v) {
            return new RegExp("(?:^|;)\\s*" + O + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', v);
          }
          function C(O, v) {
            if (O) {
              if (!/^[\x00-\xFF]+$/.test(v))
                return v;
              try {
                const g = new TextDecoder(O, {
                  fatal: !0
                }), b = (0, de.stringToBytes)(v);
                v = g.decode(b), V = !1;
              } catch {
              }
            }
            return v;
          }
          function e(O) {
            return V && /[\x80-\xff]/.test(O) && (O = C("utf-8", O), V && (O = C("iso-8859-1", O))), O;
          }
          function t(O) {
            const v = [];
            let g;
            const b = F("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
            for (; (g = b.exec(O)) !== null; ) {
              let [, P, d, A] = g;
              if (P = parseInt(P, 10), P in v) {
                if (P === 0)
                  break;
                continue;
              }
              v[P] = [d, A];
            }
            const i = [];
            for (let P = 0; P < v.length && P in v; ++P) {
              let [d, A] = v[P];
              A = l(A), d && (A = unescape(A), P === 0 && (A = j(A))), i.push(A);
            }
            return i.join("");
          }
          function l(O) {
            if (O.startsWith('"')) {
              const v = O.slice(1).split('\\"');
              for (let g = 0; g < v.length; ++g) {
                const b = v[g].indexOf('"');
                b !== -1 && (v[g] = v[g].slice(0, b), v.length = g + 1), v[g] = v[g].replaceAll(/\\(.)/g, "$1");
              }
              O = v.join('"');
            }
            return O;
          }
          function j(O) {
            const v = O.indexOf("'");
            if (v === -1)
              return O;
            const g = O.slice(0, v), i = O.slice(v + 1).replace(/^[^']*'/, "");
            return C(g, i);
          }
          function U(O) {
            return !O.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(O) ? O : O.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(v, g, b, i) {
              if (b === "q" || b === "Q")
                return i = i.replaceAll("_", " "), i = i.replaceAll(/=([0-9a-fA-F]{2})/g, function(P, d) {
                  return String.fromCharCode(parseInt(d, 16));
                }), C(g, i);
              try {
                i = atob(i);
              } catch {
              }
              return C(g, i);
            });
          }
          return "";
        }
      },
      /* 22 */
      /***/
      (Re, ge, xe) => {
        Object.defineProperty(ge, "__esModule", {
          value: !0
        }), ge.PDFNetworkStream = void 0;
        var de = xe(1), fe = xe(20);
        const w = 200, V = 206;
        function n(l) {
          const j = l.response;
          return typeof j != "string" ? j : (0, de.stringToBytes)(j).buffer;
        }
        class F {
          constructor(j, U = {}) {
            this.url = j, this.isHttp = /^https?:/i.test(j), this.httpHeaders = this.isHttp && U.httpHeaders || /* @__PURE__ */ Object.create(null), this.withCredentials = U.withCredentials || !1, this.currXhrId = 0, this.pendingRequests = /* @__PURE__ */ Object.create(null);
          }
          requestRange(j, U, O) {
            const v = {
              begin: j,
              end: U
            };
            for (const g in O)
              v[g] = O[g];
            return this.request(v);
          }
          requestFull(j) {
            return this.request(j);
          }
          request(j) {
            const U = new XMLHttpRequest(), O = this.currXhrId++, v = this.pendingRequests[O] = {
              xhr: U
            };
            U.open("GET", this.url), U.withCredentials = this.withCredentials;
            for (const g in this.httpHeaders) {
              const b = this.httpHeaders[g];
              b !== void 0 && U.setRequestHeader(g, b);
            }
            return this.isHttp && "begin" in j && "end" in j ? (U.setRequestHeader("Range", `bytes=${j.begin}-${j.end - 1}`), v.expectedStatus = V) : v.expectedStatus = w, U.responseType = "arraybuffer", j.onError && (U.onerror = function(g) {
              j.onError(U.status);
            }), U.onreadystatechange = this.onStateChange.bind(this, O), U.onprogress = this.onProgress.bind(this, O), v.onHeadersReceived = j.onHeadersReceived, v.onDone = j.onDone, v.onError = j.onError, v.onProgress = j.onProgress, U.send(null), O;
          }
          onProgress(j, U) {
            var v;
            const O = this.pendingRequests[j];
            O && ((v = O.onProgress) == null || v.call(O, U));
          }
          onStateChange(j, U) {
            var P, d, A;
            const O = this.pendingRequests[j];
            if (!O)
              return;
            const v = O.xhr;
            if (v.readyState >= 2 && O.onHeadersReceived && (O.onHeadersReceived(), delete O.onHeadersReceived), v.readyState !== 4 || !(j in this.pendingRequests))
              return;
            if (delete this.pendingRequests[j], v.status === 0 && this.isHttp) {
              (P = O.onError) == null || P.call(O, v.status);
              return;
            }
            const g = v.status || w;
            if (!(g === w && O.expectedStatus === V) && g !== O.expectedStatus) {
              (d = O.onError) == null || d.call(O, v.status);
              return;
            }
            const i = n(v);
            if (g === V) {
              const I = v.getResponseHeader("Content-Range"), E = /bytes (\d+)-(\d+)\/(\d+)/.exec(I);
              O.onDone({
                begin: parseInt(E[1], 10),
                chunk: i
              });
            } else
              i ? O.onDone({
                begin: 0,
                chunk: i
              }) : (A = O.onError) == null || A.call(O, v.status);
          }
          getRequestXhr(j) {
            return this.pendingRequests[j].xhr;
          }
          isPendingRequest(j) {
            return j in this.pendingRequests;
          }
          abortRequest(j) {
            const U = this.pendingRequests[j].xhr;
            delete this.pendingRequests[j], U.abort();
          }
        }
        class C {
          constructor(j) {
            this._source = j, this._manager = new F(j.url, {
              httpHeaders: j.httpHeaders,
              withCredentials: j.withCredentials
            }), this._rangeChunkSize = j.rangeChunkSize, this._fullRequestReader = null, this._rangeRequestReaders = [];
          }
          _onRangeRequestReaderClosed(j) {
            const U = this._rangeRequestReaders.indexOf(j);
            U >= 0 && this._rangeRequestReaders.splice(U, 1);
          }
          getFullReader() {
            return (0, de.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once."), this._fullRequestReader = new e(this._manager, this._source), this._fullRequestReader;
          }
          getRangeReader(j, U) {
            const O = new t(this._manager, j, U);
            return O.onClosed = this._onRangeRequestReaderClosed.bind(this), this._rangeRequestReaders.push(O), O;
          }
          cancelAllRequests(j) {
            var U;
            (U = this._fullRequestReader) == null || U.cancel(j);
            for (const O of this._rangeRequestReaders.slice(0))
              O.cancel(j);
          }
        }
        ge.PDFNetworkStream = C;
        class e {
          constructor(j, U) {
            this._manager = j;
            const O = {
              onHeadersReceived: this._onHeadersReceived.bind(this),
              onDone: this._onDone.bind(this),
              onError: this._onError.bind(this),
              onProgress: this._onProgress.bind(this)
            };
            this._url = U.url, this._fullRequestId = j.requestFull(O), this._headersReceivedCapability = new de.PromiseCapability(), this._disableRange = U.disableRange || !1, this._contentLength = U.length, this._rangeChunkSize = U.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !1, this._isRangeSupported = !1, this._cachedChunks = [], this._requests = [], this._done = !1, this._storedError = void 0, this._filename = null, this.onProgress = null;
          }
          _onHeadersReceived() {
            const j = this._fullRequestId, U = this._manager.getRequestXhr(j), O = (b) => U.getResponseHeader(b), {
              allowRangeRequests: v,
              suggestedLength: g
            } = (0, fe.validateRangeRequestCapabilities)({
              getResponseHeader: O,
              isHttp: this._manager.isHttp,
              rangeChunkSize: this._rangeChunkSize,
              disableRange: this._disableRange
            });
            v && (this._isRangeSupported = !0), this._contentLength = g || this._contentLength, this._filename = (0, fe.extractFilenameFromHeader)(O), this._isRangeSupported && this._manager.abortRequest(j), this._headersReceivedCapability.resolve();
          }
          _onDone(j) {
            if (j && (this._requests.length > 0 ? this._requests.shift().resolve({
              value: j.chunk,
              done: !1
            }) : this._cachedChunks.push(j.chunk)), this._done = !0, !(this._cachedChunks.length > 0)) {
              for (const U of this._requests)
                U.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0;
            }
          }
          _onError(j) {
            this._storedError = (0, fe.createResponseStatusError)(j, this._url), this._headersReceivedCapability.reject(this._storedError);
            for (const U of this._requests)
              U.reject(this._storedError);
            this._requests.length = 0, this._cachedChunks.length = 0;
          }
          _onProgress(j) {
            var U;
            (U = this.onProgress) == null || U.call(this, {
              loaded: j.loaded,
              total: j.lengthComputable ? j.total : this._contentLength
            });
          }
          get filename() {
            return this._filename;
          }
          get isRangeSupported() {
            return this._isRangeSupported;
          }
          get isStreamingSupported() {
            return this._isStreamingSupported;
          }
          get contentLength() {
            return this._contentLength;
          }
          get headersReady() {
            return this._headersReceivedCapability.promise;
          }
          async read() {
            if (this._storedError)
              throw this._storedError;
            if (this._cachedChunks.length > 0)
              return {
                value: this._cachedChunks.shift(),
                done: !1
              };
            if (this._done)
              return {
                value: void 0,
                done: !0
              };
            const j = new de.PromiseCapability();
            return this._requests.push(j), j.promise;
          }
          cancel(j) {
            this._done = !0, this._headersReceivedCapability.reject(j);
            for (const U of this._requests)
              U.resolve({
                value: void 0,
                done: !0
              });
            this._requests.length = 0, this._manager.isPendingRequest(this._fullRequestId) && this._manager.abortRequest(this._fullRequestId), this._fullRequestReader = null;
          }
        }
        class t {
          constructor(j, U, O) {
            this._manager = j;
            const v = {
              onDone: this._onDone.bind(this),
              onError: this._onError.bind(this),
              onProgress: this._onProgress.bind(this)
            };
            this._url = j.url, this._requestId = j.requestRange(U, O, v), this._requests = [], this._queuedChunk = null, this._done = !1, this._storedError = void 0, this.onProgress = null, this.onClosed = null;
          }
          _close() {
            var j;
            (j = this.onClosed) == null || j.call(this, this);
          }
          _onDone(j) {
            const U = j.chunk;
            this._requests.length > 0 ? this._requests.shift().resolve({
              value: U,
              done: !1
            }) : this._queuedChunk = U, this._done = !0;
            for (const O of this._requests)
              O.resolve({
                value: void 0,
                done: !0
              });
            this._requests.length = 0, this._close();
          }
          _onError(j) {
            this._storedError = (0, fe.createResponseStatusError)(j, this._url);
            for (const U of this._requests)
              U.reject(this._storedError);
            this._requests.length = 0, this._queuedChunk = null;
          }
          _onProgress(j) {
            var U;
            this.isStreamingSupported || (U = this.onProgress) == null || U.call(this, {
              loaded: j.loaded
            });
          }
          get isStreamingSupported() {
            return !1;
          }
          async read() {
            if (this._storedError)
              throw this._storedError;
            if (this._queuedChunk !== null) {
              const U = this._queuedChunk;
              return this._queuedChunk = null, {
                value: U,
                done: !1
              };
            }
            if (this._done)
              return {
                value: void 0,
                done: !0
              };
            const j = new de.PromiseCapability();
            return this._requests.push(j), j.promise;
          }
          cancel(j) {
            this._done = !0;
            for (const U of this._requests)
              U.resolve({
                value: void 0,
                done: !0
              });
            this._requests.length = 0, this._manager.isPendingRequest(this._requestId) && this._manager.abortRequest(this._requestId), this._close();
          }
        }
      },
      /* 23 */
      /***/
      (Re, ge, xe) => {
        Object.defineProperty(ge, "__esModule", {
          value: !0
        }), ge.PDFNodeStream = void 0;
        var de = xe(1), fe = xe(20);
        const w = /^file:\/\/\/[a-zA-Z]:\//;
        function V(O) {
          const v = require("url"), g = v.parse(O);
          return g.protocol === "file:" || g.host ? g : /^[a-z]:[/\\]/i.test(O) ? v.parse(`file:///${O}`) : (g.host || (g.protocol = "file:"), g);
        }
        class n {
          constructor(v) {
            this.source = v, this.url = V(v.url), this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:", this.isFsUrl = this.url.protocol === "file:", this.httpHeaders = this.isHttp && v.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
          }
          get _progressiveDataLength() {
            var v;
            return ((v = this._fullRequestReader) == null ? void 0 : v._loaded) ?? 0;
          }
          getFullReader() {
            return (0, de.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once."), this._fullRequestReader = this.isFsUrl ? new j(this) : new t(this), this._fullRequestReader;
          }
          getRangeReader(v, g) {
            if (g <= this._progressiveDataLength)
              return null;
            const b = this.isFsUrl ? new U(this, v, g) : new l(this, v, g);
            return this._rangeRequestReaders.push(b), b;
          }
          cancelAllRequests(v) {
            var g;
            (g = this._fullRequestReader) == null || g.cancel(v);
            for (const b of this._rangeRequestReaders.slice(0))
              b.cancel(v);
          }
        }
        ge.PDFNodeStream = n;
        class F {
          constructor(v) {
            this._url = v.url, this._done = !1, this._storedError = null, this.onProgress = null;
            const g = v.source;
            this._contentLength = g.length, this._loaded = 0, this._filename = null, this._disableRange = g.disableRange || !1, this._rangeChunkSize = g.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !g.disableStream, this._isRangeSupported = !g.disableRange, this._readableStream = null, this._readCapability = new de.PromiseCapability(), this._headersCapability = new de.PromiseCapability();
          }
          get headersReady() {
            return this._headersCapability.promise;
          }
          get filename() {
            return this._filename;
          }
          get contentLength() {
            return this._contentLength;
          }
          get isRangeSupported() {
            return this._isRangeSupported;
          }
          get isStreamingSupported() {
            return this._isStreamingSupported;
          }
          async read() {
            var b;
            if (await this._readCapability.promise, this._done)
              return {
                value: void 0,
                done: !0
              };
            if (this._storedError)
              throw this._storedError;
            const v = this._readableStream.read();
            return v === null ? (this._readCapability = new de.PromiseCapability(), this.read()) : (this._loaded += v.length, (b = this.onProgress) == null || b.call(this, {
              loaded: this._loaded,
              total: this._contentLength
            }), {
              value: new Uint8Array(v).buffer,
              done: !1
            });
          }
          cancel(v) {
            if (!this._readableStream) {
              this._error(v);
              return;
            }
            this._readableStream.destroy(v);
          }
          _error(v) {
            this._storedError = v, this._readCapability.resolve();
          }
          _setReadableStream(v) {
            this._readableStream = v, v.on("readable", () => {
              this._readCapability.resolve();
            }), v.on("end", () => {
              v.destroy(), this._done = !0, this._readCapability.resolve();
            }), v.on("error", (g) => {
              this._error(g);
            }), !this._isStreamingSupported && this._isRangeSupported && this._error(new de.AbortException("streaming is disabled")), this._storedError && this._readableStream.destroy(this._storedError);
          }
        }
        class C {
          constructor(v) {
            this._url = v.url, this._done = !1, this._storedError = null, this.onProgress = null, this._loaded = 0, this._readableStream = null, this._readCapability = new de.PromiseCapability();
            const g = v.source;
            this._isStreamingSupported = !g.disableStream;
          }
          get isStreamingSupported() {
            return this._isStreamingSupported;
          }
          async read() {
            var b;
            if (await this._readCapability.promise, this._done)
              return {
                value: void 0,
                done: !0
              };
            if (this._storedError)
              throw this._storedError;
            const v = this._readableStream.read();
            return v === null ? (this._readCapability = new de.PromiseCapability(), this.read()) : (this._loaded += v.length, (b = this.onProgress) == null || b.call(this, {
              loaded: this._loaded
            }), {
              value: new Uint8Array(v).buffer,
              done: !1
            });
          }
          cancel(v) {
            if (!this._readableStream) {
              this._error(v);
              return;
            }
            this._readableStream.destroy(v);
          }
          _error(v) {
            this._storedError = v, this._readCapability.resolve();
          }
          _setReadableStream(v) {
            this._readableStream = v, v.on("readable", () => {
              this._readCapability.resolve();
            }), v.on("end", () => {
              v.destroy(), this._done = !0, this._readCapability.resolve();
            }), v.on("error", (g) => {
              this._error(g);
            }), this._storedError && this._readableStream.destroy(this._storedError);
          }
        }
        function e(O, v) {
          return {
            protocol: O.protocol,
            auth: O.auth,
            host: O.hostname,
            port: O.port,
            path: O.path,
            method: "GET",
            headers: v
          };
        }
        class t extends F {
          constructor(v) {
            super(v);
            const g = (b) => {
              if (b.statusCode === 404) {
                const A = new de.MissingPDFException(`Missing PDF "${this._url}".`);
                this._storedError = A, this._headersCapability.reject(A);
                return;
              }
              this._headersCapability.resolve(), this._setReadableStream(b);
              const i = (A) => this._readableStream.headers[A.toLowerCase()], {
                allowRangeRequests: P,
                suggestedLength: d
              } = (0, fe.validateRangeRequestCapabilities)({
                getResponseHeader: i,
                isHttp: v.isHttp,
                rangeChunkSize: this._rangeChunkSize,
                disableRange: this._disableRange
              });
              this._isRangeSupported = P, this._contentLength = d || this._contentLength, this._filename = (0, fe.extractFilenameFromHeader)(i);
            };
            if (this._request = null, this._url.protocol === "http:") {
              const b = require("http");
              this._request = b.request(e(this._url, v.httpHeaders), g);
            } else {
              const b = require("https");
              this._request = b.request(e(this._url, v.httpHeaders), g);
            }
            this._request.on("error", (b) => {
              this._storedError = b, this._headersCapability.reject(b);
            }), this._request.end();
          }
        }
        class l extends C {
          constructor(v, g, b) {
            super(v), this._httpHeaders = {};
            for (const P in v.httpHeaders) {
              const d = v.httpHeaders[P];
              d !== void 0 && (this._httpHeaders[P] = d);
            }
            this._httpHeaders.Range = `bytes=${g}-${b - 1}`;
            const i = (P) => {
              if (P.statusCode === 404) {
                const d = new de.MissingPDFException(`Missing PDF "${this._url}".`);
                this._storedError = d;
                return;
              }
              this._setReadableStream(P);
            };
            if (this._request = null, this._url.protocol === "http:") {
              const P = require("http");
              this._request = P.request(e(this._url, this._httpHeaders), i);
            } else {
              const P = require("https");
              this._request = P.request(e(this._url, this._httpHeaders), i);
            }
            this._request.on("error", (P) => {
              this._storedError = P;
            }), this._request.end();
          }
        }
        class j extends F {
          constructor(v) {
            super(v);
            let g = decodeURIComponent(this._url.path);
            w.test(this._url.href) && (g = g.replace(/^\//, ""));
            const b = require("fs");
            b.lstat(g, (i, P) => {
              if (i) {
                i.code === "ENOENT" && (i = new de.MissingPDFException(`Missing PDF "${g}".`)), this._storedError = i, this._headersCapability.reject(i);
                return;
              }
              this._contentLength = P.size, this._setReadableStream(b.createReadStream(g)), this._headersCapability.resolve();
            });
          }
        }
        class U extends C {
          constructor(v, g, b) {
            super(v);
            let i = decodeURIComponent(this._url.path);
            w.test(this._url.href) && (i = i.replace(/^\//, ""));
            const P = require("fs");
            this._setReadableStream(P.createReadStream(i, {
              start: g,
              end: b - 1
            }));
          }
        }
      },
      /* 24 */
      /***/
      (Re, ge, xe) => {
        Object.defineProperty(ge, "__esModule", {
          value: !0
        }), ge.SVGGraphics = void 0;
        var de = xe(6), fe = xe(1);
        const w = {
          fontStyle: "normal",
          fontWeight: "normal",
          fillColor: "#000000"
        }, V = "http://www.w3.org/XML/1998/namespace", n = "http://www.w3.org/1999/xlink", F = ["butt", "round", "square"], C = ["miter", "round", "bevel"], e = function(P, d = "", A = !1) {
          if (URL.createObjectURL && typeof Blob < "u" && !A)
            return URL.createObjectURL(new Blob([P], {
              type: d
            }));
          const I = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          let E = `data:${d};base64,`;
          for (let k = 0, H = P.length; k < H; k += 3) {
            const x = P[k] & 255, R = P[k + 1] & 255, f = P[k + 2] & 255, c = x >> 2, N = (x & 3) << 4 | R >> 4, u = k + 1 < H ? (R & 15) << 2 | f >> 6 : 64, p = k + 2 < H ? f & 63 : 64;
            E += I[c] + I[N] + I[u] + I[p];
          }
          return E;
        }, t = function() {
          const P = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]), d = 12, A = new Int32Array(256);
          for (let f = 0; f < 256; f++) {
            let c = f;
            for (let N = 0; N < 8; N++)
              c = c & 1 ? 3988292384 ^ c >> 1 & 2147483647 : c >> 1 & 2147483647;
            A[f] = c;
          }
          function I(f, c, N) {
            let u = -1;
            for (let p = c; p < N; p++) {
              const S = (u ^ f[p]) & 255, B = A[S];
              u = u >>> 8 ^ B;
            }
            return u ^ -1;
          }
          function E(f, c, N, u) {
            let p = u;
            const S = c.length;
            N[p] = S >> 24 & 255, N[p + 1] = S >> 16 & 255, N[p + 2] = S >> 8 & 255, N[p + 3] = S & 255, p += 4, N[p] = f.charCodeAt(0) & 255, N[p + 1] = f.charCodeAt(1) & 255, N[p + 2] = f.charCodeAt(2) & 255, N[p + 3] = f.charCodeAt(3) & 255, p += 4, N.set(c, p), p += c.length;
            const B = I(N, u + 4, p);
            N[p] = B >> 24 & 255, N[p + 1] = B >> 16 & 255, N[p + 2] = B >> 8 & 255, N[p + 3] = B & 255;
          }
          function k(f, c, N) {
            let u = 1, p = 0;
            for (let S = c; S < N; ++S)
              u = (u + (f[S] & 255)) % 65521, p = (p + u) % 65521;
            return p << 16 | u;
          }
          function H(f) {
            if (!fe.isNodeJS)
              return x(f);
            try {
              const c = parseInt(process.versions.node) >= 8 ? f : Buffer.from(f), N = require("zlib").deflateSync(c, {
                level: 9
              });
              return N instanceof Uint8Array ? N : new Uint8Array(N);
            } catch (c) {
              (0, fe.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + c);
            }
            return x(f);
          }
          function x(f) {
            let c = f.length;
            const N = 65535, u = Math.ceil(c / N), p = new Uint8Array(2 + c + u * 5 + 4);
            let S = 0;
            p[S++] = 120, p[S++] = 156;
            let B = 0;
            for (; c > N; )
              p[S++] = 0, p[S++] = 255, p[S++] = 255, p[S++] = 0, p[S++] = 0, p.set(f.subarray(B, B + N), S), S += N, B += N, c -= N;
            p[S++] = 1, p[S++] = c & 255, p[S++] = c >> 8 & 255, p[S++] = ~c & 65535 & 255, p[S++] = (~c & 65535) >> 8 & 255, p.set(f.subarray(B), S), S += f.length - B;
            const T = k(f, 0, f.length);
            return p[S++] = T >> 24 & 255, p[S++] = T >> 16 & 255, p[S++] = T >> 8 & 255, p[S++] = T & 255, p;
          }
          function R(f, c, N, u) {
            const p = f.width, S = f.height;
            let B, T, D;
            const K = f.data;
            switch (c) {
              case fe.ImageKind.GRAYSCALE_1BPP:
                T = 0, B = 1, D = p + 7 >> 3;
                break;
              case fe.ImageKind.RGB_24BPP:
                T = 2, B = 8, D = p * 3;
                break;
              case fe.ImageKind.RGBA_32BPP:
                T = 6, B = 8, D = p * 4;
                break;
              default:
                throw new Error("invalid format");
            }
            const _ = new Uint8Array((1 + D) * S);
            let o = 0, m = 0;
            for (let G = 0; G < S; ++G)
              _[o++] = 0, _.set(K.subarray(m, m + D), o), m += D, o += D;
            if (c === fe.ImageKind.GRAYSCALE_1BPP && u) {
              o = 0;
              for (let G = 0; G < S; G++) {
                o++;
                for (let ce = 0; ce < D; ce++)
                  _[o++] ^= 255;
              }
            }
            const s = new Uint8Array([p >> 24 & 255, p >> 16 & 255, p >> 8 & 255, p & 255, S >> 24 & 255, S >> 16 & 255, S >> 8 & 255, S & 255, B, T, 0, 0, 0]), r = H(_), y = P.length + d * 3 + s.length + r.length, M = new Uint8Array(y);
            let $ = 0;
            return M.set(P, $), $ += P.length, E("IHDR", s, M, $), $ += d + s.length, E("IDATA", r, M, $), $ += d + r.length, E("IEND", new Uint8Array(0), M, $), e(M, "image/png", N);
          }
          return function(c, N, u) {
            const p = c.kind === void 0 ? fe.ImageKind.GRAYSCALE_1BPP : c.kind;
            return R(c, p, N, u);
          };
        }();
        class l {
          constructor() {
            this.fontSizeScale = 1, this.fontWeight = w.fontWeight, this.fontSize = 0, this.textMatrix = fe.IDENTITY_MATRIX, this.fontMatrix = fe.FONT_IDENTITY_MATRIX, this.leading = 0, this.textRenderingMode = fe.TextRenderingMode.FILL, this.textMatrixScale = 1, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRise = 0, this.fillColor = w.fillColor, this.strokeColor = "#000000", this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.lineJoin = "", this.lineCap = "", this.miterLimit = 0, this.dashArray = [], this.dashPhase = 0, this.dependencies = [], this.activeClipUrl = null, this.clipGroup = null, this.maskId = "";
          }
          clone() {
            return Object.create(this);
          }
          setCurrentPoint(d, A) {
            this.x = d, this.y = A;
          }
        }
        function j(P) {
          let d = [];
          const A = [];
          for (const I of P) {
            if (I.fn === "save") {
              d.push({
                fnId: 92,
                fn: "group",
                items: []
              }), A.push(d), d = d.at(-1).items;
              continue;
            }
            I.fn === "restore" ? d = A.pop() : d.push(I);
          }
          return d;
        }
        function U(P) {
          if (Number.isInteger(P))
            return P.toString();
          const d = P.toFixed(10);
          let A = d.length - 1;
          if (d[A] !== "0")
            return d;
          do
            A--;
          while (d[A] === "0");
          return d.substring(0, d[A] === "." ? A : A + 1);
        }
        function O(P) {
          if (P[4] === 0 && P[5] === 0) {
            if (P[1] === 0 && P[2] === 0)
              return P[0] === 1 && P[3] === 1 ? "" : `scale(${U(P[0])} ${U(P[3])})`;
            if (P[0] === P[3] && P[1] === -P[2]) {
              const d = Math.acos(P[0]) * 180 / Math.PI;
              return `rotate(${U(d)})`;
            }
          } else if (P[0] === 1 && P[1] === 0 && P[2] === 0 && P[3] === 1)
            return `translate(${U(P[4])} ${U(P[5])})`;
          return `matrix(${U(P[0])} ${U(P[1])} ${U(P[2])} ${U(P[3])} ${U(P[4])} ${U(P[5])})`;
        }
        let v = 0, g = 0, b = 0;
        class i {
          constructor(d, A, I = !1) {
            (0, de.deprecated)("The SVG back-end is no longer maintained and *may* be removed in the future."), this.svgFactory = new de.DOMSVGFactory(), this.current = new l(), this.transformMatrix = fe.IDENTITY_MATRIX, this.transformStack = [], this.extraStack = [], this.commonObjs = d, this.objs = A, this.pendingClip = null, this.pendingEOFill = !1, this.embedFonts = !1, this.embeddedFonts = /* @__PURE__ */ Object.create(null), this.cssStyle = null, this.forceDataSchema = !!I, this._operatorIdMapping = [];
            for (const E in fe.OPS)
              this._operatorIdMapping[fe.OPS[E]] = E;
          }
          getObject(d, A = null) {
            return typeof d == "string" ? d.startsWith("g_") ? this.commonObjs.get(d) : this.objs.get(d) : A;
          }
          save() {
            this.transformStack.push(this.transformMatrix);
            const d = this.current;
            this.extraStack.push(d), this.current = d.clone();
          }
          restore() {
            this.transformMatrix = this.transformStack.pop(), this.current = this.extraStack.pop(), this.pendingClip = null, this.tgrp = null;
          }
          group(d) {
            this.save(), this.executeOpTree(d), this.restore();
          }
          loadDependencies(d) {
            const A = d.fnArray, I = d.argsArray;
            for (let E = 0, k = A.length; E < k; E++)
              if (A[E] === fe.OPS.dependency)
                for (const H of I[E]) {
                  const x = H.startsWith("g_") ? this.commonObjs : this.objs, R = new Promise((f) => {
                    x.get(H, f);
                  });
                  this.current.dependencies.push(R);
                }
            return Promise.all(this.current.dependencies);
          }
          transform(d, A, I, E, k, H) {
            const x = [d, A, I, E, k, H];
            this.transformMatrix = fe.Util.transform(this.transformMatrix, x), this.tgrp = null;
          }
          getSVG(d, A) {
            this.viewport = A;
            const I = this._initialize(A);
            return this.loadDependencies(d).then(() => (this.transformMatrix = fe.IDENTITY_MATRIX, this.executeOpTree(this.convertOpList(d)), I));
          }
          convertOpList(d) {
            const A = this._operatorIdMapping, I = d.argsArray, E = d.fnArray, k = [];
            for (let H = 0, x = E.length; H < x; H++) {
              const R = E[H];
              k.push({
                fnId: R,
                fn: A[R],
                args: I[H]
              });
            }
            return j(k);
          }
          executeOpTree(d) {
            for (const A of d) {
              const I = A.fn, E = A.fnId, k = A.args;
              switch (E | 0) {
                case fe.OPS.beginText:
                  this.beginText();
                  break;
                case fe.OPS.dependency:
                  break;
                case fe.OPS.setLeading:
                  this.setLeading(k);
                  break;
                case fe.OPS.setLeadingMoveText:
                  this.setLeadingMoveText(k[0], k[1]);
                  break;
                case fe.OPS.setFont:
                  this.setFont(k);
                  break;
                case fe.OPS.showText:
                  this.showText(k[0]);
                  break;
                case fe.OPS.showSpacedText:
                  this.showText(k[0]);
                  break;
                case fe.OPS.endText:
                  this.endText();
                  break;
                case fe.OPS.moveText:
                  this.moveText(k[0], k[1]);
                  break;
                case fe.OPS.setCharSpacing:
                  this.setCharSpacing(k[0]);
                  break;
                case fe.OPS.setWordSpacing:
                  this.setWordSpacing(k[0]);
                  break;
                case fe.OPS.setHScale:
                  this.setHScale(k[0]);
                  break;
                case fe.OPS.setTextMatrix:
                  this.setTextMatrix(k[0], k[1], k[2], k[3], k[4], k[5]);
                  break;
                case fe.OPS.setTextRise:
                  this.setTextRise(k[0]);
                  break;
                case fe.OPS.setTextRenderingMode:
                  this.setTextRenderingMode(k[0]);
                  break;
                case fe.OPS.setLineWidth:
                  this.setLineWidth(k[0]);
                  break;
                case fe.OPS.setLineJoin:
                  this.setLineJoin(k[0]);
                  break;
                case fe.OPS.setLineCap:
                  this.setLineCap(k[0]);
                  break;
                case fe.OPS.setMiterLimit:
                  this.setMiterLimit(k[0]);
                  break;
                case fe.OPS.setFillRGBColor:
                  this.setFillRGBColor(k[0], k[1], k[2]);
                  break;
                case fe.OPS.setStrokeRGBColor:
                  this.setStrokeRGBColor(k[0], k[1], k[2]);
                  break;
                case fe.OPS.setStrokeColorN:
                  this.setStrokeColorN(k);
                  break;
                case fe.OPS.setFillColorN:
                  this.setFillColorN(k);
                  break;
                case fe.OPS.shadingFill:
                  this.shadingFill(k[0]);
                  break;
                case fe.OPS.setDash:
                  this.setDash(k[0], k[1]);
                  break;
                case fe.OPS.setRenderingIntent:
                  this.setRenderingIntent(k[0]);
                  break;
                case fe.OPS.setFlatness:
                  this.setFlatness(k[0]);
                  break;
                case fe.OPS.setGState:
                  this.setGState(k[0]);
                  break;
                case fe.OPS.fill:
                  this.fill();
                  break;
                case fe.OPS.eoFill:
                  this.eoFill();
                  break;
                case fe.OPS.stroke:
                  this.stroke();
                  break;
                case fe.OPS.fillStroke:
                  this.fillStroke();
                  break;
                case fe.OPS.eoFillStroke:
                  this.eoFillStroke();
                  break;
                case fe.OPS.clip:
                  this.clip("nonzero");
                  break;
                case fe.OPS.eoClip:
                  this.clip("evenodd");
                  break;
                case fe.OPS.paintSolidColorImageMask:
                  this.paintSolidColorImageMask();
                  break;
                case fe.OPS.paintImageXObject:
                  this.paintImageXObject(k[0]);
                  break;
                case fe.OPS.paintInlineImageXObject:
                  this.paintInlineImageXObject(k[0]);
                  break;
                case fe.OPS.paintImageMaskXObject:
                  this.paintImageMaskXObject(k[0]);
                  break;
                case fe.OPS.paintFormXObjectBegin:
                  this.paintFormXObjectBegin(k[0], k[1]);
                  break;
                case fe.OPS.paintFormXObjectEnd:
                  this.paintFormXObjectEnd();
                  break;
                case fe.OPS.closePath:
                  this.closePath();
                  break;
                case fe.OPS.closeStroke:
                  this.closeStroke();
                  break;
                case fe.OPS.closeFillStroke:
                  this.closeFillStroke();
                  break;
                case fe.OPS.closeEOFillStroke:
                  this.closeEOFillStroke();
                  break;
                case fe.OPS.nextLine:
                  this.nextLine();
                  break;
                case fe.OPS.transform:
                  this.transform(k[0], k[1], k[2], k[3], k[4], k[5]);
                  break;
                case fe.OPS.constructPath:
                  this.constructPath(k[0], k[1]);
                  break;
                case fe.OPS.endPath:
                  this.endPath();
                  break;
                case 92:
                  this.group(A.items);
                  break;
                default:
                  (0, fe.warn)(`Unimplemented operator ${I}`);
                  break;
              }
            }
          }
          setWordSpacing(d) {
            this.current.wordSpacing = d;
          }
          setCharSpacing(d) {
            this.current.charSpacing = d;
          }
          nextLine() {
            this.moveText(0, this.current.leading);
          }
          setTextMatrix(d, A, I, E, k, H) {
            const x = this.current;
            x.textMatrix = x.lineMatrix = [d, A, I, E, k, H], x.textMatrixScale = Math.hypot(d, A), x.x = x.lineX = 0, x.y = x.lineY = 0, x.xcoords = [], x.ycoords = [], x.tspan = this.svgFactory.createElement("svg:tspan"), x.tspan.setAttributeNS(null, "font-family", x.fontFamily), x.tspan.setAttributeNS(null, "font-size", `${U(x.fontSize)}px`), x.tspan.setAttributeNS(null, "y", U(-x.y)), x.txtElement = this.svgFactory.createElement("svg:text"), x.txtElement.append(x.tspan);
          }
          beginText() {
            const d = this.current;
            d.x = d.lineX = 0, d.y = d.lineY = 0, d.textMatrix = fe.IDENTITY_MATRIX, d.lineMatrix = fe.IDENTITY_MATRIX, d.textMatrixScale = 1, d.tspan = this.svgFactory.createElement("svg:tspan"), d.txtElement = this.svgFactory.createElement("svg:text"), d.txtgrp = this.svgFactory.createElement("svg:g"), d.xcoords = [], d.ycoords = [];
          }
          moveText(d, A) {
            const I = this.current;
            I.x = I.lineX += d, I.y = I.lineY += A, I.xcoords = [], I.ycoords = [], I.tspan = this.svgFactory.createElement("svg:tspan"), I.tspan.setAttributeNS(null, "font-family", I.fontFamily), I.tspan.setAttributeNS(null, "font-size", `${U(I.fontSize)}px`), I.tspan.setAttributeNS(null, "y", U(-I.y));
          }
          showText(d) {
            const A = this.current, I = A.font, E = A.fontSize;
            if (E === 0)
              return;
            const k = A.fontSizeScale, H = A.charSpacing, x = A.wordSpacing, R = A.fontDirection, f = A.textHScale * R, c = I.vertical, N = c ? 1 : -1, u = I.defaultVMetrics, p = E * A.fontMatrix[0];
            let S = 0;
            for (const D of d) {
              if (D === null) {
                S += R * x;
                continue;
              } else if (typeof D == "number") {
                S += N * D * E / 1e3;
                continue;
              }
              const K = (D.isSpace ? x : 0) + H, _ = D.fontChar;
              let o, m, s = D.width;
              if (c) {
                let y;
                const M = D.vmetric || u;
                y = D.vmetric ? M[1] : s * 0.5, y = -y * p;
                const $ = M[2] * p;
                s = M ? -M[0] : s, o = y / k, m = (S + $) / k;
              } else
                o = S / k, m = 0;
              (D.isInFont || I.missingFile) && (A.xcoords.push(A.x + o), c && A.ycoords.push(-A.y + m), A.tspan.textContent += _);
              const r = c ? s * p - K * R : s * p + K * R;
              S += r;
            }
            A.tspan.setAttributeNS(null, "x", A.xcoords.map(U).join(" ")), c ? A.tspan.setAttributeNS(null, "y", A.ycoords.map(U).join(" ")) : A.tspan.setAttributeNS(null, "y", U(-A.y)), c ? A.y -= S : A.x += S * f, A.tspan.setAttributeNS(null, "font-family", A.fontFamily), A.tspan.setAttributeNS(null, "font-size", `${U(A.fontSize)}px`), A.fontStyle !== w.fontStyle && A.tspan.setAttributeNS(null, "font-style", A.fontStyle), A.fontWeight !== w.fontWeight && A.tspan.setAttributeNS(null, "font-weight", A.fontWeight);
            const B = A.textRenderingMode & fe.TextRenderingMode.FILL_STROKE_MASK;
            if (B === fe.TextRenderingMode.FILL || B === fe.TextRenderingMode.FILL_STROKE ? (A.fillColor !== w.fillColor && A.tspan.setAttributeNS(null, "fill", A.fillColor), A.fillAlpha < 1 && A.tspan.setAttributeNS(null, "fill-opacity", A.fillAlpha)) : A.textRenderingMode === fe.TextRenderingMode.ADD_TO_PATH ? A.tspan.setAttributeNS(null, "fill", "transparent") : A.tspan.setAttributeNS(null, "fill", "none"), B === fe.TextRenderingMode.STROKE || B === fe.TextRenderingMode.FILL_STROKE) {
              const D = 1 / (A.textMatrixScale || 1);
              this._setStrokeAttributes(A.tspan, D);
            }
            let T = A.textMatrix;
            A.textRise !== 0 && (T = T.slice(), T[5] += A.textRise), A.txtElement.setAttributeNS(null, "transform", `${O(T)} scale(${U(f)}, -1)`), A.txtElement.setAttributeNS(V, "xml:space", "preserve"), A.txtElement.append(A.tspan), A.txtgrp.append(A.txtElement), this._ensureTransformGroup().append(A.txtElement);
          }
          setLeadingMoveText(d, A) {
            this.setLeading(-A), this.moveText(d, A);
          }
          addFontStyle(d) {
            if (!d.data)
              throw new Error('addFontStyle: No font data available, ensure that the "fontExtraProperties" API parameter is set.');
            this.cssStyle || (this.cssStyle = this.svgFactory.createElement("svg:style"), this.cssStyle.setAttributeNS(null, "type", "text/css"), this.defs.append(this.cssStyle));
            const A = e(d.data, d.mimetype, this.forceDataSchema);
            this.cssStyle.textContent += `@font-face { font-family: "${d.loadedName}"; src: url(${A}); }
`;
          }
          setFont(d) {
            const A = this.current, I = this.commonObjs.get(d[0]);
            let E = d[1];
            A.font = I, this.embedFonts && !I.missingFile && !this.embeddedFonts[I.loadedName] && (this.addFontStyle(I), this.embeddedFonts[I.loadedName] = I), A.fontMatrix = I.fontMatrix || fe.FONT_IDENTITY_MATRIX;
            let k = "normal";
            I.black ? k = "900" : I.bold && (k = "bold");
            const H = I.italic ? "italic" : "normal";
            E < 0 ? (E = -E, A.fontDirection = -1) : A.fontDirection = 1, A.fontSize = E, A.fontFamily = I.loadedName, A.fontWeight = k, A.fontStyle = H, A.tspan = this.svgFactory.createElement("svg:tspan"), A.tspan.setAttributeNS(null, "y", U(-A.y)), A.xcoords = [], A.ycoords = [];
          }
          endText() {
            var A;
            const d = this.current;
            d.textRenderingMode & fe.TextRenderingMode.ADD_TO_PATH_FLAG && ((A = d.txtElement) != null && A.hasChildNodes()) && (d.element = d.txtElement, this.clip("nonzero"), this.endPath());
          }
          setLineWidth(d) {
            d > 0 && (this.current.lineWidth = d);
          }
          setLineCap(d) {
            this.current.lineCap = F[d];
          }
          setLineJoin(d) {
            this.current.lineJoin = C[d];
          }
          setMiterLimit(d) {
            this.current.miterLimit = d;
          }
          setStrokeAlpha(d) {
            this.current.strokeAlpha = d;
          }
          setStrokeRGBColor(d, A, I) {
            this.current.strokeColor = fe.Util.makeHexColor(d, A, I);
          }
          setFillAlpha(d) {
            this.current.fillAlpha = d;
          }
          setFillRGBColor(d, A, I) {
            this.current.fillColor = fe.Util.makeHexColor(d, A, I), this.current.tspan = this.svgFactory.createElement("svg:tspan"), this.current.xcoords = [], this.current.ycoords = [];
          }
          setStrokeColorN(d) {
            this.current.strokeColor = this._makeColorN_Pattern(d);
          }
          setFillColorN(d) {
            this.current.fillColor = this._makeColorN_Pattern(d);
          }
          shadingFill(d) {
            const {
              width: A,
              height: I
            } = this.viewport, E = fe.Util.inverseTransform(this.transformMatrix), [k, H, x, R] = fe.Util.getAxialAlignedBoundingBox([0, 0, A, I], E), f = this.svgFactory.createElement("svg:rect");
            f.setAttributeNS(null, "x", k), f.setAttributeNS(null, "y", H), f.setAttributeNS(null, "width", x - k), f.setAttributeNS(null, "height", R - H), f.setAttributeNS(null, "fill", this._makeShadingPattern(d)), this.current.fillAlpha < 1 && f.setAttributeNS(null, "fill-opacity", this.current.fillAlpha), this._ensureTransformGroup().append(f);
          }
          _makeColorN_Pattern(d) {
            return d[0] === "TilingPattern" ? this._makeTilingPattern(d) : this._makeShadingPattern(d);
          }
          _makeTilingPattern(d) {
            const A = d[1], I = d[2], E = d[3] || fe.IDENTITY_MATRIX, [k, H, x, R] = d[4], f = d[5], c = d[6], N = d[7], u = `shading${b++}`, [p, S, B, T] = fe.Util.normalizeRect([...fe.Util.applyTransform([k, H], E), ...fe.Util.applyTransform([x, R], E)]), [D, K] = fe.Util.singularValueDecompose2dScale(E), _ = f * D, o = c * K, m = this.svgFactory.createElement("svg:pattern");
            m.setAttributeNS(null, "id", u), m.setAttributeNS(null, "patternUnits", "userSpaceOnUse"), m.setAttributeNS(null, "width", _), m.setAttributeNS(null, "height", o), m.setAttributeNS(null, "x", `${p}`), m.setAttributeNS(null, "y", `${S}`);
            const s = this.svg, r = this.transformMatrix, y = this.current.fillColor, M = this.current.strokeColor, $ = this.svgFactory.create(B - p, T - S);
            if (this.svg = $, this.transformMatrix = E, N === 2) {
              const G = fe.Util.makeHexColor(...A);
              this.current.fillColor = G, this.current.strokeColor = G;
            }
            return this.executeOpTree(this.convertOpList(I)), this.svg = s, this.transformMatrix = r, this.current.fillColor = y, this.current.strokeColor = M, m.append($.childNodes[0]), this.defs.append(m), `url(#${u})`;
          }
          _makeShadingPattern(d) {
            switch (typeof d == "string" && (d = this.objs.get(d)), d[0]) {
              case "RadialAxial":
                const A = `shading${b++}`, I = d[3];
                let E;
                switch (d[1]) {
                  case "axial":
                    const k = d[4], H = d[5];
                    E = this.svgFactory.createElement("svg:linearGradient"), E.setAttributeNS(null, "id", A), E.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), E.setAttributeNS(null, "x1", k[0]), E.setAttributeNS(null, "y1", k[1]), E.setAttributeNS(null, "x2", H[0]), E.setAttributeNS(null, "y2", H[1]);
                    break;
                  case "radial":
                    const x = d[4], R = d[5], f = d[6], c = d[7];
                    E = this.svgFactory.createElement("svg:radialGradient"), E.setAttributeNS(null, "id", A), E.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), E.setAttributeNS(null, "cx", R[0]), E.setAttributeNS(null, "cy", R[1]), E.setAttributeNS(null, "r", c), E.setAttributeNS(null, "fx", x[0]), E.setAttributeNS(null, "fy", x[1]), E.setAttributeNS(null, "fr", f);
                    break;
                  default:
                    throw new Error(`Unknown RadialAxial type: ${d[1]}`);
                }
                for (const k of I) {
                  const H = this.svgFactory.createElement("svg:stop");
                  H.setAttributeNS(null, "offset", k[0]), H.setAttributeNS(null, "stop-color", k[1]), E.append(H);
                }
                return this.defs.append(E), `url(#${A})`;
              case "Mesh":
                return (0, fe.warn)("Unimplemented pattern Mesh"), null;
              case "Dummy":
                return "hotpink";
              default:
                throw new Error(`Unknown IR type: ${d[0]}`);
            }
          }
          setDash(d, A) {
            this.current.dashArray = d, this.current.dashPhase = A;
          }
          constructPath(d, A) {
            const I = this.current;
            let E = I.x, k = I.y, H = [], x = 0;
            for (const R of d)
              switch (R | 0) {
                case fe.OPS.rectangle:
                  E = A[x++], k = A[x++];
                  const f = A[x++], c = A[x++], N = E + f, u = k + c;
                  H.push("M", U(E), U(k), "L", U(N), U(k), "L", U(N), U(u), "L", U(E), U(u), "Z");
                  break;
                case fe.OPS.moveTo:
                  E = A[x++], k = A[x++], H.push("M", U(E), U(k));
                  break;
                case fe.OPS.lineTo:
                  E = A[x++], k = A[x++], H.push("L", U(E), U(k));
                  break;
                case fe.OPS.curveTo:
                  E = A[x + 4], k = A[x + 5], H.push("C", U(A[x]), U(A[x + 1]), U(A[x + 2]), U(A[x + 3]), U(E), U(k)), x += 6;
                  break;
                case fe.OPS.curveTo2:
                  H.push("C", U(E), U(k), U(A[x]), U(A[x + 1]), U(A[x + 2]), U(A[x + 3])), E = A[x + 2], k = A[x + 3], x += 4;
                  break;
                case fe.OPS.curveTo3:
                  E = A[x + 2], k = A[x + 3], H.push("C", U(A[x]), U(A[x + 1]), U(E), U(k), U(E), U(k)), x += 4;
                  break;
                case fe.OPS.closePath:
                  H.push("Z");
                  break;
              }
            H = H.join(" "), I.path && d.length > 0 && d[0] !== fe.OPS.rectangle && d[0] !== fe.OPS.moveTo ? H = I.path.getAttributeNS(null, "d") + H : (I.path = this.svgFactory.createElement("svg:path"), this._ensureTransformGroup().append(I.path)), I.path.setAttributeNS(null, "d", H), I.path.setAttributeNS(null, "fill", "none"), I.element = I.path, I.setCurrentPoint(E, k);
          }
          endPath() {
            const d = this.current;
            if (d.path = null, !this.pendingClip)
              return;
            if (!d.element) {
              this.pendingClip = null;
              return;
            }
            const A = `clippath${v++}`, I = this.svgFactory.createElement("svg:clipPath");
            I.setAttributeNS(null, "id", A), I.setAttributeNS(null, "transform", O(this.transformMatrix));
            const E = d.element.cloneNode(!0);
            if (this.pendingClip === "evenodd" ? E.setAttributeNS(null, "clip-rule", "evenodd") : E.setAttributeNS(null, "clip-rule", "nonzero"), this.pendingClip = null, I.append(E), this.defs.append(I), d.activeClipUrl) {
              d.clipGroup = null;
              for (const k of this.extraStack)
                k.clipGroup = null;
              I.setAttributeNS(null, "clip-path", d.activeClipUrl);
            }
            d.activeClipUrl = `url(#${A})`, this.tgrp = null;
          }
          clip(d) {
            this.pendingClip = d;
          }
          closePath() {
            const d = this.current;
            if (d.path) {
              const A = `${d.path.getAttributeNS(null, "d")}Z`;
              d.path.setAttributeNS(null, "d", A);
            }
          }
          setLeading(d) {
            this.current.leading = -d;
          }
          setTextRise(d) {
            this.current.textRise = d;
          }
          setTextRenderingMode(d) {
            this.current.textRenderingMode = d;
          }
          setHScale(d) {
            this.current.textHScale = d / 100;
          }
          setRenderingIntent(d) {
          }
          setFlatness(d) {
          }
          setGState(d) {
            for (const [A, I] of d)
              switch (A) {
                case "LW":
                  this.setLineWidth(I);
                  break;
                case "LC":
                  this.setLineCap(I);
                  break;
                case "LJ":
                  this.setLineJoin(I);
                  break;
                case "ML":
                  this.setMiterLimit(I);
                  break;
                case "D":
                  this.setDash(I[0], I[1]);
                  break;
                case "RI":
                  this.setRenderingIntent(I);
                  break;
                case "FL":
                  this.setFlatness(I);
                  break;
                case "Font":
                  this.setFont(I);
                  break;
                case "CA":
                  this.setStrokeAlpha(I);
                  break;
                case "ca":
                  this.setFillAlpha(I);
                  break;
                default:
                  (0, fe.warn)(`Unimplemented graphic state operator ${A}`);
                  break;
              }
          }
          fill() {
            const d = this.current;
            d.element && (d.element.setAttributeNS(null, "fill", d.fillColor), d.element.setAttributeNS(null, "fill-opacity", d.fillAlpha), this.endPath());
          }
          stroke() {
            const d = this.current;
            d.element && (this._setStrokeAttributes(d.element), d.element.setAttributeNS(null, "fill", "none"), this.endPath());
          }
          _setStrokeAttributes(d, A = 1) {
            const I = this.current;
            let E = I.dashArray;
            A !== 1 && E.length > 0 && (E = E.map(function(k) {
              return A * k;
            })), d.setAttributeNS(null, "stroke", I.strokeColor), d.setAttributeNS(null, "stroke-opacity", I.strokeAlpha), d.setAttributeNS(null, "stroke-miterlimit", U(I.miterLimit)), d.setAttributeNS(null, "stroke-linecap", I.lineCap), d.setAttributeNS(null, "stroke-linejoin", I.lineJoin), d.setAttributeNS(null, "stroke-width", U(A * I.lineWidth) + "px"), d.setAttributeNS(null, "stroke-dasharray", E.map(U).join(" ")), d.setAttributeNS(null, "stroke-dashoffset", U(A * I.dashPhase) + "px");
          }
          eoFill() {
            var d;
            (d = this.current.element) == null || d.setAttributeNS(null, "fill-rule", "evenodd"), this.fill();
          }
          fillStroke() {
            this.stroke(), this.fill();
          }
          eoFillStroke() {
            var d;
            (d = this.current.element) == null || d.setAttributeNS(null, "fill-rule", "evenodd"), this.fillStroke();
          }
          closeStroke() {
            this.closePath(), this.stroke();
          }
          closeFillStroke() {
            this.closePath(), this.fillStroke();
          }
          closeEOFillStroke() {
            this.closePath(), this.eoFillStroke();
          }
          paintSolidColorImageMask() {
            const d = this.svgFactory.createElement("svg:rect");
            d.setAttributeNS(null, "x", "0"), d.setAttributeNS(null, "y", "0"), d.setAttributeNS(null, "width", "1px"), d.setAttributeNS(null, "height", "1px"), d.setAttributeNS(null, "fill", this.current.fillColor), this._ensureTransformGroup().append(d);
          }
          paintImageXObject(d) {
            const A = this.getObject(d);
            if (!A) {
              (0, fe.warn)(`Dependent image with object ID ${d} is not ready yet`);
              return;
            }
            this.paintInlineImageXObject(A);
          }
          paintInlineImageXObject(d, A) {
            const I = d.width, E = d.height, k = t(d, this.forceDataSchema, !!A), H = this.svgFactory.createElement("svg:rect");
            H.setAttributeNS(null, "x", "0"), H.setAttributeNS(null, "y", "0"), H.setAttributeNS(null, "width", U(I)), H.setAttributeNS(null, "height", U(E)), this.current.element = H, this.clip("nonzero");
            const x = this.svgFactory.createElement("svg:image");
            x.setAttributeNS(n, "xlink:href", k), x.setAttributeNS(null, "x", "0"), x.setAttributeNS(null, "y", U(-E)), x.setAttributeNS(null, "width", U(I) + "px"), x.setAttributeNS(null, "height", U(E) + "px"), x.setAttributeNS(null, "transform", `scale(${U(1 / I)} ${U(-1 / E)})`), A ? A.append(x) : this._ensureTransformGroup().append(x);
          }
          paintImageMaskXObject(d) {
            const A = this.getObject(d.data, d);
            if (A.bitmap) {
              (0, fe.warn)("paintImageMaskXObject: ImageBitmap support is not implemented, ensure that the `isOffscreenCanvasSupported` API parameter is disabled.");
              return;
            }
            const I = this.current, E = A.width, k = A.height, H = I.fillColor;
            I.maskId = `mask${g++}`;
            const x = this.svgFactory.createElement("svg:mask");
            x.setAttributeNS(null, "id", I.maskId);
            const R = this.svgFactory.createElement("svg:rect");
            R.setAttributeNS(null, "x", "0"), R.setAttributeNS(null, "y", "0"), R.setAttributeNS(null, "width", U(E)), R.setAttributeNS(null, "height", U(k)), R.setAttributeNS(null, "fill", H), R.setAttributeNS(null, "mask", `url(#${I.maskId})`), this.defs.append(x), this._ensureTransformGroup().append(R), this.paintInlineImageXObject(A, x);
          }
          paintFormXObjectBegin(d, A) {
            if (Array.isArray(d) && d.length === 6 && this.transform(d[0], d[1], d[2], d[3], d[4], d[5]), A) {
              const I = A[2] - A[0], E = A[3] - A[1], k = this.svgFactory.createElement("svg:rect");
              k.setAttributeNS(null, "x", A[0]), k.setAttributeNS(null, "y", A[1]), k.setAttributeNS(null, "width", U(I)), k.setAttributeNS(null, "height", U(E)), this.current.element = k, this.clip("nonzero"), this.endPath();
            }
          }
          paintFormXObjectEnd() {
          }
          _initialize(d) {
            const A = this.svgFactory.create(d.width, d.height), I = this.svgFactory.createElement("svg:defs");
            A.append(I), this.defs = I;
            const E = this.svgFactory.createElement("svg:g");
            return E.setAttributeNS(null, "transform", O(d.transform)), A.append(E), this.svg = E, A;
          }
          _ensureClipGroup() {
            if (!this.current.clipGroup) {
              const d = this.svgFactory.createElement("svg:g");
              d.setAttributeNS(null, "clip-path", this.current.activeClipUrl), this.svg.append(d), this.current.clipGroup = d;
            }
            return this.current.clipGroup;
          }
          _ensureTransformGroup() {
            return this.tgrp || (this.tgrp = this.svgFactory.createElement("svg:g"), this.tgrp.setAttributeNS(null, "transform", O(this.transformMatrix)), this.current.activeClipUrl ? this._ensureClipGroup().append(this.tgrp) : this.svg.append(this.tgrp)), this.tgrp;
          }
        }
        ge.SVGGraphics = i;
      },
      /* 25 */
      /***/
      (Re, ge) => {
        Object.defineProperty(ge, "__esModule", {
          value: !0
        }), ge.XfaText = void 0;
        class xe {
          static textContent(fe) {
            const w = [], V = {
              items: w,
              styles: /* @__PURE__ */ Object.create(null)
            };
            function n(F) {
              var t;
              if (!F)
                return;
              let C = null;
              const e = F.name;
              if (e === "#text")
                C = F.value;
              else if (xe.shouldBuildText(e))
                (t = F == null ? void 0 : F.attributes) != null && t.textContent ? C = F.attributes.textContent : F.value && (C = F.value);
              else
                return;
              if (C !== null && w.push({
                str: C
              }), !!F.children)
                for (const l of F.children)
                  n(l);
            }
            return n(fe), V;
          }
          static shouldBuildText(fe) {
            return !(fe === "textarea" || fe === "input" || fe === "option" || fe === "select");
          }
        }
        ge.XfaText = xe;
      },
      /* 26 */
      /***/
      (Re, ge, xe) => {
        Object.defineProperty(ge, "__esModule", {
          value: !0
        }), ge.TextLayerRenderTask = void 0, ge.renderTextLayer = O, ge.updateTextLayer = v;
        var de = xe(1), fe = xe(6);
        const w = 1e5, V = 30, n = 0.8, F = /* @__PURE__ */ new Map();
        function C(g, b) {
          let i;
          if (b && de.FeatureTest.isOffscreenCanvasSupported)
            i = new OffscreenCanvas(g, g).getContext("2d", {
              alpha: !1
            });
          else {
            const P = document.createElement("canvas");
            P.width = P.height = g, i = P.getContext("2d", {
              alpha: !1
            });
          }
          return i;
        }
        function e(g, b) {
          const i = F.get(g);
          if (i)
            return i;
          const P = C(V, b);
          P.font = `${V}px ${g}`;
          const d = P.measureText("");
          let A = d.fontBoundingBoxAscent, I = Math.abs(d.fontBoundingBoxDescent);
          if (A) {
            const k = A / (A + I);
            return F.set(g, k), P.canvas.width = P.canvas.height = 0, k;
          }
          P.strokeStyle = "red", P.clearRect(0, 0, V, V), P.strokeText("g", 0, 0);
          let E = P.getImageData(0, 0, V, V).data;
          I = 0;
          for (let k = E.length - 1 - 3; k >= 0; k -= 4)
            if (E[k] > 0) {
              I = Math.ceil(k / 4 / V);
              break;
            }
          P.clearRect(0, 0, V, V), P.strokeText("A", 0, V), E = P.getImageData(0, 0, V, V).data, A = 0;
          for (let k = 0, H = E.length; k < H; k += 4)
            if (E[k] > 0) {
              A = V - Math.floor(k / 4 / V);
              break;
            }
          if (P.canvas.width = P.canvas.height = 0, A) {
            const k = A / (A + I);
            return F.set(g, k), k;
          }
          return F.set(g, n), n;
        }
        function t(g, b, i) {
          const P = document.createElement("span"), d = {
            angle: 0,
            canvasWidth: 0,
            hasText: b.str !== "",
            hasEOL: b.hasEOL,
            fontSize: 0
          };
          g._textDivs.push(P);
          const A = de.Util.transform(g._transform, b.transform);
          let I = Math.atan2(A[1], A[0]);
          const E = i[b.fontName];
          E.vertical && (I += Math.PI / 2);
          const k = Math.hypot(A[2], A[3]), H = k * e(E.fontFamily, g._isOffscreenCanvasSupported);
          let x, R;
          I === 0 ? (x = A[4], R = A[5] - H) : (x = A[4] + H * Math.sin(I), R = A[5] - H * Math.cos(I));
          const f = "calc(var(--scale-factor)*", c = P.style;
          g._container === g._rootContainer ? (c.left = `${(100 * x / g._pageWidth).toFixed(2)}%`, c.top = `${(100 * R / g._pageHeight).toFixed(2)}%`) : (c.left = `${f}${x.toFixed(2)}px)`, c.top = `${f}${R.toFixed(2)}px)`), c.fontSize = `${f}${k.toFixed(2)}px)`, c.fontFamily = E.fontFamily, d.fontSize = k, P.setAttribute("role", "presentation"), P.textContent = b.str, P.dir = b.dir, g._fontInspectorEnabled && (P.dataset.fontName = b.fontName), I !== 0 && (d.angle = I * (180 / Math.PI));
          let N = !1;
          if (b.str.length > 1)
            N = !0;
          else if (b.str !== " " && b.transform[0] !== b.transform[3]) {
            const u = Math.abs(b.transform[0]), p = Math.abs(b.transform[3]);
            u !== p && Math.max(u, p) / Math.min(u, p) > 1.5 && (N = !0);
          }
          N && (d.canvasWidth = E.vertical ? b.height : b.width), g._textDivProperties.set(P, d), g._isReadableStream && g._layoutText(P);
        }
        function l(g) {
          const {
            div: b,
            scale: i,
            properties: P,
            ctx: d,
            prevFontSize: A,
            prevFontFamily: I
          } = g, {
            style: E
          } = b;
          let k = "";
          if (P.canvasWidth !== 0 && P.hasText) {
            const {
              fontFamily: H
            } = E, {
              canvasWidth: x,
              fontSize: R
            } = P;
            (A !== R || I !== H) && (d.font = `${R * i}px ${H}`, g.prevFontSize = R, g.prevFontFamily = H);
            const {
              width: f
            } = d.measureText(b.textContent);
            f > 0 && (k = `scaleX(${x * i / f})`);
          }
          P.angle !== 0 && (k = `rotate(${P.angle}deg) ${k}`), k.length > 0 && (E.transform = k);
        }
        function j(g) {
          if (g._canceled)
            return;
          const b = g._textDivs, i = g._capability;
          if (b.length > w) {
            i.resolve();
            return;
          }
          if (!g._isReadableStream)
            for (const d of b)
              g._layoutText(d);
          i.resolve();
        }
        class U {
          constructor({
            textContentSource: b,
            container: i,
            viewport: P,
            textDivs: d,
            textDivProperties: A,
            textContentItemsStr: I,
            isOffscreenCanvasSupported: E
          }) {
            var f;
            this._textContentSource = b, this._isReadableStream = b instanceof ReadableStream, this._container = this._rootContainer = i, this._textDivs = d || [], this._textContentItemsStr = I || [], this._isOffscreenCanvasSupported = E, this._fontInspectorEnabled = !!((f = globalThis.FontInspector) != null && f.enabled), this._reader = null, this._textDivProperties = A || /* @__PURE__ */ new WeakMap(), this._canceled = !1, this._capability = new de.PromiseCapability(), this._layoutTextParams = {
              prevFontSize: null,
              prevFontFamily: null,
              div: null,
              scale: P.scale * (globalThis.devicePixelRatio || 1),
              properties: null,
              ctx: C(0, E)
            };
            const {
              pageWidth: k,
              pageHeight: H,
              pageX: x,
              pageY: R
            } = P.rawDims;
            this._transform = [1, 0, 0, -1, -x, R + H], this._pageWidth = k, this._pageHeight = H, (0, fe.setLayerDimensions)(i, P), this._capability.promise.finally(() => {
              this._layoutTextParams = null;
            }).catch(() => {
            });
          }
          get promise() {
            return this._capability.promise;
          }
          cancel() {
            this._canceled = !0, this._reader && (this._reader.cancel(new de.AbortException("TextLayer task cancelled.")).catch(() => {
            }), this._reader = null), this._capability.reject(new de.AbortException("TextLayer task cancelled."));
          }
          _processItems(b, i) {
            for (const P of b) {
              if (P.str === void 0) {
                if (P.type === "beginMarkedContentProps" || P.type === "beginMarkedContent") {
                  const d = this._container;
                  this._container = document.createElement("span"), this._container.classList.add("markedContent"), P.id !== null && this._container.setAttribute("id", `${P.id}`), d.append(this._container);
                } else
                  P.type === "endMarkedContent" && (this._container = this._container.parentNode);
                continue;
              }
              this._textContentItemsStr.push(P.str), t(this, P, i);
            }
          }
          _layoutText(b) {
            const i = this._layoutTextParams.properties = this._textDivProperties.get(b);
            if (this._layoutTextParams.div = b, l(this._layoutTextParams), i.hasText && this._container.append(b), i.hasEOL) {
              const P = document.createElement("br");
              P.setAttribute("role", "presentation"), this._container.append(P);
            }
          }
          _render() {
            const b = new de.PromiseCapability();
            let i = /* @__PURE__ */ Object.create(null);
            if (this._isReadableStream) {
              const P = () => {
                this._reader.read().then(({
                  value: d,
                  done: A
                }) => {
                  if (A) {
                    b.resolve();
                    return;
                  }
                  Object.assign(i, d.styles), this._processItems(d.items, i), P();
                }, b.reject);
              };
              this._reader = this._textContentSource.getReader(), P();
            } else if (this._textContentSource) {
              const {
                items: P,
                styles: d
              } = this._textContentSource;
              this._processItems(P, d), b.resolve();
            } else
              throw new Error('No "textContentSource" parameter specified.');
            b.promise.then(() => {
              i = null, j(this);
            }, this._capability.reject);
          }
        }
        ge.TextLayerRenderTask = U;
        function O(g) {
          !g.textContentSource && (g.textContent || g.textContentStream) && ((0, fe.deprecated)("The TextLayerRender `textContent`/`textContentStream` parameters will be removed in the future, please use `textContentSource` instead."), g.textContentSource = g.textContent || g.textContentStream);
          const {
            container: b,
            viewport: i
          } = g, P = getComputedStyle(b), d = P.getPropertyValue("visibility"), A = parseFloat(P.getPropertyValue("--scale-factor"));
          d === "visible" && (!A || Math.abs(A - i.scale) > 1e-5) && console.error("The `--scale-factor` CSS-variable must be set, to the same value as `viewport.scale`, either on the `container`-element itself or higher up in the DOM.");
          const I = new U(g);
          return I._render(), I;
        }
        function v({
          container: g,
          viewport: b,
          textDivs: i,
          textDivProperties: P,
          isOffscreenCanvasSupported: d,
          mustRotate: A = !0,
          mustRescale: I = !0
        }) {
          if (A && (0, fe.setLayerDimensions)(g, {
            rotation: b.rotation
          }), I) {
            const E = C(0, d), H = {
              prevFontSize: null,
              prevFontFamily: null,
              div: null,
              scale: b.scale * (globalThis.devicePixelRatio || 1),
              properties: null,
              ctx: E
            };
            for (const x of i)
              H.properties = P.get(x), H.div = x, l(H);
          }
        }
      },
      /* 27 */
      /***/
      (Re, ge, xe) => {
        var e, t, l, j, U, O, v, g, b, i, P, aa, A, Qn, E, sa, H, ra;
        Object.defineProperty(ge, "__esModule", {
          value: !0
        }), ge.AnnotationEditorLayer = void 0;
        var de = xe(1), fe = xe(4), w = xe(28), V = xe(33), n = xe(6), F = xe(34);
        const R = class R {
          constructor({
            uiManager: c,
            pageIndex: N,
            div: u,
            accessibilityManager: p,
            annotationLayer: S,
            viewport: B,
            l10n: T
          }) {
            Me(this, P);
            Me(this, A);
            Me(this, E);
            Me(this, H);
            Me(this, e, void 0);
            Me(this, t, !1);
            Me(this, l, null);
            Me(this, j, this.pointerup.bind(this));
            Me(this, U, this.pointerdown.bind(this));
            Me(this, O, /* @__PURE__ */ new Map());
            Me(this, v, !1);
            Me(this, g, !1);
            Me(this, b, !1);
            Me(this, i, void 0);
            const D = [w.FreeTextEditor, V.InkEditor, F.StampEditor];
            if (!R._initialized) {
              R._initialized = !0;
              for (const K of D)
                K.initialize(T);
            }
            c.registerEditorTypes(D), Xe(this, i, c), this.pageIndex = N, this.div = u, Xe(this, e, p), Xe(this, l, S), this.viewport = B, le(this, i).addLayer(this);
          }
          get isEmpty() {
            return le(this, O).size === 0;
          }
          updateToolbar(c) {
            le(this, i).updateToolbar(c);
          }
          updateMode(c = le(this, i).getMode()) {
            De(this, H, ra).call(this), c === de.AnnotationEditorType.INK ? (this.addInkEditorIfNeeded(!1), this.disableClick()) : this.enableClick(), c !== de.AnnotationEditorType.NONE && (this.div.classList.toggle("freeTextEditing", c === de.AnnotationEditorType.FREETEXT), this.div.classList.toggle("inkEditing", c === de.AnnotationEditorType.INK), this.div.classList.toggle("stampEditing", c === de.AnnotationEditorType.STAMP), this.div.hidden = !1);
          }
          addInkEditorIfNeeded(c) {
            if (!c && le(this, i).getMode() !== de.AnnotationEditorType.INK)
              return;
            if (!c) {
              for (const u of le(this, O).values())
                if (u.isEmpty()) {
                  u.setInBackground();
                  return;
                }
            }
            De(this, A, Qn).call(this, {
              offsetX: 0,
              offsetY: 0
            }, !1).setInBackground();
          }
          setEditingState(c) {
            le(this, i).setEditingState(c);
          }
          addCommands(c) {
            le(this, i).addCommands(c);
          }
          enable() {
            this.div.style.pointerEvents = "auto";
            const c = /* @__PURE__ */ new Set();
            for (const u of le(this, O).values())
              u.enableEditing(), u.annotationElementId && c.add(u.annotationElementId);
            if (!le(this, l))
              return;
            const N = le(this, l).getEditableAnnotations();
            for (const u of N) {
              if (u.hide(), le(this, i).isDeletedAnnotationElement(u.data.id) || c.has(u.data.id))
                continue;
              const p = this.deserialize(u);
              p && (this.addOrRebuild(p), p.enableEditing());
            }
          }
          disable() {
            var N;
            Xe(this, b, !0), this.div.style.pointerEvents = "none";
            const c = /* @__PURE__ */ new Set();
            for (const u of le(this, O).values()) {
              if (u.disableEditing(), !u.annotationElementId || u.serialize() !== null) {
                c.add(u.annotationElementId);
                continue;
              }
              (N = this.getEditableAnnotation(u.annotationElementId)) == null || N.show(), u.remove();
            }
            if (le(this, l)) {
              const u = le(this, l).getEditableAnnotations();
              for (const p of u) {
                const {
                  id: S
                } = p.data;
                c.has(S) || le(this, i).isDeletedAnnotationElement(S) || p.show();
              }
            }
            De(this, H, ra).call(this), this.isEmpty && (this.div.hidden = !0), Xe(this, b, !1);
          }
          getEditableAnnotation(c) {
            var N;
            return ((N = le(this, l)) == null ? void 0 : N.getEditableAnnotation(c)) || null;
          }
          setActiveEditor(c) {
            le(this, i).getActive() !== c && le(this, i).setActiveEditor(c);
          }
          enableClick() {
            this.div.addEventListener("pointerdown", le(this, U)), this.div.addEventListener("pointerup", le(this, j));
          }
          disableClick() {
            this.div.removeEventListener("pointerdown", le(this, U)), this.div.removeEventListener("pointerup", le(this, j));
          }
          attach(c) {
            le(this, O).set(c.id, c);
            const {
              annotationElementId: N
            } = c;
            N && le(this, i).isDeletedAnnotationElement(N) && le(this, i).removeDeletedAnnotationElement(c);
          }
          detach(c) {
            var N;
            le(this, O).delete(c.id), (N = le(this, e)) == null || N.removePointerInTextLayer(c.contentDiv), !le(this, b) && c.annotationElementId && le(this, i).addDeletedAnnotationElement(c);
          }
          remove(c) {
            this.detach(c), le(this, i).removeEditor(c), c.div.contains(document.activeElement) && setTimeout(() => {
              le(this, i).focusMainContainer();
            }, 0), c.div.remove(), c.isAttachedToDOM = !1, le(this, g) || this.addInkEditorIfNeeded(!1);
          }
          changeParent(c) {
            var N;
            c.parent !== this && (c.annotationElementId && (le(this, i).addDeletedAnnotationElement(c.annotationElementId), fe.AnnotationEditor.deleteAnnotationElement(c), c.annotationElementId = null), this.attach(c), (N = c.parent) == null || N.detach(c), c.setParent(this), c.div && c.isAttachedToDOM && (c.div.remove(), this.div.append(c.div)));
          }
          add(c) {
            if (this.changeParent(c), le(this, i).addEditor(c), this.attach(c), !c.isAttachedToDOM) {
              const N = c.render();
              this.div.append(N), c.isAttachedToDOM = !0;
            }
            c.fixAndSetPosition(), c.onceAdded(), le(this, i).addToAnnotationStorage(c);
          }
          moveEditorInDOM(c) {
            var u;
            if (!c.isAttachedToDOM)
              return;
            const {
              activeElement: N
            } = document;
            c.div.contains(N) && (c._focusEventsAllowed = !1, setTimeout(() => {
              c.div.contains(document.activeElement) ? c._focusEventsAllowed = !0 : (c.div.addEventListener("focusin", () => {
                c._focusEventsAllowed = !0;
              }, {
                once: !0
              }), N.focus());
            }, 0)), c._structTreeParentId = (u = le(this, e)) == null ? void 0 : u.moveElementInDOM(this.div, c.div, c.contentDiv, !0);
          }
          addOrRebuild(c) {
            c.needsToBeRebuilt() ? c.rebuild() : this.add(c);
          }
          addUndoableEditor(c) {
            const N = () => c._uiManager.rebuild(c), u = () => {
              c.remove();
            };
            this.addCommands({
              cmd: N,
              undo: u,
              mustExec: !1
            });
          }
          getNextId() {
            return le(this, i).getId();
          }
          pasteEditor(c, N) {
            le(this, i).updateToolbar(c), le(this, i).updateMode(c);
            const {
              offsetX: u,
              offsetY: p
            } = De(this, E, sa).call(this), S = this.getNextId(), B = De(this, P, aa).call(this, {
              parent: this,
              id: S,
              x: u,
              y: p,
              uiManager: le(this, i),
              isCentered: !0,
              ...N
            });
            B && this.add(B);
          }
          deserialize(c) {
            switch (c.annotationType ?? c.annotationEditorType) {
              case de.AnnotationEditorType.FREETEXT:
                return w.FreeTextEditor.deserialize(c, this, le(this, i));
              case de.AnnotationEditorType.INK:
                return V.InkEditor.deserialize(c, this, le(this, i));
              case de.AnnotationEditorType.STAMP:
                return F.StampEditor.deserialize(c, this, le(this, i));
            }
            return null;
          }
          addNewEditor() {
            De(this, A, Qn).call(this, De(this, E, sa).call(this), !0);
          }
          setSelected(c) {
            le(this, i).setSelected(c);
          }
          toggleSelected(c) {
            le(this, i).toggleSelected(c);
          }
          isSelected(c) {
            return le(this, i).isSelected(c);
          }
          unselect(c) {
            le(this, i).unselect(c);
          }
          pointerup(c) {
            const {
              isMac: N
            } = de.FeatureTest.platform;
            if (!(c.button !== 0 || c.ctrlKey && N) && c.target === this.div && le(this, v)) {
              if (Xe(this, v, !1), !le(this, t)) {
                Xe(this, t, !0);
                return;
              }
              if (le(this, i).getMode() === de.AnnotationEditorType.STAMP) {
                le(this, i).unselectAll();
                return;
              }
              De(this, A, Qn).call(this, c, !1);
            }
          }
          pointerdown(c) {
            if (le(this, v)) {
              Xe(this, v, !1);
              return;
            }
            const {
              isMac: N
            } = de.FeatureTest.platform;
            if (c.button !== 0 || c.ctrlKey && N || c.target !== this.div)
              return;
            Xe(this, v, !0);
            const u = le(this, i).getActive();
            Xe(this, t, !u || u.isEmpty());
          }
          findNewParent(c, N, u) {
            const p = le(this, i).findParent(N, u);
            return p === null || p === this ? !1 : (p.changeParent(c), !0);
          }
          destroy() {
            var c, N;
            ((c = le(this, i).getActive()) == null ? void 0 : c.parent) === this && (le(this, i).commitOrRemove(), le(this, i).setActiveEditor(null));
            for (const u of le(this, O).values())
              (N = le(this, e)) == null || N.removePointerInTextLayer(u.contentDiv), u.setParent(null), u.isAttachedToDOM = !1, u.div.remove();
            this.div = null, le(this, O).clear(), le(this, i).removeLayer(this);
          }
          render({
            viewport: c
          }) {
            this.viewport = c, (0, n.setLayerDimensions)(this.div, c);
            for (const N of le(this, i).getEditors(this.pageIndex))
              this.add(N);
            this.updateMode();
          }
          update({
            viewport: c
          }) {
            le(this, i).commitOrRemove(), this.viewport = c, (0, n.setLayerDimensions)(this.div, {
              rotation: c.rotation
            }), this.updateMode();
          }
          get pageDimensions() {
            const {
              pageWidth: c,
              pageHeight: N
            } = this.viewport.rawDims;
            return [c, N];
          }
        };
        e = new WeakMap(), t = new WeakMap(), l = new WeakMap(), j = new WeakMap(), U = new WeakMap(), O = new WeakMap(), v = new WeakMap(), g = new WeakMap(), b = new WeakMap(), i = new WeakMap(), P = new WeakSet(), aa = function(c) {
          switch (le(this, i).getMode()) {
            case de.AnnotationEditorType.FREETEXT:
              return new w.FreeTextEditor(c);
            case de.AnnotationEditorType.INK:
              return new V.InkEditor(c);
            case de.AnnotationEditorType.STAMP:
              return new F.StampEditor(c);
          }
          return null;
        }, A = new WeakSet(), Qn = function(c, N) {
          const u = this.getNextId(), p = De(this, P, aa).call(this, {
            parent: this,
            id: u,
            x: c.offsetX,
            y: c.offsetY,
            uiManager: le(this, i),
            isCentered: N
          });
          return p && this.add(p), p;
        }, E = new WeakSet(), sa = function() {
          const {
            x: c,
            y: N,
            width: u,
            height: p
          } = this.div.getBoundingClientRect(), S = Math.max(0, c), B = Math.max(0, N), T = Math.min(window.innerWidth, c + u), D = Math.min(window.innerHeight, N + p), K = (S + T) / 2 - c, _ = (B + D) / 2 - N, [o, m] = this.viewport.rotation % 180 === 0 ? [K, _] : [_, K];
          return {
            offsetX: o,
            offsetY: m
          };
        }, H = new WeakSet(), ra = function() {
          Xe(this, g, !0);
          for (const c of le(this, O).values())
            c.isEmpty() && c.remove();
          Xe(this, g, !1);
        }, Ot(R, "_initialized", !1);
        let C = R;
        ge.AnnotationEditorLayer = C;
      },
      /* 28 */
      /***/
      (Re, ge, xe) => {
        var F, C, e, t, l, j, U, O, v, g, za, i, Ga, d, Wa, I, Dn, k, oa, x, qa, f, ca;
        Object.defineProperty(ge, "__esModule", {
          value: !0
        }), ge.FreeTextEditor = void 0;
        var de = xe(1), fe = xe(5), w = xe(4), V = xe(29);
        const N = class N extends w.AnnotationEditor {
          constructor(S) {
            super({
              ...S,
              name: "freeTextEditor"
            });
            Me(this, g);
            Me(this, i);
            Me(this, d);
            Me(this, I);
            Me(this, k);
            Me(this, x);
            Me(this, f);
            Me(this, F, this.editorDivBlur.bind(this));
            Me(this, C, this.editorDivFocus.bind(this));
            Me(this, e, this.editorDivInput.bind(this));
            Me(this, t, this.editorDivKeydown.bind(this));
            Me(this, l, void 0);
            Me(this, j, "");
            Me(this, U, `${this.id}-editor`);
            Me(this, O, void 0);
            Me(this, v, null);
            Xe(this, l, S.color || N._defaultColor || w.AnnotationEditor._defaultLineColor), Xe(this, O, S.fontSize || N._defaultFontSize);
          }
          static get _keyboardManager() {
            const S = N.prototype, B = (K) => K.isEmpty(), T = fe.AnnotationEditorUIManager.TRANSLATE_SMALL, D = fe.AnnotationEditorUIManager.TRANSLATE_BIG;
            return (0, de.shadow)(this, "_keyboardManager", new fe.KeyboardManager([[["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], S.commitOrRemove, {
              bubbles: !0
            }], [["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], S.commitOrRemove], [["ArrowLeft", "mac+ArrowLeft"], S._translateEmpty, {
              args: [-T, 0],
              checker: B
            }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], S._translateEmpty, {
              args: [-D, 0],
              checker: B
            }], [["ArrowRight", "mac+ArrowRight"], S._translateEmpty, {
              args: [T, 0],
              checker: B
            }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], S._translateEmpty, {
              args: [D, 0],
              checker: B
            }], [["ArrowUp", "mac+ArrowUp"], S._translateEmpty, {
              args: [0, -T],
              checker: B
            }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], S._translateEmpty, {
              args: [0, -D],
              checker: B
            }], [["ArrowDown", "mac+ArrowDown"], S._translateEmpty, {
              args: [0, T],
              checker: B
            }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], S._translateEmpty, {
              args: [0, D],
              checker: B
            }]]));
          }
          static initialize(S) {
            w.AnnotationEditor.initialize(S, {
              strings: ["free_text2_default_content", "editor_free_text2_aria_label"]
            });
            const B = getComputedStyle(document.documentElement);
            this._internalPadding = parseFloat(B.getPropertyValue("--freetext-padding"));
          }
          static updateDefaultParams(S, B) {
            switch (S) {
              case de.AnnotationEditorParamsType.FREETEXT_SIZE:
                N._defaultFontSize = B;
                break;
              case de.AnnotationEditorParamsType.FREETEXT_COLOR:
                N._defaultColor = B;
                break;
            }
          }
          updateParams(S, B) {
            switch (S) {
              case de.AnnotationEditorParamsType.FREETEXT_SIZE:
                De(this, g, za).call(this, B);
                break;
              case de.AnnotationEditorParamsType.FREETEXT_COLOR:
                De(this, i, Ga).call(this, B);
                break;
            }
          }
          static get defaultPropertiesToUpdate() {
            return [[de.AnnotationEditorParamsType.FREETEXT_SIZE, N._defaultFontSize], [de.AnnotationEditorParamsType.FREETEXT_COLOR, N._defaultColor || w.AnnotationEditor._defaultLineColor]];
          }
          get propertiesToUpdate() {
            return [[de.AnnotationEditorParamsType.FREETEXT_SIZE, le(this, O)], [de.AnnotationEditorParamsType.FREETEXT_COLOR, le(this, l)]];
          }
          _translateEmpty(S, B) {
            this._uiManager.translateSelectedEditors(S, B, !0);
          }
          getInitialTranslation() {
            const S = this.parentScale;
            return [-N._internalPadding * S, -(N._internalPadding + le(this, O)) * S];
          }
          rebuild() {
            this.parent && (super.rebuild(), this.div !== null && (this.isAttachedToDOM || this.parent.add(this)));
          }
          enableEditMode() {
            this.isInEditMode() || (this.parent.setEditingState(!1), this.parent.updateToolbar(de.AnnotationEditorType.FREETEXT), super.enableEditMode(), this.overlayDiv.classList.remove("enabled"), this.editorDiv.contentEditable = !0, this._isDraggable = !1, this.div.removeAttribute("aria-activedescendant"), this.editorDiv.addEventListener("keydown", le(this, t)), this.editorDiv.addEventListener("focus", le(this, C)), this.editorDiv.addEventListener("blur", le(this, F)), this.editorDiv.addEventListener("input", le(this, e)));
          }
          disableEditMode() {
            this.isInEditMode() && (this.parent.setEditingState(!0), super.disableEditMode(), this.overlayDiv.classList.add("enabled"), this.editorDiv.contentEditable = !1, this.div.setAttribute("aria-activedescendant", le(this, U)), this._isDraggable = !0, this.editorDiv.removeEventListener("keydown", le(this, t)), this.editorDiv.removeEventListener("focus", le(this, C)), this.editorDiv.removeEventListener("blur", le(this, F)), this.editorDiv.removeEventListener("input", le(this, e)), this.div.focus({
              preventScroll: !0
            }), this.isEditing = !1, this.parent.div.classList.add("freeTextEditing"));
          }
          focusin(S) {
            this._focusEventsAllowed && (super.focusin(S), S.target !== this.editorDiv && this.editorDiv.focus());
          }
          onceAdded() {
            var S;
            if (this.width) {
              De(this, f, ca).call(this);
              return;
            }
            this.enableEditMode(), this.editorDiv.focus(), (S = this._initialOptions) != null && S.isCentered && this.center(), this._initialOptions = null;
          }
          isEmpty() {
            return !this.editorDiv || this.editorDiv.innerText.trim() === "";
          }
          remove() {
            this.isEditing = !1, this.parent && (this.parent.setEditingState(!0), this.parent.div.classList.add("freeTextEditing")), super.remove();
          }
          commit() {
            if (!this.isInEditMode())
              return;
            super.commit(), this.disableEditMode();
            const S = le(this, j), B = Xe(this, j, De(this, d, Wa).call(this).trimEnd());
            if (S === B)
              return;
            const T = (D) => {
              if (Xe(this, j, D), !D) {
                this.remove();
                return;
              }
              De(this, k, oa).call(this), this._uiManager.rebuild(this), De(this, I, Dn).call(this);
            };
            this.addCommands({
              cmd: () => {
                T(B);
              },
              undo: () => {
                T(S);
              },
              mustExec: !1
            }), De(this, I, Dn).call(this);
          }
          shouldGetKeyboardEvents() {
            return this.isInEditMode();
          }
          enterInEditMode() {
            this.enableEditMode(), this.editorDiv.focus();
          }
          dblclick(S) {
            this.enterInEditMode();
          }
          keydown(S) {
            S.target === this.div && S.key === "Enter" && (this.enterInEditMode(), S.preventDefault());
          }
          editorDivKeydown(S) {
            N._keyboardManager.exec(this, S);
          }
          editorDivFocus(S) {
            this.isEditing = !0;
          }
          editorDivBlur(S) {
            this.isEditing = !1;
          }
          editorDivInput(S) {
            this.parent.div.classList.toggle("freeTextEditing", this.isEmpty());
          }
          disableEditing() {
            this.editorDiv.setAttribute("role", "comment"), this.editorDiv.removeAttribute("aria-multiline");
          }
          enableEditing() {
            this.editorDiv.setAttribute("role", "textbox"), this.editorDiv.setAttribute("aria-multiline", !0);
          }
          render() {
            if (this.div)
              return this.div;
            let S, B;
            this.width && (S = this.x, B = this.y), super.render(), this.editorDiv = document.createElement("div"), this.editorDiv.className = "internal", this.editorDiv.setAttribute("id", le(this, U)), this.enableEditing(), w.AnnotationEditor._l10nPromise.get("editor_free_text2_aria_label").then((D) => {
              var K;
              return (K = this.editorDiv) == null ? void 0 : K.setAttribute("aria-label", D);
            }), w.AnnotationEditor._l10nPromise.get("free_text2_default_content").then((D) => {
              var K;
              return (K = this.editorDiv) == null ? void 0 : K.setAttribute("default-content", D);
            }), this.editorDiv.contentEditable = !0;
            const {
              style: T
            } = this.editorDiv;
            if (T.fontSize = `calc(${le(this, O)}px * var(--scale-factor))`, T.color = le(this, l), this.div.append(this.editorDiv), this.overlayDiv = document.createElement("div"), this.overlayDiv.classList.add("overlay", "enabled"), this.div.append(this.overlayDiv), (0, fe.bindEvents)(this, this.div, ["dblclick", "keydown"]), this.width) {
              const [D, K] = this.parentDimensions;
              if (this.annotationElementId) {
                const {
                  position: _
                } = le(this, v);
                let [o, m] = this.getInitialTranslation();
                [o, m] = this.pageTranslationToScreen(o, m);
                const [s, r] = this.pageDimensions, [y, M] = this.pageTranslation;
                let $, G;
                switch (this.rotation) {
                  case 0:
                    $ = S + (_[0] - y) / s, G = B + this.height - (_[1] - M) / r;
                    break;
                  case 90:
                    $ = S + (_[0] - y) / s, G = B - (_[1] - M) / r, [o, m] = [m, -o];
                    break;
                  case 180:
                    $ = S - this.width + (_[0] - y) / s, G = B - (_[1] - M) / r, [o, m] = [-o, -m];
                    break;
                  case 270:
                    $ = S + (_[0] - y - this.height * r) / s, G = B + (_[1] - M - this.width * s) / r, [o, m] = [-m, o];
                    break;
                }
                this.setAt($ * D, G * K, o, m);
              } else
                this.setAt(S * D, B * K, this.width * D, this.height * K);
              De(this, k, oa).call(this), this._isDraggable = !0, this.editorDiv.contentEditable = !1;
            } else
              this._isDraggable = !1, this.editorDiv.contentEditable = !0;
            return this.div;
          }
          get contentDiv() {
            return this.editorDiv;
          }
          static deserialize(S, B, T) {
            let D = null;
            if (S instanceof V.FreeTextAnnotationElement) {
              const {
                data: {
                  defaultAppearanceData: {
                    fontSize: _,
                    fontColor: o
                  },
                  rect: m,
                  rotation: s,
                  id: r
                },
                textContent: y,
                textPosition: M,
                parent: {
                  page: {
                    pageNumber: $
                  }
                }
              } = S;
              if (!y || y.length === 0)
                return null;
              D = S = {
                annotationType: de.AnnotationEditorType.FREETEXT,
                color: Array.from(o),
                fontSize: _,
                value: y.join(`
`),
                position: M,
                pageIndex: $ - 1,
                rect: m,
                rotation: s,
                id: r,
                deleted: !1
              };
            }
            const K = super.deserialize(S, B, T);
            return Xe(K, O, S.fontSize), Xe(K, l, de.Util.makeHexColor(...S.color)), Xe(K, j, S.value), K.annotationElementId = S.id || null, Xe(K, v, D), K;
          }
          serialize(S = !1) {
            if (this.isEmpty())
              return null;
            if (this.deleted)
              return {
                pageIndex: this.pageIndex,
                id: this.annotationElementId,
                deleted: !0
              };
            const B = N._internalPadding * this.parentScale, T = this.getRect(B, B), D = w.AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : le(this, l)), K = {
              annotationType: de.AnnotationEditorType.FREETEXT,
              color: D,
              fontSize: le(this, O),
              value: le(this, j),
              pageIndex: this.pageIndex,
              rect: T,
              rotation: this.rotation,
              structTreeParentId: this._structTreeParentId
            };
            return S ? K : this.annotationElementId && !De(this, x, qa).call(this, K) ? null : (K.id = this.annotationElementId, K);
          }
        };
        F = new WeakMap(), C = new WeakMap(), e = new WeakMap(), t = new WeakMap(), l = new WeakMap(), j = new WeakMap(), U = new WeakMap(), O = new WeakMap(), v = new WeakMap(), g = new WeakSet(), za = function(S) {
          const B = (D) => {
            this.editorDiv.style.fontSize = `calc(${D}px * var(--scale-factor))`, this.translate(0, -(D - le(this, O)) * this.parentScale), Xe(this, O, D), De(this, I, Dn).call(this);
          }, T = le(this, O);
          this.addCommands({
            cmd: () => {
              B(S);
            },
            undo: () => {
              B(T);
            },
            mustExec: !0,
            type: de.AnnotationEditorParamsType.FREETEXT_SIZE,
            overwriteIfSameType: !0,
            keepUndo: !0
          });
        }, i = new WeakSet(), Ga = function(S) {
          const B = le(this, l);
          this.addCommands({
            cmd: () => {
              Xe(this, l, this.editorDiv.style.color = S);
            },
            undo: () => {
              Xe(this, l, this.editorDiv.style.color = B);
            },
            mustExec: !0,
            type: de.AnnotationEditorParamsType.FREETEXT_COLOR,
            overwriteIfSameType: !0,
            keepUndo: !0
          });
        }, d = new WeakSet(), Wa = function() {
          const S = this.editorDiv.getElementsByTagName("div");
          if (S.length === 0)
            return this.editorDiv.innerText;
          const B = [];
          for (const T of S)
            B.push(T.innerText.replace(/\r\n?|\n/, ""));
          return B.join(`
`);
        }, I = new WeakSet(), Dn = function() {
          const [S, B] = this.parentDimensions;
          let T;
          if (this.isAttachedToDOM)
            T = this.div.getBoundingClientRect();
          else {
            const {
              currentLayer: D,
              div: K
            } = this, _ = K.style.display;
            K.style.display = "hidden", D.div.append(this.div), T = K.getBoundingClientRect(), K.remove(), K.style.display = _;
          }
          this.rotation % 180 === this.parentRotation % 180 ? (this.width = T.width / S, this.height = T.height / B) : (this.width = T.height / S, this.height = T.width / B), this.fixAndSetPosition();
        }, k = new WeakSet(), oa = function() {
          if (this.editorDiv.replaceChildren(), !!le(this, j))
            for (const S of le(this, j).split(`
`)) {
              const B = document.createElement("div");
              B.append(S ? document.createTextNode(S) : document.createElement("br")), this.editorDiv.append(B);
            }
        }, x = new WeakSet(), qa = function(S) {
          const {
            value: B,
            fontSize: T,
            color: D,
            rect: K,
            pageIndex: _
          } = le(this, v);
          return S.value !== B || S.fontSize !== T || S.rect.some((o, m) => Math.abs(o - K[m]) >= 1) || S.color.some((o, m) => o !== D[m]) || S.pageIndex !== _;
        }, f = new WeakSet(), ca = function(S = !1) {
          if (!this.annotationElementId)
            return;
          if (De(this, I, Dn).call(this), !S && (this.width === 0 || this.height === 0)) {
            setTimeout(() => De(this, f, ca).call(this, !0), 0);
            return;
          }
          const B = N._internalPadding * this.parentScale;
          le(this, v).rect = this.getRect(B, B);
        }, Ot(N, "_freeTextDefaultContent", ""), Ot(N, "_internalPadding", 0), Ot(N, "_defaultColor", null), Ot(N, "_defaultFontSize", 10), Ot(N, "_type", "freetext");
        let n = N;
        ge.FreeTextEditor = n;
      },
      /* 29 */
      /***/
      (Re, ge, xe) => {
        var m, r, fn, M, Va, G, ce, q, re, Z, te, L, X, J, Y, ae, se, Q, z, ie, ne, W, oe, Ka, pe, ei, Ce, la, Pe, ha, me, we, _e, Se, Ae, Te, ke, ua, Ve, je, at, $e, Ya, ze, da;
        Object.defineProperty(ge, "__esModule", {
          value: !0
        }), ge.StampAnnotationElement = ge.InkAnnotationElement = ge.FreeTextAnnotationElement = ge.AnnotationLayer = void 0;
        var de = xe(1), fe = xe(6), w = xe(3), V = xe(30), n = xe(31), F = xe(32);
        const C = 1e3, e = 9, t = /* @__PURE__ */ new WeakSet();
        function l(Qe) {
          return {
            width: Qe[2] - Qe[0],
            height: Qe[3] - Qe[1]
          };
        }
        class j {
          static create(Oe) {
            switch (Oe.data.annotationType) {
              case de.AnnotationType.LINK:
                return new O(Oe);
              case de.AnnotationType.TEXT:
                return new v(Oe);
              case de.AnnotationType.WIDGET:
                switch (Oe.data.fieldType) {
                  case "Tx":
                    return new b(Oe);
                  case "Btn":
                    return Oe.data.radioButton ? new d(Oe) : Oe.data.checkBox ? new P(Oe) : new A(Oe);
                  case "Ch":
                    return new I(Oe);
                  case "Sig":
                    return new i(Oe);
                }
                return new g(Oe);
              case de.AnnotationType.POPUP:
                return new E(Oe);
              case de.AnnotationType.FREETEXT:
                return new H(Oe);
              case de.AnnotationType.LINE:
                return new x(Oe);
              case de.AnnotationType.SQUARE:
                return new R(Oe);
              case de.AnnotationType.CIRCLE:
                return new f(Oe);
              case de.AnnotationType.POLYLINE:
                return new c(Oe);
              case de.AnnotationType.CARET:
                return new u(Oe);
              case de.AnnotationType.INK:
                return new p(Oe);
              case de.AnnotationType.POLYGON:
                return new N(Oe);
              case de.AnnotationType.HIGHLIGHT:
                return new S(Oe);
              case de.AnnotationType.UNDERLINE:
                return new B(Oe);
              case de.AnnotationType.SQUIGGLY:
                return new T(Oe);
              case de.AnnotationType.STRIKEOUT:
                return new D(Oe);
              case de.AnnotationType.STAMP:
                return new K(Oe);
              case de.AnnotationType.FILEATTACHMENT:
                return new _(Oe);
              default:
                return new U(Oe);
            }
          }
        }
        const s = class s {
          constructor(Oe, {
            isRenderable: he = !1,
            ignoreBorder: ye = !1,
            createQuadrilaterals: Ie = !1
          } = {}) {
            Me(this, m, !1);
            this.isRenderable = he, this.data = Oe.data, this.layer = Oe.layer, this.linkService = Oe.linkService, this.downloadManager = Oe.downloadManager, this.imageResourcesPath = Oe.imageResourcesPath, this.renderForms = Oe.renderForms, this.svgFactory = Oe.svgFactory, this.annotationStorage = Oe.annotationStorage, this.enableScripting = Oe.enableScripting, this.hasJSActions = Oe.hasJSActions, this._fieldObjects = Oe.fieldObjects, this.parent = Oe.parent, he && (this.container = this._createContainer(ye)), Ie && this._createQuadrilaterals();
          }
          static _hasPopupData({
            titleObj: Oe,
            contentsObj: he,
            richText: ye
          }) {
            return !!(Oe != null && Oe.str || he != null && he.str || ye != null && ye.str);
          }
          get hasPopupData() {
            return s._hasPopupData(this.data);
          }
          _createContainer(Oe) {
            const {
              data: he,
              parent: {
                page: ye,
                viewport: Ie
              }
            } = this, Le = document.createElement("section");
            Le.setAttribute("data-annotation-id", he.id), this instanceof g || (Le.tabIndex = C), Le.style.zIndex = this.parent.zIndex++, this.data.popupRef && Le.setAttribute("aria-haspopup", "dialog"), he.noRotate && Le.classList.add("norotate");
            const {
              pageWidth: Be,
              pageHeight: Ne,
              pageX: Ue,
              pageY: qe
            } = Ie.rawDims;
            if (!he.rect || this instanceof E) {
              const {
                rotation: ut
              } = he;
              return !he.hasOwnCanvas && ut !== 0 && this.setRotation(ut, Le), Le;
            }
            const {
              width: tt,
              height: ht
            } = l(he.rect), rt = de.Util.normalizeRect([he.rect[0], ye.view[3] - he.rect[1] + ye.view[1], he.rect[2], ye.view[3] - he.rect[3] + ye.view[1]]);
            if (!Oe && he.borderStyle.width > 0) {
              Le.style.borderWidth = `${he.borderStyle.width}px`;
              const ut = he.borderStyle.horizontalCornerRadius, bt = he.borderStyle.verticalCornerRadius;
              if (ut > 0 || bt > 0) {
                const We = `calc(${ut}px * var(--scale-factor)) / calc(${bt}px * var(--scale-factor))`;
                Le.style.borderRadius = We;
              } else if (this instanceof d) {
                const We = `calc(${tt}px * var(--scale-factor)) / calc(${ht}px * var(--scale-factor))`;
                Le.style.borderRadius = We;
              }
              switch (he.borderStyle.style) {
                case de.AnnotationBorderStyleType.SOLID:
                  Le.style.borderStyle = "solid";
                  break;
                case de.AnnotationBorderStyleType.DASHED:
                  Le.style.borderStyle = "dashed";
                  break;
                case de.AnnotationBorderStyleType.BEVELED:
                  (0, de.warn)("Unimplemented border style: beveled");
                  break;
                case de.AnnotationBorderStyleType.INSET:
                  (0, de.warn)("Unimplemented border style: inset");
                  break;
                case de.AnnotationBorderStyleType.UNDERLINE:
                  Le.style.borderBottomStyle = "solid";
                  break;
              }
              const Ge = he.borderColor || null;
              Ge ? (Xe(this, m, !0), Le.style.borderColor = de.Util.makeHexColor(Ge[0] | 0, Ge[1] | 0, Ge[2] | 0)) : Le.style.borderWidth = 0;
            }
            Le.style.left = `${100 * (rt[0] - Ue) / Be}%`, Le.style.top = `${100 * (rt[1] - qe) / Ne}%`;
            const {
              rotation: nt
            } = he;
            return he.hasOwnCanvas || nt === 0 ? (Le.style.width = `${100 * tt / Be}%`, Le.style.height = `${100 * ht / Ne}%`) : this.setRotation(nt, Le), Le;
          }
          setRotation(Oe, he = this.container) {
            if (!this.data.rect)
              return;
            const {
              pageWidth: ye,
              pageHeight: Ie
            } = this.parent.viewport.rawDims, {
              width: Le,
              height: Be
            } = l(this.data.rect);
            let Ne, Ue;
            Oe % 180 === 0 ? (Ne = 100 * Le / ye, Ue = 100 * Be / Ie) : (Ne = 100 * Be / ye, Ue = 100 * Le / Ie), he.style.width = `${Ne}%`, he.style.height = `${Ue}%`, he.setAttribute("data-main-rotation", (360 - Oe) % 360);
          }
          get _commonActions() {
            const Oe = (he, ye, Ie) => {
              const Le = Ie.detail[he], Be = Le[0], Ne = Le.slice(1);
              Ie.target.style[ye] = V.ColorConverters[`${Be}_HTML`](Ne), this.annotationStorage.setValue(this.data.id, {
                [ye]: V.ColorConverters[`${Be}_rgb`](Ne)
              });
            };
            return (0, de.shadow)(this, "_commonActions", {
              display: (he) => {
                const {
                  display: ye
                } = he.detail, Ie = ye % 2 === 1;
                this.container.style.visibility = Ie ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
                  noView: Ie,
                  noPrint: ye === 1 || ye === 2
                });
              },
              print: (he) => {
                this.annotationStorage.setValue(this.data.id, {
                  noPrint: !he.detail.print
                });
              },
              hidden: (he) => {
                const {
                  hidden: ye
                } = he.detail;
                this.container.style.visibility = ye ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
                  noPrint: ye,
                  noView: ye
                });
              },
              focus: (he) => {
                setTimeout(() => he.target.focus({
                  preventScroll: !1
                }), 0);
              },
              userName: (he) => {
                he.target.title = he.detail.userName;
              },
              readonly: (he) => {
                he.target.disabled = he.detail.readonly;
              },
              required: (he) => {
                this._setRequired(he.target, he.detail.required);
              },
              bgColor: (he) => {
                Oe("bgColor", "backgroundColor", he);
              },
              fillColor: (he) => {
                Oe("fillColor", "backgroundColor", he);
              },
              fgColor: (he) => {
                Oe("fgColor", "color", he);
              },
              textColor: (he) => {
                Oe("textColor", "color", he);
              },
              borderColor: (he) => {
                Oe("borderColor", "borderColor", he);
              },
              strokeColor: (he) => {
                Oe("strokeColor", "borderColor", he);
              },
              rotation: (he) => {
                const ye = he.detail.rotation;
                this.setRotation(ye), this.annotationStorage.setValue(this.data.id, {
                  rotation: ye
                });
              }
            });
          }
          _dispatchEventFromSandbox(Oe, he) {
            const ye = this._commonActions;
            for (const Ie of Object.keys(he.detail)) {
              const Le = Oe[Ie] || ye[Ie];
              Le == null || Le(he);
            }
          }
          _setDefaultPropertiesFromJS(Oe) {
            if (!this.enableScripting)
              return;
            const he = this.annotationStorage.getRawValue(this.data.id);
            if (!he)
              return;
            const ye = this._commonActions;
            for (const [Ie, Le] of Object.entries(he)) {
              const Be = ye[Ie];
              if (Be) {
                const Ne = {
                  detail: {
                    [Ie]: Le
                  },
                  target: Oe
                };
                Be(Ne), delete he[Ie];
              }
            }
          }
          _createQuadrilaterals() {
            if (!this.container)
              return;
            const {
              quadPoints: Oe
            } = this.data;
            if (!Oe)
              return;
            const [he, ye, Ie, Le] = this.data.rect;
            if (Oe.length === 1) {
              const [, {
                x: bt,
                y: Ge
              }, {
                x: We,
                y: Je
              }] = Oe[0];
              if (Ie === bt && Le === Ge && he === We && ye === Je)
                return;
            }
            const {
              style: Be
            } = this.container;
            let Ne;
            if (le(this, m)) {
              const {
                borderColor: bt,
                borderWidth: Ge
              } = Be;
              Be.borderWidth = 0, Ne = ["url('data:image/svg+xml;utf8,", '<svg xmlns="http://www.w3.org/2000/svg"', ' preserveAspectRatio="none" viewBox="0 0 1 1">', `<g fill="transparent" stroke="${bt}" stroke-width="${Ge}">`], this.container.classList.add("hasBorder");
            }
            const Ue = Ie - he, qe = Le - ye, {
              svgFactory: tt
            } = this, ht = tt.createElement("svg");
            ht.classList.add("quadrilateralsContainer"), ht.setAttribute("width", 0), ht.setAttribute("height", 0);
            const rt = tt.createElement("defs");
            ht.append(rt);
            const nt = tt.createElement("clipPath"), ut = `clippath_${this.data.id}`;
            nt.setAttribute("id", ut), nt.setAttribute("clipPathUnits", "objectBoundingBox"), rt.append(nt);
            for (const [, {
              x: bt,
              y: Ge
            }, {
              x: We,
              y: Je
            }] of Oe) {
              const et = tt.createElement("rect"), lt = (We - he) / Ue, pt = (Le - Ge) / qe, ot = (bt - We) / Ue, st = (Ge - Je) / qe;
              et.setAttribute("x", lt), et.setAttribute("y", pt), et.setAttribute("width", ot), et.setAttribute("height", st), nt.append(et), Ne == null || Ne.push(`<rect vector-effect="non-scaling-stroke" x="${lt}" y="${pt}" width="${ot}" height="${st}"/>`);
            }
            le(this, m) && (Ne.push("</g></svg>')"), Be.backgroundImage = Ne.join("")), this.container.append(ht), this.container.style.clipPath = `url(#${ut})`;
          }
          _createPopup() {
            const {
              container: Oe,
              data: he
            } = this;
            Oe.setAttribute("aria-haspopup", "dialog");
            const ye = new E({
              data: {
                color: he.color,
                titleObj: he.titleObj,
                modificationDate: he.modificationDate,
                contentsObj: he.contentsObj,
                richText: he.richText,
                parentRect: he.rect,
                borderStyle: 0,
                id: `popup_${he.id}`,
                rotation: he.rotation
              },
              parent: this.parent,
              elements: [this]
            });
            this.parent.div.append(ye.render());
          }
          render() {
            (0, de.unreachable)("Abstract method `AnnotationElement.render` called");
          }
          _getElementsByName(Oe, he = null) {
            const ye = [];
            if (this._fieldObjects) {
              const Ie = this._fieldObjects[Oe];
              if (Ie)
                for (const {
                  page: Le,
                  id: Be,
                  exportValues: Ne
                } of Ie) {
                  if (Le === -1 || Be === he)
                    continue;
                  const Ue = typeof Ne == "string" ? Ne : null, qe = document.querySelector(`[data-element-id="${Be}"]`);
                  if (qe && !t.has(qe)) {
                    (0, de.warn)(`_getElementsByName - element not allowed: ${Be}`);
                    continue;
                  }
                  ye.push({
                    id: Be,
                    exportValue: Ue,
                    domElement: qe
                  });
                }
              return ye;
            }
            for (const Ie of document.getElementsByName(Oe)) {
              const {
                exportValue: Le
              } = Ie, Be = Ie.getAttribute("data-element-id");
              Be !== he && t.has(Ie) && ye.push({
                id: Be,
                exportValue: Le,
                domElement: Ie
              });
            }
            return ye;
          }
          show() {
            var Oe;
            this.container && (this.container.hidden = !1), (Oe = this.popup) == null || Oe.maybeShow();
          }
          hide() {
            var Oe;
            this.container && (this.container.hidden = !0), (Oe = this.popup) == null || Oe.forceHide();
          }
          getElementsToTriggerPopup() {
            return this.container;
          }
          addHighlightArea() {
            const Oe = this.getElementsToTriggerPopup();
            if (Array.isArray(Oe))
              for (const he of Oe)
                he.classList.add("highlightArea");
            else
              Oe.classList.add("highlightArea");
          }
          _editOnDoubleClick() {
            const {
              annotationEditorType: Oe,
              data: {
                id: he
              }
            } = this;
            this.container.addEventListener("dblclick", () => {
              var ye;
              (ye = this.linkService.eventBus) == null || ye.dispatch("switchannotationeditormode", {
                source: this,
                mode: Oe,
                editId: he
              });
            });
          }
        };
        m = new WeakMap();
        let U = s;
        class O extends U {
          constructor(he, ye = null) {
            super(he, {
              isRenderable: !0,
              ignoreBorder: !!(ye != null && ye.ignoreBorder),
              createQuadrilaterals: !0
            });
            Me(this, r);
            Me(this, M);
            this.isTooltipOnly = he.data.isTooltipOnly;
          }
          render() {
            const {
              data: he,
              linkService: ye
            } = this, Ie = document.createElement("a");
            Ie.setAttribute("data-element-id", he.id);
            let Le = !1;
            return he.url ? (ye.addLinkAttributes(Ie, he.url, he.newWindow), Le = !0) : he.action ? (this._bindNamedAction(Ie, he.action), Le = !0) : he.attachment ? (this._bindAttachment(Ie, he.attachment), Le = !0) : he.setOCGState ? (De(this, M, Va).call(this, Ie, he.setOCGState), Le = !0) : he.dest ? (this._bindLink(Ie, he.dest), Le = !0) : (he.actions && (he.actions.Action || he.actions["Mouse Up"] || he.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions && (this._bindJSAction(Ie, he), Le = !0), he.resetForm ? (this._bindResetFormAction(Ie, he.resetForm), Le = !0) : this.isTooltipOnly && !Le && (this._bindLink(Ie, ""), Le = !0)), this.container.classList.add("linkAnnotation"), Le && this.container.append(Ie), this.container;
          }
          _bindLink(he, ye) {
            he.href = this.linkService.getDestinationHash(ye), he.onclick = () => (ye && this.linkService.goToDestination(ye), !1), (ye || ye === "") && De(this, r, fn).call(this);
          }
          _bindNamedAction(he, ye) {
            he.href = this.linkService.getAnchorUrl(""), he.onclick = () => (this.linkService.executeNamedAction(ye), !1), De(this, r, fn).call(this);
          }
          _bindAttachment(he, ye) {
            he.href = this.linkService.getAnchorUrl(""), he.onclick = () => {
              var Ie;
              return (Ie = this.downloadManager) == null || Ie.openOrDownloadData(this.container, ye.content, ye.filename), !1;
            }, De(this, r, fn).call(this);
          }
          _bindJSAction(he, ye) {
            he.href = this.linkService.getAnchorUrl("");
            const Ie = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
            for (const Le of Object.keys(ye.actions)) {
              const Be = Ie.get(Le);
              Be && (he[Be] = () => {
                var Ne;
                return (Ne = this.linkService.eventBus) == null || Ne.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: ye.id,
                    name: Le
                  }
                }), !1;
              });
            }
            he.onclick || (he.onclick = () => !1), De(this, r, fn).call(this);
          }
          _bindResetFormAction(he, ye) {
            const Ie = he.onclick;
            if (Ie || (he.href = this.linkService.getAnchorUrl("")), De(this, r, fn).call(this), !this._fieldObjects) {
              (0, de.warn)('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.'), Ie || (he.onclick = () => !1);
              return;
            }
            he.onclick = () => {
              var ht;
              Ie == null || Ie();
              const {
                fields: Le,
                refs: Be,
                include: Ne
              } = ye, Ue = [];
              if (Le.length !== 0 || Be.length !== 0) {
                const rt = new Set(Be);
                for (const nt of Le) {
                  const ut = this._fieldObjects[nt] || [];
                  for (const {
                    id: bt
                  } of ut)
                    rt.add(bt);
                }
                for (const nt of Object.values(this._fieldObjects))
                  for (const ut of nt)
                    rt.has(ut.id) === Ne && Ue.push(ut);
              } else
                for (const rt of Object.values(this._fieldObjects))
                  Ue.push(...rt);
              const qe = this.annotationStorage, tt = [];
              for (const rt of Ue) {
                const {
                  id: nt
                } = rt;
                switch (tt.push(nt), rt.type) {
                  case "text": {
                    const bt = rt.defaultValue || "";
                    qe.setValue(nt, {
                      value: bt
                    });
                    break;
                  }
                  case "checkbox":
                  case "radiobutton": {
                    const bt = rt.defaultValue === rt.exportValues;
                    qe.setValue(nt, {
                      value: bt
                    });
                    break;
                  }
                  case "combobox":
                  case "listbox": {
                    const bt = rt.defaultValue || "";
                    qe.setValue(nt, {
                      value: bt
                    });
                    break;
                  }
                  default:
                    continue;
                }
                const ut = document.querySelector(`[data-element-id="${nt}"]`);
                if (ut) {
                  if (!t.has(ut)) {
                    (0, de.warn)(`_bindResetFormAction - element not allowed: ${nt}`);
                    continue;
                  }
                } else
                  continue;
                ut.dispatchEvent(new Event("resetform"));
              }
              return this.enableScripting && ((ht = this.linkService.eventBus) == null || ht.dispatch("dispatcheventinsandbox", {
                source: this,
                detail: {
                  id: "app",
                  ids: tt,
                  name: "ResetForm"
                }
              })), !1;
            };
          }
        }
        r = new WeakSet(), fn = function() {
          this.container.setAttribute("data-internal-link", "");
        }, M = new WeakSet(), Va = function(he, ye) {
          he.href = this.linkService.getAnchorUrl(""), he.onclick = () => (this.linkService.executeSetOCGState(ye), !1), De(this, r, fn).call(this);
        };
        class v extends U {
          constructor(Oe) {
            super(Oe, {
              isRenderable: !0
            });
          }
          render() {
            this.container.classList.add("textAnnotation");
            const Oe = document.createElement("img");
            return Oe.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg", Oe.alt = "[{{type}} Annotation]", Oe.dataset.l10nId = "text_annotation_type", Oe.dataset.l10nArgs = JSON.stringify({
              type: this.data.name
            }), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.append(Oe), this.container;
          }
        }
        class g extends U {
          render() {
            return this.data.alternativeText && (this.container.title = this.data.alternativeText), this.container;
          }
          showElementAndHideCanvas(Oe) {
            var he;
            this.data.hasOwnCanvas && (((he = Oe.previousSibling) == null ? void 0 : he.nodeName) === "CANVAS" && (Oe.previousSibling.hidden = !0), Oe.hidden = !1);
          }
          _getKeyModifier(Oe) {
            const {
              isWin: he,
              isMac: ye
            } = de.FeatureTest.platform;
            return he && Oe.ctrlKey || ye && Oe.metaKey;
          }
          _setEventListener(Oe, he, ye, Ie, Le) {
            ye.includes("mouse") ? Oe.addEventListener(ye, (Be) => {
              var Ne;
              (Ne = this.linkService.eventBus) == null || Ne.dispatch("dispatcheventinsandbox", {
                source: this,
                detail: {
                  id: this.data.id,
                  name: Ie,
                  value: Le(Be),
                  shift: Be.shiftKey,
                  modifier: this._getKeyModifier(Be)
                }
              });
            }) : Oe.addEventListener(ye, (Be) => {
              var Ne;
              if (ye === "blur") {
                if (!he.focused || !Be.relatedTarget)
                  return;
                he.focused = !1;
              } else if (ye === "focus") {
                if (he.focused)
                  return;
                he.focused = !0;
              }
              Le && ((Ne = this.linkService.eventBus) == null || Ne.dispatch("dispatcheventinsandbox", {
                source: this,
                detail: {
                  id: this.data.id,
                  name: Ie,
                  value: Le(Be)
                }
              }));
            });
          }
          _setEventListeners(Oe, he, ye, Ie) {
            var Le, Be, Ne;
            for (const [Ue, qe] of ye)
              (qe === "Action" || (Le = this.data.actions) != null && Le[qe]) && ((qe === "Focus" || qe === "Blur") && (he || (he = {
                focused: !1
              })), this._setEventListener(Oe, he, Ue, qe, Ie), qe === "Focus" && !((Be = this.data.actions) != null && Be.Blur) ? this._setEventListener(Oe, he, "blur", "Blur", null) : qe === "Blur" && !((Ne = this.data.actions) != null && Ne.Focus) && this._setEventListener(Oe, he, "focus", "Focus", null));
          }
          _setBackgroundColor(Oe) {
            const he = this.data.backgroundColor || null;
            Oe.style.backgroundColor = he === null ? "transparent" : de.Util.makeHexColor(he[0], he[1], he[2]);
          }
          _setTextStyle(Oe) {
            const he = ["left", "center", "right"], {
              fontColor: ye
            } = this.data.defaultAppearanceData, Ie = this.data.defaultAppearanceData.fontSize || e, Le = Oe.style;
            let Be;
            const Ne = 2, Ue = (qe) => Math.round(10 * qe) / 10;
            if (this.data.multiLine) {
              const qe = Math.abs(this.data.rect[3] - this.data.rect[1] - Ne), tt = Math.round(qe / (de.LINE_FACTOR * Ie)) || 1, ht = qe / tt;
              Be = Math.min(Ie, Ue(ht / de.LINE_FACTOR));
            } else {
              const qe = Math.abs(this.data.rect[3] - this.data.rect[1] - Ne);
              Be = Math.min(Ie, Ue(qe / de.LINE_FACTOR));
            }
            Le.fontSize = `calc(${Be}px * var(--scale-factor))`, Le.color = de.Util.makeHexColor(ye[0], ye[1], ye[2]), this.data.textAlignment !== null && (Le.textAlign = he[this.data.textAlignment]);
          }
          _setRequired(Oe, he) {
            he ? Oe.setAttribute("required", !0) : Oe.removeAttribute("required"), Oe.setAttribute("aria-required", he);
          }
        }
        class b extends g {
          constructor(Oe) {
            const he = Oe.renderForms || !Oe.data.hasAppearance && !!Oe.data.fieldValue;
            super(Oe, {
              isRenderable: he
            });
          }
          setPropertyOnSiblings(Oe, he, ye, Ie) {
            const Le = this.annotationStorage;
            for (const Be of this._getElementsByName(Oe.name, Oe.id))
              Be.domElement && (Be.domElement[he] = ye), Le.setValue(Be.id, {
                [Ie]: ye
              });
          }
          render() {
            var Ie, Le;
            const Oe = this.annotationStorage, he = this.data.id;
            this.container.classList.add("textWidgetAnnotation");
            let ye = null;
            if (this.renderForms) {
              const Be = Oe.getValue(he, {
                value: this.data.fieldValue
              });
              let Ne = Be.value || "";
              const Ue = Oe.getValue(he, {
                charLimit: this.data.maxLen
              }).charLimit;
              Ue && Ne.length > Ue && (Ne = Ne.slice(0, Ue));
              let qe = Be.formattedValue || ((Ie = this.data.textContent) == null ? void 0 : Ie.join(`
`)) || null;
              qe && this.data.comb && (qe = qe.replaceAll(/\s+/g, ""));
              const tt = {
                userValue: Ne,
                formattedValue: qe,
                lastCommittedValue: null,
                commitKey: 1,
                focused: !1
              };
              this.data.multiLine ? (ye = document.createElement("textarea"), ye.textContent = qe ?? Ne, this.data.doNotScroll && (ye.style.overflowY = "hidden")) : (ye = document.createElement("input"), ye.type = "text", ye.setAttribute("value", qe ?? Ne), this.data.doNotScroll && (ye.style.overflowX = "hidden")), this.data.hasOwnCanvas && (ye.hidden = !0), t.add(ye), ye.setAttribute("data-element-id", he), ye.disabled = this.data.readOnly, ye.name = this.data.fieldName, ye.tabIndex = C, this._setRequired(ye, this.data.required), Ue && (ye.maxLength = Ue), ye.addEventListener("input", (rt) => {
                Oe.setValue(he, {
                  value: rt.target.value
                }), this.setPropertyOnSiblings(ye, "value", rt.target.value, "value"), tt.formattedValue = null;
              }), ye.addEventListener("resetform", (rt) => {
                const nt = this.data.defaultFieldValue ?? "";
                ye.value = tt.userValue = nt, tt.formattedValue = null;
              });
              let ht = (rt) => {
                const {
                  formattedValue: nt
                } = tt;
                nt != null && (rt.target.value = nt), rt.target.scrollLeft = 0;
              };
              if (this.enableScripting && this.hasJSActions) {
                ye.addEventListener("focus", (nt) => {
                  if (tt.focused)
                    return;
                  const {
                    target: ut
                  } = nt;
                  tt.userValue && (ut.value = tt.userValue), tt.lastCommittedValue = ut.value, tt.commitKey = 1, tt.focused = !0;
                }), ye.addEventListener("updatefromsandbox", (nt) => {
                  this.showElementAndHideCanvas(nt.target);
                  const ut = {
                    value(bt) {
                      tt.userValue = bt.detail.value ?? "", Oe.setValue(he, {
                        value: tt.userValue.toString()
                      }), bt.target.value = tt.userValue;
                    },
                    formattedValue(bt) {
                      const {
                        formattedValue: Ge
                      } = bt.detail;
                      tt.formattedValue = Ge, Ge != null && bt.target !== document.activeElement && (bt.target.value = Ge), Oe.setValue(he, {
                        formattedValue: Ge
                      });
                    },
                    selRange(bt) {
                      bt.target.setSelectionRange(...bt.detail.selRange);
                    },
                    charLimit: (bt) => {
                      var et;
                      const {
                        charLimit: Ge
                      } = bt.detail, {
                        target: We
                      } = bt;
                      if (Ge === 0) {
                        We.removeAttribute("maxLength");
                        return;
                      }
                      We.setAttribute("maxLength", Ge);
                      let Je = tt.userValue;
                      !Je || Je.length <= Ge || (Je = Je.slice(0, Ge), We.value = tt.userValue = Je, Oe.setValue(he, {
                        value: Je
                      }), (et = this.linkService.eventBus) == null || et.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id: he,
                          name: "Keystroke",
                          value: Je,
                          willCommit: !0,
                          commitKey: 1,
                          selStart: We.selectionStart,
                          selEnd: We.selectionEnd
                        }
                      }));
                    }
                  };
                  this._dispatchEventFromSandbox(ut, nt);
                }), ye.addEventListener("keydown", (nt) => {
                  var Ge;
                  tt.commitKey = 1;
                  let ut = -1;
                  if (nt.key === "Escape" ? ut = 0 : nt.key === "Enter" && !this.data.multiLine ? ut = 2 : nt.key === "Tab" && (tt.commitKey = 3), ut === -1)
                    return;
                  const {
                    value: bt
                  } = nt.target;
                  tt.lastCommittedValue !== bt && (tt.lastCommittedValue = bt, tt.userValue = bt, (Ge = this.linkService.eventBus) == null || Ge.dispatch("dispatcheventinsandbox", {
                    source: this,
                    detail: {
                      id: he,
                      name: "Keystroke",
                      value: bt,
                      willCommit: !0,
                      commitKey: ut,
                      selStart: nt.target.selectionStart,
                      selEnd: nt.target.selectionEnd
                    }
                  }));
                });
                const rt = ht;
                ht = null, ye.addEventListener("blur", (nt) => {
                  var bt;
                  if (!tt.focused || !nt.relatedTarget)
                    return;
                  tt.focused = !1;
                  const {
                    value: ut
                  } = nt.target;
                  tt.userValue = ut, tt.lastCommittedValue !== ut && ((bt = this.linkService.eventBus) == null || bt.dispatch("dispatcheventinsandbox", {
                    source: this,
                    detail: {
                      id: he,
                      name: "Keystroke",
                      value: ut,
                      willCommit: !0,
                      commitKey: tt.commitKey,
                      selStart: nt.target.selectionStart,
                      selEnd: nt.target.selectionEnd
                    }
                  })), rt(nt);
                }), (Le = this.data.actions) != null && Le.Keystroke && ye.addEventListener("beforeinput", (nt) => {
                  var pt;
                  tt.lastCommittedValue = null;
                  const {
                    data: ut,
                    target: bt
                  } = nt, {
                    value: Ge,
                    selectionStart: We,
                    selectionEnd: Je
                  } = bt;
                  let et = We, lt = Je;
                  switch (nt.inputType) {
                    case "deleteWordBackward": {
                      const ot = Ge.substring(0, We).match(/\w*[^\w]*$/);
                      ot && (et -= ot[0].length);
                      break;
                    }
                    case "deleteWordForward": {
                      const ot = Ge.substring(We).match(/^[^\w]*\w*/);
                      ot && (lt += ot[0].length);
                      break;
                    }
                    case "deleteContentBackward":
                      We === Je && (et -= 1);
                      break;
                    case "deleteContentForward":
                      We === Je && (lt += 1);
                      break;
                  }
                  nt.preventDefault(), (pt = this.linkService.eventBus) == null || pt.dispatch("dispatcheventinsandbox", {
                    source: this,
                    detail: {
                      id: he,
                      name: "Keystroke",
                      value: Ge,
                      change: ut || "",
                      willCommit: !1,
                      selStart: et,
                      selEnd: lt
                    }
                  });
                }), this._setEventListeners(ye, tt, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (nt) => nt.target.value);
              }
              if (ht && ye.addEventListener("blur", ht), this.data.comb) {
                const nt = (this.data.rect[2] - this.data.rect[0]) / Ue;
                ye.classList.add("comb"), ye.style.letterSpacing = `calc(${nt}px * var(--scale-factor) - 1ch)`;
              }
            } else
              ye = document.createElement("div"), ye.textContent = this.data.fieldValue, ye.style.verticalAlign = "middle", ye.style.display = "table-cell";
            return this._setTextStyle(ye), this._setBackgroundColor(ye), this._setDefaultPropertiesFromJS(ye), this.container.append(ye), this.container;
          }
        }
        class i extends g {
          constructor(Oe) {
            super(Oe, {
              isRenderable: !!Oe.data.hasOwnCanvas
            });
          }
        }
        class P extends g {
          constructor(Oe) {
            super(Oe, {
              isRenderable: Oe.renderForms
            });
          }
          render() {
            const Oe = this.annotationStorage, he = this.data, ye = he.id;
            let Ie = Oe.getValue(ye, {
              value: he.exportValue === he.fieldValue
            }).value;
            typeof Ie == "string" && (Ie = Ie !== "Off", Oe.setValue(ye, {
              value: Ie
            })), this.container.classList.add("buttonWidgetAnnotation", "checkBox");
            const Le = document.createElement("input");
            return t.add(Le), Le.setAttribute("data-element-id", ye), Le.disabled = he.readOnly, this._setRequired(Le, this.data.required), Le.type = "checkbox", Le.name = he.fieldName, Ie && Le.setAttribute("checked", !0), Le.setAttribute("exportValue", he.exportValue), Le.tabIndex = C, Le.addEventListener("change", (Be) => {
              const {
                name: Ne,
                checked: Ue
              } = Be.target;
              for (const qe of this._getElementsByName(Ne, ye)) {
                const tt = Ue && qe.exportValue === he.exportValue;
                qe.domElement && (qe.domElement.checked = tt), Oe.setValue(qe.id, {
                  value: tt
                });
              }
              Oe.setValue(ye, {
                value: Ue
              });
            }), Le.addEventListener("resetform", (Be) => {
              const Ne = he.defaultFieldValue || "Off";
              Be.target.checked = Ne === he.exportValue;
            }), this.enableScripting && this.hasJSActions && (Le.addEventListener("updatefromsandbox", (Be) => {
              const Ne = {
                value(Ue) {
                  Ue.target.checked = Ue.detail.value !== "Off", Oe.setValue(ye, {
                    value: Ue.target.checked
                  });
                }
              };
              this._dispatchEventFromSandbox(Ne, Be);
            }), this._setEventListeners(Le, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (Be) => Be.target.checked)), this._setBackgroundColor(Le), this._setDefaultPropertiesFromJS(Le), this.container.append(Le), this.container;
          }
        }
        class d extends g {
          constructor(Oe) {
            super(Oe, {
              isRenderable: Oe.renderForms
            });
          }
          render() {
            this.container.classList.add("buttonWidgetAnnotation", "radioButton");
            const Oe = this.annotationStorage, he = this.data, ye = he.id;
            let Ie = Oe.getValue(ye, {
              value: he.fieldValue === he.buttonValue
            }).value;
            typeof Ie == "string" && (Ie = Ie !== he.buttonValue, Oe.setValue(ye, {
              value: Ie
            }));
            const Le = document.createElement("input");
            if (t.add(Le), Le.setAttribute("data-element-id", ye), Le.disabled = he.readOnly, this._setRequired(Le, this.data.required), Le.type = "radio", Le.name = he.fieldName, Ie && Le.setAttribute("checked", !0), Le.tabIndex = C, Le.addEventListener("change", (Be) => {
              const {
                name: Ne,
                checked: Ue
              } = Be.target;
              for (const qe of this._getElementsByName(Ne, ye))
                Oe.setValue(qe.id, {
                  value: !1
                });
              Oe.setValue(ye, {
                value: Ue
              });
            }), Le.addEventListener("resetform", (Be) => {
              const Ne = he.defaultFieldValue;
              Be.target.checked = Ne != null && Ne === he.buttonValue;
            }), this.enableScripting && this.hasJSActions) {
              const Be = he.buttonValue;
              Le.addEventListener("updatefromsandbox", (Ne) => {
                const Ue = {
                  value: (qe) => {
                    const tt = Be === qe.detail.value;
                    for (const ht of this._getElementsByName(qe.target.name)) {
                      const rt = tt && ht.id === ye;
                      ht.domElement && (ht.domElement.checked = rt), Oe.setValue(ht.id, {
                        value: rt
                      });
                    }
                  }
                };
                this._dispatchEventFromSandbox(Ue, Ne);
              }), this._setEventListeners(Le, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (Ne) => Ne.target.checked);
            }
            return this._setBackgroundColor(Le), this._setDefaultPropertiesFromJS(Le), this.container.append(Le), this.container;
          }
        }
        class A extends O {
          constructor(Oe) {
            super(Oe, {
              ignoreBorder: Oe.data.hasAppearance
            });
          }
          render() {
            const Oe = super.render();
            Oe.classList.add("buttonWidgetAnnotation", "pushButton"), this.data.alternativeText && (Oe.title = this.data.alternativeText);
            const he = Oe.lastChild;
            return this.enableScripting && this.hasJSActions && he && (this._setDefaultPropertiesFromJS(he), he.addEventListener("updatefromsandbox", (ye) => {
              this._dispatchEventFromSandbox({}, ye);
            })), Oe;
          }
        }
        class I extends g {
          constructor(Oe) {
            super(Oe, {
              isRenderable: Oe.renderForms
            });
          }
          render() {
            this.container.classList.add("choiceWidgetAnnotation");
            const Oe = this.annotationStorage, he = this.data.id, ye = Oe.getValue(he, {
              value: this.data.fieldValue
            }), Ie = document.createElement("select");
            t.add(Ie), Ie.setAttribute("data-element-id", he), Ie.disabled = this.data.readOnly, this._setRequired(Ie, this.data.required), Ie.name = this.data.fieldName, Ie.tabIndex = C;
            let Le = this.data.combo && this.data.options.length > 0;
            this.data.combo || (Ie.size = this.data.options.length, this.data.multiSelect && (Ie.multiple = !0)), Ie.addEventListener("resetform", (tt) => {
              const ht = this.data.defaultFieldValue;
              for (const rt of Ie.options)
                rt.selected = rt.value === ht;
            });
            for (const tt of this.data.options) {
              const ht = document.createElement("option");
              ht.textContent = tt.displayValue, ht.value = tt.exportValue, ye.value.includes(tt.exportValue) && (ht.setAttribute("selected", !0), Le = !1), Ie.append(ht);
            }
            let Be = null;
            if (Le) {
              const tt = document.createElement("option");
              tt.value = " ", tt.setAttribute("hidden", !0), tt.setAttribute("selected", !0), Ie.prepend(tt), Be = () => {
                tt.remove(), Ie.removeEventListener("input", Be), Be = null;
              }, Ie.addEventListener("input", Be);
            }
            const Ne = (tt) => {
              const ht = tt ? "value" : "textContent", {
                options: rt,
                multiple: nt
              } = Ie;
              return nt ? Array.prototype.filter.call(rt, (ut) => ut.selected).map((ut) => ut[ht]) : rt.selectedIndex === -1 ? null : rt[rt.selectedIndex][ht];
            };
            let Ue = Ne(!1);
            const qe = (tt) => {
              const ht = tt.target.options;
              return Array.prototype.map.call(ht, (rt) => ({
                displayValue: rt.textContent,
                exportValue: rt.value
              }));
            };
            return this.enableScripting && this.hasJSActions ? (Ie.addEventListener("updatefromsandbox", (tt) => {
              const ht = {
                value(rt) {
                  Be == null || Be();
                  const nt = rt.detail.value, ut = new Set(Array.isArray(nt) ? nt : [nt]);
                  for (const bt of Ie.options)
                    bt.selected = ut.has(bt.value);
                  Oe.setValue(he, {
                    value: Ne(!0)
                  }), Ue = Ne(!1);
                },
                multipleSelection(rt) {
                  Ie.multiple = !0;
                },
                remove(rt) {
                  const nt = Ie.options, ut = rt.detail.remove;
                  nt[ut].selected = !1, Ie.remove(ut), nt.length > 0 && Array.prototype.findIndex.call(nt, (Ge) => Ge.selected) === -1 && (nt[0].selected = !0), Oe.setValue(he, {
                    value: Ne(!0),
                    items: qe(rt)
                  }), Ue = Ne(!1);
                },
                clear(rt) {
                  for (; Ie.length !== 0; )
                    Ie.remove(0);
                  Oe.setValue(he, {
                    value: null,
                    items: []
                  }), Ue = Ne(!1);
                },
                insert(rt) {
                  const {
                    index: nt,
                    displayValue: ut,
                    exportValue: bt
                  } = rt.detail.insert, Ge = Ie.children[nt], We = document.createElement("option");
                  We.textContent = ut, We.value = bt, Ge ? Ge.before(We) : Ie.append(We), Oe.setValue(he, {
                    value: Ne(!0),
                    items: qe(rt)
                  }), Ue = Ne(!1);
                },
                items(rt) {
                  const {
                    items: nt
                  } = rt.detail;
                  for (; Ie.length !== 0; )
                    Ie.remove(0);
                  for (const ut of nt) {
                    const {
                      displayValue: bt,
                      exportValue: Ge
                    } = ut, We = document.createElement("option");
                    We.textContent = bt, We.value = Ge, Ie.append(We);
                  }
                  Ie.options.length > 0 && (Ie.options[0].selected = !0), Oe.setValue(he, {
                    value: Ne(!0),
                    items: qe(rt)
                  }), Ue = Ne(!1);
                },
                indices(rt) {
                  const nt = new Set(rt.detail.indices);
                  for (const ut of rt.target.options)
                    ut.selected = nt.has(ut.index);
                  Oe.setValue(he, {
                    value: Ne(!0)
                  }), Ue = Ne(!1);
                },
                editable(rt) {
                  rt.target.disabled = !rt.detail.editable;
                }
              };
              this._dispatchEventFromSandbox(ht, tt);
            }), Ie.addEventListener("input", (tt) => {
              var rt;
              const ht = Ne(!0);
              Oe.setValue(he, {
                value: ht
              }), tt.preventDefault(), (rt = this.linkService.eventBus) == null || rt.dispatch("dispatcheventinsandbox", {
                source: this,
                detail: {
                  id: he,
                  name: "Keystroke",
                  value: Ue,
                  changeEx: ht,
                  willCommit: !1,
                  commitKey: 1,
                  keyDown: !1
                }
              });
            }), this._setEventListeners(Ie, null, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], (tt) => tt.target.value)) : Ie.addEventListener("input", function(tt) {
              Oe.setValue(he, {
                value: Ne(!0)
              });
            }), this.data.combo && this._setTextStyle(Ie), this._setBackgroundColor(Ie), this._setDefaultPropertiesFromJS(Ie), this.container.append(Ie), this.container;
          }
        }
        class E extends U {
          constructor(Oe) {
            const {
              data: he,
              elements: ye
            } = Oe;
            super(Oe, {
              isRenderable: U._hasPopupData(he)
            }), this.elements = ye;
          }
          render() {
            this.container.classList.add("popupAnnotation");
            const Oe = new k({
              container: this.container,
              color: this.data.color,
              titleObj: this.data.titleObj,
              modificationDate: this.data.modificationDate,
              contentsObj: this.data.contentsObj,
              richText: this.data.richText,
              rect: this.data.rect,
              parentRect: this.data.parentRect || null,
              parent: this.parent,
              elements: this.elements,
              open: this.data.open
            }), he = [];
            for (const ye of this.elements)
              ye.popup = Oe, he.push(ye.data.id), ye.addHighlightArea();
            return this.container.setAttribute("aria-controls", he.map((ye) => `${de.AnnotationPrefix}${ye}`).join(",")), this.container;
          }
        }
        class k {
          constructor({
            container: Oe,
            color: he,
            elements: ye,
            titleObj: Ie,
            modificationDate: Le,
            contentsObj: Be,
            richText: Ne,
            parent: Ue,
            rect: qe,
            parentRect: tt,
            open: ht
          }) {
            Me(this, oe);
            Me(this, pe);
            Me(this, Ce);
            Me(this, Pe);
            Me(this, G, null);
            Me(this, ce, De(this, oe, Ka).bind(this));
            Me(this, q, De(this, Pe, ha).bind(this));
            Me(this, re, De(this, Ce, la).bind(this));
            Me(this, Z, De(this, pe, ei).bind(this));
            Me(this, te, null);
            Me(this, L, null);
            Me(this, X, null);
            Me(this, J, null);
            Me(this, Y, null);
            Me(this, ae, null);
            Me(this, se, !1);
            Me(this, Q, null);
            Me(this, z, null);
            Me(this, ie, null);
            Me(this, ne, null);
            Me(this, W, !1);
            var nt;
            Xe(this, L, Oe), Xe(this, ne, Ie), Xe(this, X, Be), Xe(this, ie, Ne), Xe(this, Y, Ue), Xe(this, te, he), Xe(this, z, qe), Xe(this, ae, tt), Xe(this, J, ye);
            const rt = fe.PDFDateString.toDateObject(Le);
            rt && Xe(this, G, Ue.l10n.get("annotation_date_string", {
              date: rt.toLocaleDateString(),
              time: rt.toLocaleTimeString()
            })), this.trigger = ye.flatMap((ut) => ut.getElementsToTriggerPopup());
            for (const ut of this.trigger)
              ut.addEventListener("click", le(this, Z)), ut.addEventListener("mouseenter", le(this, re)), ut.addEventListener("mouseleave", le(this, q)), ut.classList.add("popupTriggerArea");
            for (const ut of ye)
              (nt = ut.container) == null || nt.addEventListener("keydown", le(this, ce));
            le(this, L).hidden = !0, ht && De(this, pe, ei).call(this);
          }
          render() {
            if (le(this, Q))
              return;
            const {
              page: {
                view: Oe
              },
              viewport: {
                rawDims: {
                  pageWidth: he,
                  pageHeight: ye,
                  pageX: Ie,
                  pageY: Le
                }
              }
            } = le(this, Y), Be = Xe(this, Q, document.createElement("div"));
            if (Be.className = "popup", le(this, te)) {
              const et = Be.style.outlineColor = de.Util.makeHexColor(...le(this, te));
              CSS.supports("background-color", "color-mix(in srgb, red 30%, white)") ? Be.style.backgroundColor = `color-mix(in srgb, ${et} 30%, white)` : Be.style.backgroundColor = de.Util.makeHexColor(...le(this, te).map((pt) => Math.floor(0.7 * (255 - pt) + pt)));
            }
            const Ne = document.createElement("span");
            Ne.className = "header";
            const Ue = document.createElement("h1");
            if (Ne.append(Ue), {
              dir: Ue.dir,
              str: Ue.textContent
            } = le(this, ne), Be.append(Ne), le(this, G)) {
              const et = document.createElement("span");
              et.classList.add("popupDate"), le(this, G).then((lt) => {
                et.textContent = lt;
              }), Ne.append(et);
            }
            const qe = le(this, X), tt = le(this, ie);
            if (tt != null && tt.str && (!(qe != null && qe.str) || qe.str === tt.str))
              F.XfaLayer.render({
                xfaHtml: tt.html,
                intent: "richText",
                div: Be
              }), Be.lastChild.classList.add("richText", "popupContent");
            else {
              const et = this._formatContents(qe);
              Be.append(et);
            }
            let ht = !!le(this, ae), rt = ht ? le(this, ae) : le(this, z);
            for (const et of le(this, J))
              if (!rt || de.Util.intersect(et.data.rect, rt) !== null) {
                rt = et.data.rect, ht = !0;
                break;
              }
            const nt = de.Util.normalizeRect([rt[0], Oe[3] - rt[1] + Oe[1], rt[2], Oe[3] - rt[3] + Oe[1]]), bt = ht ? rt[2] - rt[0] + 5 : 0, Ge = nt[0] + bt, We = nt[1], {
              style: Je
            } = le(this, L);
            Je.left = `${100 * (Ge - Ie) / he}%`, Je.top = `${100 * (We - Le) / ye}%`, le(this, L).append(Be);
          }
          _formatContents({
            str: Oe,
            dir: he
          }) {
            const ye = document.createElement("p");
            ye.classList.add("popupContent"), ye.dir = he;
            const Ie = Oe.split(/(?:\r\n?|\n)/);
            for (let Le = 0, Be = Ie.length; Le < Be; ++Le) {
              const Ne = Ie[Le];
              ye.append(document.createTextNode(Ne)), Le < Be - 1 && ye.append(document.createElement("br"));
            }
            return ye;
          }
          forceHide() {
            Xe(this, W, this.isVisible), le(this, W) && (le(this, L).hidden = !0);
          }
          maybeShow() {
            le(this, W) && (Xe(this, W, !1), le(this, L).hidden = !1);
          }
          get isVisible() {
            return le(this, L).hidden === !1;
          }
        }
        G = new WeakMap(), ce = new WeakMap(), q = new WeakMap(), re = new WeakMap(), Z = new WeakMap(), te = new WeakMap(), L = new WeakMap(), X = new WeakMap(), J = new WeakMap(), Y = new WeakMap(), ae = new WeakMap(), se = new WeakMap(), Q = new WeakMap(), z = new WeakMap(), ie = new WeakMap(), ne = new WeakMap(), W = new WeakMap(), oe = new WeakSet(), Ka = function(Oe) {
          Oe.altKey || Oe.shiftKey || Oe.ctrlKey || Oe.metaKey || (Oe.key === "Enter" || Oe.key === "Escape" && le(this, se)) && De(this, pe, ei).call(this);
        }, pe = new WeakSet(), ei = function() {
          Xe(this, se, !le(this, se)), le(this, se) ? (De(this, Ce, la).call(this), le(this, L).addEventListener("click", le(this, Z)), le(this, L).addEventListener("keydown", le(this, ce))) : (De(this, Pe, ha).call(this), le(this, L).removeEventListener("click", le(this, Z)), le(this, L).removeEventListener("keydown", le(this, ce)));
        }, Ce = new WeakSet(), la = function() {
          le(this, Q) || this.render(), this.isVisible ? le(this, se) && le(this, L).classList.add("focused") : (le(this, L).hidden = !1, le(this, L).style.zIndex = parseInt(le(this, L).style.zIndex) + 1e3);
        }, Pe = new WeakSet(), ha = function() {
          le(this, L).classList.remove("focused"), !(le(this, se) || !this.isVisible) && (le(this, L).hidden = !0, le(this, L).style.zIndex = parseInt(le(this, L).style.zIndex) - 1e3);
        };
        class H extends U {
          constructor(Oe) {
            super(Oe, {
              isRenderable: !0,
              ignoreBorder: !0
            }), this.textContent = Oe.data.textContent, this.textPosition = Oe.data.textPosition, this.annotationEditorType = de.AnnotationEditorType.FREETEXT;
          }
          render() {
            if (this.container.classList.add("freeTextAnnotation"), this.textContent) {
              const Oe = document.createElement("div");
              Oe.classList.add("annotationTextContent"), Oe.setAttribute("role", "comment");
              for (const he of this.textContent) {
                const ye = document.createElement("span");
                ye.textContent = he, Oe.append(ye);
              }
              this.container.append(Oe);
            }
            return !this.data.popupRef && this.hasPopupData && this._createPopup(), this._editOnDoubleClick(), this.container;
          }
        }
        ge.FreeTextAnnotationElement = H;
        class x extends U {
          constructor(he) {
            super(he, {
              isRenderable: !0,
              ignoreBorder: !0
            });
            Me(this, me, null);
          }
          render() {
            this.container.classList.add("lineAnnotation");
            const he = this.data, {
              width: ye,
              height: Ie
            } = l(he.rect), Le = this.svgFactory.create(ye, Ie, !0), Be = Xe(this, me, this.svgFactory.createElement("svg:line"));
            return Be.setAttribute("x1", he.rect[2] - he.lineCoordinates[0]), Be.setAttribute("y1", he.rect[3] - he.lineCoordinates[1]), Be.setAttribute("x2", he.rect[2] - he.lineCoordinates[2]), Be.setAttribute("y2", he.rect[3] - he.lineCoordinates[3]), Be.setAttribute("stroke-width", he.borderStyle.width || 1), Be.setAttribute("stroke", "transparent"), Be.setAttribute("fill", "transparent"), Le.append(Be), this.container.append(Le), !he.popupRef && this.hasPopupData && this._createPopup(), this.container;
          }
          getElementsToTriggerPopup() {
            return le(this, me);
          }
          addHighlightArea() {
            this.container.classList.add("highlightArea");
          }
        }
        me = new WeakMap();
        class R extends U {
          constructor(he) {
            super(he, {
              isRenderable: !0,
              ignoreBorder: !0
            });
            Me(this, we, null);
          }
          render() {
            this.container.classList.add("squareAnnotation");
            const he = this.data, {
              width: ye,
              height: Ie
            } = l(he.rect), Le = this.svgFactory.create(ye, Ie, !0), Be = he.borderStyle.width, Ne = Xe(this, we, this.svgFactory.createElement("svg:rect"));
            return Ne.setAttribute("x", Be / 2), Ne.setAttribute("y", Be / 2), Ne.setAttribute("width", ye - Be), Ne.setAttribute("height", Ie - Be), Ne.setAttribute("stroke-width", Be || 1), Ne.setAttribute("stroke", "transparent"), Ne.setAttribute("fill", "transparent"), Le.append(Ne), this.container.append(Le), !he.popupRef && this.hasPopupData && this._createPopup(), this.container;
          }
          getElementsToTriggerPopup() {
            return le(this, we);
          }
          addHighlightArea() {
            this.container.classList.add("highlightArea");
          }
        }
        we = new WeakMap();
        class f extends U {
          constructor(he) {
            super(he, {
              isRenderable: !0,
              ignoreBorder: !0
            });
            Me(this, _e, null);
          }
          render() {
            this.container.classList.add("circleAnnotation");
            const he = this.data, {
              width: ye,
              height: Ie
            } = l(he.rect), Le = this.svgFactory.create(ye, Ie, !0), Be = he.borderStyle.width, Ne = Xe(this, _e, this.svgFactory.createElement("svg:ellipse"));
            return Ne.setAttribute("cx", ye / 2), Ne.setAttribute("cy", Ie / 2), Ne.setAttribute("rx", ye / 2 - Be / 2), Ne.setAttribute("ry", Ie / 2 - Be / 2), Ne.setAttribute("stroke-width", Be || 1), Ne.setAttribute("stroke", "transparent"), Ne.setAttribute("fill", "transparent"), Le.append(Ne), this.container.append(Le), !he.popupRef && this.hasPopupData && this._createPopup(), this.container;
          }
          getElementsToTriggerPopup() {
            return le(this, _e);
          }
          addHighlightArea() {
            this.container.classList.add("highlightArea");
          }
        }
        _e = new WeakMap();
        class c extends U {
          constructor(he) {
            super(he, {
              isRenderable: !0,
              ignoreBorder: !0
            });
            Me(this, Se, null);
            this.containerClassName = "polylineAnnotation", this.svgElementName = "svg:polyline";
          }
          render() {
            this.container.classList.add(this.containerClassName);
            const he = this.data, {
              width: ye,
              height: Ie
            } = l(he.rect), Le = this.svgFactory.create(ye, Ie, !0);
            let Be = [];
            for (const Ue of he.vertices) {
              const qe = Ue.x - he.rect[0], tt = he.rect[3] - Ue.y;
              Be.push(qe + "," + tt);
            }
            Be = Be.join(" ");
            const Ne = Xe(this, Se, this.svgFactory.createElement(this.svgElementName));
            return Ne.setAttribute("points", Be), Ne.setAttribute("stroke-width", he.borderStyle.width || 1), Ne.setAttribute("stroke", "transparent"), Ne.setAttribute("fill", "transparent"), Le.append(Ne), this.container.append(Le), !he.popupRef && this.hasPopupData && this._createPopup(), this.container;
          }
          getElementsToTriggerPopup() {
            return le(this, Se);
          }
          addHighlightArea() {
            this.container.classList.add("highlightArea");
          }
        }
        Se = new WeakMap();
        class N extends c {
          constructor(Oe) {
            super(Oe), this.containerClassName = "polygonAnnotation", this.svgElementName = "svg:polygon";
          }
        }
        class u extends U {
          constructor(Oe) {
            super(Oe, {
              isRenderable: !0,
              ignoreBorder: !0
            });
          }
          render() {
            return this.container.classList.add("caretAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
          }
        }
        class p extends U {
          constructor(he) {
            super(he, {
              isRenderable: !0,
              ignoreBorder: !0
            });
            Me(this, Ae, []);
            this.containerClassName = "inkAnnotation", this.svgElementName = "svg:polyline", this.annotationEditorType = de.AnnotationEditorType.INK;
          }
          render() {
            this.container.classList.add(this.containerClassName);
            const he = this.data, {
              width: ye,
              height: Ie
            } = l(he.rect), Le = this.svgFactory.create(ye, Ie, !0);
            for (const Be of he.inkLists) {
              let Ne = [];
              for (const qe of Be) {
                const tt = qe.x - he.rect[0], ht = he.rect[3] - qe.y;
                Ne.push(`${tt},${ht}`);
              }
              Ne = Ne.join(" ");
              const Ue = this.svgFactory.createElement(this.svgElementName);
              le(this, Ae).push(Ue), Ue.setAttribute("points", Ne), Ue.setAttribute("stroke-width", he.borderStyle.width || 1), Ue.setAttribute("stroke", "transparent"), Ue.setAttribute("fill", "transparent"), !he.popupRef && this.hasPopupData && this._createPopup(), Le.append(Ue);
            }
            return this.container.append(Le), this.container;
          }
          getElementsToTriggerPopup() {
            return le(this, Ae);
          }
          addHighlightArea() {
            this.container.classList.add("highlightArea");
          }
        }
        Ae = new WeakMap(), ge.InkAnnotationElement = p;
        class S extends U {
          constructor(Oe) {
            super(Oe, {
              isRenderable: !0,
              ignoreBorder: !0,
              createQuadrilaterals: !0
            });
          }
          render() {
            return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("highlightAnnotation"), this.container;
          }
        }
        class B extends U {
          constructor(Oe) {
            super(Oe, {
              isRenderable: !0,
              ignoreBorder: !0,
              createQuadrilaterals: !0
            });
          }
          render() {
            return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("underlineAnnotation"), this.container;
          }
        }
        class T extends U {
          constructor(Oe) {
            super(Oe, {
              isRenderable: !0,
              ignoreBorder: !0,
              createQuadrilaterals: !0
            });
          }
          render() {
            return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("squigglyAnnotation"), this.container;
          }
        }
        class D extends U {
          constructor(Oe) {
            super(Oe, {
              isRenderable: !0,
              ignoreBorder: !0,
              createQuadrilaterals: !0
            });
          }
          render() {
            return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("strikeoutAnnotation"), this.container;
          }
        }
        class K extends U {
          constructor(Oe) {
            super(Oe, {
              isRenderable: !0,
              ignoreBorder: !0
            });
          }
          render() {
            return this.container.classList.add("stampAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
          }
        }
        ge.StampAnnotationElement = K;
        class _ extends U {
          constructor(he) {
            var Le;
            super(he, {
              isRenderable: !0
            });
            Me(this, ke);
            Me(this, Te, null);
            const {
              filename: ye,
              content: Ie
            } = this.data.file;
            this.filename = (0, fe.getFilenameFromUrl)(ye, !0), this.content = Ie, (Le = this.linkService.eventBus) == null || Le.dispatch("fileattachmentannotation", {
              source: this,
              filename: ye,
              content: Ie
            });
          }
          render() {
            this.container.classList.add("fileAttachmentAnnotation");
            const {
              container: he,
              data: ye
            } = this;
            let Ie;
            ye.hasAppearance || ye.fillAlpha === 0 ? Ie = document.createElement("div") : (Ie = document.createElement("img"), Ie.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(ye.name) ? "paperclip" : "pushpin"}.svg`, ye.fillAlpha && ye.fillAlpha < 1 && (Ie.style = `filter: opacity(${Math.round(ye.fillAlpha * 100)}%);`)), Ie.addEventListener("dblclick", De(this, ke, ua).bind(this)), Xe(this, Te, Ie);
            const {
              isMac: Le
            } = de.FeatureTest.platform;
            return he.addEventListener("keydown", (Be) => {
              Be.key === "Enter" && (Le ? Be.metaKey : Be.ctrlKey) && De(this, ke, ua).call(this);
            }), !ye.popupRef && this.hasPopupData ? this._createPopup() : Ie.classList.add("popupTriggerArea"), he.append(Ie), he;
          }
          getElementsToTriggerPopup() {
            return le(this, Te);
          }
          addHighlightArea() {
            this.container.classList.add("highlightArea");
          }
        }
        Te = new WeakMap(), ke = new WeakSet(), ua = function() {
          var he;
          (he = this.downloadManager) == null || he.openOrDownloadData(this.container, this.content, this.filename);
        };
        class o {
          constructor({
            div: Oe,
            accessibilityManager: he,
            annotationCanvasMap: ye,
            l10n: Ie,
            page: Le,
            viewport: Be
          }) {
            Me(this, $e);
            Me(this, ze);
            Me(this, Ve, null);
            Me(this, je, null);
            Me(this, at, /* @__PURE__ */ new Map());
            this.div = Oe, Xe(this, Ve, he), Xe(this, je, ye), this.l10n = Ie, this.page = Le, this.viewport = Be, this.zIndex = 0, this.l10n || (this.l10n = n.NullL10n);
          }
          async render(Oe) {
            const {
              annotations: he
            } = Oe, ye = this.div;
            (0, fe.setLayerDimensions)(ye, this.viewport);
            const Ie = /* @__PURE__ */ new Map(), Le = {
              data: null,
              layer: ye,
              linkService: Oe.linkService,
              downloadManager: Oe.downloadManager,
              imageResourcesPath: Oe.imageResourcesPath || "",
              renderForms: Oe.renderForms !== !1,
              svgFactory: new fe.DOMSVGFactory(),
              annotationStorage: Oe.annotationStorage || new w.AnnotationStorage(),
              enableScripting: Oe.enableScripting === !0,
              hasJSActions: Oe.hasJSActions,
              fieldObjects: Oe.fieldObjects,
              parent: this,
              elements: null
            };
            for (const Be of he) {
              if (Be.noHTML)
                continue;
              const Ne = Be.annotationType === de.AnnotationType.POPUP;
              if (Ne) {
                const tt = Ie.get(Be.id);
                if (!tt)
                  continue;
                Le.elements = tt;
              } else {
                const {
                  width: tt,
                  height: ht
                } = l(Be.rect);
                if (tt <= 0 || ht <= 0)
                  continue;
              }
              Le.data = Be;
              const Ue = j.create(Le);
              if (!Ue.isRenderable)
                continue;
              if (!Ne && Be.popupRef) {
                const tt = Ie.get(Be.popupRef);
                tt ? tt.push(Ue) : Ie.set(Be.popupRef, [Ue]);
              }
              Ue.annotationEditorType > 0 && le(this, at).set(Ue.data.id, Ue);
              const qe = Ue.render();
              Be.hidden && (qe.style.visibility = "hidden"), De(this, $e, Ya).call(this, qe, Be.id);
            }
            De(this, ze, da).call(this), await this.l10n.translate(ye);
          }
          update({
            viewport: Oe
          }) {
            const he = this.div;
            this.viewport = Oe, (0, fe.setLayerDimensions)(he, {
              rotation: Oe.rotation
            }), De(this, ze, da).call(this), he.hidden = !1;
          }
          getEditableAnnotations() {
            return Array.from(le(this, at).values());
          }
          getEditableAnnotation(Oe) {
            return le(this, at).get(Oe);
          }
        }
        Ve = new WeakMap(), je = new WeakMap(), at = new WeakMap(), $e = new WeakSet(), Ya = function(Oe, he) {
          var Ie;
          const ye = Oe.firstChild || Oe;
          ye.id = `${de.AnnotationPrefix}${he}`, this.div.append(Oe), (Ie = le(this, Ve)) == null || Ie.moveElementInDOM(this.div, Oe, ye, !1);
        }, ze = new WeakSet(), da = function() {
          if (!le(this, je))
            return;
          const Oe = this.div;
          for (const [he, ye] of le(this, je)) {
            const Ie = Oe.querySelector(`[data-annotation-id="${he}"]`);
            if (!Ie)
              continue;
            const {
              firstChild: Le
            } = Ie;
            Le ? Le.nodeName === "CANVAS" ? Le.replaceWith(ye) : Le.before(ye) : Ie.append(ye);
          }
          le(this, je).clear();
        }, ge.AnnotationLayer = o;
      },
      /* 30 */
      /***/
      (Re, ge) => {
        Object.defineProperty(ge, "__esModule", {
          value: !0
        }), ge.ColorConverters = void 0;
        function xe(w) {
          return Math.floor(Math.max(0, Math.min(1, w)) * 255).toString(16).padStart(2, "0");
        }
        function de(w) {
          return Math.max(0, Math.min(255, 255 * w));
        }
        class fe {
          static CMYK_G([V, n, F, C]) {
            return ["G", 1 - Math.min(1, 0.3 * V + 0.59 * F + 0.11 * n + C)];
          }
          static G_CMYK([V]) {
            return ["CMYK", 0, 0, 0, 1 - V];
          }
          static G_RGB([V]) {
            return ["RGB", V, V, V];
          }
          static G_rgb([V]) {
            return V = de(V), [V, V, V];
          }
          static G_HTML([V]) {
            const n = xe(V);
            return `#${n}${n}${n}`;
          }
          static RGB_G([V, n, F]) {
            return ["G", 0.3 * V + 0.59 * n + 0.11 * F];
          }
          static RGB_rgb(V) {
            return V.map(de);
          }
          static RGB_HTML(V) {
            return `#${V.map(xe).join("")}`;
          }
          static T_HTML() {
            return "#00000000";
          }
          static T_rgb() {
            return [null];
          }
          static CMYK_RGB([V, n, F, C]) {
            return ["RGB", 1 - Math.min(1, V + C), 1 - Math.min(1, F + C), 1 - Math.min(1, n + C)];
          }
          static CMYK_rgb([V, n, F, C]) {
            return [de(1 - Math.min(1, V + C)), de(1 - Math.min(1, F + C)), de(1 - Math.min(1, n + C))];
          }
          static CMYK_HTML(V) {
            const n = this.CMYK_RGB(V).slice(1);
            return this.RGB_HTML(n);
          }
          static RGB_CMYK([V, n, F]) {
            const C = 1 - V, e = 1 - n, t = 1 - F, l = Math.min(C, e, t);
            return ["CMYK", C, e, t, l];
          }
        }
        ge.ColorConverters = fe;
      },
      /* 31 */
      /***/
      (Re, ge) => {
        Object.defineProperty(ge, "__esModule", {
          value: !0
        }), ge.NullL10n = void 0, ge.getL10nFallback = de;
        const xe = {
          of_pages: "of {{pagesCount}}",
          page_of_pages: "({{pageNumber}} of {{pagesCount}})",
          document_properties_kb: "{{size_kb}} KB ({{size_b}} bytes)",
          document_properties_mb: "{{size_mb}} MB ({{size_b}} bytes)",
          document_properties_date_string: "{{date}}, {{time}}",
          document_properties_page_size_unit_inches: "in",
          document_properties_page_size_unit_millimeters: "mm",
          document_properties_page_size_orientation_portrait: "portrait",
          document_properties_page_size_orientation_landscape: "landscape",
          document_properties_page_size_name_a3: "A3",
          document_properties_page_size_name_a4: "A4",
          document_properties_page_size_name_letter: "Letter",
          document_properties_page_size_name_legal: "Legal",
          document_properties_page_size_dimension_string: "{{width}} × {{height}} {{unit}} ({{orientation}})",
          document_properties_page_size_dimension_name_string: "{{width}} × {{height}} {{unit}} ({{name}}, {{orientation}})",
          document_properties_linearized_yes: "Yes",
          document_properties_linearized_no: "No",
          additional_layers: "Additional Layers",
          page_landmark: "Page {{page}}",
          thumb_page_title: "Page {{page}}",
          thumb_page_canvas: "Thumbnail of Page {{page}}",
          find_reached_top: "Reached top of document, continued from bottom",
          find_reached_bottom: "Reached end of document, continued from top",
          "find_match_count[one]": "{{current}} of {{total}} match",
          "find_match_count[other]": "{{current}} of {{total}} matches",
          "find_match_count_limit[one]": "More than {{limit}} match",
          "find_match_count_limit[other]": "More than {{limit}} matches",
          find_not_found: "Phrase not found",
          page_scale_width: "Page Width",
          page_scale_fit: "Page Fit",
          page_scale_auto: "Automatic Zoom",
          page_scale_actual: "Actual Size",
          page_scale_percent: "{{scale}}%",
          loading_error: "An error occurred while loading the PDF.",
          invalid_file_error: "Invalid or corrupted PDF file.",
          missing_file_error: "Missing PDF file.",
          unexpected_response_error: "Unexpected server response.",
          rendering_error: "An error occurred while rendering the page.",
          annotation_date_string: "{{date}}, {{time}}",
          printing_not_supported: "Warning: Printing is not fully supported by this browser.",
          printing_not_ready: "Warning: The PDF is not fully loaded for printing.",
          web_fonts_disabled: "Web fonts are disabled: unable to use embedded PDF fonts.",
          free_text2_default_content: "Start typing…",
          editor_free_text2_aria_label: "Text Editor",
          editor_ink2_aria_label: "Draw Editor",
          editor_ink_canvas_aria_label: "User-created image",
          editor_alt_text_button_label: "Alt text",
          editor_alt_text_edit_button_label: "Edit alt text",
          editor_alt_text_decorative_tooltip: "Marked as decorative"
        };
        xe.print_progress_percent = "{{progress}}%";
        function de(V, n) {
          switch (V) {
            case "find_match_count":
              V = `find_match_count[${n.total === 1 ? "one" : "other"}]`;
              break;
            case "find_match_count_limit":
              V = `find_match_count_limit[${n.limit === 1 ? "one" : "other"}]`;
              break;
          }
          return xe[V] || "";
        }
        function fe(V, n) {
          return n ? V.replaceAll(/\{\{\s*(\w+)\s*\}\}/g, (F, C) => C in n ? n[C] : "{{" + C + "}}") : V;
        }
        const w = {
          async getLanguage() {
            return "en-us";
          },
          async getDirection() {
            return "ltr";
          },
          async get(V, n = null, F = de(V, n)) {
            return fe(F, n);
          },
          async translate(V) {
          }
        };
        ge.NullL10n = w;
      },
      /* 32 */
      /***/
      (Re, ge, xe) => {
        Object.defineProperty(ge, "__esModule", {
          value: !0
        }), ge.XfaLayer = void 0;
        var de = xe(25);
        class fe {
          static setupStorage(V, n, F, C, e) {
            const t = C.getValue(n, {
              value: null
            });
            switch (F.name) {
              case "textarea":
                if (t.value !== null && (V.textContent = t.value), e === "print")
                  break;
                V.addEventListener("input", (l) => {
                  C.setValue(n, {
                    value: l.target.value
                  });
                });
                break;
              case "input":
                if (F.attributes.type === "radio" || F.attributes.type === "checkbox") {
                  if (t.value === F.attributes.xfaOn ? V.setAttribute("checked", !0) : t.value === F.attributes.xfaOff && V.removeAttribute("checked"), e === "print")
                    break;
                  V.addEventListener("change", (l) => {
                    C.setValue(n, {
                      value: l.target.checked ? l.target.getAttribute("xfaOn") : l.target.getAttribute("xfaOff")
                    });
                  });
                } else {
                  if (t.value !== null && V.setAttribute("value", t.value), e === "print")
                    break;
                  V.addEventListener("input", (l) => {
                    C.setValue(n, {
                      value: l.target.value
                    });
                  });
                }
                break;
              case "select":
                if (t.value !== null) {
                  V.setAttribute("value", t.value);
                  for (const l of F.children)
                    l.attributes.value === t.value ? l.attributes.selected = !0 : l.attributes.hasOwnProperty("selected") && delete l.attributes.selected;
                }
                V.addEventListener("input", (l) => {
                  const j = l.target.options, U = j.selectedIndex === -1 ? "" : j[j.selectedIndex].value;
                  C.setValue(n, {
                    value: U
                  });
                });
                break;
            }
          }
          static setAttributes({
            html: V,
            element: n,
            storage: F = null,
            intent: C,
            linkService: e
          }) {
            const {
              attributes: t
            } = n, l = V instanceof HTMLAnchorElement;
            t.type === "radio" && (t.name = `${t.name}-${C}`);
            for (const [j, U] of Object.entries(t))
              if (U != null)
                switch (j) {
                  case "class":
                    U.length && V.setAttribute(j, U.join(" "));
                    break;
                  case "dataId":
                    break;
                  case "id":
                    V.setAttribute("data-element-id", U);
                    break;
                  case "style":
                    Object.assign(V.style, U);
                    break;
                  case "textContent":
                    V.textContent = U;
                    break;
                  default:
                    (!l || j !== "href" && j !== "newWindow") && V.setAttribute(j, U);
                }
            l && e.addLinkAttributes(V, t.href, t.newWindow), F && t.dataId && this.setupStorage(V, t.dataId, n, F);
          }
          static render(V) {
            var O;
            const n = V.annotationStorage, F = V.linkService, C = V.xfaHtml, e = V.intent || "display", t = document.createElement(C.name);
            C.attributes && this.setAttributes({
              html: t,
              element: C,
              intent: e,
              linkService: F
            });
            const l = [[C, -1, t]], j = V.div;
            if (j.append(t), V.viewport) {
              const v = `matrix(${V.viewport.transform.join(",")})`;
              j.style.transform = v;
            }
            e !== "richText" && j.setAttribute("class", "xfaLayer xfaFont");
            const U = [];
            for (; l.length > 0; ) {
              const [v, g, b] = l.at(-1);
              if (g + 1 === v.children.length) {
                l.pop();
                continue;
              }
              const i = v.children[++l.at(-1)[1]];
              if (i === null)
                continue;
              const {
                name: P
              } = i;
              if (P === "#text") {
                const A = document.createTextNode(i.value);
                U.push(A), b.append(A);
                continue;
              }
              const d = (O = i == null ? void 0 : i.attributes) != null && O.xmlns ? document.createElementNS(i.attributes.xmlns, P) : document.createElement(P);
              if (b.append(d), i.attributes && this.setAttributes({
                html: d,
                element: i,
                storage: n,
                intent: e,
                linkService: F
              }), i.children && i.children.length > 0)
                l.push([i, -1, d]);
              else if (i.value) {
                const A = document.createTextNode(i.value);
                de.XfaText.shouldBuildText(P) && U.push(A), d.append(A);
              }
            }
            for (const v of j.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea"))
              v.setAttribute("readOnly", !0);
            return {
              textDivs: U
            };
          }
          static update(V) {
            const n = `matrix(${V.viewport.transform.join(",")})`;
            V.div.style.transform = n, V.div.hidden = !1;
          }
        }
        ge.XfaLayer = fe;
      },
      /* 33 */
      /***/
      (Re, ge, xe) => {
        var C, e, t, l, j, U, O, v, g, b, i, P, d, A, I, Ja, k, Za, x, Qa, f, es, N, fa, p, ts, B, ga, D, ns, _, is, m, as, r, ss, M, rs, G, rn, q, pa, Z, ti, L, ni, J, Cn, ae, ma, Q, ii, ie, os, W, xa, ue, cs, ve, ls, Fe, ba, be, ai, we, kn;
        Object.defineProperty(ge, "__esModule", {
          value: !0
        }), ge.InkEditor = void 0;
        var de = xe(1), fe = xe(4), w = xe(29), V = xe(6), n = xe(5);
        const Se = class Se extends fe.AnnotationEditor {
          constructor(ke) {
            super({
              ...ke,
              name: "inkEditor"
            });
            Me(this, I);
            Me(this, k);
            Me(this, x);
            Me(this, f);
            Me(this, N);
            Me(this, p);
            Me(this, B);
            Me(this, D);
            Me(this, _);
            Me(this, m);
            Me(this, r);
            Me(this, M);
            Me(this, G);
            Me(this, q);
            Me(this, Z);
            Me(this, L);
            Me(this, J);
            Me(this, ae);
            Me(this, Q);
            Me(this, ve);
            Me(this, Fe);
            Me(this, be);
            Me(this, we);
            Me(this, C, 0);
            Me(this, e, 0);
            Me(this, t, this.canvasPointermove.bind(this));
            Me(this, l, this.canvasPointerleave.bind(this));
            Me(this, j, this.canvasPointerup.bind(this));
            Me(this, U, this.canvasPointerdown.bind(this));
            Me(this, O, new Path2D());
            Me(this, v, !1);
            Me(this, g, !1);
            Me(this, b, !1);
            Me(this, i, null);
            Me(this, P, 0);
            Me(this, d, 0);
            Me(this, A, null);
            this.color = ke.color || null, this.thickness = ke.thickness || null, this.opacity = ke.opacity || null, this.paths = [], this.bezierPath2D = [], this.allRawPaths = [], this.currentPath = [], this.scaleFactor = 1, this.translationX = this.translationY = 0, this.x = 0, this.y = 0, this._willKeepAspectRatio = !0;
          }
          static initialize(ke) {
            fe.AnnotationEditor.initialize(ke, {
              strings: ["editor_ink_canvas_aria_label", "editor_ink2_aria_label"]
            });
          }
          static updateDefaultParams(ke, Ee) {
            switch (ke) {
              case de.AnnotationEditorParamsType.INK_THICKNESS:
                Se._defaultThickness = Ee;
                break;
              case de.AnnotationEditorParamsType.INK_COLOR:
                Se._defaultColor = Ee;
                break;
              case de.AnnotationEditorParamsType.INK_OPACITY:
                Se._defaultOpacity = Ee / 100;
                break;
            }
          }
          updateParams(ke, Ee) {
            switch (ke) {
              case de.AnnotationEditorParamsType.INK_THICKNESS:
                De(this, I, Ja).call(this, Ee);
                break;
              case de.AnnotationEditorParamsType.INK_COLOR:
                De(this, k, Za).call(this, Ee);
                break;
              case de.AnnotationEditorParamsType.INK_OPACITY:
                De(this, x, Qa).call(this, Ee);
                break;
            }
          }
          static get defaultPropertiesToUpdate() {
            return [[de.AnnotationEditorParamsType.INK_THICKNESS, Se._defaultThickness], [de.AnnotationEditorParamsType.INK_COLOR, Se._defaultColor || fe.AnnotationEditor._defaultLineColor], [de.AnnotationEditorParamsType.INK_OPACITY, Math.round(Se._defaultOpacity * 100)]];
          }
          get propertiesToUpdate() {
            return [[de.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || Se._defaultThickness], [de.AnnotationEditorParamsType.INK_COLOR, this.color || Se._defaultColor || fe.AnnotationEditor._defaultLineColor], [de.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * (this.opacity ?? Se._defaultOpacity))]];
          }
          rebuild() {
            this.parent && (super.rebuild(), this.div !== null && (this.canvas || (De(this, Z, ti).call(this), De(this, L, ni).call(this)), this.isAttachedToDOM || (this.parent.add(this), De(this, J, Cn).call(this)), De(this, we, kn).call(this)));
          }
          remove() {
            this.canvas !== null && (this.isEmpty() || this.commit(), this.canvas.width = this.canvas.height = 0, this.canvas.remove(), this.canvas = null, le(this, i).disconnect(), Xe(this, i, null), super.remove());
          }
          setParent(ke) {
            !this.parent && ke ? this._uiManager.removeShouldRescale(this) : this.parent && ke === null && this._uiManager.addShouldRescale(this), super.setParent(ke);
          }
          onScaleChanging() {
            const [ke, Ee] = this.parentDimensions, Ve = this.width * ke, je = this.height * Ee;
            this.setDimensions(Ve, je);
          }
          enableEditMode() {
            le(this, v) || this.canvas === null || (super.enableEditMode(), this._isDraggable = !1, this.canvas.addEventListener("pointerdown", le(this, U)));
          }
          disableEditMode() {
            !this.isInEditMode() || this.canvas === null || (super.disableEditMode(), this._isDraggable = !this.isEmpty(), this.div.classList.remove("editing"), this.canvas.removeEventListener("pointerdown", le(this, U)));
          }
          onceAdded() {
            this._isDraggable = !this.isEmpty();
          }
          isEmpty() {
            return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;
          }
          commit() {
            le(this, v) || (super.commit(), this.isEditing = !1, this.disableEditMode(), this.setInForeground(), Xe(this, v, !0), this.div.classList.add("disabled"), De(this, we, kn).call(this, !0), this.makeResizable(), this.parent.addInkEditorIfNeeded(!0), this.moveInDOM(), this.div.focus({
              preventScroll: !0
            }));
          }
          focusin(ke) {
            this._focusEventsAllowed && (super.focusin(ke), this.enableEditMode());
          }
          canvasPointerdown(ke) {
            ke.button !== 0 || !this.isInEditMode() || le(this, v) || (this.setInForeground(), ke.preventDefault(), ke.type !== "mouse" && this.div.focus(), De(this, p, ts).call(this, ke.offsetX, ke.offsetY));
          }
          canvasPointermove(ke) {
            ke.preventDefault(), De(this, B, ga).call(this, ke.offsetX, ke.offsetY);
          }
          canvasPointerup(ke) {
            ke.preventDefault(), De(this, q, pa).call(this, ke);
          }
          canvasPointerleave(ke) {
            De(this, q, pa).call(this, ke);
          }
          get isResizable() {
            return !this.isEmpty() && le(this, v);
          }
          render() {
            if (this.div)
              return this.div;
            let ke, Ee;
            this.width && (ke = this.x, Ee = this.y), super.render(), fe.AnnotationEditor._l10nPromise.get("editor_ink2_aria_label").then((ct) => {
              var ze;
              return (ze = this.div) == null ? void 0 : ze.setAttribute("aria-label", ct);
            });
            const [Ve, je, at, $e] = De(this, f, es).call(this);
            if (this.setAt(Ve, je, 0, 0), this.setDims(at, $e), De(this, Z, ti).call(this), this.width) {
              const [ct, ze] = this.parentDimensions;
              this.setAspectRatio(this.width * ct, this.height * ze), this.setAt(ke * ct, Ee * ze, this.width * ct, this.height * ze), Xe(this, b, !0), De(this, J, Cn).call(this), this.setDims(this.width * ct, this.height * ze), De(this, G, rn).call(this), this.div.classList.add("disabled");
            } else
              this.div.classList.add("editing"), this.enableEditMode();
            return De(this, L, ni).call(this), this.div;
          }
          setDimensions(ke, Ee) {
            const Ve = Math.round(ke), je = Math.round(Ee);
            if (le(this, P) === Ve && le(this, d) === je)
              return;
            Xe(this, P, Ve), Xe(this, d, je), this.canvas.style.visibility = "hidden";
            const [at, $e] = this.parentDimensions;
            this.width = ke / at, this.height = Ee / $e, this.fixAndSetPosition(), le(this, v) && De(this, ae, ma).call(this, ke, Ee), De(this, J, Cn).call(this), De(this, G, rn).call(this), this.canvas.style.visibility = "visible", this.fixDims();
          }
          static deserialize(ke, Ee, Ve) {
            var Le, Be, Ne;
            if (ke instanceof w.InkAnnotationElement)
              return null;
            const je = super.deserialize(ke, Ee, Ve);
            je.thickness = ke.thickness, je.color = de.Util.makeHexColor(...ke.color), je.opacity = ke.opacity;
            const [at, $e] = je.pageDimensions, ct = je.width * at, ze = je.height * $e, Ye = je.parentScale, Qe = ke.thickness / 2;
            Xe(je, v, !0), Xe(je, P, Math.round(ct)), Xe(je, d, Math.round(ze));
            const {
              paths: Oe,
              rect: he,
              rotation: ye
            } = ke;
            for (let {
              bezier: Ue
            } of Oe) {
              Ue = De(Le = Se, ue, cs).call(Le, Ue, he, ye);
              const qe = [];
              je.paths.push(qe);
              let tt = Ye * (Ue[0] - Qe), ht = Ye * (Ue[1] - Qe);
              for (let nt = 2, ut = Ue.length; nt < ut; nt += 6) {
                const bt = Ye * (Ue[nt] - Qe), Ge = Ye * (Ue[nt + 1] - Qe), We = Ye * (Ue[nt + 2] - Qe), Je = Ye * (Ue[nt + 3] - Qe), et = Ye * (Ue[nt + 4] - Qe), lt = Ye * (Ue[nt + 5] - Qe);
                qe.push([[tt, ht], [bt, Ge], [We, Je], [et, lt]]), tt = et, ht = lt;
              }
              const rt = De(this, ie, os).call(this, qe);
              je.bezierPath2D.push(rt);
            }
            const Ie = De(Be = je, Fe, ba).call(Be);
            return Xe(je, e, Math.max(fe.AnnotationEditor.MIN_SIZE, Ie[2] - Ie[0])), Xe(je, C, Math.max(fe.AnnotationEditor.MIN_SIZE, Ie[3] - Ie[1])), De(Ne = je, ae, ma).call(Ne, ct, ze), je;
          }
          serialize() {
            if (this.isEmpty())
              return null;
            const ke = this.getRect(0, 0), Ee = fe.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);
            return {
              annotationType: de.AnnotationEditorType.INK,
              color: Ee,
              thickness: this.thickness,
              opacity: this.opacity,
              paths: De(this, ve, ls).call(this, this.scaleFactor / this.parentScale, this.translationX, this.translationY, ke),
              pageIndex: this.pageIndex,
              rect: ke,
              rotation: this.rotation,
              structTreeParentId: this._structTreeParentId
            };
          }
        };
        C = new WeakMap(), e = new WeakMap(), t = new WeakMap(), l = new WeakMap(), j = new WeakMap(), U = new WeakMap(), O = new WeakMap(), v = new WeakMap(), g = new WeakMap(), b = new WeakMap(), i = new WeakMap(), P = new WeakMap(), d = new WeakMap(), A = new WeakMap(), I = new WeakSet(), Ja = function(ke) {
          const Ee = this.thickness;
          this.addCommands({
            cmd: () => {
              this.thickness = ke, De(this, we, kn).call(this);
            },
            undo: () => {
              this.thickness = Ee, De(this, we, kn).call(this);
            },
            mustExec: !0,
            type: de.AnnotationEditorParamsType.INK_THICKNESS,
            overwriteIfSameType: !0,
            keepUndo: !0
          });
        }, k = new WeakSet(), Za = function(ke) {
          const Ee = this.color;
          this.addCommands({
            cmd: () => {
              this.color = ke, De(this, G, rn).call(this);
            },
            undo: () => {
              this.color = Ee, De(this, G, rn).call(this);
            },
            mustExec: !0,
            type: de.AnnotationEditorParamsType.INK_COLOR,
            overwriteIfSameType: !0,
            keepUndo: !0
          });
        }, x = new WeakSet(), Qa = function(ke) {
          ke /= 100;
          const Ee = this.opacity;
          this.addCommands({
            cmd: () => {
              this.opacity = ke, De(this, G, rn).call(this);
            },
            undo: () => {
              this.opacity = Ee, De(this, G, rn).call(this);
            },
            mustExec: !0,
            type: de.AnnotationEditorParamsType.INK_OPACITY,
            overwriteIfSameType: !0,
            keepUndo: !0
          });
        }, f = new WeakSet(), es = function() {
          const {
            parentRotation: ke,
            parentDimensions: [Ee, Ve]
          } = this;
          switch (ke) {
            case 90:
              return [0, Ve, Ve, Ee];
            case 180:
              return [Ee, Ve, Ee, Ve];
            case 270:
              return [Ee, 0, Ve, Ee];
            default:
              return [0, 0, Ee, Ve];
          }
        }, N = new WeakSet(), fa = function() {
          const {
            ctx: ke,
            color: Ee,
            opacity: Ve,
            thickness: je,
            parentScale: at,
            scaleFactor: $e
          } = this;
          ke.lineWidth = je * at / $e, ke.lineCap = "round", ke.lineJoin = "round", ke.miterLimit = 10, ke.strokeStyle = `${Ee}${(0, n.opacityToHex)(Ve)}`;
        }, p = new WeakSet(), ts = function(ke, Ee) {
          this.canvas.addEventListener("contextmenu", V.noContextMenu), this.canvas.addEventListener("pointerleave", le(this, l)), this.canvas.addEventListener("pointermove", le(this, t)), this.canvas.addEventListener("pointerup", le(this, j)), this.canvas.removeEventListener("pointerdown", le(this, U)), this.isEditing = !0, le(this, b) || (Xe(this, b, !0), De(this, J, Cn).call(this), this.thickness || (this.thickness = Se._defaultThickness), this.color || (this.color = Se._defaultColor || fe.AnnotationEditor._defaultLineColor), this.opacity ?? (this.opacity = Se._defaultOpacity)), this.currentPath.push([ke, Ee]), Xe(this, g, !1), De(this, N, fa).call(this), Xe(this, A, () => {
            De(this, m, as).call(this), le(this, A) && window.requestAnimationFrame(le(this, A));
          }), window.requestAnimationFrame(le(this, A));
        }, B = new WeakSet(), ga = function(ke, Ee) {
          const [Ve, je] = this.currentPath.at(-1);
          if (this.currentPath.length > 1 && ke === Ve && Ee === je)
            return;
          const at = this.currentPath;
          let $e = le(this, O);
          if (at.push([ke, Ee]), Xe(this, g, !0), at.length <= 2) {
            $e.moveTo(...at[0]), $e.lineTo(ke, Ee);
            return;
          }
          at.length === 3 && (Xe(this, O, $e = new Path2D()), $e.moveTo(...at[0])), De(this, r, ss).call(this, $e, ...at.at(-3), ...at.at(-2), ke, Ee);
        }, D = new WeakSet(), ns = function() {
          if (this.currentPath.length === 0)
            return;
          const ke = this.currentPath.at(-1);
          le(this, O).lineTo(...ke);
        }, _ = new WeakSet(), is = function(ke, Ee) {
          Xe(this, A, null), ke = Math.min(Math.max(ke, 0), this.canvas.width), Ee = Math.min(Math.max(Ee, 0), this.canvas.height), De(this, B, ga).call(this, ke, Ee), De(this, D, ns).call(this);
          let Ve;
          if (this.currentPath.length !== 1)
            Ve = De(this, M, rs).call(this);
          else {
            const ze = [ke, Ee];
            Ve = [[ze, ze.slice(), ze.slice(), ze]];
          }
          const je = le(this, O), at = this.currentPath;
          this.currentPath = [], Xe(this, O, new Path2D());
          const $e = () => {
            this.allRawPaths.push(at), this.paths.push(Ve), this.bezierPath2D.push(je), this.rebuild();
          }, ct = () => {
            this.allRawPaths.pop(), this.paths.pop(), this.bezierPath2D.pop(), this.paths.length === 0 ? this.remove() : (this.canvas || (De(this, Z, ti).call(this), De(this, L, ni).call(this)), De(this, we, kn).call(this));
          };
          this.addCommands({
            cmd: $e,
            undo: ct,
            mustExec: !0
          });
        }, m = new WeakSet(), as = function() {
          if (!le(this, g))
            return;
          Xe(this, g, !1);
          const ke = Math.ceil(this.thickness * this.parentScale), Ee = this.currentPath.slice(-3), Ve = Ee.map(($e) => $e[0]), je = Ee.map(($e) => $e[1]);
          Math.min(...Ve) - ke, Math.max(...Ve) + ke, Math.min(...je) - ke, Math.max(...je) + ke;
          const {
            ctx: at
          } = this;
          at.save(), at.clearRect(0, 0, this.canvas.width, this.canvas.height);
          for (const $e of this.bezierPath2D)
            at.stroke($e);
          at.stroke(le(this, O)), at.restore();
        }, r = new WeakSet(), ss = function(ke, Ee, Ve, je, at, $e, ct) {
          const ze = (Ee + je) / 2, Ye = (Ve + at) / 2, Qe = (je + $e) / 2, Oe = (at + ct) / 2;
          ke.bezierCurveTo(ze + 2 * (je - ze) / 3, Ye + 2 * (at - Ye) / 3, Qe + 2 * (je - Qe) / 3, Oe + 2 * (at - Oe) / 3, Qe, Oe);
        }, M = new WeakSet(), rs = function() {
          const ke = this.currentPath;
          if (ke.length <= 2)
            return [[ke[0], ke[0], ke.at(-1), ke.at(-1)]];
          const Ee = [];
          let Ve, [je, at] = ke[0];
          for (Ve = 1; Ve < ke.length - 2; Ve++) {
            const [he, ye] = ke[Ve], [Ie, Le] = ke[Ve + 1], Be = (he + Ie) / 2, Ne = (ye + Le) / 2, Ue = [je + 2 * (he - je) / 3, at + 2 * (ye - at) / 3], qe = [Be + 2 * (he - Be) / 3, Ne + 2 * (ye - Ne) / 3];
            Ee.push([[je, at], Ue, qe, [Be, Ne]]), [je, at] = [Be, Ne];
          }
          const [$e, ct] = ke[Ve], [ze, Ye] = ke[Ve + 1], Qe = [je + 2 * ($e - je) / 3, at + 2 * (ct - at) / 3], Oe = [ze + 2 * ($e - ze) / 3, Ye + 2 * (ct - Ye) / 3];
          return Ee.push([[je, at], Qe, Oe, [ze, Ye]]), Ee;
        }, G = new WeakSet(), rn = function() {
          if (this.isEmpty()) {
            De(this, Q, ii).call(this);
            return;
          }
          De(this, N, fa).call(this);
          const {
            canvas: ke,
            ctx: Ee
          } = this;
          Ee.setTransform(1, 0, 0, 1, 0, 0), Ee.clearRect(0, 0, ke.width, ke.height), De(this, Q, ii).call(this);
          for (const Ve of this.bezierPath2D)
            Ee.stroke(Ve);
        }, q = new WeakSet(), pa = function(ke) {
          this.canvas.removeEventListener("pointerleave", le(this, l)), this.canvas.removeEventListener("pointermove", le(this, t)), this.canvas.removeEventListener("pointerup", le(this, j)), this.canvas.addEventListener("pointerdown", le(this, U)), setTimeout(() => {
            this.canvas.removeEventListener("contextmenu", V.noContextMenu);
          }, 10), De(this, _, is).call(this, ke.offsetX, ke.offsetY), this.addToAnnotationStorage(), this.setInBackground();
        }, Z = new WeakSet(), ti = function() {
          this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = 0, this.canvas.className = "inkEditorCanvas", fe.AnnotationEditor._l10nPromise.get("editor_ink_canvas_aria_label").then((ke) => {
            var Ee;
            return (Ee = this.canvas) == null ? void 0 : Ee.setAttribute("aria-label", ke);
          }), this.div.append(this.canvas), this.ctx = this.canvas.getContext("2d");
        }, L = new WeakSet(), ni = function() {
          Xe(this, i, new ResizeObserver((ke) => {
            const Ee = ke[0].contentRect;
            Ee.width && Ee.height && this.setDimensions(Ee.width, Ee.height);
          })), le(this, i).observe(this.div);
        }, J = new WeakSet(), Cn = function() {
          if (!le(this, b))
            return;
          const [ke, Ee] = this.parentDimensions;
          this.canvas.width = Math.ceil(this.width * ke), this.canvas.height = Math.ceil(this.height * Ee), De(this, Q, ii).call(this);
        }, ae = new WeakSet(), ma = function(ke, Ee) {
          const Ve = De(this, be, ai).call(this), je = (ke - Ve) / le(this, e), at = (Ee - Ve) / le(this, C);
          this.scaleFactor = Math.min(je, at);
        }, Q = new WeakSet(), ii = function() {
          const ke = De(this, be, ai).call(this) / 2;
          this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + ke, this.translationY * this.scaleFactor + ke);
        }, ie = new WeakSet(), os = function(ke) {
          const Ee = new Path2D();
          for (let Ve = 0, je = ke.length; Ve < je; Ve++) {
            const [at, $e, ct, ze] = ke[Ve];
            Ve === 0 && Ee.moveTo(...at), Ee.bezierCurveTo($e[0], $e[1], ct[0], ct[1], ze[0], ze[1]);
          }
          return Ee;
        }, W = new WeakSet(), xa = function(ke, Ee, Ve) {
          const [je, at, $e, ct] = Ee;
          switch (Ve) {
            case 0:
              for (let ze = 0, Ye = ke.length; ze < Ye; ze += 2)
                ke[ze] += je, ke[ze + 1] = ct - ke[ze + 1];
              break;
            case 90:
              for (let ze = 0, Ye = ke.length; ze < Ye; ze += 2) {
                const Qe = ke[ze];
                ke[ze] = ke[ze + 1] + je, ke[ze + 1] = Qe + at;
              }
              break;
            case 180:
              for (let ze = 0, Ye = ke.length; ze < Ye; ze += 2)
                ke[ze] = $e - ke[ze], ke[ze + 1] += at;
              break;
            case 270:
              for (let ze = 0, Ye = ke.length; ze < Ye; ze += 2) {
                const Qe = ke[ze];
                ke[ze] = $e - ke[ze + 1], ke[ze + 1] = ct - Qe;
              }
              break;
            default:
              throw new Error("Invalid rotation");
          }
          return ke;
        }, ue = new WeakSet(), cs = function(ke, Ee, Ve) {
          const [je, at, $e, ct] = Ee;
          switch (Ve) {
            case 0:
              for (let ze = 0, Ye = ke.length; ze < Ye; ze += 2)
                ke[ze] -= je, ke[ze + 1] = ct - ke[ze + 1];
              break;
            case 90:
              for (let ze = 0, Ye = ke.length; ze < Ye; ze += 2) {
                const Qe = ke[ze];
                ke[ze] = ke[ze + 1] - at, ke[ze + 1] = Qe - je;
              }
              break;
            case 180:
              for (let ze = 0, Ye = ke.length; ze < Ye; ze += 2)
                ke[ze] = $e - ke[ze], ke[ze + 1] -= at;
              break;
            case 270:
              for (let ze = 0, Ye = ke.length; ze < Ye; ze += 2) {
                const Qe = ke[ze];
                ke[ze] = ct - ke[ze + 1], ke[ze + 1] = $e - Qe;
              }
              break;
            default:
              throw new Error("Invalid rotation");
          }
          return ke;
        }, ve = new WeakSet(), ls = function(ke, Ee, Ve, je) {
          var Ye, Qe;
          const at = [], $e = this.thickness / 2, ct = ke * Ee + $e, ze = ke * Ve + $e;
          for (const Oe of this.paths) {
            const he = [], ye = [];
            for (let Ie = 0, Le = Oe.length; Ie < Le; Ie++) {
              const [Be, Ne, Ue, qe] = Oe[Ie], tt = ke * Be[0] + ct, ht = ke * Be[1] + ze, rt = ke * Ne[0] + ct, nt = ke * Ne[1] + ze, ut = ke * Ue[0] + ct, bt = ke * Ue[1] + ze, Ge = ke * qe[0] + ct, We = ke * qe[1] + ze;
              Ie === 0 && (he.push(tt, ht), ye.push(tt, ht)), he.push(rt, nt, ut, bt, Ge, We), ye.push(rt, nt), Ie === Le - 1 && ye.push(Ge, We);
            }
            at.push({
              bezier: De(Ye = Se, W, xa).call(Ye, he, je, this.rotation),
              points: De(Qe = Se, W, xa).call(Qe, ye, je, this.rotation)
            });
          }
          return at;
        }, Fe = new WeakSet(), ba = function() {
          let ke = 1 / 0, Ee = -1 / 0, Ve = 1 / 0, je = -1 / 0;
          for (const at of this.paths)
            for (const [$e, ct, ze, Ye] of at) {
              const Qe = de.Util.bezierBoundingBox(...$e, ...ct, ...ze, ...Ye);
              ke = Math.min(ke, Qe[0]), Ve = Math.min(Ve, Qe[1]), Ee = Math.max(Ee, Qe[2]), je = Math.max(je, Qe[3]);
            }
          return [ke, Ve, Ee, je];
        }, be = new WeakSet(), ai = function() {
          return le(this, v) ? Math.ceil(this.thickness * this.parentScale) : 0;
        }, we = new WeakSet(), kn = function(ke = !1) {
          if (this.isEmpty())
            return;
          if (!le(this, v)) {
            De(this, G, rn).call(this);
            return;
          }
          const Ee = De(this, Fe, ba).call(this), Ve = De(this, be, ai).call(this);
          Xe(this, e, Math.max(fe.AnnotationEditor.MIN_SIZE, Ee[2] - Ee[0])), Xe(this, C, Math.max(fe.AnnotationEditor.MIN_SIZE, Ee[3] - Ee[1]));
          const je = Math.ceil(Ve + le(this, e) * this.scaleFactor), at = Math.ceil(Ve + le(this, C) * this.scaleFactor), [$e, ct] = this.parentDimensions;
          this.width = je / $e, this.height = at / ct, this.setAspectRatio(je, at);
          const ze = this.translationX, Ye = this.translationY;
          this.translationX = -Ee[0], this.translationY = -Ee[1], De(this, J, Cn).call(this), De(this, G, rn).call(this), Xe(this, P, je), Xe(this, d, at), this.setDims(je, at);
          const Qe = ke ? Ve / this.scaleFactor / 2 : 0;
          this.translate(ze - this.translationX - Qe, Ye - this.translationY - Qe);
        }, Me(Se, ie), Me(Se, W), Me(Se, ue), Ot(Se, "_defaultColor", null), Ot(Se, "_defaultOpacity", 1), Ot(Se, "_defaultThickness", 1), Ot(Se, "_type", "ink");
        let F = Se;
        ge.InkEditor = F;
      },
      /* 34 */
      /***/
      (Re, ge, xe) => {
        var F, C, e, t, l, j, U, O, v, g, b, Ln, P, Nn, A, si, E, ya, H, hs, R, us, c, wa, u, ri, S, ds;
        Object.defineProperty(ge, "__esModule", {
          value: !0
        }), ge.StampEditor = void 0;
        var de = xe(1), fe = xe(4), w = xe(6), V = xe(29);
        const T = class T extends fe.AnnotationEditor {
          constructor(_) {
            super({
              ..._,
              name: "stampEditor"
            });
            Me(this, b);
            Me(this, P);
            Me(this, A);
            Me(this, E);
            Me(this, H);
            Me(this, R);
            Me(this, c);
            Me(this, u);
            Me(this, S);
            Me(this, F, null);
            Me(this, C, null);
            Me(this, e, null);
            Me(this, t, null);
            Me(this, l, null);
            Me(this, j, null);
            Me(this, U, null);
            Me(this, O, null);
            Me(this, v, !1);
            Me(this, g, !1);
            Xe(this, t, _.bitmapUrl), Xe(this, l, _.bitmapFile);
          }
          static initialize(_) {
            fe.AnnotationEditor.initialize(_);
          }
          static get supportedTypes() {
            const _ = ["apng", "avif", "bmp", "gif", "jpeg", "png", "svg+xml", "webp", "x-icon"];
            return (0, de.shadow)(this, "supportedTypes", _.map((o) => `image/${o}`));
          }
          static get supportedTypesStr() {
            return (0, de.shadow)(this, "supportedTypesStr", this.supportedTypes.join(","));
          }
          static isHandlingMimeForPasting(_) {
            return this.supportedTypes.includes(_);
          }
          static paste(_, o) {
            o.pasteEditor(de.AnnotationEditorType.STAMP, {
              bitmapFile: _.getAsFile()
            });
          }
          remove() {
            var _, o;
            le(this, C) && (Xe(this, F, null), this._uiManager.imageManager.deleteId(le(this, C)), (_ = le(this, j)) == null || _.remove(), Xe(this, j, null), (o = le(this, U)) == null || o.disconnect(), Xe(this, U, null)), super.remove();
          }
          rebuild() {
            if (!this.parent) {
              le(this, C) && De(this, A, si).call(this);
              return;
            }
            super.rebuild(), this.div !== null && (le(this, C) && De(this, A, si).call(this), this.isAttachedToDOM || this.parent.add(this));
          }
          onceAdded() {
            this._isDraggable = !0, this.div.focus();
          }
          isEmpty() {
            return !(le(this, e) || le(this, F) || le(this, t) || le(this, l));
          }
          get isResizable() {
            return !0;
          }
          render() {
            if (this.div)
              return this.div;
            let _, o;
            if (this.width && (_ = this.x, o = this.y), super.render(), this.div.hidden = !0, le(this, F) ? De(this, E, ya).call(this) : De(this, A, si).call(this), this.width) {
              const [m, s] = this.parentDimensions;
              this.setAt(_ * m, o * s, this.width * m, this.height * s);
            }
            return this.div;
          }
          static deserialize(_, o, m) {
            if (_ instanceof V.StampAnnotationElement)
              return null;
            const s = super.deserialize(_, o, m), {
              rect: r,
              bitmapUrl: y,
              bitmapId: M,
              isSvg: $,
              accessibilityData: G
            } = _;
            M && m.imageManager.isValidId(M) ? Xe(s, C, M) : Xe(s, t, y), Xe(s, v, $);
            const [ce, q] = s.pageDimensions;
            return s.width = (r[2] - r[0]) / ce, s.height = (r[3] - r[1]) / q, G && (s.altTextData = G), s;
          }
          serialize(_ = !1, o = null) {
            if (this.isEmpty())
              return null;
            const m = {
              annotationType: de.AnnotationEditorType.STAMP,
              bitmapId: le(this, C),
              pageIndex: this.pageIndex,
              rect: this.getRect(0, 0),
              rotation: this.rotation,
              isSvg: le(this, v),
              structTreeParentId: this._structTreeParentId
            };
            if (_)
              return m.bitmapUrl = De(this, u, ri).call(this, !0), m.accessibilityData = this.altTextData, m;
            const {
              decorative: s,
              altText: r
            } = this.altTextData;
            if (!s && r && (m.accessibilityData = {
              type: "Figure",
              alt: r
            }), o === null)
              return m;
            o.stamps || (o.stamps = /* @__PURE__ */ new Map());
            const y = le(this, v) ? (m.rect[2] - m.rect[0]) * (m.rect[3] - m.rect[1]) : null;
            if (!o.stamps.has(le(this, C)))
              o.stamps.set(le(this, C), {
                area: y,
                serialized: m
              }), m.bitmap = De(this, u, ri).call(this, !1);
            else if (le(this, v)) {
              const M = o.stamps.get(le(this, C));
              y > M.area && (M.area = y, M.serialized.bitmap.close(), M.serialized.bitmap = De(this, u, ri).call(this, !1));
            }
            return m;
          }
        };
        F = new WeakMap(), C = new WeakMap(), e = new WeakMap(), t = new WeakMap(), l = new WeakMap(), j = new WeakMap(), U = new WeakMap(), O = new WeakMap(), v = new WeakMap(), g = new WeakMap(), b = new WeakSet(), Ln = function(_, o = !1) {
          if (!_) {
            this.remove();
            return;
          }
          Xe(this, F, _.bitmap), o || (Xe(this, C, _.id), Xe(this, v, _.isSvg)), De(this, E, ya).call(this);
        }, P = new WeakSet(), Nn = function() {
          Xe(this, e, null), this._uiManager.enableWaiting(!1), le(this, j) && this.div.focus();
        }, A = new WeakSet(), si = function() {
          if (le(this, C)) {
            this._uiManager.enableWaiting(!0), this._uiManager.imageManager.getFromId(le(this, C)).then((o) => De(this, b, Ln).call(this, o, !0)).finally(() => De(this, P, Nn).call(this));
            return;
          }
          if (le(this, t)) {
            const o = le(this, t);
            Xe(this, t, null), this._uiManager.enableWaiting(!0), Xe(this, e, this._uiManager.imageManager.getFromUrl(o).then((m) => De(this, b, Ln).call(this, m)).finally(() => De(this, P, Nn).call(this)));
            return;
          }
          if (le(this, l)) {
            const o = le(this, l);
            Xe(this, l, null), this._uiManager.enableWaiting(!0), Xe(this, e, this._uiManager.imageManager.getFromFile(o).then((m) => De(this, b, Ln).call(this, m)).finally(() => De(this, P, Nn).call(this)));
            return;
          }
          const _ = document.createElement("input");
          _.type = "file", _.accept = T.supportedTypesStr, Xe(this, e, new Promise((o) => {
            _.addEventListener("change", async () => {
              if (!_.files || _.files.length === 0)
                this.remove();
              else {
                this._uiManager.enableWaiting(!0);
                const m = await this._uiManager.imageManager.getFromFile(_.files[0]);
                De(this, b, Ln).call(this, m);
              }
              o();
            }), _.addEventListener("cancel", () => {
              this.remove(), o();
            });
          }).finally(() => De(this, P, Nn).call(this))), _.click();
        }, E = new WeakSet(), ya = function() {
          const {
            div: _
          } = this;
          let {
            width: o,
            height: m
          } = le(this, F);
          const [s, r] = this.pageDimensions, y = 0.75;
          if (this.width)
            o = this.width * s, m = this.height * r;
          else if (o > y * s || m > y * r) {
            const ce = Math.min(y * s / o, y * r / m);
            o *= ce, m *= ce;
          }
          const [M, $] = this.parentDimensions;
          this.setDims(o * M / s, m * $ / r), this._uiManager.enableWaiting(!1);
          const G = Xe(this, j, document.createElement("canvas"));
          _.append(G), _.hidden = !1, De(this, c, wa).call(this, o, m), De(this, S, ds).call(this), le(this, g) || (this.parent.addUndoableEditor(this), Xe(this, g, !0)), this._uiManager._eventBus.dispatch("reporttelemetry", {
            source: this,
            details: {
              type: "editing",
              subtype: this.editorType,
              data: {
                action: "inserted_image"
              }
            }
          }), this.addAltTextButton();
        }, H = new WeakSet(), hs = function(_, o) {
          var y;
          const [m, s] = this.parentDimensions;
          this.width = _ / m, this.height = o / s, this.setDims(_, o), (y = this._initialOptions) != null && y.isCentered ? this.center() : this.fixAndSetPosition(), this._initialOptions = null, le(this, O) !== null && clearTimeout(le(this, O)), Xe(this, O, setTimeout(() => {
            Xe(this, O, null), De(this, c, wa).call(this, _, o);
          }, 200));
        }, R = new WeakSet(), us = function(_, o) {
          const {
            width: m,
            height: s
          } = le(this, F);
          let r = m, y = s, M = le(this, F);
          for (; r > 2 * _ || y > 2 * o; ) {
            const $ = r, G = y;
            r > 2 * _ && (r = r >= 16384 ? Math.floor(r / 2) - 1 : Math.ceil(r / 2)), y > 2 * o && (y = y >= 16384 ? Math.floor(y / 2) - 1 : Math.ceil(y / 2));
            const ce = new OffscreenCanvas(r, y);
            ce.getContext("2d").drawImage(M, 0, 0, $, G, 0, 0, r, y), M = ce.transferToImageBitmap();
          }
          return M;
        }, c = new WeakSet(), wa = function(_, o) {
          _ = Math.ceil(_), o = Math.ceil(o);
          const m = le(this, j);
          if (!m || m.width === _ && m.height === o)
            return;
          m.width = _, m.height = o;
          const s = le(this, v) ? le(this, F) : De(this, R, us).call(this, _, o), r = m.getContext("2d");
          r.filter = this._uiManager.hcmFilter, r.drawImage(s, 0, 0, s.width, s.height, 0, 0, _, o);
        }, u = new WeakSet(), ri = function(_) {
          if (_) {
            if (le(this, v)) {
              const s = this._uiManager.imageManager.getSvgUrl(le(this, C));
              if (s)
                return s;
            }
            const o = document.createElement("canvas");
            return {
              width: o.width,
              height: o.height
            } = le(this, F), o.getContext("2d").drawImage(le(this, F), 0, 0), o.toDataURL();
          }
          if (le(this, v)) {
            const [o, m] = this.pageDimensions, s = Math.round(this.width * o * w.PixelsPerInch.PDF_TO_CSS_UNITS), r = Math.round(this.height * m * w.PixelsPerInch.PDF_TO_CSS_UNITS), y = new OffscreenCanvas(s, r);
            return y.getContext("2d").drawImage(le(this, F), 0, 0, le(this, F).width, le(this, F).height, 0, 0, s, r), y.transferToImageBitmap();
          }
          return structuredClone(le(this, F));
        }, S = new WeakSet(), ds = function() {
          Xe(this, U, new ResizeObserver((_) => {
            const o = _[0].contentRect;
            o.width && o.height && De(this, H, hs).call(this, o.width, o.height);
          })), le(this, U).observe(this.div);
        }, Ot(T, "_type", "stamp");
        let n = T;
        ge.StampEditor = n;
      }
      /******/
    ], __webpack_module_cache__ = {};
    function __w_pdfjs_require__(Re) {
      var ge = __webpack_module_cache__[Re];
      if (ge !== void 0)
        return ge.exports;
      var xe = __webpack_module_cache__[Re] = {
        /******/
        // no module.id needed
        /******/
        // no module.loaded needed
        /******/
        exports: {}
        /******/
      };
      return __webpack_modules__[Re](xe, xe.exports, __w_pdfjs_require__), xe.exports;
    }
    var __webpack_exports__ = {};
    return (() => {
      var Re = __webpack_exports__;
      Object.defineProperty(Re, "__esModule", {
        value: !0
      }), Object.defineProperty(Re, "AbortException", {
        enumerable: !0,
        get: function() {
          return ge.AbortException;
        }
      }), Object.defineProperty(Re, "AnnotationEditorLayer", {
        enumerable: !0,
        get: function() {
          return w.AnnotationEditorLayer;
        }
      }), Object.defineProperty(Re, "AnnotationEditorParamsType", {
        enumerable: !0,
        get: function() {
          return ge.AnnotationEditorParamsType;
        }
      }), Object.defineProperty(Re, "AnnotationEditorType", {
        enumerable: !0,
        get: function() {
          return ge.AnnotationEditorType;
        }
      }), Object.defineProperty(Re, "AnnotationEditorUIManager", {
        enumerable: !0,
        get: function() {
          return V.AnnotationEditorUIManager;
        }
      }), Object.defineProperty(Re, "AnnotationLayer", {
        enumerable: !0,
        get: function() {
          return n.AnnotationLayer;
        }
      }), Object.defineProperty(Re, "AnnotationMode", {
        enumerable: !0,
        get: function() {
          return ge.AnnotationMode;
        }
      }), Object.defineProperty(Re, "CMapCompressionType", {
        enumerable: !0,
        get: function() {
          return ge.CMapCompressionType;
        }
      }), Object.defineProperty(Re, "DOMSVGFactory", {
        enumerable: !0,
        get: function() {
          return de.DOMSVGFactory;
        }
      }), Object.defineProperty(Re, "FeatureTest", {
        enumerable: !0,
        get: function() {
          return ge.FeatureTest;
        }
      }), Object.defineProperty(Re, "GlobalWorkerOptions", {
        enumerable: !0,
        get: function() {
          return F.GlobalWorkerOptions;
        }
      }), Object.defineProperty(Re, "ImageKind", {
        enumerable: !0,
        get: function() {
          return ge.ImageKind;
        }
      }), Object.defineProperty(Re, "InvalidPDFException", {
        enumerable: !0,
        get: function() {
          return ge.InvalidPDFException;
        }
      }), Object.defineProperty(Re, "MissingPDFException", {
        enumerable: !0,
        get: function() {
          return ge.MissingPDFException;
        }
      }), Object.defineProperty(Re, "OPS", {
        enumerable: !0,
        get: function() {
          return ge.OPS;
        }
      }), Object.defineProperty(Re, "PDFDataRangeTransport", {
        enumerable: !0,
        get: function() {
          return xe.PDFDataRangeTransport;
        }
      }), Object.defineProperty(Re, "PDFDateString", {
        enumerable: !0,
        get: function() {
          return de.PDFDateString;
        }
      }), Object.defineProperty(Re, "PDFWorker", {
        enumerable: !0,
        get: function() {
          return xe.PDFWorker;
        }
      }), Object.defineProperty(Re, "PasswordResponses", {
        enumerable: !0,
        get: function() {
          return ge.PasswordResponses;
        }
      }), Object.defineProperty(Re, "PermissionFlag", {
        enumerable: !0,
        get: function() {
          return ge.PermissionFlag;
        }
      }), Object.defineProperty(Re, "PixelsPerInch", {
        enumerable: !0,
        get: function() {
          return de.PixelsPerInch;
        }
      }), Object.defineProperty(Re, "PromiseCapability", {
        enumerable: !0,
        get: function() {
          return ge.PromiseCapability;
        }
      }), Object.defineProperty(Re, "RenderingCancelledException", {
        enumerable: !0,
        get: function() {
          return de.RenderingCancelledException;
        }
      }), Object.defineProperty(Re, "SVGGraphics", {
        enumerable: !0,
        get: function() {
          return xe.SVGGraphics;
        }
      }), Object.defineProperty(Re, "UnexpectedResponseException", {
        enumerable: !0,
        get: function() {
          return ge.UnexpectedResponseException;
        }
      }), Object.defineProperty(Re, "Util", {
        enumerable: !0,
        get: function() {
          return ge.Util;
        }
      }), Object.defineProperty(Re, "VerbosityLevel", {
        enumerable: !0,
        get: function() {
          return ge.VerbosityLevel;
        }
      }), Object.defineProperty(Re, "XfaLayer", {
        enumerable: !0,
        get: function() {
          return C.XfaLayer;
        }
      }), Object.defineProperty(Re, "build", {
        enumerable: !0,
        get: function() {
          return xe.build;
        }
      }), Object.defineProperty(Re, "createValidAbsoluteUrl", {
        enumerable: !0,
        get: function() {
          return ge.createValidAbsoluteUrl;
        }
      }), Object.defineProperty(Re, "getDocument", {
        enumerable: !0,
        get: function() {
          return xe.getDocument;
        }
      }), Object.defineProperty(Re, "getFilenameFromUrl", {
        enumerable: !0,
        get: function() {
          return de.getFilenameFromUrl;
        }
      }), Object.defineProperty(Re, "getPdfFilenameFromUrl", {
        enumerable: !0,
        get: function() {
          return de.getPdfFilenameFromUrl;
        }
      }), Object.defineProperty(Re, "getXfaPageViewport", {
        enumerable: !0,
        get: function() {
          return de.getXfaPageViewport;
        }
      }), Object.defineProperty(Re, "isDataScheme", {
        enumerable: !0,
        get: function() {
          return de.isDataScheme;
        }
      }), Object.defineProperty(Re, "isPdfFile", {
        enumerable: !0,
        get: function() {
          return de.isPdfFile;
        }
      }), Object.defineProperty(Re, "loadScript", {
        enumerable: !0,
        get: function() {
          return de.loadScript;
        }
      }), Object.defineProperty(Re, "noContextMenu", {
        enumerable: !0,
        get: function() {
          return de.noContextMenu;
        }
      }), Object.defineProperty(Re, "normalizeUnicode", {
        enumerable: !0,
        get: function() {
          return ge.normalizeUnicode;
        }
      }), Object.defineProperty(Re, "renderTextLayer", {
        enumerable: !0,
        get: function() {
          return fe.renderTextLayer;
        }
      }), Object.defineProperty(Re, "setLayerDimensions", {
        enumerable: !0,
        get: function() {
          return de.setLayerDimensions;
        }
      }), Object.defineProperty(Re, "shadow", {
        enumerable: !0,
        get: function() {
          return ge.shadow;
        }
      }), Object.defineProperty(Re, "updateTextLayer", {
        enumerable: !0,
        get: function() {
          return fe.updateTextLayer;
        }
      }), Object.defineProperty(Re, "version", {
        enumerable: !0,
        get: function() {
          return xe.version;
        }
      });
      var ge = __w_pdfjs_require__(1), xe = __w_pdfjs_require__(2), de = __w_pdfjs_require__(6), fe = __w_pdfjs_require__(26), w = __w_pdfjs_require__(27), V = __w_pdfjs_require__(5), n = __w_pdfjs_require__(29), F = __w_pdfjs_require__(14), C = __w_pdfjs_require__(32);
    })(), __webpack_exports__;
  })()
));
const findIndices = (Re, ge) => Re.map((xe, de, fe) => ge(xe, de, fe) ? de : null).filter((xe) => xe != null), splitAt = (Re, ge) => [-1, ...ge, Re.length].reduce(({ xs: xe, a: de }, fe) => ({ xs: (xe == null ? void 0 : xe.concat([Re.slice(de + 1, fe)])) ?? [], a: fe }), {}).xs, concatArrays = (Re, ge) => Re.slice(0, -1).concat([Re[Re.length - 1].concat(ge[0])]).concat(ge.slice(1)), isNumber = /\d/, isCFI = /^epubcfi\((.*)\)$/, escapeCFI = (Re) => Re.replace(/[\^[\](),;=]/g, "^$&"), wrap = (Re) => isCFI.test(Re) ? Re : `epubcfi(${Re})`, unwrap = (Re) => {
  var ge;
  return ((ge = Re.match(isCFI)) == null ? void 0 : ge[1]) ?? Re;
}, lift = (Re) => (...ge) => `epubcfi(${Re(...ge.map((xe) => {
  var de;
  return ((de = xe.match(isCFI)) == null ? void 0 : de[1]) ?? xe;
}))})`, joinIndir = lift((...Re) => Re.join("!")), tokenizer = (Re) => {
  const ge = [];
  let xe, de, fe = "";
  const w = (n) => (ge.push(n), xe = null, fe = ""), V = (n) => (fe += n, de = !1);
  for (const n of Array.from(Re.trim()).concat("")) {
    if (n === "^" && !de) {
      de = !0;
      continue;
    }
    if (xe === "!")
      w(["!"]);
    else if (xe === ",")
      w([","]);
    else if (xe === "/" || xe === ":")
      if (isNumber.test(n)) {
        V(n);
        continue;
      } else
        w([xe, parseInt(fe)]);
    else if (xe === "~")
      if (isNumber.test(n) || n === ".") {
        V(n);
        continue;
      } else
        w(["~", parseFloat(fe)]);
    else if (xe === "@") {
      if (n === ":") {
        w(["@", parseFloat(fe)]), xe = "@";
        continue;
      }
      if (isNumber.test(n) || n === ".") {
        V(n);
        continue;
      } else
        w(["@", parseFloat(fe)]);
    } else if (xe === "[") {
      n === ";" && !de ? (w(["[", fe]), xe = ";") : n === "," && !de ? (w(["[", fe]), xe = "[") : n === "]" && !de ? w(["[", fe]) : V(n);
      continue;
    } else if (xe != null && xe.startsWith(";")) {
      n === "=" && !de ? (xe = `;${fe}`, fe = "") : n === ";" && !de ? (w([xe, fe]), xe = ";") : n === "]" && !de ? w([xe, fe]) : V(n);
      continue;
    }
    (n === "/" || n === ":" || n === "~" || n === "@" || n === "[" || n === "!" || n === ",") && (xe = n);
  }
  return ge;
}, findTokens = (Re, ge) => findIndices(Re, ([xe]) => xe === ge), parser = (Re) => {
  const ge = [];
  let xe;
  for (const [de, fe] of Re) {
    if (de === "/")
      ge.push({ index: fe });
    else {
      const w = ge[ge.length - 1];
      if (de === ":")
        w.offset = fe;
      else if (de === "~")
        w.temporal = fe;
      else if (de === "@")
        w.spatial = (w.spatial ?? []).concat(fe);
      else if (de === ";s")
        w.side = fe;
      else if (de === "[")
        if (xe === "/" && fe)
          w.id = fe;
        else {
          w.text = (w.text ?? []).concat(fe);
          continue;
        }
    }
    xe = de;
  }
  return ge;
}, parserIndir = (Re) => splitAt(Re, findTokens(Re, "!")).map(parser), parse = (Re) => {
  const ge = tokenizer(unwrap(Re)), xe = findTokens(ge, ",");
  if (!xe.length)
    return parserIndir(ge);
  const [de, fe, w] = splitAt(ge, xe).map(parserIndir);
  return { parent: de, start: fe, end: w };
}, partToString = ({ index: Re, id: ge, offset: xe, temporal: de, spatial: fe, text: w, side: V }) => {
  var F;
  const n = V ? `;s=${V}` : "";
  return `/${Re}` + (ge ? `[${escapeCFI(ge)}${n}]` : "") + (xe != null && Re % 2 ? `:${xe}` : "") + (de ? `~${de}` : "") + (fe ? `@${fe.join(":")}` : "") + (w || !ge && V ? "[" + (((F = w == null ? void 0 : w.map(escapeCFI)) == null ? void 0 : F.join(",")) ?? "") + n + "]" : "");
}, toInnerString = (Re) => Re.parent ? [Re.parent, Re.start, Re.end].map(toInnerString).join(",") : Re.map((ge) => ge.map(partToString).join("")).join("!"), toString = (Re) => wrap(toInnerString(Re)), collapse = (Re, ge) => typeof Re == "string" ? toString(collapse(parse(Re), ge)) : Re.parent ? concatArrays(Re.parent, Re[ge ? "end" : "start"]) : Re, buildRange = (Re, ge) => {
  typeof Re == "string" && (Re = parse(Re)), typeof ge == "string" && (ge = parse(ge)), Re = collapse(Re), ge = collapse(ge, !0);
  const xe = Re[Re.length - 1], de = ge[ge.length - 1], fe = [], w = [], V = [];
  let n = !0;
  const F = Math.max(xe.length, de.length);
  for (let e = 0; e < F; e++) {
    const t = xe[e], l = de[e];
    n && (n = (t == null ? void 0 : t.index) === (l == null ? void 0 : l.index) && !(t != null && t.offset) && !(l != null && l.offset)), n ? fe.push(t) : (t && w.push(t), l && V.push(l));
  }
  const C = Re.slice(0, -1).concat([fe]);
  return toString({ parent: C, start: [w], end: [V] });
}, isTextNode = ({ nodeType: Re }) => Re === 3 || Re === 4, isElementNode = ({ nodeType: Re }) => Re === 1, getChildNodes = (Re, ge) => {
  const xe = Array.from(Re.childNodes).filter((de) => isTextNode(de) || isElementNode(de));
  return ge ? xe.map((de) => {
    const fe = ge(de);
    return fe === NodeFilter.FILTER_REJECT ? null : fe === NodeFilter.FILTER_SKIP ? getChildNodes(de, ge) : de;
  }).flat().filter((de) => de) : xe;
}, indexChildNodes = (Re, ge) => {
  const xe = getChildNodes(Re, ge).reduce((de, fe) => {
    let w = de[de.length - 1];
    return w ? isTextNode(fe) ? Array.isArray(w) ? w.push(fe) : isTextNode(w) ? de[de.length - 1] = [w, fe] : de.push(fe) : isElementNode(w) ? de.push(null, fe) : de.push(fe) : de.push(fe), de;
  }, []);
  return isElementNode(xe[0]) && xe.unshift("first"), isElementNode(xe[xe.length - 1]) && xe.push("last"), xe.unshift("before"), xe.push("after"), xe;
}, partsToNode = (Re, ge, xe) => {
  const { id: de } = ge[ge.length - 1];
  if (de) {
    const V = Re.ownerDocument.getElementById(de);
    if (V)
      return { node: V, offset: 0 };
  }
  for (const { index: V } of ge) {
    const n = Re ? indexChildNodes(Re, xe)[V] : null;
    if (n === "first")
      return { node: Re.firstChild ?? Re };
    if (n === "last")
      return { node: Re.lastChild ?? Re };
    if (n === "before")
      return { node: Re, before: !0 };
    if (n === "after")
      return { node: Re, after: !0 };
    Re = n;
  }
  const { offset: fe } = ge[ge.length - 1];
  if (!Array.isArray(Re))
    return { node: Re, offset: fe };
  let w = 0;
  for (const V of Re) {
    const { length: n } = V.nodeValue;
    if (w + n >= fe)
      return { node: V, offset: fe - w };
    w += n;
  }
}, nodeToParts = (Re, ge, xe) => {
  const { parentNode: de, id: fe } = Re, w = indexChildNodes(de, xe), V = w.findIndex((C) => Array.isArray(C) ? C.some((e) => e === Re) : C === Re), n = w[V];
  if (Array.isArray(n)) {
    let C = 0;
    for (const e of n)
      if (e === Re) {
        C += ge;
        break;
      } else
        C += e.nodeValue.length;
    ge = C;
  }
  const F = { id: fe, index: V, offset: ge };
  return (de !== Re.ownerDocument.documentElement ? nodeToParts(de, null, xe).concat(F) : [F]).filter((C) => C.index !== -1);
}, fromRange = (Re, ge) => {
  const { startContainer: xe, startOffset: de, endContainer: fe, endOffset: w } = Re, V = nodeToParts(xe, de, ge);
  if (Re.collapsed)
    return toString([V]);
  const n = nodeToParts(fe, w, ge);
  return buildRange([V], [n]);
}, toRange = (Re, ge, xe) => {
  const de = collapse(ge), fe = collapse(ge, !0), w = Re.documentElement, V = partsToNode(w, de[0], xe), n = partsToNode(w, fe[0], xe), F = Re.createRange();
  return V.before ? F.setStartBefore(V.node) : V.after ? F.setStartAfter(V.node) : F.setStart(V.node, V.offset), n.before ? F.setEndBefore(n.node) : n.after ? F.setEndAfter(n.node) : F.setEnd(n.node, n.offset), F;
}, fromElements = (Re) => {
  const ge = [], { parentNode: xe } = Re[0], de = nodeToParts(xe);
  for (const [fe, w] of indexChildNodes(xe).entries()) {
    const V = Re[ge.length];
    w === V && ge.push(toString([de.concat({ id: V.id, index: fe })]));
  }
  return ge;
}, toElement = (Re, ge) => partsToNode(Re.documentElement, collapse(ge)).node, fake = {
  fromIndex: (Re) => wrap(`/6/${(Re + 1) * 2}`),
  toIndex: (Re) => (Re == null ? void 0 : Re.at(-1).index) / 2 - 1
}, assignIDs = (Re) => {
  let ge = 0;
  const xe = (de) => {
    if (de.id = ge++, de.subitems)
      for (const fe of de.subitems)
        xe(fe);
  };
  for (const de of Re)
    xe(de);
  return Re;
}, flatten = (Re) => Re.map((ge) => {
  var xe;
  return (xe = ge.subitems) != null && xe.length ? [ge, flatten(ge.subitems)].flat() : ge;
}).flat();
class TOCProgress {
  async init({ toc: ge, ids: xe, splitHref: de, getFragment: fe }) {
    assignIDs(ge);
    const w = flatten(ge), V = /* @__PURE__ */ new Map();
    for (const [F, C] of w.entries()) {
      const [e, t] = await de(C == null ? void 0 : C.href) ?? [], l = { fragment: t, item: C };
      V.has(e) ? V.get(e).items.push(l) : V.set(e, { prev: w[F - 1], items: [l] });
    }
    const n = /* @__PURE__ */ new Map();
    for (const [F, C] of xe.entries())
      V.has(C) ? n.set(C, V.get(C)) : n.set(C, n.get(xe[F - 1]));
    this.ids = xe, this.map = n, this.getFragment = fe;
  }
  getProgress(ge, xe) {
    var F;
    if (!this.ids)
      return;
    const de = this.ids[ge], fe = this.map.get(de);
    if (!fe)
      return null;
    const { prev: w, items: V } = fe;
    if (!V)
      return w;
    if (!xe || V.length === 1 && !V[0].fragment)
      return V[0].item;
    const n = xe.startContainer.getRootNode();
    for (const [C, { fragment: e }] of V.entries()) {
      const t = this.getFragment(n, e);
      if (t && xe.comparePoint(t, 0) > 0)
        return ((F = V[C - 1]) == null ? void 0 : F.item) ?? w;
    }
    return V[V.length - 1].item;
  }
}
var ci, fs;
class SectionProgress {
  constructor(ge, xe, de) {
    Me(this, ci);
    this.sizes = ge.map((fe) => fe.linear != "no" && fe.size > 0 ? fe.size : 0), this.sizePerLoc = xe, this.sizePerTimeUnit = de, this.sizeTotal = this.sizes.reduce((fe, w) => fe + w, 0), this.sectionFractions = De(this, ci, fs).call(this);
  }
  // get progress given index of and fractions within a section
  getProgress(ge, xe, de = 0) {
    const { sizes: fe, sizePerLoc: w, sizePerTimeUnit: V, sizeTotal: n } = this, F = fe[ge] ?? 0, e = fe.slice(0, ge).reduce((U, O) => U + O, 0) + xe * F, t = e + de * F, l = n - e, j = (1 - xe) * F;
    return {
      fraction: t / n,
      section: {
        current: ge,
        total: fe.length
      },
      location: {
        current: Math.floor(e / w),
        next: Math.floor(t / w),
        total: Math.ceil(n / w)
      },
      time: {
        section: j / V,
        total: l / V
      }
    };
  }
  // the inverse of `getProgress`
  // get index of and fraction in section based on total fraction
  getSection(ge) {
    if (ge <= 0)
      return [0, 0];
    if (ge >= 1)
      return [this.sizes.length - 1, 1];
    ge = ge + Number.EPSILON;
    const { sizeTotal: xe } = this;
    let de = this.sectionFractions.findIndex((w) => w > ge) - 1;
    if (de < 0)
      return [0, 0];
    for (; !this.sizes[de]; )
      de++;
    const fe = (ge - this.sectionFractions[de]) / (this.sizes[de] / xe);
    return [de, fe];
  }
}
ci = new WeakSet(), fs = function() {
  const { sizeTotal: ge } = this, xe = [0];
  let de = 0;
  for (const fe of this.sizes)
    xe.push((de += fe) / ge);
  return xe;
};
const createSVGElement = (Re) => document.createElementNS("http://www.w3.org/2000/svg", Re);
var an, sn;
class Overlayer {
  constructor() {
    Me(this, an, createSVGElement("svg"));
    Me(this, sn, /* @__PURE__ */ new Map());
    Object.assign(le(this, an).style, {
      position: "absolute",
      top: "0",
      left: "0",
      width: "100%",
      height: "100%",
      pointerEvents: "none"
    });
  }
  get element() {
    return le(this, an);
  }
  add(ge, xe, de, fe) {
    le(this, sn).has(ge) && this.remove(ge), typeof xe == "function" && (xe = xe(le(this, an).getRootNode()));
    const w = xe.getClientRects(), V = de(w, fe);
    le(this, an).append(V), le(this, sn).set(ge, { range: xe, draw: de, options: fe, element: V, rects: w });
  }
  remove(ge) {
    le(this, sn).has(ge) && (le(this, an).removeChild(le(this, sn).get(ge).element), le(this, sn).delete(ge));
  }
  redraw() {
    for (const ge of le(this, sn).values()) {
      const { range: xe, draw: de, options: fe, element: w } = ge;
      le(this, an).removeChild(w);
      const V = xe.getClientRects(), n = de(V, fe);
      le(this, an).append(n), ge.element = n, ge.rects = V;
    }
  }
  hitTest({ x: ge, y: xe }) {
    const de = Array.from(le(this, sn).entries());
    for (let fe = de.length - 1; fe >= 0; fe--) {
      const [w, V] = de[fe];
      for (const { left: n, top: F, right: C, bottom: e } of V.rects)
        if (F <= xe && n <= ge && e > xe && C > ge)
          return [w, V.range];
    }
    return [];
  }
  static underline(ge, xe = {}) {
    const { color: de = "red", width: fe = 2, writingMode: w } = xe, V = createSVGElement("g");
    if (V.setAttribute("fill", de), w === "vertical-rl" || w === "vertical-lr")
      for (const { right: n, top: F, height: C } of ge) {
        const e = createSVGElement("rect");
        e.setAttribute("x", n - fe), e.setAttribute("y", F), e.setAttribute("height", C), e.setAttribute("width", fe), V.append(e);
      }
    else
      for (const { left: n, bottom: F, width: C } of ge) {
        const e = createSVGElement("rect");
        e.setAttribute("x", n), e.setAttribute("y", F - fe), e.setAttribute("height", fe), e.setAttribute("width", C), V.append(e);
      }
    return V;
  }
  static strikethrough(ge, xe = {}) {
    const { color: de = "red", width: fe = 2, writingMode: w } = xe, V = createSVGElement("g");
    if (V.setAttribute("fill", de), w === "vertical-rl" || w === "vertical-lr")
      for (const { right: n, left: F, top: C, height: e } of ge) {
        const t = createSVGElement("rect");
        t.setAttribute("x", (n + F) / 2), t.setAttribute("y", C), t.setAttribute("height", e), t.setAttribute("width", fe), V.append(t);
      }
    else
      for (const { left: n, top: F, bottom: C, width: e } of ge) {
        const t = createSVGElement("rect");
        t.setAttribute("x", n), t.setAttribute("y", (F + C) / 2), t.setAttribute("height", fe), t.setAttribute("width", e), V.append(t);
      }
    return V;
  }
  static squiggly(ge, xe = {}) {
    const { color: de = "red", width: fe = 2, writingMode: w } = xe, V = createSVGElement("g");
    V.setAttribute("fill", "none"), V.setAttribute("stroke", de), V.setAttribute("stroke-width", fe);
    const n = fe * 1.5;
    if (w === "vertical-rl" || w === "vertical-lr")
      for (const { right: F, top: C, height: e } of ge) {
        const t = createSVGElement("path"), l = Math.round(e / n / 1.5), j = e / l, U = Array.from(
          { length: l },
          (O, v) => `l${v % 2 ? -n : n} ${j}`
        ).join("");
        t.setAttribute("d", `M${F} ${C}${U}`), V.append(t);
      }
    else
      for (const { left: F, bottom: C, width: e } of ge) {
        const t = createSVGElement("path"), l = Math.round(e / n / 1.5), j = e / l, U = Array.from(
          { length: l },
          (O, v) => `l${j} ${v % 2 ? n : -n}`
        ).join("");
        t.setAttribute("d", `M${F} ${C}${U}`), V.append(t);
      }
    return V;
  }
  static highlight(ge, xe = {}) {
    const { color: de = "red" } = xe, fe = createSVGElement("g");
    fe.setAttribute("fill", de), fe.style.opacity = "var(--overlayer-highlight-opacity, .3)", fe.style.mixBlendMode = "var(--overlayer-highlight-blend-mode, normal)";
    for (const { left: w, top: V, height: n, width: F } of ge) {
      const C = createSVGElement("rect");
      C.setAttribute("x", w), C.setAttribute("y", V), C.setAttribute("height", n), C.setAttribute("width", F), fe.append(C);
    }
    return fe;
  }
  static outline(ge, xe = {}) {
    const { color: de = "red", width: fe = 3, radius: w = 3 } = xe, V = createSVGElement("g");
    V.setAttribute("fill", "none"), V.setAttribute("stroke", de), V.setAttribute("stroke-width", fe);
    for (const { left: n, top: F, height: C, width: e } of ge) {
      const t = createSVGElement("rect");
      t.setAttribute("x", n), t.setAttribute("y", F), t.setAttribute("height", C), t.setAttribute("width", e), t.setAttribute("rx", w), V.append(t);
    }
    return V;
  }
  // make an exact copy of an image in the overlay
  // one can then apply filters to the entire element, without affecting them;
  // it's a bit silly and probably better to just invert images twice
  // (though the color will be off in that case if you do heu-rotate)
  static copyImage([ge], xe = {}) {
    const { src: de } = xe, fe = createSVGElement("image"), { left: w, top: V, height: n, width: F } = ge;
    return fe.setAttribute("href", de), fe.setAttribute("x", w), fe.setAttribute("y", V), fe.setAttribute("height", n), fe.setAttribute("width", F), fe;
  }
}
an = new WeakMap(), sn = new WeakMap();
const walkRange = (Re, ge) => {
  const xe = [];
  for (let de = ge.currentNode; de; de = ge.nextNode()) {
    const fe = Re.comparePoint(de, 0);
    if (fe === 0)
      xe.push(de);
    else if (fe > 0)
      break;
  }
  return xe;
}, walkDocument = (Re, ge) => {
  const xe = [];
  for (let de = ge.nextNode(); de; de = ge.nextNode())
    xe.push(de);
  return xe;
}, filter = NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_CDATA_SECTION, acceptNode = (Re) => {
  if (Re.nodeType === 1) {
    const ge = Re.tagName.toLowerCase();
    return ge === "script" || ge === "style" ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_SKIP;
  }
  return NodeFilter.FILTER_ACCEPT;
}, textWalker = function* (Re, ge) {
  const xe = Re.commonAncestorContainer ?? Re.body ?? Re, de = document.createTreeWalker(xe, filter, { acceptNode }), w = (Re.commonAncestorContainer ? walkRange : walkDocument)(Re, de), V = w.map((F) => F.nodeValue), n = (F, C, e, t) => {
    const l = document.createRange();
    return l.setStart(w[F], C), l.setEnd(w[e], t), l;
  };
  for (const F of ge(V, n))
    yield F;
}, SEARCH_PREFIX = "foliate-search:";
var Zt, Vt;
class History extends EventTarget {
  constructor() {
    super(...arguments);
    Me(this, Zt, []);
    Me(this, Vt, -1);
  }
  pushState(xe) {
    const de = le(this, Zt)[le(this, Vt)];
    de === xe || de != null && de.fraction && de.fraction === xe.fraction || (le(this, Zt)[++xn(this, Vt)._] = xe, le(this, Zt).length = le(this, Vt) + 1, this.dispatchEvent(new Event("index-change")));
  }
  replaceState(xe) {
    const de = le(this, Vt);
    le(this, Zt)[de] = xe;
  }
  back() {
    const xe = le(this, Vt);
    if (xe <= 0)
      return;
    const de = { state: le(this, Zt)[xe - 1] };
    Xe(this, Vt, xe - 1), this.dispatchEvent(new CustomEvent("popstate", { detail: de })), this.dispatchEvent(new Event("index-change"));
  }
  forward() {
    const xe = le(this, Vt);
    if (xe >= le(this, Zt).length - 1)
      return;
    const de = { state: le(this, Zt)[xe + 1] };
    Xe(this, Vt, xe + 1), this.dispatchEvent(new CustomEvent("popstate", { detail: de })), this.dispatchEvent(new Event("index-change"));
  }
  get canGoBack() {
    return le(this, Vt) > 0;
  }
  get canGoForward() {
    return le(this, Vt) < le(this, Zt).length - 1;
  }
  clear() {
    Xe(this, Zt, []), Xe(this, Vt, -1);
  }
}
Zt = new WeakMap(), Vt = new WeakMap();
const languageInfo = (Re) => {
  var ge, xe;
  if (!Re)
    return {};
  try {
    const de = Intl.getCanonicalLocales(Re)[0], fe = new Intl.Locale(de), w = ["zh", "ja", "kr"].includes(fe.language), V = (xe = ((ge = fe.getTextInfo) == null ? void 0 : ge.call(fe)) ?? fe.textInfo) == null ? void 0 : xe.direction;
    return { canonical: de, locale: fe, isCJK: w, direction: V };
  } catch (de) {
    return console.warn(de), {};
  }
};
var li, cn, en, un, ln, tn, on, hi, gs, ui, ps, di, ms, Fn, oi, fi, xs, gi, bs, pi, ys;
class View extends HTMLElement {
  constructor() {
    super();
    Me(this, tn);
    Me(this, hi);
    Me(this, ui);
    Me(this, di);
    Me(this, Fn);
    Me(this, fi);
    Me(this, gi);
    Me(this, pi);
    Me(this, li, this.attachShadow({ mode: "open" }));
    Me(this, cn, void 0);
    Me(this, en, void 0);
    Me(this, un, void 0);
    Me(this, ln, /* @__PURE__ */ new Map());
    Ot(this, "isFixedLayout", !1);
    Ot(this, "lastLocation");
    Ot(this, "history", new History());
    this.history.addEventListener("popstate", ({ detail: xe }) => {
      const de = this.resolveNavigation(xe.state);
      this.renderer.goTo(de);
    });
  }
  async open(xe) {
    var de, fe, w;
    if (this.book = xe, this.language = languageInfo((de = xe.metadata) == null ? void 0 : de.language), xe.splitTOCHref && xe.getTOCFragment) {
      const V = xe.sections.map((C) => C.id);
      Xe(this, cn, new SectionProgress(xe.sections, 1500, 1600));
      const n = xe.splitTOCHref.bind(xe), F = xe.getTOCFragment.bind(xe);
      Xe(this, en, new TOCProgress()), await le(this, en).init({
        toc: xe.toc ?? [],
        ids: V,
        splitHref: n,
        getFragment: F
      }), Xe(this, un, new TOCProgress()), await le(this, un).init({
        toc: xe.pageList ?? [],
        ids: V,
        splitHref: n,
        getFragment: F
      });
    }
    if (this.isFixedLayout = ((fe = this.book.rendition) == null ? void 0 : fe.layout) === "pre-paginated", this.isFixedLayout ? (await import("./fixed-layout-DpOZsuor.js"), this.renderer = document.createElement("foliate-fxl")) : (await import("./paginator-D852wEfb.js"), this.renderer = document.createElement("foliate-paginator")), this.renderer.setAttribute("exportparts", "head,foot,filter"), this.renderer.addEventListener("load", (V) => De(this, ui, ps).call(this, V.detail)), this.renderer.addEventListener("relocate", (V) => De(this, hi, gs).call(this, V.detail)), this.renderer.addEventListener("create-overlayer", (V) => V.detail.attach(De(this, fi, xs).call(this, V.detail))), this.renderer.open(xe), le(this, li).append(this.renderer), xe.sections.some((V) => V.mediaOverlay)) {
      (w = xe.media).activeClass || (w.activeClass = "-epub-media-overlay-active");
      const V = xe.media.activeClass;
      this.mediaOverlay = xe.getMediaOverlay();
      let n;
      this.mediaOverlay.addEventListener("highlight", (F) => {
        const C = this.resolveNavigation(F.detail.text);
        this.renderer.goTo(C).then(() => {
          const { doc: e } = this.renderer.getContents().find((l) => l.index = C.index), t = C.anchor(e);
          t.classList.add(V), n = new WeakRef(t);
        });
      }), this.mediaOverlay.addEventListener("unhighlight", () => {
        var F, C;
        (C = (F = n == null ? void 0 : n.deref()) == null ? void 0 : F.classList) == null || C.remove(V);
      });
    }
  }
  close() {
    var xe, de;
    (xe = this.renderer) == null || xe.destroy(), (de = this.renderer) == null || de.remove(), Xe(this, cn, null), Xe(this, en, null), Xe(this, un, null), Xe(this, ln, /* @__PURE__ */ new Map()), this.lastLocation = null, this.history.clear(), this.tts = null, this.mediaOverlay = null;
  }
  goToTextStart() {
    var xe, de;
    return this.goTo(((de = (xe = this.book.landmarks) == null ? void 0 : xe.find((fe) => fe.type.includes("bodymatter") || fe.type.includes("text"))) == null ? void 0 : de.href) ?? this.book.sections.findIndex((fe) => fe.linear !== "no"));
  }
  async init({ lastLocation: xe, showTextStart: de }) {
    const fe = xe ? this.resolveNavigation(xe) : null;
    fe ? (await this.renderer.goTo(fe), this.history.pushState(xe)) : de ? await this.goToTextStart() : (this.history.pushState(0), await this.next());
  }
  async addAnnotation(xe, de) {
    var C;
    const { value: fe } = xe;
    if (fe.startsWith(SEARCH_PREFIX)) {
      const e = fe.replace(SEARCH_PREFIX, ""), { index: t, anchor: l } = await this.resolveNavigation(e), j = De(this, Fn, oi).call(this, t);
      if (j) {
        const { overlayer: U, doc: O } = j;
        if (de) {
          U.remove(fe);
          return;
        }
        const v = O ? l(O) : l;
        U.add(fe, v, Overlayer.outline);
      }
      return;
    }
    const { index: w, anchor: V } = await this.resolveNavigation(fe), n = De(this, Fn, oi).call(this, w);
    if (n) {
      const { overlayer: e, doc: t } = n;
      if (e.remove(fe), !de) {
        const l = t ? V(t) : V, j = (U, O) => e.add(fe, l, U, O);
        De(this, tn, on).call(this, "draw-annotation", { draw: j, annotation: xe, doc: t, range: l });
      }
    }
    const F = ((C = le(this, en).getProgress(w)) == null ? void 0 : C.label) ?? "";
    return { index: w, label: F };
  }
  deleteAnnotation(xe) {
    return this.addAnnotation(xe, !0);
  }
  async showAnnotation(xe) {
    const { value: de } = xe, fe = await this.goTo(de);
    if (fe) {
      const { index: w, anchor: V } = fe, { doc: n } = De(this, Fn, oi).call(this, w), F = V(n);
      De(this, tn, on).call(this, "show-annotation", { value: de, index: w, range: F });
    }
  }
  getCFI(xe, de) {
    const fe = this.book.sections[xe].cfi ?? fake.fromIndex(xe);
    return de ? joinIndir(fe, fromRange(de)) : fe;
  }
  resolveCFI(xe) {
    if (this.book.resolveCFI)
      return this.book.resolveCFI(xe);
    {
      const de = parse(xe);
      return { index: fake.toIndex((de.parent ?? de).shift()), anchor: (V) => toRange(V, de) };
    }
  }
  resolveNavigation(xe) {
    try {
      if (typeof xe == "number")
        return { index: xe };
      if (typeof xe.fraction == "number") {
        const [de, fe] = le(this, cn).getSection(xe.fraction);
        return { index: de, anchor: fe };
      }
      return isCFI.test(xe) ? this.resolveCFI(xe) : this.book.resolveHref(xe);
    } catch (de) {
      console.error(de), console.error(`Could not resolve target ${xe}`);
    }
  }
  async goTo(xe) {
    const de = this.resolveNavigation(xe);
    try {
      return await this.renderer.goTo(de), this.history.pushState(xe), de;
    } catch (fe) {
      console.error(fe), console.error(`Could not go to ${xe}`);
    }
  }
  async goToFraction(xe) {
    const [de, fe] = le(this, cn).getSection(xe);
    await this.renderer.goTo({ index: de, anchor: fe }), this.history.pushState({ fraction: xe });
  }
  async select(xe) {
    try {
      const de = await this.resolveNavigation(xe);
      await this.renderer.goTo({ ...de, select: !0 }), this.history.pushState(xe);
    } catch (de) {
      console.error(de), console.error(`Could not go to ${xe}`);
    }
  }
  deselect() {
    for (const { doc: xe } of this.renderer.getContents())
      xe.defaultView.getSelection().removeAllRanges();
  }
  getSectionFractions() {
    var xe;
    return (((xe = le(this, cn)) == null ? void 0 : xe.sectionFractions) ?? []).map((de) => de + Number.EPSILON);
  }
  getProgressOf(xe, de) {
    var V, n;
    const fe = (V = le(this, en)) == null ? void 0 : V.getProgress(xe, de), w = (n = le(this, un)) == null ? void 0 : n.getProgress(xe, de);
    return { tocItem: fe, pageItem: w };
  }
  async getTOCItemOf(xe) {
    try {
      const { index: de, anchor: fe } = await this.resolveNavigation(xe), w = await this.book.sections[de].createDocument(), V = fe(w), n = V instanceof Range, F = n ? V : w.createRange();
      return n || F.selectNodeContents(V), le(this, en).getProgress(de, F);
    } catch (de) {
      console.error(de), console.error(`Could not get ${xe}`);
    }
  }
  async prev(xe) {
    await this.renderer.prev(xe);
  }
  async next(xe) {
    await this.renderer.next(xe);
  }
  goLeft() {
    return this.book.dir === "rtl" ? this.next() : this.prev();
  }
  goRight() {
    return this.book.dir === "rtl" ? this.prev() : this.next();
  }
  async *search(xe) {
    var C;
    this.clearSearch();
    const { searchMatcher: de } = await import("./search-Dw1WQJVD.js"), { query: fe, index: w } = xe, V = de(
      textWalker,
      { defaultLocale: this.language, ...xe }
    ), n = w != null ? De(this, gi, bs).call(this, V, fe, w) : De(this, pi, ys).call(this, V, fe), F = [];
    le(this, ln).set(w, F);
    for await (const e of n)
      if (e.subitems) {
        const t = e.subitems.map(({ cfi: l }) => ({ value: SEARCH_PREFIX + l }));
        le(this, ln).set(e.index, t);
        for (const l of t)
          this.addAnnotation(l);
        yield {
          label: ((C = le(this, en).getProgress(e.index)) == null ? void 0 : C.label) ?? "",
          subitems: e.subitems
        };
      } else {
        if (e.cfi) {
          const t = { value: SEARCH_PREFIX + e.cfi };
          F.push(t), this.addAnnotation(t);
        }
        yield e;
      }
    yield "done";
  }
  clearSearch() {
    for (const xe of le(this, ln).values())
      for (const de of xe)
        this.deleteAnnotation(de);
    le(this, ln).clear();
  }
  async initTTS() {
    const xe = this.renderer.getContents()[0].doc;
    if (this.tts && this.tts.doc === xe)
      return;
    const { TTS: de } = await import("./tts-CuDZu6rz.js");
    this.tts = new de(xe, textWalker, (fe) => this.renderer.scrollToAnchor(fe, !0));
  }
  startMediaOverlay() {
    const { index: xe } = this.renderer.getContents()[0];
    return this.mediaOverlay.start(xe);
  }
}
li = new WeakMap(), cn = new WeakMap(), en = new WeakMap(), un = new WeakMap(), ln = new WeakMap(), tn = new WeakSet(), on = function(xe, de, fe) {
  return this.dispatchEvent(new CustomEvent(xe, { detail: de, cancelable: fe }));
}, hi = new WeakSet(), gs = function({ reason: xe, range: de, index: fe, fraction: w, size: V }) {
  var t, l, j;
  const n = ((t = le(this, cn)) == null ? void 0 : t.getProgress(fe, w, V)) ?? {}, F = (l = le(this, en)) == null ? void 0 : l.getProgress(fe, de), C = (j = le(this, un)) == null ? void 0 : j.getProgress(fe, de), e = this.getCFI(fe, de);
  this.lastLocation = { ...n, tocItem: F, pageItem: C, cfi: e, range: de }, (xe === "snap" || xe === "page" || xe === "scroll") && this.history.replaceState(e), De(this, tn, on).call(this, "relocate", this.lastLocation);
}, ui = new WeakSet(), ps = function({ doc: xe, index: de }) {
  var fe, w;
  (fe = xe.documentElement).lang || (fe.lang = this.language.canonical ?? ""), this.language.isCJK || (w = xe.documentElement).dir || (w.dir = this.language.direction ?? ""), De(this, di, ms).call(this, xe, de), De(this, tn, on).call(this, "load", { doc: xe, index: de });
}, di = new WeakSet(), ms = function(xe, de) {
  const { book: fe } = this, w = fe.sections[de];
  for (const V of xe.querySelectorAll("a[href]"))
    V.addEventListener("click", (n) => {
      var e, t;
      n.preventDefault();
      const F = V.getAttribute("href"), C = ((e = w == null ? void 0 : w.resolveHref) == null ? void 0 : e.call(w, F)) ?? F;
      (t = fe == null ? void 0 : fe.isExternal) != null && t.call(fe, C) ? Promise.resolve(De(this, tn, on).call(this, "external-link", { a: V, href: C }, !0)).then((l) => l ? globalThis.open(C, "_blank") : null).catch((l) => console.error(l)) : Promise.resolve(De(this, tn, on).call(this, "link", { a: V, href: C }, !0)).then((l) => l ? this.goTo(C) : null).catch((l) => console.error(l));
    });
}, Fn = new WeakSet(), oi = function(xe) {
  return this.renderer.getContents().find((de) => de.index === xe && de.overlayer);
}, fi = new WeakSet(), xs = function({ doc: xe, index: de }) {
  const fe = new Overlayer();
  xe.addEventListener("click", (V) => {
    const [n, F] = fe.hitTest(V);
    n && !n.startsWith(SEARCH_PREFIX) && De(this, tn, on).call(this, "show-annotation", { value: n, index: de, range: F });
  }, !1);
  const w = le(this, ln).get(de);
  if (w)
    for (const V of w)
      this.addAnnotation(V);
  return De(this, tn, on).call(this, "create-overlay", { index: de }), fe;
}, gi = new WeakSet(), bs = async function* (xe, de, fe) {
  const w = await this.book.sections[fe].createDocument();
  for (const { range: V, excerpt: n } of xe(w, de))
    yield { cfi: this.getCFI(fe, V), excerpt: n };
}, pi = new WeakSet(), ys = async function* (xe, de) {
  const { sections: fe } = this.book;
  for (const [w, { createDocument: V }] of fe.entries()) {
    if (!V)
      continue;
    const n = await V(), F = Array.from(xe(n, de), ({ range: e, excerpt: t }) => ({ cfi: this.getCFI(w, e), excerpt: t }));
    yield { progress: (w + 1) / fe.length }, F.length && (yield { index: w, subitems: F });
  }
};
customElements.define("foliate-view", View);
const isZip = async (Re) => {
  const ge = new Uint8Array(await Re.slice(0, 4).arrayBuffer());
  return ge[0] === 80 && ge[1] === 75 && ge[2] === 3 && ge[3] === 4;
}, isPDF = async (Re) => {
  const ge = new Uint8Array(await Re.slice(0, 5).arrayBuffer());
  return ge[0] === 37 && ge[1] === 80 && ge[2] === 68 && ge[3] === 70 && ge[4] === 45;
}, makeZipLoader = async (Re) => {
  const { configure: ge, ZipReader: xe, BlobReader: de, TextWriter: fe, BlobWriter: w } = await import("./zip-BLPDOR3v.js");
  ge({ useWebWorkers: !1 });
  const n = await new xe(new de(Re)).getEntries(), F = new Map(n.map((j) => [j.filename, j])), C = (j) => (U, ...O) => F.has(U) ? j(F.get(U), ...O) : null, e = C((j) => j.getData(new fe())), t = C((j, U) => j.getData(new w(U)));
  return { entries: n, loadText: e, loadBlob: t, getSize: (j) => {
    var U;
    return ((U = F.get(j)) == null ? void 0 : U.uncompressedSize) ?? 0;
  } };
}, getFileEntries = async (Re) => Re.isFile ? Re : (await Promise.all(
  Array.from(
    await new Promise(
      (ge, xe) => Re.createReader().readEntries(
        (de) => ge(de),
        (de) => xe(de)
      )
    ),
    getFileEntries
  )
)).flat(), makeDirectoryLoader = async (Re) => {
  const ge = await getFileEntries(Re), xe = await Promise.all(
    ge.map(
      (e) => new Promise(
        (t, l) => e.file(
          (j) => t([j, e.fullPath]),
          (j) => l(j)
        )
      )
    )
  ), de = new Map(
    xe.map(([e, t]) => [t.replace(Re.fullPath + "/", ""), e])
  ), fe = new TextDecoder(), w = (e) => e ? fe.decode(e) : null, V = (e) => {
    var t;
    return ((t = de.get(e)) == null ? void 0 : t.arrayBuffer()) ?? null;
  };
  return { loadText: async (e) => w(await V(e)), loadBlob: (e) => de.get(e), getSize: (e) => {
    var t;
    return ((t = de.get(e)) == null ? void 0 : t.size) ?? 0;
  } };
}, isCBZ = ({ name: Re, type: ge }) => ge === "application/vnd.comicbook+zip" || Re.endsWith(".cbz"), isFB2 = ({ name: Re, type: ge }) => ge === "application/x-fictionbook+xml" || Re.endsWith(".fb2"), isFBZ = ({ name: Re, type: ge }) => ge === "application/x-zip-compressed-fb2" || Re.endsWith(".fb2.zip") || Re.endsWith(".fbz"), getView = async (Re, ge) => {
  let xe;
  if (Re.isDirectory) {
    const fe = await makeDirectoryLoader(Re), { EPUB: w } = await import("./epub-DvjS5vdD.js");
    xe = await new w(fe).init();
  } else if (Re.size)
    if (await isZip(Re)) {
      const fe = await makeZipLoader(Re);
      if (isCBZ(Re)) {
        const { makeComicBook: w } = await import("./comic-book-D2H5riQt.js");
        xe = w(fe, Re);
      } else if (isFBZ(Re)) {
        const { makeFB2: w } = await import("./fb2-DHUjllK8.js"), { entries: V } = fe, n = V.find((C) => C.filename.endsWith(".fb2")), F = await fe.loadBlob((n ?? V[0]).filename);
        xe = await w(F);
      } else {
        const { EPUB: w } = await import("./epub-DvjS5vdD.js");
        xe = await new w(fe).init();
      }
    } else if (await isPDF(Re)) {
      const { makePDF: fe } = await import("./pdf-CsfA1oys.js");
      xe = await fe(Re);
    } else {
      const { isMOBI: fe, MOBI: w } = await import("./mobi-Di0D6QEl.js");
      if (await fe(Re)) {
        const V = await import("./fflate-9VGFqnqw.js");
        xe = await new w({ unzlib: V.unzlibSync }).open(Re);
      } else if (isFB2(Re)) {
        const { makeFB2: V } = await import("./fb2-DHUjllK8.js");
        xe = await V(Re);
      }
    }
  else
    throw new Error("File not found");
  if (!xe)
    throw new Error("File type not supported");
  const de = document.createElement("foliate-view");
  return ge.append(de), await de.open(xe), de;
};
function keyListener(Re, ge) {
  Re.addEventListener(
    "keyup",
    (xe) => {
      xe.key === "ArrowUp" || xe.key === "ArrowRight" ? ge("next") : (xe.key === "ArrowDown" || xe.key === "ArrowLeft") && ge("prev");
    },
    !1
  );
}
function wheelListener(Re, ge) {
  let fe = 0, w;
  Re.addEventListener("wheel", (V) => {
    V.ignore || (V.ignore = !0, clearTimeout(w), fe += V.deltaY, w = setTimeout(() => {
      if (Math.abs(fe) >= 750) {
        let n = Math.sign(fe) > 0 ? "next" : "prev";
        ge(n), fe = 0;
      }
      fe = 0;
    }, 50));
  });
}
function swipListener(Re, ge) {
  let w, V, n;
  Re.addEventListener(
    "touchstart",
    (F) => {
      F.ignore || (F.ignore = !0, w = F.changedTouches[0].pageX, V = F.changedTouches[0].pageY, n = Date.now());
    },
    !1
  ), Re.addEventListener(
    "touchend",
    (F) => {
      var l, j;
      if (F.ignore)
        return;
      F.ignore = !0;
      const C = F.changedTouches[0].pageX - w, e = F.changedTouches[0].pageY - V;
      Date.now() - n <= 500 && (Math.abs(C) >= 50 && Math.abs(e) <= 200 ? ge(C < 0 ? "prev" : "next") : Math.abs(e) >= 50 && Math.abs(C) <= 200 ? ge(e < 0 ? "up" : "down") : ((j = (l = Re == null ? void 0 : Re.defaultView) == null ? void 0 : l.getSelection()) == null || j.removeAllRanges(), Re.dispatchEvent(
        new MouseEvent("click", {
          clientX: w,
          clientY: V
        })
      ), F.preventDefault()));
    },
    !1
  );
}
const _export_sfc = (Re, ge) => {
  const xe = Re.__vccOpts || Re;
  for (const [de, fe] of ge)
    xe[de] = fe;
  return xe;
}, _hoisted_1$1 = { class: "reader" }, _hoisted_2$1 = { class: "viewHolder" }, _hoisted_3$1 = { key: 0 }, _sfc_main$1 = {
  __name: "BookView",
  props: {
    url: {
      type: [String, File]
    },
    location: {
      type: [String, Number]
    },
    tocChanged: Function,
    getRendition: Function
  },
  emits: ["update:location"],
  setup(Re, { expose: ge, emit: xe }) {
    const de = Re, { tocChanged: fe, getRendition: w } = de, { url: V, location: n } = toRefs(de), F = xe;
    let C = null;
    const e = ref(null), t = ref(!1), l = ({ spacing: A, justify: I, hyphenate: E }) => `
    @namespace epub "http://www.idpf.org/2007/ops";
    html {
        color-scheme: light dark;
    }
    /* https://github.com/whatwg/html/issues/5426 */
    @media (prefers-color-scheme: dark) {
        a:link {
            color: lightblue;
        }
    }
    p, li, blockquote, dd {
        line-height: ${A};
        text-align: ${I ? "justify" : "start"};
        -webkit-hyphens: ${E ? "auto" : "manual"};
        hyphens: ${E ? "auto" : "manual"};
        -webkit-hyphenate-limit-before: 3;
        -webkit-hyphenate-limit-after: 2;
        -webkit-hyphenate-limit-lines: 2;
        hanging-punctuation: allow-end last;
        widows: 2;
    }
    /* prevent the above from overriding the align attribute */
    [align="left"] { text-align: left; }
    [align="right"] { text-align: right; }
    [align="center"] { text-align: center; }
    [align="justify"] { text-align: justify; }

    pre {
        white-space: pre-wrap !important;
    }
    aside[epub|type~="endnote"],
    aside[epub|type~="footnote"],
    aside[epub|type~="note"],
    aside[epub|type~="rearnote"] {
        display: none;
    }
`, j = async () => {
      V.value && (C && C.close(), typeof V.value == "string" ? fetch(V.value).then((A) => A.blob()).then(async (A) => {
        const I = V.value.split("/");
        C = await getView(
          new File([A], I[I.length - 1]),
          e.value
        ), U();
      }).catch((A) => console.error(A)) : (C = await getView(V.value, e.value), U()));
    }, U = () => {
      var I, E;
      t.value = !0;
      const { book: A } = C;
      (E = (I = C.renderer).setStyles) == null || E.call(
        I,
        l({
          spacing: 1.4,
          justify: !0,
          hyphenate: !0
        })
      ), v(), w(C), fe && fe(A.toc), n.value ? C == null || C.goTo(n.value) : C.renderer.next();
    }, O = (A) => {
      A === "next" ? i() : A === "prev" && P();
    }, v = () => {
      C.addEventListener("load", g), C.addEventListener("relocate", b);
    }, g = ({ detail: { doc: A } }) => {
      wheelListener(A, O), swipListener(A, O), keyListener(A, O);
    }, b = ({ detail: A }) => {
      F("update:location", A);
    }, i = () => C == null ? void 0 : C.next(), P = () => C == null ? void 0 : C.prev(), d = (A) => C == null ? void 0 : C.goTo(A);
    return watch(V, () => {
      j();
    }), onMounted(() => {
      j();
    }), ge({
      nextPage: i,
      prevPage: P,
      setLocation: d
    }), (A, I) => (openBlock(), createElementBlock("div", _hoisted_1$1, [
      createElementVNode("div", _hoisted_2$1, [
        withDirectives(createElementVNode("div", {
          ref_key: "viewer",
          ref: e,
          id: "viewer"
        }, null, 512), [
          [vShow, t.value]
        ]),
        t.value ? createCommentVNode("", !0) : (openBlock(), createElementBlock("div", _hoisted_3$1, [
          renderSlot(A.$slots, "loadingView", {}, void 0, !0)
        ]))
      ])
    ]));
  }
}, BookView = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-27a30866"]]), _hoisted_1 = { class: "container" }, _hoisted_2 = /* @__PURE__ */ createElementVNode("span", {
  class: "tocButtonBar",
  style: { top: "35%" }
}, null, -1), _hoisted_3 = /* @__PURE__ */ createElementVNode("span", {
  class: "tocButtonBar",
  style: { top: "66%" }
}, null, -1), _hoisted_4 = [
  _hoisted_2,
  _hoisted_3
], _hoisted_5 = ["title"], _hoisted_6 = /* @__PURE__ */ createElementVNode("div", { class: "loadingView" }, "Loading…", -1), _hoisted_7 = { key: 0 }, _hoisted_8 = { class: "tocArea" }, _sfc_main = {
  __name: "VueReader",
  props: {
    title: {
      type: String
    },
    showToc: {
      type: Boolean,
      default: !0
    },
    title: {
      type: String,
      default: ""
    },
    getRendition: {
      type: Function
    },
    backgroundColor: {
      type: String,
      default: "#fff"
    }
  },
  setup(Re) {
    const ge = defineComponent({
      name: "TocComponent",
      props: {
        toc: {
          type: Array,
          default: () => []
        },
        current: {
          type: [String, Number],
          default: ""
        },
        setLocation: {
          type: Function,
          required: !0
        },
        isSubmenu: {
          type: Boolean,
          default: !1,
          required: !1
        }
      },
      setup(v) {
        const g = getCurrentInstance(), b = h.bind(g), { setLocation: i, isSubmenu: P } = v, { toc: d, current: A } = toRefs(v);
        return () => d.value.map((I, E) => b("div", { key: E }, [
          b(
            "button",
            {
              class: [
                "tocAreaButton",
                I.href === A.value ? "active" : ""
              ],
              onClick: () => {
                I.subitems && I.subitems.length > 0 ? (I.expansion = !I.expansion, i(I.href, !1)) : i(I.href);
              }
            },
            [
              P ? " ".repeat(4) + I.label : I.label,
              // 展开
              I.subitems && I.subitems.length > 0 && b("div", {
                class: `${I.expansion ? "open" : ""} expansion`
              })
            ]
          ),
          //多级目录
          I.subitems && I.subitems.length > 0 && b(
            Transition,
            { name: "collapse-transition" },
            {
              default: () => b(
                "div",
                {
                  style: {
                    display: I.expansion ? void 0 : "none"
                  }
                },
                [
                  b(ge, {
                    toc: I.subitems,
                    current: A.value,
                    setLocation: i,
                    isSubmenu: !0
                  })
                ]
              )
            }
          )
        ]));
      }
    }), xe = Re, de = reactive({
      toc: [],
      //目录
      expandedToc: !1
      //目录展开
    }), { getRendition: fe } = xe, { toc: w, expandedToc: V } = toRefs(de), n = ref(null), F = ref(null), C = ref(""), e = (v) => {
      var i;
      fe && fe(v);
      const { book: g } = v, b = (i = g.metadata) == null ? void 0 : i.title;
      C.value = b || "";
    }, t = (v) => {
      w.value = v;
    }, l = () => {
      V.value = !V.value;
    }, j = () => {
      var v;
      (v = n.value) == null || v.nextPage();
    }, U = () => {
      var v;
      (v = n.value) == null || v.prevPage();
    }, O = (v, g = !0) => {
      n.value.setLocation(v), V.value = !1, V.value = !g;
    };
    return (v, g) => (openBlock(), createElementBlock("div", _hoisted_1, [
      createElementVNode("div", {
        class: normalizeClass(["readerArea", { containerExpanded: unref(V) }]),
        style: normalizeStyle({ backgroundColor: Re.backgroundColor })
      }, [
        Re.showToc ? (openBlock(), createElementBlock("button", {
          key: 0,
          class: normalizeClass(["tocButton", { tocButtonExpanded: unref(V) }]),
          type: "button",
          onClick: l
        }, _hoisted_4, 2)) : createCommentVNode("", !0),
        renderSlot(v.$slots, "title", {}, () => [
          createElementVNode("div", {
            class: "titleArea",
            title: Re.title || C.value
          }, toDisplayString(Re.title || C.value), 9, _hoisted_5)
        ]),
        createVNode(BookView, mergeProps({
          ref_key: "bookRef",
          ref: n
        }, v.$attrs, {
          tocChanged: t,
          getRendition: e
        }), {
          loadingView: withCtx(() => [
            renderSlot(v.$slots, "loadingView", {}, () => [
              _hoisted_6
            ])
          ]),
          _: 3
        }, 16),
        createElementVNode("button", {
          class: "arrow pre",
          onClick: U
        }, "‹"),
        createElementVNode("button", {
          class: "arrow next",
          onClick: j
        }, "›")
      ], 6),
      Re.showToc ? (openBlock(), createElementBlock("div", _hoisted_7, [
        createElementVNode("div", _hoisted_8, [
          createVNode(unref(ge), {
            toc: unref(w),
            current: F.value,
            setLocation: O
          }, null, 8, ["toc", "current"])
        ]),
        unref(V) ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "tocBackground",
          onClick: l
        })) : createCommentVNode("", !0)
      ])) : createCommentVNode("", !0)
    ]));
  }
};
export {
  BookView as B,
  _sfc_main as _,
  toRange as a,
  fromElements as f,
  parse as p,
  toElement as t
};
