const I = (e) => e.replace(/\s+/g, " "), T = (e, { startIndex: g, startOffset: l, endIndex: a, endOffset: c }) => {
  const r = e[g], s = e[a], m = r === s ? r.slice(l, c) : r.slice(l) + e.slice(r + 1, s).join("") + s.slice(0, c), d = I(r.slice(0, l)).trimStart(), t = I(s.slice(c)).trimEnd(), n = d.length < 50 ? "" : "…", o = t.length < 50 ? "" : "…", i = `${n}${d.slice(-50)}`, u = `${t.slice(0, 50)}${o}`;
  return { pre: i, match: m, post: u };
}, E = function* (e, g, l = {}) {
  const { locales: a = "en", sensitivity: c } = l, r = c === "variant", s = e.join(""), m = r ? s : s.toLocaleLowerCase(a), d = r ? g : g.toLocaleLowerCase(a), t = d.length;
  let n = -1, o = -1, i = 0;
  do
    if (n = m.indexOf(d, n + 1), n > -1) {
      for (; i <= n; )
        i += e[++o].length;
      const u = o, f = n - (i - e[o].length), h = n + t;
      for (; i <= h; )
        i += e[++o].length;
      const p = o, x = h - (i - e[o].length), y = { startIndex: u, startOffset: f, endIndex: p, endOffset: x };
      yield { range: y, excerpt: T(e, y) };
    }
  while (n > -1);
}, L = function* (e, g, l = {}) {
  var i;
  const { locales: a = "en", granularity: c = "word", sensitivity: r = "base" } = l;
  let s, m;
  try {
    s = new Intl.Segmenter(a, { usage: "search", granularity: c }), m = new Intl.Collator(a, { sensitivity: r });
  } catch (u) {
    console.warn(u), s = new Intl.Segmenter("en", { usage: "search", granularity: c }), m = new Intl.Collator("en", { sensitivity: r });
  }
  const d = Array.from(s.segment(g)).length, t = [];
  let n = 0, o = s.segment(e[n])[Symbol.iterator]();
  e:
    for (; n < e.length; ) {
      for (; t.length < d; ) {
        const { done: f, value: h } = o.next();
        if (f)
          if (n++, n < e.length) {
            o = s.segment(e[n])[Symbol.iterator]();
            continue;
          } else
            break e;
        const { index: p, segment: x } = h;
        if (/[^\p{Format}]/u.test(x)) {
          if (/\s/u.test(x)) {
            /\s/u.test((i = t[t.length - 1]) == null ? void 0 : i.segment) || t.push({ strIndex: n, index: p, segment: " " });
            continue;
          }
          h.strIndex = n, t.push(h);
        }
      }
      const u = t.map((f) => f.segment).join("");
      if (m.compare(g, u) === 0) {
        const f = n, h = t[t.length - 1], p = h.index + h.segment.length, x = t[0].strIndex, y = t[0].index, w = { startIndex: x, startOffset: y, endIndex: f, endOffset: p };
        yield { range: w, excerpt: T(e, w) };
      }
      t.shift();
    }
}, C = (e, g, l) => {
  const { granularity: a = "grapheme", sensitivity: c = "base" } = l;
  return !(Intl != null && Intl.Segmenter) || a === "grapheme" && (c === "variant" || c === "accent") ? E(e, g, l) : L(e, g, l);
}, N = (e, g) => {
  const { defalutLocale: l, matchCase: a, matchDiacritics: c, matchWholeWords: r } = g;
  return function* (s, m) {
    const d = e(s, function* (t, n) {
      for (const o of C(t, m, {
        locales: s.body.lang || s.documentElement.lang || l || "en",
        granularity: r ? "word" : "grapheme",
        sensitivity: c && a ? "variant" : c && !a ? "accent" : !c && a ? "case" : "base"
      })) {
        const { startIndex: i, startOffset: u, endIndex: f, endOffset: h } = o.range;
        o.range = n(i, u, f, h), yield o;
      }
    });
    for (const t of d)
      yield t;
  };
};
export {
  C as search,
  N as searchMatcher
};
